// Begin CVS Header
//   $Source: /fs/turing/cvs/copasi_dev/copasi/MIRIAM/WebServicesIssues/soapC.cpp,v $
//   $Revision: 1.4 $
//   $Name: Build-33 $
//   $Author: shoops $
//   $Date: 2009/04/21 16:17:18 $
// End CVS Header

// Copyright (C) 2008 by Pedro Mendes, Virginia Tech Intellectual
// Properties, Inc., EML Research, gGmbH, University of Heidelberg,
// and The University of Manchester.
// All rights reserved.

/* soapC.cpp
   Generated by gSOAP 2.7.12 from MIRIAM.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
 */

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.12 2009-01-22 20:17:15 GMT")

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
  if (soap->header)
    soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
  if (soap->header)
    {
      soap->part = SOAP_IN_HEADER;

      if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
        return soap->error;

      soap->part = SOAP_END_HEADER;
    }

  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
  soap->part = SOAP_IN_HEADER;
  soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
  soap->part = SOAP_END_HEADER;
  return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
  if (!soap->header)
    {
      soap->header = soap_new_SOAP_ENV__Header(soap, -1);
      soap_default_SOAP_ENV__Header(soap, soap->header);
    }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
  if (!soap->fault)
    {
      soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);

      if (!soap->fault)
        return;

      soap_default_SOAP_ENV__Fault(soap, soap->fault);
    }

  if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
    {
      soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
      soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
    }

  if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
    {
      soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
      soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
    }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
  soap_fault(soap);

  if (soap->fault)
    soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
  if (soap->fault)
    return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);

  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
  return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
  soap_fault(soap);

  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;

  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
  soap_fault(soap);

  if (soap->version == 2)
    {
      if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
        {
          soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
          soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
        }

      return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
    }

  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
  soap_fault(soap);

  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;

  return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
  soap_fault(soap);

  if (soap->version == 1)
    {
      if (!soap->fault->detail)
        {
          soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
          soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
        }

      return (const char**)&soap->fault->detail->__any;
    }

  if (!soap->fault->SOAP_ENV__Detail)
    {
      soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
      soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
    }

  return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
  int t;

  for (;;)
    if (!soap_getelement(soap, &t))
      if (soap->error || soap_ignore_element(soap))
        break;

  if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
    soap->error = SOAP_OK;

  return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C"
{
#endif
  SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
  {
    if (soap_peek_element(soap))
      return NULL;

    if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
      * type = soap_lookup_type(soap, soap->href);

    switch (*type)
      {
        case SOAP_TYPE_byte:
          return soap_in_byte(soap, NULL, NULL, "xsd:byte");
        case SOAP_TYPE_int:
          return soap_in_int(soap, NULL, NULL, "xsd:int");
        case SOAP_TYPE_std__string:
          return soap_in_std__string(soap, NULL, NULL, "xsd:string");
        case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
          return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string");
        case SOAP_TYPE_ns2__checkRegExp:
          return soap_in_ns2__checkRegExp(soap, NULL, NULL, "ns2:checkRegExp");
        case SOAP_TYPE_ns2__checkRegExpResponse:
          return soap_in_ns2__checkRegExpResponse(soap, NULL, NULL, "ns2:checkRegExpResponse");
        case SOAP_TYPE_ns2__getDataTypesId:
          return soap_in_ns2__getDataTypesId(soap, NULL, NULL, "ns2:getDataTypesId");
        case SOAP_TYPE_ns2__getDataTypesIdResponse:
          return soap_in_ns2__getDataTypesIdResponse(soap, NULL, NULL, "ns2:getDataTypesIdResponse");
        case SOAP_TYPE_ns2__getDataTypesName:
          return soap_in_ns2__getDataTypesName(soap, NULL, NULL, "ns2:getDataTypesName");
        case SOAP_TYPE_ns2__getDataTypesNameResponse:
          return soap_in_ns2__getDataTypesNameResponse(soap, NULL, NULL, "ns2:getDataTypesNameResponse");
        case SOAP_TYPE_ns2__getNames:
          return soap_in_ns2__getNames(soap, NULL, NULL, "ns2:getNames");
        case SOAP_TYPE_ns2__getNamesResponse:
          return soap_in_ns2__getNamesResponse(soap, NULL, NULL, "ns2:getNamesResponse");
        case SOAP_TYPE_ns2__getDataTypeSynonyms:
          return soap_in_ns2__getDataTypeSynonyms(soap, NULL, NULL, "ns2:getDataTypeSynonyms");
        case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
          return soap_in_ns2__getDataTypeSynonymsResponse(soap, NULL, NULL, "ns2:getDataTypeSynonymsResponse");
        case SOAP_TYPE_ns2__getResourceLocation:
          return soap_in_ns2__getResourceLocation(soap, NULL, NULL, "ns2:getResourceLocation");
        case SOAP_TYPE_ns2__getResourceLocationResponse:
          return soap_in_ns2__getResourceLocationResponse(soap, NULL, NULL, "ns2:getResourceLocationResponse");
        case SOAP_TYPE_ns2__getResourceInstitution:
          return soap_in_ns2__getResourceInstitution(soap, NULL, NULL, "ns2:getResourceInstitution");
        case SOAP_TYPE_ns2__getResourceInstitutionResponse:
          return soap_in_ns2__getResourceInstitutionResponse(soap, NULL, NULL, "ns2:getResourceInstitutionResponse");
        case SOAP_TYPE_ns2__getResourceInfo:
          return soap_in_ns2__getResourceInfo(soap, NULL, NULL, "ns2:getResourceInfo");
        case SOAP_TYPE_ns2__getResourceInfoResponse:
          return soap_in_ns2__getResourceInfoResponse(soap, NULL, NULL, "ns2:getResourceInfoResponse");
        case SOAP_TYPE_ns2__getDataTypePattern:
          return soap_in_ns2__getDataTypePattern(soap, NULL, NULL, "ns2:getDataTypePattern");
        case SOAP_TYPE_ns2__getDataTypePatternResponse:
          return soap_in_ns2__getDataTypePatternResponse(soap, NULL, NULL, "ns2:getDataTypePatternResponse");
        case SOAP_TYPE_ns2__getMiriamURI:
          return soap_in_ns2__getMiriamURI(soap, NULL, NULL, "ns2:getMiriamURI");
        case SOAP_TYPE_ns2__getMiriamURIResponse:
          return soap_in_ns2__getMiriamURIResponse(soap, NULL, NULL, "ns2:getMiriamURIResponse");
        case SOAP_TYPE_ns2__getOfficialDataTypeURI:
          return soap_in_ns2__getOfficialDataTypeURI(soap, NULL, NULL, "ns2:getOfficialDataTypeURI");
        case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
          return soap_in_ns2__getOfficialDataTypeURIResponse(soap, NULL, NULL, "ns2:getOfficialDataTypeURIResponse");
        case SOAP_TYPE_ns2__isDeprecated:
          return soap_in_ns2__isDeprecated(soap, NULL, NULL, "ns2:isDeprecated");
        case SOAP_TYPE_ns2__isDeprecatedResponse:
          return soap_in_ns2__isDeprecatedResponse(soap, NULL, NULL, "ns2:isDeprecatedResponse");
        case SOAP_TYPE_ns2__getLocations_:
          return soap_in_ns2__getLocations_(soap, NULL, NULL, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse_:
          return soap_in_ns2__getLocationsResponse_(soap, NULL, NULL, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getLocations:
          return soap_in_ns2__getLocations(soap, NULL, NULL, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse:
          return soap_in_ns2__getLocationsResponse(soap, NULL, NULL, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getDataTypeDef:
          return soap_in_ns2__getDataTypeDef(soap, NULL, NULL, "ns2:getDataTypeDef");
        case SOAP_TYPE_ns2__getDataTypeDefResponse:
          return soap_in_ns2__getDataTypeDefResponse(soap, NULL, NULL, "ns2:getDataTypeDefResponse");
        case SOAP_TYPE_ns2__getDataTypeURIs:
          return soap_in_ns2__getDataTypeURIs(soap, NULL, NULL, "ns2:getDataTypeURIs");
        case SOAP_TYPE_ns2__getDataTypeURIsResponse:
          return soap_in_ns2__getDataTypeURIsResponse(soap, NULL, NULL, "ns2:getDataTypeURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURI:
          return soap_in_ns2__getDataTypeURI(soap, NULL, NULL, "ns2:getDataTypeURI");
        case SOAP_TYPE_ns2__getDataTypeURIResponse:
          return soap_in_ns2__getDataTypeURIResponse(soap, NULL, NULL, "ns2:getDataTypeURIResponse");
        case SOAP_TYPE_ns2__getJavaLibraryVersion:
          return soap_in_ns2__getJavaLibraryVersion(soap, NULL, NULL, "ns2:getJavaLibraryVersion");
        case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
          return soap_in_ns2__getJavaLibraryVersionResponse(soap, NULL, NULL, "ns2:getJavaLibraryVersionResponse");
        case SOAP_TYPE_ns2__getServicesVersion:
          return soap_in_ns2__getServicesVersion(soap, NULL, NULL, "ns2:getServicesVersion");
        case SOAP_TYPE_ns2__getServicesVersionResponse:
          return soap_in_ns2__getServicesVersionResponse(soap, NULL, NULL, "ns2:getServicesVersionResponse");
        case SOAP_TYPE_ns2__getServicesInfo:
          return soap_in_ns2__getServicesInfo(soap, NULL, NULL, "ns2:getServicesInfo");
        case SOAP_TYPE_ns2__getServicesInfoResponse:
          return soap_in_ns2__getServicesInfoResponse(soap, NULL, NULL, "ns2:getServicesInfoResponse");
        case SOAP_TYPE_ns2__getDataResources:
          return soap_in_ns2__getDataResources(soap, NULL, NULL, "ns2:getDataResources");
        case SOAP_TYPE_ns2__getDataResourcesResponse:
          return soap_in_ns2__getDataResourcesResponse(soap, NULL, NULL, "ns2:getDataResourcesResponse");
        case SOAP_TYPE_ns2__getURI:
          return soap_in_ns2__getURI(soap, NULL, NULL, "ns2:getURI");
        case SOAP_TYPE_ns2__getURIResponse:
          return soap_in_ns2__getURIResponse(soap, NULL, NULL, "ns2:getURIResponse");
        case SOAP_TYPE_ns2__getLocation:
          return soap_in_ns2__getLocation(soap, NULL, NULL, "ns2:getLocation");
        case SOAP_TYPE_ns2__getLocationResponse:
          return soap_in_ns2__getLocationResponse(soap, NULL, NULL, "ns2:getLocationResponse");
        case SOAP_TYPE_ns2__getName:
          return soap_in_ns2__getName(soap, NULL, NULL, "ns2:getName");
        case SOAP_TYPE_ns2__getNameResponse:
          return soap_in_ns2__getNameResponse(soap, NULL, NULL, "ns2:getNameResponse");
        case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
          return soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string");
        case SOAP_TYPE_PointerTostd__string:
          return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
        case SOAP_TYPE_string:
        {
          char **s;
          s = soap_in_string(soap, NULL, NULL, "xsd:string");
          return s ? *s : NULL;
        }
        default:
        {
          const char *t = soap->type;

          if (!*t)
            t = soap->tag;

          if (!soap_match_tag(soap, t, "xsd:string"))
            {
              *type = SOAP_TYPE_std__string;
              return soap_in_std__string(soap, NULL, NULL, NULL);
            }

          if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
            {
              *type = SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring;
              return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "xsd:byte"))
            {
              *type = SOAP_TYPE_byte;
              return soap_in_byte(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "xsd:int"))
            {
              *type = SOAP_TYPE_int;
              return soap_in_int(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:checkRegExp"))
            {
              *type = SOAP_TYPE_ns2__checkRegExp;
              return soap_in_ns2__checkRegExp(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:checkRegExpResponse"))
            {
              *type = SOAP_TYPE_ns2__checkRegExpResponse;
              return soap_in_ns2__checkRegExpResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypesId"))
            {
              *type = SOAP_TYPE_ns2__getDataTypesId;
              return soap_in_ns2__getDataTypesId(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypesIdResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataTypesIdResponse;
              return soap_in_ns2__getDataTypesIdResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypesName"))
            {
              *type = SOAP_TYPE_ns2__getDataTypesName;
              return soap_in_ns2__getDataTypesName(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypesNameResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataTypesNameResponse;
              return soap_in_ns2__getDataTypesNameResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getNames"))
            {
              *type = SOAP_TYPE_ns2__getNames;
              return soap_in_ns2__getNames(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getNamesResponse"))
            {
              *type = SOAP_TYPE_ns2__getNamesResponse;
              return soap_in_ns2__getNamesResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeSynonyms"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeSynonyms;
              return soap_in_ns2__getDataTypeSynonyms(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeSynonymsResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeSynonymsResponse;
              return soap_in_ns2__getDataTypeSynonymsResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getResourceLocation"))
            {
              *type = SOAP_TYPE_ns2__getResourceLocation;
              return soap_in_ns2__getResourceLocation(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getResourceLocationResponse"))
            {
              *type = SOAP_TYPE_ns2__getResourceLocationResponse;
              return soap_in_ns2__getResourceLocationResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getResourceInstitution"))
            {
              *type = SOAP_TYPE_ns2__getResourceInstitution;
              return soap_in_ns2__getResourceInstitution(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getResourceInstitutionResponse"))
            {
              *type = SOAP_TYPE_ns2__getResourceInstitutionResponse;
              return soap_in_ns2__getResourceInstitutionResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getResourceInfo"))
            {
              *type = SOAP_TYPE_ns2__getResourceInfo;
              return soap_in_ns2__getResourceInfo(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getResourceInfoResponse"))
            {
              *type = SOAP_TYPE_ns2__getResourceInfoResponse;
              return soap_in_ns2__getResourceInfoResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypePattern"))
            {
              *type = SOAP_TYPE_ns2__getDataTypePattern;
              return soap_in_ns2__getDataTypePattern(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypePatternResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataTypePatternResponse;
              return soap_in_ns2__getDataTypePatternResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getMiriamURI"))
            {
              *type = SOAP_TYPE_ns2__getMiriamURI;
              return soap_in_ns2__getMiriamURI(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getMiriamURIResponse"))
            {
              *type = SOAP_TYPE_ns2__getMiriamURIResponse;
              return soap_in_ns2__getMiriamURIResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getOfficialDataTypeURI"))
            {
              *type = SOAP_TYPE_ns2__getOfficialDataTypeURI;
              return soap_in_ns2__getOfficialDataTypeURI(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getOfficialDataTypeURIResponse"))
            {
              *type = SOAP_TYPE_ns2__getOfficialDataTypeURIResponse;
              return soap_in_ns2__getOfficialDataTypeURIResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:isDeprecated"))
            {
              *type = SOAP_TYPE_ns2__isDeprecated;
              return soap_in_ns2__isDeprecated(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:isDeprecatedResponse"))
            {
              *type = SOAP_TYPE_ns2__isDeprecatedResponse;
              return soap_in_ns2__isDeprecatedResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getLocations"))
            {
              *type = SOAP_TYPE_ns2__getLocations_;
              return soap_in_ns2__getLocations_(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getLocationsResponse"))
            {
              *type = SOAP_TYPE_ns2__getLocationsResponse_;
              return soap_in_ns2__getLocationsResponse_(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getLocations"))
            {
              *type = SOAP_TYPE_ns2__getLocations;
              return soap_in_ns2__getLocations(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getLocationsResponse"))
            {
              *type = SOAP_TYPE_ns2__getLocationsResponse;
              return soap_in_ns2__getLocationsResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeDef"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeDef;
              return soap_in_ns2__getDataTypeDef(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeDefResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeDefResponse;
              return soap_in_ns2__getDataTypeDefResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeURIs"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeURIs;
              return soap_in_ns2__getDataTypeURIs(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeURIsResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeURIsResponse;
              return soap_in_ns2__getDataTypeURIsResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeURI"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeURI;
              return soap_in_ns2__getDataTypeURI(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataTypeURIResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataTypeURIResponse;
              return soap_in_ns2__getDataTypeURIResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getJavaLibraryVersion"))
            {
              *type = SOAP_TYPE_ns2__getJavaLibraryVersion;
              return soap_in_ns2__getJavaLibraryVersion(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getJavaLibraryVersionResponse"))
            {
              *type = SOAP_TYPE_ns2__getJavaLibraryVersionResponse;
              return soap_in_ns2__getJavaLibraryVersionResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getServicesVersion"))
            {
              *type = SOAP_TYPE_ns2__getServicesVersion;
              return soap_in_ns2__getServicesVersion(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getServicesVersionResponse"))
            {
              *type = SOAP_TYPE_ns2__getServicesVersionResponse;
              return soap_in_ns2__getServicesVersionResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getServicesInfo"))
            {
              *type = SOAP_TYPE_ns2__getServicesInfo;
              return soap_in_ns2__getServicesInfo(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getServicesInfoResponse"))
            {
              *type = SOAP_TYPE_ns2__getServicesInfoResponse;
              return soap_in_ns2__getServicesInfoResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataResources"))
            {
              *type = SOAP_TYPE_ns2__getDataResources;
              return soap_in_ns2__getDataResources(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getDataResourcesResponse"))
            {
              *type = SOAP_TYPE_ns2__getDataResourcesResponse;
              return soap_in_ns2__getDataResourcesResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getURI"))
            {
              *type = SOAP_TYPE_ns2__getURI;
              return soap_in_ns2__getURI(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getURIResponse"))
            {
              *type = SOAP_TYPE_ns2__getURIResponse;
              return soap_in_ns2__getURIResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getLocation"))
            {
              *type = SOAP_TYPE_ns2__getLocation;
              return soap_in_ns2__getLocation(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getLocationResponse"))
            {
              *type = SOAP_TYPE_ns2__getLocationResponse;
              return soap_in_ns2__getLocationResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getName"))
            {
              *type = SOAP_TYPE_ns2__getName;
              return soap_in_ns2__getName(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "ns2:getNameResponse"))
            {
              *type = SOAP_TYPE_ns2__getNameResponse;
              return soap_in_ns2__getNameResponse(soap, NULL, NULL, NULL);
            }

          if (!soap_match_tag(soap, t, "xsd:string"))
            {
              char **s;
              *type = SOAP_TYPE_string;
              s = soap_in_string(soap, NULL, NULL, NULL);
              return s ? *s : NULL;
            }

          t = soap->tag;

          if (!soap_match_tag(soap, t, "xsd:QName"))
            {
              char **s;
              *type = SOAP_TYPE__QName;
              s = soap_in__QName(soap, NULL, NULL, NULL);
              return s ? *s : NULL;
            }
        }
      }

    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
  if (!soap_peek_element(soap))
    {
      int t;
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));

      if (soap->mustUnderstand && !soap->other)
        return soap->error = SOAP_MUSTUNDERSTAND;

      if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
        {
          DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
          return soap->error = SOAP_TAG_MISMATCH;
        }

      if (!*soap->id || !soap_getelement(soap, &t))
        {
          soap->peeked = 0;

          if (soap->fignore)
            soap->error = soap->fignore(soap, soap->tag);
          else
            soap->error = SOAP_OK;

          DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));

          if (!soap->error && soap->body)
            {
              soap->level++;

              while (!soap_ignore_element(soap))
                ;

              if (soap->error == SOAP_NO_TAG)
                soap->error = soap_element_end_in(soap, NULL);
            }
        }
    }

  return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
  int i;
  struct soap_plist *pp;

  if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
    for (i = 0; i < SOAP_PTRHASH; i++)
      for (pp = soap->pht[i]; pp; pp = pp->next)
        if (pp->mark1 == 2 || pp->mark2 == 2)
          if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
            return soap->error;

  return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C"
{
#endif
  SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
  {
    switch (type)
      {
        case SOAP_TYPE_byte:
          return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
        case SOAP_TYPE_int:
          return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
        case SOAP_TYPE_std__string:
          return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
        case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
          return ((ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_out(soap, tag, id, "xsd:string");
        case SOAP_TYPE_ns2__checkRegExp:
          return soap_out_ns2__checkRegExp(soap, tag, id, (const struct ns2__checkRegExp *)ptr, "ns2:checkRegExp");
        case SOAP_TYPE_ns2__checkRegExpResponse:
          return soap_out_ns2__checkRegExpResponse(soap, tag, id, (const struct ns2__checkRegExpResponse *)ptr, "ns2:checkRegExpResponse");
        case SOAP_TYPE_ns2__getDataTypesId:
          return soap_out_ns2__getDataTypesId(soap, tag, id, (const struct ns2__getDataTypesId *)ptr, "ns2:getDataTypesId");
        case SOAP_TYPE_ns2__getDataTypesIdResponse:
          return soap_out_ns2__getDataTypesIdResponse(soap, tag, id, (const struct ns2__getDataTypesIdResponse *)ptr, "ns2:getDataTypesIdResponse");
        case SOAP_TYPE_ns2__getDataTypesName:
          return soap_out_ns2__getDataTypesName(soap, tag, id, (const struct ns2__getDataTypesName *)ptr, "ns2:getDataTypesName");
        case SOAP_TYPE_ns2__getDataTypesNameResponse:
          return soap_out_ns2__getDataTypesNameResponse(soap, tag, id, (const struct ns2__getDataTypesNameResponse *)ptr, "ns2:getDataTypesNameResponse");
        case SOAP_TYPE_ns2__getNames:
          return soap_out_ns2__getNames(soap, tag, id, (const struct ns2__getNames *)ptr, "ns2:getNames");
        case SOAP_TYPE_ns2__getNamesResponse:
          return soap_out_ns2__getNamesResponse(soap, tag, id, (const struct ns2__getNamesResponse *)ptr, "ns2:getNamesResponse");
        case SOAP_TYPE_ns2__getDataTypeSynonyms:
          return soap_out_ns2__getDataTypeSynonyms(soap, tag, id, (const struct ns2__getDataTypeSynonyms *)ptr, "ns2:getDataTypeSynonyms");
        case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
          return soap_out_ns2__getDataTypeSynonymsResponse(soap, tag, id, (const struct ns2__getDataTypeSynonymsResponse *)ptr, "ns2:getDataTypeSynonymsResponse");
        case SOAP_TYPE_ns2__getResourceLocation:
          return soap_out_ns2__getResourceLocation(soap, tag, id, (const struct ns2__getResourceLocation *)ptr, "ns2:getResourceLocation");
        case SOAP_TYPE_ns2__getResourceLocationResponse:
          return soap_out_ns2__getResourceLocationResponse(soap, tag, id, (const struct ns2__getResourceLocationResponse *)ptr, "ns2:getResourceLocationResponse");
        case SOAP_TYPE_ns2__getResourceInstitution:
          return soap_out_ns2__getResourceInstitution(soap, tag, id, (const struct ns2__getResourceInstitution *)ptr, "ns2:getResourceInstitution");
        case SOAP_TYPE_ns2__getResourceInstitutionResponse:
          return soap_out_ns2__getResourceInstitutionResponse(soap, tag, id, (const struct ns2__getResourceInstitutionResponse *)ptr, "ns2:getResourceInstitutionResponse");
        case SOAP_TYPE_ns2__getResourceInfo:
          return soap_out_ns2__getResourceInfo(soap, tag, id, (const struct ns2__getResourceInfo *)ptr, "ns2:getResourceInfo");
        case SOAP_TYPE_ns2__getResourceInfoResponse:
          return soap_out_ns2__getResourceInfoResponse(soap, tag, id, (const struct ns2__getResourceInfoResponse *)ptr, "ns2:getResourceInfoResponse");
        case SOAP_TYPE_ns2__getDataTypePattern:
          return soap_out_ns2__getDataTypePattern(soap, tag, id, (const struct ns2__getDataTypePattern *)ptr, "ns2:getDataTypePattern");
        case SOAP_TYPE_ns2__getDataTypePatternResponse:
          return soap_out_ns2__getDataTypePatternResponse(soap, tag, id, (const struct ns2__getDataTypePatternResponse *)ptr, "ns2:getDataTypePatternResponse");
        case SOAP_TYPE_ns2__getMiriamURI:
          return soap_out_ns2__getMiriamURI(soap, tag, id, (const struct ns2__getMiriamURI *)ptr, "ns2:getMiriamURI");
        case SOAP_TYPE_ns2__getMiriamURIResponse:
          return soap_out_ns2__getMiriamURIResponse(soap, tag, id, (const struct ns2__getMiriamURIResponse *)ptr, "ns2:getMiriamURIResponse");
        case SOAP_TYPE_ns2__getOfficialDataTypeURI:
          return soap_out_ns2__getOfficialDataTypeURI(soap, tag, id, (const struct ns2__getOfficialDataTypeURI *)ptr, "ns2:getOfficialDataTypeURI");
        case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
          return soap_out_ns2__getOfficialDataTypeURIResponse(soap, tag, id, (const struct ns2__getOfficialDataTypeURIResponse *)ptr, "ns2:getOfficialDataTypeURIResponse");
        case SOAP_TYPE_ns2__isDeprecated:
          return soap_out_ns2__isDeprecated(soap, tag, id, (const struct ns2__isDeprecated *)ptr, "ns2:isDeprecated");
        case SOAP_TYPE_ns2__isDeprecatedResponse:
          return soap_out_ns2__isDeprecatedResponse(soap, tag, id, (const struct ns2__isDeprecatedResponse *)ptr, "ns2:isDeprecatedResponse");
        case SOAP_TYPE_ns2__getLocations_:
          return soap_out_ns2__getLocations_(soap, tag, id, (const struct ns2__getLocations_ *)ptr, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse_:
          return soap_out_ns2__getLocationsResponse_(soap, tag, id, (const struct ns2__getLocationsResponse_ *)ptr, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getLocations:
          return soap_out_ns2__getLocations(soap, tag, id, (const struct ns2__getLocations *)ptr, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse:
          return soap_out_ns2__getLocationsResponse(soap, tag, id, (const struct ns2__getLocationsResponse *)ptr, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getDataTypeDef:
          return soap_out_ns2__getDataTypeDef(soap, tag, id, (const struct ns2__getDataTypeDef *)ptr, "ns2:getDataTypeDef");
        case SOAP_TYPE_ns2__getDataTypeDefResponse:
          return soap_out_ns2__getDataTypeDefResponse(soap, tag, id, (const struct ns2__getDataTypeDefResponse *)ptr, "ns2:getDataTypeDefResponse");
        case SOAP_TYPE_ns2__getDataTypeURIs:
          return soap_out_ns2__getDataTypeURIs(soap, tag, id, (const struct ns2__getDataTypeURIs *)ptr, "ns2:getDataTypeURIs");
        case SOAP_TYPE_ns2__getDataTypeURIsResponse:
          return soap_out_ns2__getDataTypeURIsResponse(soap, tag, id, (const struct ns2__getDataTypeURIsResponse *)ptr, "ns2:getDataTypeURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURI:
          return soap_out_ns2__getDataTypeURI(soap, tag, id, (const struct ns2__getDataTypeURI *)ptr, "ns2:getDataTypeURI");
        case SOAP_TYPE_ns2__getDataTypeURIResponse:
          return soap_out_ns2__getDataTypeURIResponse(soap, tag, id, (const struct ns2__getDataTypeURIResponse *)ptr, "ns2:getDataTypeURIResponse");
        case SOAP_TYPE_ns2__getJavaLibraryVersion:
          return soap_out_ns2__getJavaLibraryVersion(soap, tag, id, (const struct ns2__getJavaLibraryVersion *)ptr, "ns2:getJavaLibraryVersion");
        case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
          return soap_out_ns2__getJavaLibraryVersionResponse(soap, tag, id, (const struct ns2__getJavaLibraryVersionResponse *)ptr, "ns2:getJavaLibraryVersionResponse");
        case SOAP_TYPE_ns2__getServicesVersion:
          return soap_out_ns2__getServicesVersion(soap, tag, id, (const struct ns2__getServicesVersion *)ptr, "ns2:getServicesVersion");
        case SOAP_TYPE_ns2__getServicesVersionResponse:
          return soap_out_ns2__getServicesVersionResponse(soap, tag, id, (const struct ns2__getServicesVersionResponse *)ptr, "ns2:getServicesVersionResponse");
        case SOAP_TYPE_ns2__getServicesInfo:
          return soap_out_ns2__getServicesInfo(soap, tag, id, (const struct ns2__getServicesInfo *)ptr, "ns2:getServicesInfo");
        case SOAP_TYPE_ns2__getServicesInfoResponse:
          return soap_out_ns2__getServicesInfoResponse(soap, tag, id, (const struct ns2__getServicesInfoResponse *)ptr, "ns2:getServicesInfoResponse");
        case SOAP_TYPE_ns2__getDataResources:
          return soap_out_ns2__getDataResources(soap, tag, id, (const struct ns2__getDataResources *)ptr, "ns2:getDataResources");
        case SOAP_TYPE_ns2__getDataResourcesResponse:
          return soap_out_ns2__getDataResourcesResponse(soap, tag, id, (const struct ns2__getDataResourcesResponse *)ptr, "ns2:getDataResourcesResponse");
        case SOAP_TYPE_ns2__getURI:
          return soap_out_ns2__getURI(soap, tag, id, (const struct ns2__getURI *)ptr, "ns2:getURI");
        case SOAP_TYPE_ns2__getURIResponse:
          return soap_out_ns2__getURIResponse(soap, tag, id, (const struct ns2__getURIResponse *)ptr, "ns2:getURIResponse");
        case SOAP_TYPE_ns2__getLocation:
          return soap_out_ns2__getLocation(soap, tag, id, (const struct ns2__getLocation *)ptr, "ns2:getLocation");
        case SOAP_TYPE_ns2__getLocationResponse:
          return soap_out_ns2__getLocationResponse(soap, tag, id, (const struct ns2__getLocationResponse *)ptr, "ns2:getLocationResponse");
        case SOAP_TYPE_ns2__getName:
          return soap_out_ns2__getName(soap, tag, id, (const struct ns2__getName *)ptr, "ns2:getName");
        case SOAP_TYPE_ns2__getNameResponse:
          return soap_out_ns2__getNameResponse(soap, tag, id, (const struct ns2__getNameResponse *)ptr, "ns2:getNameResponse");
        case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
          return soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, id, (ArrayOf_USCORExsd_USCOREstring *const*)ptr, "xsd:string");
        case SOAP_TYPE_PointerTostd__string:
          return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
        case SOAP_TYPE__QName:
          return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
        case SOAP_TYPE_string:
          return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
      }

    return SOAP_OK;
  }

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C"
{
#endif
  SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
  {
    (void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */

    switch (type)
      {
        case SOAP_TYPE_std__string:
          soap_serialize_std__string(soap, (const std::string *)ptr);
          break;
        case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
          ((ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_serialize(soap);
          break;
        case SOAP_TYPE_ns2__checkRegExp:
          soap_serialize_ns2__checkRegExp(soap, (const struct ns2__checkRegExp *)ptr);
          break;
        case SOAP_TYPE_ns2__checkRegExpResponse:
          soap_serialize_ns2__checkRegExpResponse(soap, (const struct ns2__checkRegExpResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesId:
          soap_serialize_ns2__getDataTypesId(soap, (const struct ns2__getDataTypesId *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesIdResponse:
          soap_serialize_ns2__getDataTypesIdResponse(soap, (const struct ns2__getDataTypesIdResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesName:
          soap_serialize_ns2__getDataTypesName(soap, (const struct ns2__getDataTypesName *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesNameResponse:
          soap_serialize_ns2__getDataTypesNameResponse(soap, (const struct ns2__getDataTypesNameResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getNames:
          soap_serialize_ns2__getNames(soap, (const struct ns2__getNames *)ptr);
          break;
        case SOAP_TYPE_ns2__getNamesResponse:
          soap_serialize_ns2__getNamesResponse(soap, (const struct ns2__getNamesResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeSynonyms:
          soap_serialize_ns2__getDataTypeSynonyms(soap, (const struct ns2__getDataTypeSynonyms *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
          soap_serialize_ns2__getDataTypeSynonymsResponse(soap, (const struct ns2__getDataTypeSynonymsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceLocation:
          soap_serialize_ns2__getResourceLocation(soap, (const struct ns2__getResourceLocation *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceLocationResponse:
          soap_serialize_ns2__getResourceLocationResponse(soap, (const struct ns2__getResourceLocationResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInstitution:
          soap_serialize_ns2__getResourceInstitution(soap, (const struct ns2__getResourceInstitution *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInstitutionResponse:
          soap_serialize_ns2__getResourceInstitutionResponse(soap, (const struct ns2__getResourceInstitutionResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInfo:
          soap_serialize_ns2__getResourceInfo(soap, (const struct ns2__getResourceInfo *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInfoResponse:
          soap_serialize_ns2__getResourceInfoResponse(soap, (const struct ns2__getResourceInfoResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypePattern:
          soap_serialize_ns2__getDataTypePattern(soap, (const struct ns2__getDataTypePattern *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypePatternResponse:
          soap_serialize_ns2__getDataTypePatternResponse(soap, (const struct ns2__getDataTypePatternResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getMiriamURI:
          soap_serialize_ns2__getMiriamURI(soap, (const struct ns2__getMiriamURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getMiriamURIResponse:
          soap_serialize_ns2__getMiriamURIResponse(soap, (const struct ns2__getMiriamURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getOfficialDataTypeURI:
          soap_serialize_ns2__getOfficialDataTypeURI(soap, (const struct ns2__getOfficialDataTypeURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
          soap_serialize_ns2__getOfficialDataTypeURIResponse(soap, (const struct ns2__getOfficialDataTypeURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__isDeprecated:
          soap_serialize_ns2__isDeprecated(soap, (const struct ns2__isDeprecated *)ptr);
          break;
        case SOAP_TYPE_ns2__isDeprecatedResponse:
          soap_serialize_ns2__isDeprecatedResponse(soap, (const struct ns2__isDeprecatedResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocations_:
          soap_serialize_ns2__getLocations_(soap, (const struct ns2__getLocations_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocationsResponse_:
          soap_serialize_ns2__getLocationsResponse_(soap, (const struct ns2__getLocationsResponse_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocations:
          soap_serialize_ns2__getLocations(soap, (const struct ns2__getLocations *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocationsResponse:
          soap_serialize_ns2__getLocationsResponse(soap, (const struct ns2__getLocationsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeDef:
          soap_serialize_ns2__getDataTypeDef(soap, (const struct ns2__getDataTypeDef *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeDefResponse:
          soap_serialize_ns2__getDataTypeDefResponse(soap, (const struct ns2__getDataTypeDefResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIs:
          soap_serialize_ns2__getDataTypeURIs(soap, (const struct ns2__getDataTypeURIs *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIsResponse:
          soap_serialize_ns2__getDataTypeURIsResponse(soap, (const struct ns2__getDataTypeURIsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURI:
          soap_serialize_ns2__getDataTypeURI(soap, (const struct ns2__getDataTypeURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIResponse:
          soap_serialize_ns2__getDataTypeURIResponse(soap, (const struct ns2__getDataTypeURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getJavaLibraryVersion:
          soap_serialize_ns2__getJavaLibraryVersion(soap, (const struct ns2__getJavaLibraryVersion *)ptr);
          break;
        case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
          soap_serialize_ns2__getJavaLibraryVersionResponse(soap, (const struct ns2__getJavaLibraryVersionResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesVersion:
          soap_serialize_ns2__getServicesVersion(soap, (const struct ns2__getServicesVersion *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesVersionResponse:
          soap_serialize_ns2__getServicesVersionResponse(soap, (const struct ns2__getServicesVersionResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesInfo:
          soap_serialize_ns2__getServicesInfo(soap, (const struct ns2__getServicesInfo *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesInfoResponse:
          soap_serialize_ns2__getServicesInfoResponse(soap, (const struct ns2__getServicesInfoResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataResources:
          soap_serialize_ns2__getDataResources(soap, (const struct ns2__getDataResources *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataResourcesResponse:
          soap_serialize_ns2__getDataResourcesResponse(soap, (const struct ns2__getDataResourcesResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getURI:
          soap_serialize_ns2__getURI(soap, (const struct ns2__getURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getURIResponse:
          soap_serialize_ns2__getURIResponse(soap, (const struct ns2__getURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocation:
          soap_serialize_ns2__getLocation(soap, (const struct ns2__getLocation *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocationResponse:
          soap_serialize_ns2__getLocationResponse(soap, (const struct ns2__getLocationResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getName:
          soap_serialize_ns2__getName(soap, (const struct ns2__getName *)ptr);
          break;
        case SOAP_TYPE_ns2__getNameResponse:
          soap_serialize_ns2__getNameResponse(soap, (const struct ns2__getNameResponse *)ptr);
          break;
        case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
          soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, (ArrayOf_USCORExsd_USCOREstring *const*)ptr);
          break;
        case SOAP_TYPE_PointerTostd__string:
          soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
          break;
        case SOAP_TYPE__QName:
          soap_serialize_string(soap, (char*const*)&ptr);
          break;
        case SOAP_TYPE_string:
          soap_serialize_string(soap, (char*const*)&ptr);
          break;
      }
  }

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
  switch (t)
    {
      case SOAP_TYPE_std__string:
        return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
        return (void*)soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getNameResponse:
        return (void*)soap_instantiate_ns2__getNameResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getName:
        return (void*)soap_instantiate_ns2__getName(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getLocationResponse:
        return (void*)soap_instantiate_ns2__getLocationResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getLocation:
        return (void*)soap_instantiate_ns2__getLocation(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getURIResponse:
        return (void*)soap_instantiate_ns2__getURIResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getURI:
        return (void*)soap_instantiate_ns2__getURI(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataResourcesResponse:
        return (void*)soap_instantiate_ns2__getDataResourcesResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataResources:
        return (void*)soap_instantiate_ns2__getDataResources(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getServicesInfoResponse:
        return (void*)soap_instantiate_ns2__getServicesInfoResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getServicesInfo:
        return (void*)soap_instantiate_ns2__getServicesInfo(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getServicesVersionResponse:
        return (void*)soap_instantiate_ns2__getServicesVersionResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getServicesVersion:
        return (void*)soap_instantiate_ns2__getServicesVersion(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
        return (void*)soap_instantiate_ns2__getJavaLibraryVersionResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getJavaLibraryVersion:
        return (void*)soap_instantiate_ns2__getJavaLibraryVersion(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeURIResponse:
        return (void*)soap_instantiate_ns2__getDataTypeURIResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeURI:
        return (void*)soap_instantiate_ns2__getDataTypeURI(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeURIsResponse:
        return (void*)soap_instantiate_ns2__getDataTypeURIsResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeURIs:
        return (void*)soap_instantiate_ns2__getDataTypeURIs(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeDefResponse:
        return (void*)soap_instantiate_ns2__getDataTypeDefResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeDef:
        return (void*)soap_instantiate_ns2__getDataTypeDef(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getLocationsResponse:
        return (void*)soap_instantiate_ns2__getLocationsResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getLocations:
        return (void*)soap_instantiate_ns2__getLocations(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getLocationsResponse_:
        return (void*)soap_instantiate_ns2__getLocationsResponse_(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getLocations_:
        return (void*)soap_instantiate_ns2__getLocations_(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__isDeprecatedResponse:
        return (void*)soap_instantiate_ns2__isDeprecatedResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__isDeprecated:
        return (void*)soap_instantiate_ns2__isDeprecated(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
        return (void*)soap_instantiate_ns2__getOfficialDataTypeURIResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getOfficialDataTypeURI:
        return (void*)soap_instantiate_ns2__getOfficialDataTypeURI(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getMiriamURIResponse:
        return (void*)soap_instantiate_ns2__getMiriamURIResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getMiriamURI:
        return (void*)soap_instantiate_ns2__getMiriamURI(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypePatternResponse:
        return (void*)soap_instantiate_ns2__getDataTypePatternResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypePattern:
        return (void*)soap_instantiate_ns2__getDataTypePattern(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getResourceInfoResponse:
        return (void*)soap_instantiate_ns2__getResourceInfoResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getResourceInfo:
        return (void*)soap_instantiate_ns2__getResourceInfo(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getResourceInstitutionResponse:
        return (void*)soap_instantiate_ns2__getResourceInstitutionResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getResourceInstitution:
        return (void*)soap_instantiate_ns2__getResourceInstitution(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getResourceLocationResponse:
        return (void*)soap_instantiate_ns2__getResourceLocationResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getResourceLocation:
        return (void*)soap_instantiate_ns2__getResourceLocation(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
        return (void*)soap_instantiate_ns2__getDataTypeSynonymsResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypeSynonyms:
        return (void*)soap_instantiate_ns2__getDataTypeSynonyms(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getNamesResponse:
        return (void*)soap_instantiate_ns2__getNamesResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getNames:
        return (void*)soap_instantiate_ns2__getNames(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypesNameResponse:
        return (void*)soap_instantiate_ns2__getDataTypesNameResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypesName:
        return (void*)soap_instantiate_ns2__getDataTypesName(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypesIdResponse:
        return (void*)soap_instantiate_ns2__getDataTypesIdResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__getDataTypesId:
        return (void*)soap_instantiate_ns2__getDataTypesId(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__checkRegExpResponse:
        return (void*)soap_instantiate_ns2__checkRegExpResponse(soap, -1, type, arrayType, n);
      case SOAP_TYPE_ns2__checkRegExp:
        return (void*)soap_instantiate_ns2__checkRegExp(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
      case SOAP_TYPE_SOAP_ENV__Header:
        return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
      case SOAP_TYPE_SOAP_ENV__Code:
        return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
      case SOAP_TYPE_SOAP_ENV__Detail:
        return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
      case SOAP_TYPE_SOAP_ENV__Reason:
        return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
      case SOAP_TYPE_SOAP_ENV__Fault:
        return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
    }

  return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{
  switch (p->type)
    {
      case SOAP_TYPE_std__string:

        if (p->size < 0)
          delete(std::string*)p->ptr;
        else
          delete[](std::string*)p->ptr;

        break;
      case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:

        if (p->size < 0)
          delete(ArrayOf_USCORExsd_USCOREstring*)p->ptr;
        else
          delete[](ArrayOf_USCORExsd_USCOREstring*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getNameResponse:

        if (p->size < 0)
          delete(struct ns2__getNameResponse*)p->ptr;
        else
          delete[](struct ns2__getNameResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getName:

        if (p->size < 0)
          delete(struct ns2__getName*)p->ptr;
        else
          delete[](struct ns2__getName*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getLocationResponse:

        if (p->size < 0)
          delete(struct ns2__getLocationResponse*)p->ptr;
        else
          delete[](struct ns2__getLocationResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getLocation:

        if (p->size < 0)
          delete(struct ns2__getLocation*)p->ptr;
        else
          delete[](struct ns2__getLocation*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getURIResponse:

        if (p->size < 0)
          delete(struct ns2__getURIResponse*)p->ptr;
        else
          delete[](struct ns2__getURIResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getURI:

        if (p->size < 0)
          delete(struct ns2__getURI*)p->ptr;
        else
          delete[](struct ns2__getURI*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataResourcesResponse:

        if (p->size < 0)
          delete(struct ns2__getDataResourcesResponse*)p->ptr;
        else
          delete[](struct ns2__getDataResourcesResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataResources:

        if (p->size < 0)
          delete(struct ns2__getDataResources*)p->ptr;
        else
          delete[](struct ns2__getDataResources*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getServicesInfoResponse:

        if (p->size < 0)
          delete(struct ns2__getServicesInfoResponse*)p->ptr;
        else
          delete[](struct ns2__getServicesInfoResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getServicesInfo:

        if (p->size < 0)
          delete(struct ns2__getServicesInfo*)p->ptr;
        else
          delete[](struct ns2__getServicesInfo*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getServicesVersionResponse:

        if (p->size < 0)
          delete(struct ns2__getServicesVersionResponse*)p->ptr;
        else
          delete[](struct ns2__getServicesVersionResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getServicesVersion:

        if (p->size < 0)
          delete(struct ns2__getServicesVersion*)p->ptr;
        else
          delete[](struct ns2__getServicesVersion*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:

        if (p->size < 0)
          delete(struct ns2__getJavaLibraryVersionResponse*)p->ptr;
        else
          delete[](struct ns2__getJavaLibraryVersionResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getJavaLibraryVersion:

        if (p->size < 0)
          delete(struct ns2__getJavaLibraryVersion*)p->ptr;
        else
          delete[](struct ns2__getJavaLibraryVersion*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeURIResponse:

        if (p->size < 0)
          delete(struct ns2__getDataTypeURIResponse*)p->ptr;
        else
          delete[](struct ns2__getDataTypeURIResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeURI:

        if (p->size < 0)
          delete(struct ns2__getDataTypeURI*)p->ptr;
        else
          delete[](struct ns2__getDataTypeURI*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeURIsResponse:

        if (p->size < 0)
          delete(struct ns2__getDataTypeURIsResponse*)p->ptr;
        else
          delete[](struct ns2__getDataTypeURIsResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeURIs:

        if (p->size < 0)
          delete(struct ns2__getDataTypeURIs*)p->ptr;
        else
          delete[](struct ns2__getDataTypeURIs*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeDefResponse:

        if (p->size < 0)
          delete(struct ns2__getDataTypeDefResponse*)p->ptr;
        else
          delete[](struct ns2__getDataTypeDefResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeDef:

        if (p->size < 0)
          delete(struct ns2__getDataTypeDef*)p->ptr;
        else
          delete[](struct ns2__getDataTypeDef*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getLocationsResponse:

        if (p->size < 0)
          delete(struct ns2__getLocationsResponse*)p->ptr;
        else
          delete[](struct ns2__getLocationsResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getLocations:

        if (p->size < 0)
          delete(struct ns2__getLocations*)p->ptr;
        else
          delete[](struct ns2__getLocations*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getLocationsResponse_:

        if (p->size < 0)
          delete(struct ns2__getLocationsResponse_*)p->ptr;
        else
          delete[](struct ns2__getLocationsResponse_*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getLocations_:

        if (p->size < 0)
          delete(struct ns2__getLocations_*)p->ptr;
        else
          delete[](struct ns2__getLocations_*)p->ptr;

        break;
      case SOAP_TYPE_ns2__isDeprecatedResponse:

        if (p->size < 0)
          delete(struct ns2__isDeprecatedResponse*)p->ptr;
        else
          delete[](struct ns2__isDeprecatedResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__isDeprecated:

        if (p->size < 0)
          delete(struct ns2__isDeprecated*)p->ptr;
        else
          delete[](struct ns2__isDeprecated*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:

        if (p->size < 0)
          delete(struct ns2__getOfficialDataTypeURIResponse*)p->ptr;
        else
          delete[](struct ns2__getOfficialDataTypeURIResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getOfficialDataTypeURI:

        if (p->size < 0)
          delete(struct ns2__getOfficialDataTypeURI*)p->ptr;
        else
          delete[](struct ns2__getOfficialDataTypeURI*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getMiriamURIResponse:

        if (p->size < 0)
          delete(struct ns2__getMiriamURIResponse*)p->ptr;
        else
          delete[](struct ns2__getMiriamURIResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getMiriamURI:

        if (p->size < 0)
          delete(struct ns2__getMiriamURI*)p->ptr;
        else
          delete[](struct ns2__getMiriamURI*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypePatternResponse:

        if (p->size < 0)
          delete(struct ns2__getDataTypePatternResponse*)p->ptr;
        else
          delete[](struct ns2__getDataTypePatternResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypePattern:

        if (p->size < 0)
          delete(struct ns2__getDataTypePattern*)p->ptr;
        else
          delete[](struct ns2__getDataTypePattern*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getResourceInfoResponse:

        if (p->size < 0)
          delete(struct ns2__getResourceInfoResponse*)p->ptr;
        else
          delete[](struct ns2__getResourceInfoResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getResourceInfo:

        if (p->size < 0)
          delete(struct ns2__getResourceInfo*)p->ptr;
        else
          delete[](struct ns2__getResourceInfo*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getResourceInstitutionResponse:

        if (p->size < 0)
          delete(struct ns2__getResourceInstitutionResponse*)p->ptr;
        else
          delete[](struct ns2__getResourceInstitutionResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getResourceInstitution:

        if (p->size < 0)
          delete(struct ns2__getResourceInstitution*)p->ptr;
        else
          delete[](struct ns2__getResourceInstitution*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getResourceLocationResponse:

        if (p->size < 0)
          delete(struct ns2__getResourceLocationResponse*)p->ptr;
        else
          delete[](struct ns2__getResourceLocationResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getResourceLocation:

        if (p->size < 0)
          delete(struct ns2__getResourceLocation*)p->ptr;
        else
          delete[](struct ns2__getResourceLocation*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:

        if (p->size < 0)
          delete(struct ns2__getDataTypeSynonymsResponse*)p->ptr;
        else
          delete[](struct ns2__getDataTypeSynonymsResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypeSynonyms:

        if (p->size < 0)
          delete(struct ns2__getDataTypeSynonyms*)p->ptr;
        else
          delete[](struct ns2__getDataTypeSynonyms*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getNamesResponse:

        if (p->size < 0)
          delete(struct ns2__getNamesResponse*)p->ptr;
        else
          delete[](struct ns2__getNamesResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getNames:

        if (p->size < 0)
          delete(struct ns2__getNames*)p->ptr;
        else
          delete[](struct ns2__getNames*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypesNameResponse:

        if (p->size < 0)
          delete(struct ns2__getDataTypesNameResponse*)p->ptr;
        else
          delete[](struct ns2__getDataTypesNameResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypesName:

        if (p->size < 0)
          delete(struct ns2__getDataTypesName*)p->ptr;
        else
          delete[](struct ns2__getDataTypesName*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypesIdResponse:

        if (p->size < 0)
          delete(struct ns2__getDataTypesIdResponse*)p->ptr;
        else
          delete[](struct ns2__getDataTypesIdResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__getDataTypesId:

        if (p->size < 0)
          delete(struct ns2__getDataTypesId*)p->ptr;
        else
          delete[](struct ns2__getDataTypesId*)p->ptr;

        break;
      case SOAP_TYPE_ns2__checkRegExpResponse:

        if (p->size < 0)
          delete(struct ns2__checkRegExpResponse*)p->ptr;
        else
          delete[](struct ns2__checkRegExpResponse*)p->ptr;

        break;
      case SOAP_TYPE_ns2__checkRegExp:

        if (p->size < 0)
          delete(struct ns2__checkRegExp*)p->ptr;
        else
          delete[](struct ns2__checkRegExp*)p->ptr;

        break;
      case SOAP_TYPE_SOAP_ENV__Header:

        if (p->size < 0)
          delete(struct SOAP_ENV__Header*)p->ptr;
        else
          delete[](struct SOAP_ENV__Header*)p->ptr;

        break;
      case SOAP_TYPE_SOAP_ENV__Code:

        if (p->size < 0)
          delete(struct SOAP_ENV__Code*)p->ptr;
        else
          delete[](struct SOAP_ENV__Code*)p->ptr;

        break;
      case SOAP_TYPE_SOAP_ENV__Detail:

        if (p->size < 0)
          delete(struct SOAP_ENV__Detail*)p->ptr;
        else
          delete[](struct SOAP_ENV__Detail*)p->ptr;

        break;
      case SOAP_TYPE_SOAP_ENV__Reason:

        if (p->size < 0)
          delete(struct SOAP_ENV__Reason*)p->ptr;
        else
          delete[](struct SOAP_ENV__Reason*)p->ptr;

        break;
      case SOAP_TYPE_SOAP_ENV__Fault:

        if (p->size < 0)
          delete(struct SOAP_ENV__Fault*)p->ptr;
        else
          delete[](struct SOAP_ENV__Fault*)p->ptr;

        break;
      default: return SOAP_ERR;
    }

  return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{
  return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
  *a = SOAP_DEFAULT_byte;
#else
  *a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);

  if (soap_out_byte(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
  return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
  if ((p = soap_in_byte(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
  char *p;
  p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
  *a = SOAP_DEFAULT_int;
#else
  *a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);

  if (soap_out_int(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
  return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
  if ((p = soap_in_int(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
  int *p;
  p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
  (void)soap; /* appease -Wall -Werror */
  p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{
  (void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);

  if (soap_out_std__string(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
  if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
    return soap_element_null(soap, tag, id, type);

  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
    return soap->error;

  return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
  if ((p = soap_in_std__string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;

  if (!s)
    s = soap_new_std__string(soap, -1);

  if (soap->null)
    if (s)
      s->erase();

  if (soap->body && !*soap->href)
    {
      char *t;
      s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);

      if (s)
        if ((t = soap_string_in(soap, 1, -1, -1)))
          s->assign(t);
        else
          return NULL;
    }
  else
    s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);

  if (soap->body && soap_element_end_in(soap, tag))
    return NULL;

  return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{
  return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new std::string;

      if (size)
        *size = sizeof(std::string);
    }
  else
    {
      cp->ptr = (void*)new std::string[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(std::string);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
  *(std::string*)p = *(std::string*)q;
}

void ArrayOf_USCORExsd_USCOREstring::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->__size = 0;
  this->__ptr = NULL;
}

void ArrayOf_USCORExsd_USCOREstring::soap_serialize(struct soap *soap) const
{
  if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring))
    for (int i = 0; i < this->__size; i++)
      {
        soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
        soap_serialize_std__string(soap, this->__ptr + i);
      }
}

int ArrayOf_USCORExsd_USCOREstring::soap_put(struct soap *soap, const char *tag, const char *type) const
{
  register int id = soap_embed(soap, (void*)this, (struct soap_array*) & this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);

  if (this->soap_out(soap, tag, id, type))
    return soap->error;

  return soap_putindependent(soap);
}

int ArrayOf_USCORExsd_USCOREstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ArrayOf_USCORExsd_USCOREstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, const ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
  int i, n = a->__size;
  char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
  id = soap_element_id(soap, tag, id, a, (struct soap_array*) & a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);

  if (id < 0)
    return soap->error;

  if (soap_array_begin_out(soap, tag, id, t, NULL))
    return soap->error;

  for (i = 0; i < n; i++)
    {
      soap->position = 1;
      soap->positions[0] = i;
      soap_out_std__string(soap, "item", -1, &a->__ptr[i], "");
    }

  soap->position = 0;
  return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCORExsd_USCOREstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ArrayOf_USCORExsd_USCOREstring(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_get_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *p, const char *tag, const char *type)
{
  if ((p = soap_in_ArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

void *ArrayOf_USCORExsd_USCOREstring::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_in_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
  int i, j;
  std::string *p;

  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;

  if (soap_match_array(soap, type))
    {
      soap->error = SOAP_TYPE;
      return NULL;
    }

  a = (ArrayOf_USCORExsd_USCOREstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOf_USCORExsd_USCOREstring), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  if (soap->alloced)
    a->soap_default(soap);

  if (soap->body && !*soap->href)
    {
      a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);

      if (a->__size >= 0)
        {
          a->__ptr = soap_new_std__string(soap, a->__size);

          for (i = 0; i < a->__size; i++)
            soap_default_std__string(soap, a->__ptr + i);

          for (i = 0; i < a->__size; i++)
            {
              soap_peek_element(soap);

              if (soap->position)
                {
                  i = soap->positions[0] - j;

                  if (i < 0 || i >= a->__size)
                    {
                      soap->error = SOAP_IOB;
                      return NULL;
                    }
                }

              if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
                {
                  if (soap->error != SOAP_NO_TAG)
                    return NULL;

                  soap->error = SOAP_OK;
                  break;
                }
            }
        }
      else
        {
          std::string q;

          if (soap_new_block(soap) == NULL)
            return NULL;

          for (a->__size = 0; ; a->__size++)
            {
              p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));

              if (!p)
                return NULL;

              memcpy(p, &q, sizeof(std::string));
              soap_default_std__string(soap, p);

              if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
                {
                  if (soap->error != SOAP_NO_TAG)
                    return NULL;

                  soap->error = SOAP_OK;
                  break;
                }
            }

          soap_pop_block(soap, NULL);

          if (soap->blist->size)
            a->__ptr = soap_new_std__string(soap, soap->blist->size / sizeof(std::string));
          else
            a->__ptr = NULL;

          soap_save_block(soap, NULL, (char*)a->__ptr, 1);
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (ArrayOf_USCORExsd_USCOREstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, 0, sizeof(ArrayOf_USCORExsd_USCOREstring), 0, soap_copy_ArrayOf_USCORExsd_USCOREstring);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC6 soap_new_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n)
{
  return soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_instantiate_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCORExsd_USCOREstring(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new ArrayOf_USCORExsd_USCOREstring;

      if (size)
        *size = sizeof(ArrayOf_USCORExsd_USCOREstring);

      ((ArrayOf_USCORExsd_USCOREstring*)cp->ptr)->soap = soap;
    }
  else
    {
      cp->ptr = (void*)new ArrayOf_USCORExsd_USCOREstring[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(ArrayOf_USCORExsd_USCOREstring);

      for (int i = 0; i < n; i++)
        ((ArrayOf_USCORExsd_USCOREstring*)cp->ptr)[i].soap = soap;
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (ArrayOf_USCORExsd_USCOREstring*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCORExsd_USCOREstring %p -> %p\n", q, p));
  *(ArrayOf_USCORExsd_USCOREstring*)p = *(ArrayOf_USCORExsd_USCOREstring*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->faultcode);
  soap_default_string(soap, &a->faultstring);
  soap_default_string(soap, &a->faultactor);
  a->detail = NULL;
  a->SOAP_ENV__Code = NULL;
  a->SOAP_ENV__Reason = NULL;
  soap_default_string(soap, &a->SOAP_ENV__Node);
  soap_default_string(soap, &a->SOAP_ENV__Role);
  a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->faultcode);
  soap_serialize_string(soap, &a->faultstring);
  soap_serialize_string(soap, &a->faultactor);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
  soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
  soap_serialize_string(soap, &a->SOAP_ENV__Node);
  soap_serialize_string(soap, &a->SOAP_ENV__Role);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);

  if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
  const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);

  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
    return soap->error;

  if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
    return soap->error;

  if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
    return soap->error;

  if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
    return soap->error;

  if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
    return soap->error;

  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
    return soap->error;

  if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
    return soap->error;

  if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
    return soap->error;

  if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
    return soap->error;

  if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
  if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
  size_t soap_flag_faultcode = 1;
  size_t soap_flag_faultstring = 1;
  size_t soap_flag_faultactor = 1;
  size_t soap_flag_detail = 1;
  size_t soap_flag_SOAP_ENV__Code = 1;
  size_t soap_flag_SOAP_ENV__Reason = 1;
  size_t soap_flag_SOAP_ENV__Node = 1;
  size_t soap_flag_SOAP_ENV__Role = 1;
  size_t soap_flag_SOAP_ENV__Detail = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_SOAP_ENV__Fault(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
              {
                soap_flag_faultcode--;
                continue;
              }

          if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
              {
                soap_flag_faultstring--;
                continue;
              }

          if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
              {
                soap_flag_faultactor--;
                continue;
              }

          if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
              {
                soap_flag_detail--;
                continue;
              }

          if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
              {
                soap_flag_SOAP_ENV__Code--;
                continue;
              }

          if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
              {
                soap_flag_SOAP_ENV__Reason--;
                continue;
              }

          if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
              {
                soap_flag_SOAP_ENV__Node--;
                continue;
              }

          if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
              {
                soap_flag_SOAP_ENV__Role--;
                continue;
              }

          if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
              {
                soap_flag_SOAP_ENV__Detail--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
  return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct SOAP_ENV__Fault;

      if (size)
        *size = sizeof(struct SOAP_ENV__Fault);
    }
  else
    {
      cp->ptr = (void*)new struct SOAP_ENV__Fault[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct SOAP_ENV__Fault);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
  *(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);

  if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
    return soap->error;

  if (soap->lang)
    soap_set_attr(soap, "xml:lang", soap->lang);

  if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
  if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
  size_t soap_flag_SOAP_ENV__Text = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_SOAP_ENV__Reason(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
              {
                soap_flag_SOAP_ENV__Text--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
  return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct SOAP_ENV__Reason;

      if (size)
        *size = sizeof(struct SOAP_ENV__Reason);
    }
  else
    {
      cp->ptr = (void*)new struct SOAP_ENV__Reason[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct SOAP_ENV__Reason);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
  *(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->__type = 0;
  a->fault = NULL;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);

  if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
    return soap->error;

  if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
    return soap->error;

  soap_outliteral(soap, "-any", &a->__any, NULL);
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
  if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
  size_t soap_flag_fault = 1;
  size_t soap_flag___any = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_SOAP_ENV__Detail(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
            if ((a->fault = soap_getelement(soap, &a->__type)))
              {
                soap_flag_fault = 0;
                continue;
              }

          if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_inliteral(soap, "-any", &a->__any))
              {
                soap_flag___any--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
  return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct SOAP_ENV__Detail;

      if (size)
        *size = sizeof(struct SOAP_ENV__Detail);
    }
  else
    {
      cp->ptr = (void*)new struct SOAP_ENV__Detail[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct SOAP_ENV__Detail);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
  *(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->SOAP_ENV__Value);
  a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->SOAP_ENV__Value);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);

  if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
  const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);

  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
    return soap->error;

  if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
    return soap->error;

  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
  if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
  size_t soap_flag_SOAP_ENV__Value = 1;
  size_t soap_flag_SOAP_ENV__Subcode = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_SOAP_ENV__Code(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
              {
                soap_flag_SOAP_ENV__Value--;
                continue;
              }

          if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
              {
                soap_flag_SOAP_ENV__Subcode--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
  return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct SOAP_ENV__Code;

      if (size)
        *size = sizeof(struct SOAP_ENV__Code);
    }
  else
    {
      cp->ptr = (void*)new struct SOAP_ENV__Code[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct SOAP_ENV__Code);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
  *(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);

  if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
  if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_SOAP_ENV__Header(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
  return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct SOAP_ENV__Header;

      if (size)
        *size = sizeof(struct SOAP_ENV__Header);
    }
  else
    {
      cp->ptr = (void*)new struct SOAP_ENV__Header[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct SOAP_ENV__Header);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
  *(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__checkRegExp(struct soap *soap, struct ns2__checkRegExp *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_identifier);
  soap_default_std__string(soap, &a->_datatype);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__checkRegExp(struct soap *soap, const struct ns2__checkRegExp *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_identifier, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_identifier);
  soap_embedded(soap, &a->_datatype, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_datatype);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__checkRegExp(struct soap *soap, const struct ns2__checkRegExp *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__checkRegExp);

  if (soap_out_ns2__checkRegExp(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__checkRegExp(struct soap *soap, const char *tag, int id, const struct ns2__checkRegExp *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__checkRegExp), type))
    return soap->error;

  if (soap_out_std__string(soap, "identifier", -1, &a->_identifier, ""))
    return soap->error;

  if (soap_out_std__string(soap, "datatype", -1, &a->_datatype, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__checkRegExp * SOAP_FMAC4 soap_get_ns2__checkRegExp(struct soap *soap, struct ns2__checkRegExp *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__checkRegExp(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__checkRegExp * SOAP_FMAC4 soap_in_ns2__checkRegExp(struct soap *soap, const char *tag, struct ns2__checkRegExp *a, const char *type)
{
  size_t soap_flag__identifier = 1;
  size_t soap_flag__datatype = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__checkRegExp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__checkRegExp, sizeof(struct ns2__checkRegExp), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__checkRegExp(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_identifier, "xsd:string"))
              {
                soap_flag__identifier--;
                continue;
              }

          if (soap_flag__datatype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_datatype, "xsd:string"))
              {
                soap_flag__datatype--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__checkRegExp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__checkRegExp, 0, sizeof(struct ns2__checkRegExp), 0, soap_copy_ns2__checkRegExp);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__identifier > 0 || soap_flag__datatype > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__checkRegExp * SOAP_FMAC6 soap_new_ns2__checkRegExp(struct soap *soap, int n)
{
  return soap_instantiate_ns2__checkRegExp(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__checkRegExp(struct soap *soap, struct ns2__checkRegExp *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__checkRegExp * SOAP_FMAC4 soap_instantiate_ns2__checkRegExp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__checkRegExp(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__checkRegExp, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__checkRegExp;

      if (size)
        *size = sizeof(struct ns2__checkRegExp);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__checkRegExp[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__checkRegExp);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__checkRegExp*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__checkRegExp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__checkRegExp %p -> %p\n", q, p));
  *(struct ns2__checkRegExp*)p = *(struct ns2__checkRegExp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__checkRegExpResponse(struct soap *soap, struct ns2__checkRegExpResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_checkRegExpReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__checkRegExpResponse(struct soap *soap, const struct ns2__checkRegExpResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_checkRegExpReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_checkRegExpReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__checkRegExpResponse(struct soap *soap, const struct ns2__checkRegExpResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__checkRegExpResponse);

  if (soap_out_ns2__checkRegExpResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__checkRegExpResponse(struct soap *soap, const char *tag, int id, const struct ns2__checkRegExpResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__checkRegExpResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "checkRegExpReturn", -1, &a->_checkRegExpReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__checkRegExpResponse * SOAP_FMAC4 soap_get_ns2__checkRegExpResponse(struct soap *soap, struct ns2__checkRegExpResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__checkRegExpResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__checkRegExpResponse * SOAP_FMAC4 soap_in_ns2__checkRegExpResponse(struct soap *soap, const char *tag, struct ns2__checkRegExpResponse *a, const char *type)
{
  size_t soap_flag__checkRegExpReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__checkRegExpResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__checkRegExpResponse, sizeof(struct ns2__checkRegExpResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__checkRegExpResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__checkRegExpReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_checkRegExpReturn, "xsd:string"))
              {
                soap_flag__checkRegExpReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__checkRegExpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__checkRegExpResponse, 0, sizeof(struct ns2__checkRegExpResponse), 0, soap_copy_ns2__checkRegExpResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__checkRegExpReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__checkRegExpResponse * SOAP_FMAC6 soap_new_ns2__checkRegExpResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__checkRegExpResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__checkRegExpResponse(struct soap *soap, struct ns2__checkRegExpResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__checkRegExpResponse * SOAP_FMAC4 soap_instantiate_ns2__checkRegExpResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__checkRegExpResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__checkRegExpResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__checkRegExpResponse;

      if (size)
        *size = sizeof(struct ns2__checkRegExpResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__checkRegExpResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__checkRegExpResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__checkRegExpResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__checkRegExpResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__checkRegExpResponse %p -> %p\n", q, p));
  *(struct ns2__checkRegExpResponse*)p = *(struct ns2__checkRegExpResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesId(struct soap *soap, struct ns2__getDataTypesId *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesId(struct soap *soap, const struct ns2__getDataTypesId *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesId(struct soap *soap, const struct ns2__getDataTypesId *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesId);

  if (soap_out_ns2__getDataTypesId(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesId(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesId *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesId), type))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesId * SOAP_FMAC4 soap_get_ns2__getDataTypesId(struct soap *soap, struct ns2__getDataTypesId *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypesId(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypesId * SOAP_FMAC4 soap_in_ns2__getDataTypesId(struct soap *soap, const char *tag, struct ns2__getDataTypesId *a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypesId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesId, sizeof(struct ns2__getDataTypesId), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypesId(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypesId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesId, 0, sizeof(struct ns2__getDataTypesId), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypesId * SOAP_FMAC6 soap_new_ns2__getDataTypesId(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypesId(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesId(struct soap *soap, struct ns2__getDataTypesId *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesId * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesId(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesId, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypesId;

      if (size)
        *size = sizeof(struct ns2__getDataTypesId);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypesId[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypesId);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypesId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesId %p -> %p\n", q, p));
  *(struct ns2__getDataTypesId*)p = *(struct ns2__getDataTypesId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesIdResponse(struct soap *soap, struct ns2__getDataTypesIdResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->getDataTypesIdReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesIdResponse(struct soap *soap, const struct ns2__getDataTypesIdResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->getDataTypesIdReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesIdResponse(struct soap *soap, const struct ns2__getDataTypesIdResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesIdResponse);

  if (soap_out_ns2__getDataTypesIdResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesIdResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesIdResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesIdResponse), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesIdReturn", -1, &a->getDataTypesIdReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesIdResponse * SOAP_FMAC4 soap_get_ns2__getDataTypesIdResponse(struct soap *soap, struct ns2__getDataTypesIdResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypesIdResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypesIdResponse * SOAP_FMAC4 soap_in_ns2__getDataTypesIdResponse(struct soap *soap, const char *tag, struct ns2__getDataTypesIdResponse *a, const char *type)
{
  size_t soap_flag_getDataTypesIdReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypesIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesIdResponse, sizeof(struct ns2__getDataTypesIdResponse), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypesIdResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_getDataTypesIdReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesIdReturn", &a->getDataTypesIdReturn, "xsd:string"))
              {
                soap_flag_getDataTypesIdReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypesIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesIdResponse, 0, sizeof(struct ns2__getDataTypesIdResponse), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypesIdResponse * SOAP_FMAC6 soap_new_ns2__getDataTypesIdResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypesIdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesIdResponse(struct soap *soap, struct ns2__getDataTypesIdResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesIdResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesIdResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesIdResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypesIdResponse;

      if (size)
        *size = sizeof(struct ns2__getDataTypesIdResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypesIdResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypesIdResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypesIdResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesIdResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypesIdResponse*)p = *(struct ns2__getDataTypesIdResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesName(struct soap *soap, struct ns2__getDataTypesName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesName(struct soap *soap, const struct ns2__getDataTypesName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesName(struct soap *soap, const struct ns2__getDataTypesName *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesName);

  if (soap_out_ns2__getDataTypesName(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesName(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesName *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesName), type))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesName * SOAP_FMAC4 soap_get_ns2__getDataTypesName(struct soap *soap, struct ns2__getDataTypesName *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypesName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypesName * SOAP_FMAC4 soap_in_ns2__getDataTypesName(struct soap *soap, const char *tag, struct ns2__getDataTypesName *a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypesName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesName, sizeof(struct ns2__getDataTypesName), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypesName(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypesName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesName, 0, sizeof(struct ns2__getDataTypesName), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypesName * SOAP_FMAC6 soap_new_ns2__getDataTypesName(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypesName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesName(struct soap *soap, struct ns2__getDataTypesName *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesName * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesName(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesName, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypesName;

      if (size)
        *size = sizeof(struct ns2__getDataTypesName);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypesName[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypesName);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypesName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesName %p -> %p\n", q, p));
  *(struct ns2__getDataTypesName*)p = *(struct ns2__getDataTypesName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesNameResponse(struct soap *soap, struct ns2__getDataTypesNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->getDataTypesNameReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesNameResponse(struct soap *soap, const struct ns2__getDataTypesNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->getDataTypesNameReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesNameResponse(struct soap *soap, const struct ns2__getDataTypesNameResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesNameResponse);

  if (soap_out_ns2__getDataTypesNameResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesNameResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesNameResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesNameResponse), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesNameReturn", -1, &a->getDataTypesNameReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesNameResponse * SOAP_FMAC4 soap_get_ns2__getDataTypesNameResponse(struct soap *soap, struct ns2__getDataTypesNameResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypesNameResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypesNameResponse * SOAP_FMAC4 soap_in_ns2__getDataTypesNameResponse(struct soap *soap, const char *tag, struct ns2__getDataTypesNameResponse *a, const char *type)
{
  size_t soap_flag_getDataTypesNameReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypesNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesNameResponse, sizeof(struct ns2__getDataTypesNameResponse), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypesNameResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_getDataTypesNameReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesNameReturn", &a->getDataTypesNameReturn, "xsd:string"))
              {
                soap_flag_getDataTypesNameReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypesNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesNameResponse, 0, sizeof(struct ns2__getDataTypesNameResponse), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypesNameResponse * SOAP_FMAC6 soap_new_ns2__getDataTypesNameResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypesNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesNameResponse(struct soap *soap, struct ns2__getDataTypesNameResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesNameResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesNameResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesNameResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypesNameResponse;

      if (size)
        *size = sizeof(struct ns2__getDataTypesNameResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypesNameResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypesNameResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypesNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesNameResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypesNameResponse*)p = *(struct ns2__getDataTypesNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getNames(struct soap *soap, struct ns2__getNames *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getNames(struct soap *soap, const struct ns2__getNames *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_uri, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getNames(struct soap *soap, const struct ns2__getNames *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getNames);

  if (soap_out_ns2__getNames(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNames(struct soap *soap, const char *tag, int id, const struct ns2__getNames *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNames), type))
    return soap->error;

  if (soap_out_std__string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getNames * SOAP_FMAC4 soap_get_ns2__getNames(struct soap *soap, struct ns2__getNames *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getNames(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getNames * SOAP_FMAC4 soap_in_ns2__getNames(struct soap *soap, const char *tag, struct ns2__getNames *a, const char *type)
{
  size_t soap_flag__uri = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNames, sizeof(struct ns2__getNames), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getNames(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_uri, "xsd:string"))
              {
                soap_flag__uri--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNames, 0, sizeof(struct ns2__getNames), 0, soap_copy_ns2__getNames);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__uri > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getNames * SOAP_FMAC6 soap_new_ns2__getNames(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getNames(struct soap *soap, struct ns2__getNames *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getNames * SOAP_FMAC4 soap_instantiate_ns2__getNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNames(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNames, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getNames;

      if (size)
        *size = sizeof(struct ns2__getNames);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getNames[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getNames);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getNames*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getNames %p -> %p\n", q, p));
  *(struct ns2__getNames*)p = *(struct ns2__getNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getNamesResponse(struct soap *soap, struct ns2__getNamesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getNamesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getNamesResponse(struct soap *soap, const struct ns2__getNamesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getNamesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getNamesResponse(struct soap *soap, const struct ns2__getNamesResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getNamesResponse);

  if (soap_out_ns2__getNamesResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNamesResponse(struct soap *soap, const char *tag, int id, const struct ns2__getNamesResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNamesResponse), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getNamesReturn", -1, &a->_getNamesReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getNamesResponse * SOAP_FMAC4 soap_get_ns2__getNamesResponse(struct soap *soap, struct ns2__getNamesResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getNamesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getNamesResponse * SOAP_FMAC4 soap_in_ns2__getNamesResponse(struct soap *soap, const char *tag, struct ns2__getNamesResponse *a, const char *type)
{
  size_t soap_flag__getNamesReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getNamesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNamesResponse, sizeof(struct ns2__getNamesResponse), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getNamesResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getNamesReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getNamesReturn, "xsd:string"))
              {
                soap_flag__getNamesReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNamesResponse, 0, sizeof(struct ns2__getNamesResponse), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getNamesResponse * SOAP_FMAC6 soap_new_ns2__getNamesResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getNamesResponse(struct soap *soap, struct ns2__getNamesResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getNamesResponse * SOAP_FMAC4 soap_instantiate_ns2__getNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNamesResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNamesResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getNamesResponse;

      if (size)
        *size = sizeof(struct ns2__getNamesResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getNamesResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getNamesResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getNamesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getNamesResponse %p -> %p\n", q, p));
  *(struct ns2__getNamesResponse*)p = *(struct ns2__getNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeSynonyms(struct soap *soap, struct ns2__getDataTypeSynonyms *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeSynonyms(struct soap *soap, const struct ns2__getDataTypeSynonyms *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_name, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeSynonyms(struct soap *soap, const struct ns2__getDataTypeSynonyms *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeSynonyms);

  if (soap_out_ns2__getDataTypeSynonyms(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeSynonyms(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeSynonyms *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeSynonyms), type))
    return soap->error;

  if (soap_out_std__string(soap, "name", -1, &a->_name, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonyms * SOAP_FMAC4 soap_get_ns2__getDataTypeSynonyms(struct soap *soap, struct ns2__getDataTypeSynonyms *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeSynonyms(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeSynonyms * SOAP_FMAC4 soap_in_ns2__getDataTypeSynonyms(struct soap *soap, const char *tag, struct ns2__getDataTypeSynonyms *a, const char *type)
{
  size_t soap_flag__name = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeSynonyms *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeSynonyms, sizeof(struct ns2__getDataTypeSynonyms), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeSynonyms(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_name, "xsd:string"))
              {
                soap_flag__name--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeSynonyms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeSynonyms, 0, sizeof(struct ns2__getDataTypeSynonyms), 0, soap_copy_ns2__getDataTypeSynonyms);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__name > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeSynonyms * SOAP_FMAC6 soap_new_ns2__getDataTypeSynonyms(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeSynonyms(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeSynonyms(struct soap *soap, struct ns2__getDataTypeSynonyms *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonyms * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeSynonyms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeSynonyms(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeSynonyms, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeSynonyms;

      if (size)
        *size = sizeof(struct ns2__getDataTypeSynonyms);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeSynonyms[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeSynonyms);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeSynonyms*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeSynonyms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeSynonyms %p -> %p\n", q, p));
  *(struct ns2__getDataTypeSynonyms*)p = *(struct ns2__getDataTypeSynonyms*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeSynonymsResponse(struct soap *soap, struct ns2__getDataTypeSynonymsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeSynonymsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeSynonymsResponse(struct soap *soap, const struct ns2__getDataTypeSynonymsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeSynonymsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeSynonymsResponse(struct soap *soap, const struct ns2__getDataTypeSynonymsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeSynonymsResponse);

  if (soap_out_ns2__getDataTypeSynonymsResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeSynonymsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeSynonymsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeSynonymsResponse), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeSynonymsReturn", -1, &a->_getDataTypeSynonymsReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeSynonymsResponse(struct soap *soap, struct ns2__getDataTypeSynonymsResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeSynonymsResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeSynonymsResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeSynonymsResponse *a, const char *type)
{
  size_t soap_flag__getDataTypeSynonymsReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeSynonymsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeSynonymsResponse, sizeof(struct ns2__getDataTypeSynonymsResponse), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeSynonymsResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getDataTypeSynonymsReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeSynonymsReturn, "xsd:string"))
              {
                soap_flag__getDataTypeSynonymsReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeSynonymsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeSynonymsResponse, 0, sizeof(struct ns2__getDataTypeSynonymsResponse), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeSynonymsResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeSynonymsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeSynonymsResponse(struct soap *soap, struct ns2__getDataTypeSynonymsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeSynonymsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeSynonymsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeSynonymsResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeSynonymsResponse;

      if (size)
        *size = sizeof(struct ns2__getDataTypeSynonymsResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeSynonymsResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeSynonymsResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeSynonymsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeSynonymsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeSynonymsResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeSynonymsResponse*)p = *(struct ns2__getDataTypeSynonymsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceLocation(struct soap *soap, struct ns2__getResourceLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceLocation(struct soap *soap, const struct ns2__getResourceLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_id, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceLocation(struct soap *soap, const struct ns2__getResourceLocation *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceLocation);

  if (soap_out_ns2__getResourceLocation(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceLocation(struct soap *soap, const char *tag, int id, const struct ns2__getResourceLocation *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceLocation), type))
    return soap->error;

  if (soap_out_std__string(soap, "id", -1, &a->_id, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceLocation * SOAP_FMAC4 soap_get_ns2__getResourceLocation(struct soap *soap, struct ns2__getResourceLocation *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getResourceLocation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getResourceLocation * SOAP_FMAC4 soap_in_ns2__getResourceLocation(struct soap *soap, const char *tag, struct ns2__getResourceLocation *a, const char *type)
{
  size_t soap_flag__id = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getResourceLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceLocation, sizeof(struct ns2__getResourceLocation), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getResourceLocation(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_id, "xsd:string"))
              {
                soap_flag__id--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getResourceLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceLocation, 0, sizeof(struct ns2__getResourceLocation), 0, soap_copy_ns2__getResourceLocation);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getResourceLocation * SOAP_FMAC6 soap_new_ns2__getResourceLocation(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getResourceLocation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceLocation(struct soap *soap, struct ns2__getResourceLocation *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceLocation * SOAP_FMAC4 soap_instantiate_ns2__getResourceLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceLocation(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceLocation, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getResourceLocation;

      if (size)
        *size = sizeof(struct ns2__getResourceLocation);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getResourceLocation[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getResourceLocation);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getResourceLocation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceLocation %p -> %p\n", q, p));
  *(struct ns2__getResourceLocation*)p = *(struct ns2__getResourceLocation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceLocationResponse(struct soap *soap, struct ns2__getResourceLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getResourceLocationReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceLocationResponse(struct soap *soap, const struct ns2__getResourceLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getResourceLocationReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getResourceLocationReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceLocationResponse(struct soap *soap, const struct ns2__getResourceLocationResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceLocationResponse);

  if (soap_out_ns2__getResourceLocationResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceLocationResponse(struct soap *soap, const char *tag, int id, const struct ns2__getResourceLocationResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceLocationResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getResourceLocationReturn", -1, &a->_getResourceLocationReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceLocationResponse * SOAP_FMAC4 soap_get_ns2__getResourceLocationResponse(struct soap *soap, struct ns2__getResourceLocationResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getResourceLocationResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getResourceLocationResponse * SOAP_FMAC4 soap_in_ns2__getResourceLocationResponse(struct soap *soap, const char *tag, struct ns2__getResourceLocationResponse *a, const char *type)
{
  size_t soap_flag__getResourceLocationReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getResourceLocationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceLocationResponse, sizeof(struct ns2__getResourceLocationResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getResourceLocationResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getResourceLocationReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getResourceLocationReturn, "xsd:string"))
              {
                soap_flag__getResourceLocationReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getResourceLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceLocationResponse, 0, sizeof(struct ns2__getResourceLocationResponse), 0, soap_copy_ns2__getResourceLocationResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getResourceLocationReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getResourceLocationResponse * SOAP_FMAC6 soap_new_ns2__getResourceLocationResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getResourceLocationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceLocationResponse(struct soap *soap, struct ns2__getResourceLocationResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceLocationResponse * SOAP_FMAC4 soap_instantiate_ns2__getResourceLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceLocationResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceLocationResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getResourceLocationResponse;

      if (size)
        *size = sizeof(struct ns2__getResourceLocationResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getResourceLocationResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getResourceLocationResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getResourceLocationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceLocationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceLocationResponse %p -> %p\n", q, p));
  *(struct ns2__getResourceLocationResponse*)p = *(struct ns2__getResourceLocationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInstitution(struct soap *soap, struct ns2__getResourceInstitution *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInstitution(struct soap *soap, const struct ns2__getResourceInstitution *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_id, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInstitution(struct soap *soap, const struct ns2__getResourceInstitution *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInstitution);

  if (soap_out_ns2__getResourceInstitution(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInstitution(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInstitution *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInstitution), type))
    return soap->error;

  if (soap_out_std__string(soap, "id", -1, &a->_id, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInstitution * SOAP_FMAC4 soap_get_ns2__getResourceInstitution(struct soap *soap, struct ns2__getResourceInstitution *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getResourceInstitution(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getResourceInstitution * SOAP_FMAC4 soap_in_ns2__getResourceInstitution(struct soap *soap, const char *tag, struct ns2__getResourceInstitution *a, const char *type)
{
  size_t soap_flag__id = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getResourceInstitution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInstitution, sizeof(struct ns2__getResourceInstitution), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getResourceInstitution(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_id, "xsd:string"))
              {
                soap_flag__id--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getResourceInstitution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInstitution, 0, sizeof(struct ns2__getResourceInstitution), 0, soap_copy_ns2__getResourceInstitution);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getResourceInstitution * SOAP_FMAC6 soap_new_ns2__getResourceInstitution(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getResourceInstitution(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInstitution(struct soap *soap, struct ns2__getResourceInstitution *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInstitution * SOAP_FMAC4 soap_instantiate_ns2__getResourceInstitution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInstitution(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInstitution, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getResourceInstitution;

      if (size)
        *size = sizeof(struct ns2__getResourceInstitution);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getResourceInstitution[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getResourceInstitution);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getResourceInstitution*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInstitution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInstitution %p -> %p\n", q, p));
  *(struct ns2__getResourceInstitution*)p = *(struct ns2__getResourceInstitution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInstitutionResponse(struct soap *soap, struct ns2__getResourceInstitutionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getResourceInstitutionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInstitutionResponse(struct soap *soap, const struct ns2__getResourceInstitutionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getResourceInstitutionReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getResourceInstitutionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInstitutionResponse(struct soap *soap, const struct ns2__getResourceInstitutionResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInstitutionResponse);

  if (soap_out_ns2__getResourceInstitutionResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInstitutionResponse(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInstitutionResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInstitutionResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getResourceInstitutionReturn", -1, &a->_getResourceInstitutionReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInstitutionResponse * SOAP_FMAC4 soap_get_ns2__getResourceInstitutionResponse(struct soap *soap, struct ns2__getResourceInstitutionResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getResourceInstitutionResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getResourceInstitutionResponse * SOAP_FMAC4 soap_in_ns2__getResourceInstitutionResponse(struct soap *soap, const char *tag, struct ns2__getResourceInstitutionResponse *a, const char *type)
{
  size_t soap_flag__getResourceInstitutionReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getResourceInstitutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInstitutionResponse, sizeof(struct ns2__getResourceInstitutionResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getResourceInstitutionResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getResourceInstitutionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getResourceInstitutionReturn, "xsd:string"))
              {
                soap_flag__getResourceInstitutionReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getResourceInstitutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInstitutionResponse, 0, sizeof(struct ns2__getResourceInstitutionResponse), 0, soap_copy_ns2__getResourceInstitutionResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getResourceInstitutionReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getResourceInstitutionResponse * SOAP_FMAC6 soap_new_ns2__getResourceInstitutionResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getResourceInstitutionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInstitutionResponse(struct soap *soap, struct ns2__getResourceInstitutionResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInstitutionResponse * SOAP_FMAC4 soap_instantiate_ns2__getResourceInstitutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInstitutionResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInstitutionResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getResourceInstitutionResponse;

      if (size)
        *size = sizeof(struct ns2__getResourceInstitutionResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getResourceInstitutionResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getResourceInstitutionResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getResourceInstitutionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInstitutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInstitutionResponse %p -> %p\n", q, p));
  *(struct ns2__getResourceInstitutionResponse*)p = *(struct ns2__getResourceInstitutionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInfo(struct soap *soap, struct ns2__getResourceInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInfo(struct soap *soap, const struct ns2__getResourceInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_id, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInfo(struct soap *soap, const struct ns2__getResourceInfo *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInfo);

  if (soap_out_ns2__getResourceInfo(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInfo(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInfo *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInfo), type))
    return soap->error;

  if (soap_out_std__string(soap, "id", -1, &a->_id, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInfo * SOAP_FMAC4 soap_get_ns2__getResourceInfo(struct soap *soap, struct ns2__getResourceInfo *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getResourceInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getResourceInfo * SOAP_FMAC4 soap_in_ns2__getResourceInfo(struct soap *soap, const char *tag, struct ns2__getResourceInfo *a, const char *type)
{
  size_t soap_flag__id = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getResourceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInfo, sizeof(struct ns2__getResourceInfo), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getResourceInfo(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_id, "xsd:string"))
              {
                soap_flag__id--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getResourceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInfo, 0, sizeof(struct ns2__getResourceInfo), 0, soap_copy_ns2__getResourceInfo);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getResourceInfo * SOAP_FMAC6 soap_new_ns2__getResourceInfo(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getResourceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInfo(struct soap *soap, struct ns2__getResourceInfo *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInfo * SOAP_FMAC4 soap_instantiate_ns2__getResourceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInfo(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInfo, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getResourceInfo;

      if (size)
        *size = sizeof(struct ns2__getResourceInfo);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getResourceInfo[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getResourceInfo);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getResourceInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInfo %p -> %p\n", q, p));
  *(struct ns2__getResourceInfo*)p = *(struct ns2__getResourceInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInfoResponse(struct soap *soap, struct ns2__getResourceInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getResourceInfoReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInfoResponse(struct soap *soap, const struct ns2__getResourceInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getResourceInfoReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getResourceInfoReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInfoResponse(struct soap *soap, const struct ns2__getResourceInfoResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInfoResponse);

  if (soap_out_ns2__getResourceInfoResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInfoResponse(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInfoResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInfoResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getResourceInfoReturn", -1, &a->_getResourceInfoReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInfoResponse * SOAP_FMAC4 soap_get_ns2__getResourceInfoResponse(struct soap *soap, struct ns2__getResourceInfoResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getResourceInfoResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getResourceInfoResponse * SOAP_FMAC4 soap_in_ns2__getResourceInfoResponse(struct soap *soap, const char *tag, struct ns2__getResourceInfoResponse *a, const char *type)
{
  size_t soap_flag__getResourceInfoReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getResourceInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInfoResponse, sizeof(struct ns2__getResourceInfoResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getResourceInfoResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getResourceInfoReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getResourceInfoReturn, "xsd:string"))
              {
                soap_flag__getResourceInfoReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getResourceInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInfoResponse, 0, sizeof(struct ns2__getResourceInfoResponse), 0, soap_copy_ns2__getResourceInfoResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getResourceInfoReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getResourceInfoResponse * SOAP_FMAC6 soap_new_ns2__getResourceInfoResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getResourceInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInfoResponse(struct soap *soap, struct ns2__getResourceInfoResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInfoResponse * SOAP_FMAC4 soap_instantiate_ns2__getResourceInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInfoResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInfoResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getResourceInfoResponse;

      if (size)
        *size = sizeof(struct ns2__getResourceInfoResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getResourceInfoResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getResourceInfoResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getResourceInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInfoResponse %p -> %p\n", q, p));
  *(struct ns2__getResourceInfoResponse*)p = *(struct ns2__getResourceInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypePattern(struct soap *soap, struct ns2__getDataTypePattern *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_nickname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypePattern(struct soap *soap, const struct ns2__getDataTypePattern *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_nickname, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_nickname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypePattern(struct soap *soap, const struct ns2__getDataTypePattern *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypePattern);

  if (soap_out_ns2__getDataTypePattern(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypePattern(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypePattern *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypePattern), type))
    return soap->error;

  if (soap_out_std__string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypePattern * SOAP_FMAC4 soap_get_ns2__getDataTypePattern(struct soap *soap, struct ns2__getDataTypePattern *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypePattern(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypePattern * SOAP_FMAC4 soap_in_ns2__getDataTypePattern(struct soap *soap, const char *tag, struct ns2__getDataTypePattern *a, const char *type)
{
  size_t soap_flag__nickname = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypePattern *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypePattern, sizeof(struct ns2__getDataTypePattern), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypePattern(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_nickname, "xsd:string"))
              {
                soap_flag__nickname--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypePattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypePattern, 0, sizeof(struct ns2__getDataTypePattern), 0, soap_copy_ns2__getDataTypePattern);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__nickname > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypePattern * SOAP_FMAC6 soap_new_ns2__getDataTypePattern(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypePattern(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypePattern(struct soap *soap, struct ns2__getDataTypePattern *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypePattern * SOAP_FMAC4 soap_instantiate_ns2__getDataTypePattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypePattern(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypePattern, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypePattern;

      if (size)
        *size = sizeof(struct ns2__getDataTypePattern);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypePattern[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypePattern);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypePattern*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypePattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypePattern %p -> %p\n", q, p));
  *(struct ns2__getDataTypePattern*)p = *(struct ns2__getDataTypePattern*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypePatternResponse(struct soap *soap, struct ns2__getDataTypePatternResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getDataTypePatternReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypePatternResponse(struct soap *soap, const struct ns2__getDataTypePatternResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getDataTypePatternReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getDataTypePatternReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypePatternResponse(struct soap *soap, const struct ns2__getDataTypePatternResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypePatternResponse);

  if (soap_out_ns2__getDataTypePatternResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypePatternResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypePatternResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypePatternResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getDataTypePatternReturn", -1, &a->_getDataTypePatternReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypePatternResponse * SOAP_FMAC4 soap_get_ns2__getDataTypePatternResponse(struct soap *soap, struct ns2__getDataTypePatternResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypePatternResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypePatternResponse * SOAP_FMAC4 soap_in_ns2__getDataTypePatternResponse(struct soap *soap, const char *tag, struct ns2__getDataTypePatternResponse *a, const char *type)
{
  size_t soap_flag__getDataTypePatternReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypePatternResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypePatternResponse, sizeof(struct ns2__getDataTypePatternResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypePatternResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getDataTypePatternReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getDataTypePatternReturn, "xsd:string"))
              {
                soap_flag__getDataTypePatternReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypePatternResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypePatternResponse, 0, sizeof(struct ns2__getDataTypePatternResponse), 0, soap_copy_ns2__getDataTypePatternResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypePatternReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypePatternResponse * SOAP_FMAC6 soap_new_ns2__getDataTypePatternResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypePatternResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypePatternResponse(struct soap *soap, struct ns2__getDataTypePatternResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypePatternResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypePatternResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypePatternResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypePatternResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypePatternResponse;

      if (size)
        *size = sizeof(struct ns2__getDataTypePatternResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypePatternResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypePatternResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypePatternResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypePatternResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypePatternResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypePatternResponse*)p = *(struct ns2__getDataTypePatternResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getMiriamURI(struct soap *soap, struct ns2__getMiriamURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getMiriamURI(struct soap *soap, const struct ns2__getMiriamURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_uri, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getMiriamURI(struct soap *soap, const struct ns2__getMiriamURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getMiriamURI);

  if (soap_out_ns2__getMiriamURI(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMiriamURI(struct soap *soap, const char *tag, int id, const struct ns2__getMiriamURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMiriamURI), type))
    return soap->error;

  if (soap_out_std__string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getMiriamURI * SOAP_FMAC4 soap_get_ns2__getMiriamURI(struct soap *soap, struct ns2__getMiriamURI *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getMiriamURI(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getMiriamURI * SOAP_FMAC4 soap_in_ns2__getMiriamURI(struct soap *soap, const char *tag, struct ns2__getMiriamURI *a, const char *type)
{
  size_t soap_flag__uri = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getMiriamURI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMiriamURI, sizeof(struct ns2__getMiriamURI), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getMiriamURI(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_uri, "xsd:string"))
              {
                soap_flag__uri--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getMiriamURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMiriamURI, 0, sizeof(struct ns2__getMiriamURI), 0, soap_copy_ns2__getMiriamURI);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__uri > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getMiriamURI * SOAP_FMAC6 soap_new_ns2__getMiriamURI(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getMiriamURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getMiriamURI(struct soap *soap, struct ns2__getMiriamURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getMiriamURI * SOAP_FMAC4 soap_instantiate_ns2__getMiriamURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMiriamURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMiriamURI, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getMiriamURI;

      if (size)
        *size = sizeof(struct ns2__getMiriamURI);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getMiriamURI[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getMiriamURI);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getMiriamURI*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMiriamURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getMiriamURI %p -> %p\n", q, p));
  *(struct ns2__getMiriamURI*)p = *(struct ns2__getMiriamURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getMiriamURIResponse(struct soap *soap, struct ns2__getMiriamURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getMiriamURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getMiriamURIResponse(struct soap *soap, const struct ns2__getMiriamURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getMiriamURIReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getMiriamURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getMiriamURIResponse(struct soap *soap, const struct ns2__getMiriamURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getMiriamURIResponse);

  if (soap_out_ns2__getMiriamURIResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMiriamURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getMiriamURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMiriamURIResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getMiriamURIReturn", -1, &a->_getMiriamURIReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getMiriamURIResponse * SOAP_FMAC4 soap_get_ns2__getMiriamURIResponse(struct soap *soap, struct ns2__getMiriamURIResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getMiriamURIResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getMiriamURIResponse * SOAP_FMAC4 soap_in_ns2__getMiriamURIResponse(struct soap *soap, const char *tag, struct ns2__getMiriamURIResponse *a, const char *type)
{
  size_t soap_flag__getMiriamURIReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getMiriamURIResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMiriamURIResponse, sizeof(struct ns2__getMiriamURIResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getMiriamURIResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getMiriamURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getMiriamURIReturn, "xsd:string"))
              {
                soap_flag__getMiriamURIReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getMiriamURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMiriamURIResponse, 0, sizeof(struct ns2__getMiriamURIResponse), 0, soap_copy_ns2__getMiriamURIResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getMiriamURIReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getMiriamURIResponse * SOAP_FMAC6 soap_new_ns2__getMiriamURIResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getMiriamURIResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getMiriamURIResponse(struct soap *soap, struct ns2__getMiriamURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getMiriamURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getMiriamURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMiriamURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMiriamURIResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getMiriamURIResponse;

      if (size)
        *size = sizeof(struct ns2__getMiriamURIResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getMiriamURIResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getMiriamURIResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getMiriamURIResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMiriamURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getMiriamURIResponse %p -> %p\n", q, p));
  *(struct ns2__getMiriamURIResponse*)p = *(struct ns2__getMiriamURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getOfficialDataTypeURI(struct soap *soap, struct ns2__getOfficialDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getOfficialDataTypeURI(struct soap *soap, const struct ns2__getOfficialDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_uri, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getOfficialDataTypeURI(struct soap *soap, const struct ns2__getOfficialDataTypeURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getOfficialDataTypeURI);

  if (soap_out_ns2__getOfficialDataTypeURI(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOfficialDataTypeURI(struct soap *soap, const char *tag, int id, const struct ns2__getOfficialDataTypeURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOfficialDataTypeURI), type))
    return soap->error;

  if (soap_out_std__string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURI * SOAP_FMAC4 soap_get_ns2__getOfficialDataTypeURI(struct soap *soap, struct ns2__getOfficialDataTypeURI *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getOfficialDataTypeURI(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURI * SOAP_FMAC4 soap_in_ns2__getOfficialDataTypeURI(struct soap *soap, const char *tag, struct ns2__getOfficialDataTypeURI *a, const char *type)
{
  size_t soap_flag__uri = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getOfficialDataTypeURI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOfficialDataTypeURI, sizeof(struct ns2__getOfficialDataTypeURI), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getOfficialDataTypeURI(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_uri, "xsd:string"))
              {
                soap_flag__uri--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getOfficialDataTypeURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOfficialDataTypeURI, 0, sizeof(struct ns2__getOfficialDataTypeURI), 0, soap_copy_ns2__getOfficialDataTypeURI);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__uri > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getOfficialDataTypeURI * SOAP_FMAC6 soap_new_ns2__getOfficialDataTypeURI(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getOfficialDataTypeURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getOfficialDataTypeURI(struct soap *soap, struct ns2__getOfficialDataTypeURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURI * SOAP_FMAC4 soap_instantiate_ns2__getOfficialDataTypeURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOfficialDataTypeURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getOfficialDataTypeURI, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getOfficialDataTypeURI;

      if (size)
        *size = sizeof(struct ns2__getOfficialDataTypeURI);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getOfficialDataTypeURI[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getOfficialDataTypeURI);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getOfficialDataTypeURI*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getOfficialDataTypeURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getOfficialDataTypeURI %p -> %p\n", q, p));
  *(struct ns2__getOfficialDataTypeURI*)p = *(struct ns2__getOfficialDataTypeURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getOfficialDataTypeURIResponse(struct soap *soap, struct ns2__getOfficialDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getOfficialDataTypeURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const struct ns2__getOfficialDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getOfficialDataTypeURIReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getOfficialDataTypeURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const struct ns2__getOfficialDataTypeURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse);

  if (soap_out_ns2__getOfficialDataTypeURIResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getOfficialDataTypeURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getOfficialDataTypeURIReturn", -1, &a->_getOfficialDataTypeURIReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC4 soap_get_ns2__getOfficialDataTypeURIResponse(struct soap *soap, struct ns2__getOfficialDataTypeURIResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getOfficialDataTypeURIResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC4 soap_in_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const char *tag, struct ns2__getOfficialDataTypeURIResponse *a, const char *type)
{
  size_t soap_flag__getOfficialDataTypeURIReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getOfficialDataTypeURIResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse, sizeof(struct ns2__getOfficialDataTypeURIResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getOfficialDataTypeURIResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getOfficialDataTypeURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getOfficialDataTypeURIReturn, "xsd:string"))
              {
                soap_flag__getOfficialDataTypeURIReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getOfficialDataTypeURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse, 0, sizeof(struct ns2__getOfficialDataTypeURIResponse), 0, soap_copy_ns2__getOfficialDataTypeURIResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getOfficialDataTypeURIReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC6 soap_new_ns2__getOfficialDataTypeURIResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getOfficialDataTypeURIResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getOfficialDataTypeURIResponse(struct soap *soap, struct ns2__getOfficialDataTypeURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getOfficialDataTypeURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOfficialDataTypeURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getOfficialDataTypeURIResponse;

      if (size)
        *size = sizeof(struct ns2__getOfficialDataTypeURIResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getOfficialDataTypeURIResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getOfficialDataTypeURIResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getOfficialDataTypeURIResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getOfficialDataTypeURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getOfficialDataTypeURIResponse %p -> %p\n", q, p));
  *(struct ns2__getOfficialDataTypeURIResponse*)p = *(struct ns2__getOfficialDataTypeURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__isDeprecated(struct soap *soap, struct ns2__isDeprecated *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__isDeprecated(struct soap *soap, const struct ns2__isDeprecated *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_uri, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__isDeprecated(struct soap *soap, const struct ns2__isDeprecated *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__isDeprecated);

  if (soap_out_ns2__isDeprecated(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__isDeprecated(struct soap *soap, const char *tag, int id, const struct ns2__isDeprecated *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__isDeprecated), type))
    return soap->error;

  if (soap_out_std__string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__isDeprecated * SOAP_FMAC4 soap_get_ns2__isDeprecated(struct soap *soap, struct ns2__isDeprecated *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__isDeprecated(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__isDeprecated * SOAP_FMAC4 soap_in_ns2__isDeprecated(struct soap *soap, const char *tag, struct ns2__isDeprecated *a, const char *type)
{
  size_t soap_flag__uri = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__isDeprecated *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__isDeprecated, sizeof(struct ns2__isDeprecated), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__isDeprecated(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_uri, "xsd:string"))
              {
                soap_flag__uri--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__isDeprecated *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__isDeprecated, 0, sizeof(struct ns2__isDeprecated), 0, soap_copy_ns2__isDeprecated);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__uri > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__isDeprecated * SOAP_FMAC6 soap_new_ns2__isDeprecated(struct soap *soap, int n)
{
  return soap_instantiate_ns2__isDeprecated(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__isDeprecated(struct soap *soap, struct ns2__isDeprecated *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__isDeprecated * SOAP_FMAC4 soap_instantiate_ns2__isDeprecated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__isDeprecated(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__isDeprecated, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__isDeprecated;

      if (size)
        *size = sizeof(struct ns2__isDeprecated);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__isDeprecated[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__isDeprecated);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__isDeprecated*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__isDeprecated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__isDeprecated %p -> %p\n", q, p));
  *(struct ns2__isDeprecated*)p = *(struct ns2__isDeprecated*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__isDeprecatedResponse(struct soap *soap, struct ns2__isDeprecatedResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_isDeprecatedReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__isDeprecatedResponse(struct soap *soap, const struct ns2__isDeprecatedResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_isDeprecatedReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_isDeprecatedReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__isDeprecatedResponse(struct soap *soap, const struct ns2__isDeprecatedResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__isDeprecatedResponse);

  if (soap_out_ns2__isDeprecatedResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__isDeprecatedResponse(struct soap *soap, const char *tag, int id, const struct ns2__isDeprecatedResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__isDeprecatedResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "isDeprecatedReturn", -1, &a->_isDeprecatedReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__isDeprecatedResponse * SOAP_FMAC4 soap_get_ns2__isDeprecatedResponse(struct soap *soap, struct ns2__isDeprecatedResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__isDeprecatedResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__isDeprecatedResponse * SOAP_FMAC4 soap_in_ns2__isDeprecatedResponse(struct soap *soap, const char *tag, struct ns2__isDeprecatedResponse *a, const char *type)
{
  size_t soap_flag__isDeprecatedReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__isDeprecatedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__isDeprecatedResponse, sizeof(struct ns2__isDeprecatedResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__isDeprecatedResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__isDeprecatedReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_isDeprecatedReturn, "xsd:string"))
              {
                soap_flag__isDeprecatedReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__isDeprecatedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__isDeprecatedResponse, 0, sizeof(struct ns2__isDeprecatedResponse), 0, soap_copy_ns2__isDeprecatedResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__isDeprecatedReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__isDeprecatedResponse * SOAP_FMAC6 soap_new_ns2__isDeprecatedResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__isDeprecatedResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__isDeprecatedResponse(struct soap *soap, struct ns2__isDeprecatedResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__isDeprecatedResponse * SOAP_FMAC4 soap_instantiate_ns2__isDeprecatedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__isDeprecatedResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__isDeprecatedResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__isDeprecatedResponse;

      if (size)
        *size = sizeof(struct ns2__isDeprecatedResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__isDeprecatedResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__isDeprecatedResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__isDeprecatedResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__isDeprecatedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__isDeprecatedResponse %p -> %p\n", q, p));
  *(struct ns2__isDeprecatedResponse*)p = *(struct ns2__isDeprecatedResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocations_(struct soap *soap, struct ns2__getLocations_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_nickname);
  soap_default_std__string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocations_(struct soap *soap, const struct ns2__getLocations_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_nickname, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_nickname);
  soap_embedded(soap, &a->_id, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocations_(struct soap *soap, const struct ns2__getLocations_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocations_);

  if (soap_out_ns2__getLocations_(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocations_(struct soap *soap, const char *tag, int id, const struct ns2__getLocations_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocations_), type))
    return soap->error;

  if (soap_out_std__string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;

  if (soap_out_std__string(soap, "id", -1, &a->_id, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocations_ * SOAP_FMAC4 soap_get_ns2__getLocations_(struct soap *soap, struct ns2__getLocations_ *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getLocations_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getLocations_ * SOAP_FMAC4 soap_in_ns2__getLocations_(struct soap *soap, const char *tag, struct ns2__getLocations_ *a, const char *type)
{
  size_t soap_flag__nickname = 1;
  size_t soap_flag__id = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getLocations_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocations_, sizeof(struct ns2__getLocations_), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getLocations_(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_nickname, "xsd:string"))
              {
                soap_flag__nickname--;
                continue;
              }

          if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_id, "xsd:string"))
              {
                soap_flag__id--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getLocations_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocations_, 0, sizeof(struct ns2__getLocations_), 0, soap_copy_ns2__getLocations_);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__nickname > 0 || soap_flag__id > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getLocations_ * SOAP_FMAC6 soap_new_ns2__getLocations_(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getLocations_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocations_(struct soap *soap, struct ns2__getLocations_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocations_ * SOAP_FMAC4 soap_instantiate_ns2__getLocations_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocations_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocations_, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getLocations_;

      if (size)
        *size = sizeof(struct ns2__getLocations_);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getLocations_[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getLocations_);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getLocations_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocations_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocations_ %p -> %p\n", q, p));
  *(struct ns2__getLocations_*)p = *(struct ns2__getLocations_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocationsResponse_(struct soap *soap, struct ns2__getLocationsResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getLocationsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocationsResponse_(struct soap *soap, const struct ns2__getLocationsResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getLocationsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocationsResponse_(struct soap *soap, const struct ns2__getLocationsResponse_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocationsResponse_);

  if (soap_out_ns2__getLocationsResponse_(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocationsResponse_(struct soap *soap, const char *tag, int id, const struct ns2__getLocationsResponse_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocationsResponse_), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getLocationsReturn", -1, &a->_getLocationsReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocationsResponse_ * SOAP_FMAC4 soap_get_ns2__getLocationsResponse_(struct soap *soap, struct ns2__getLocationsResponse_ *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getLocationsResponse_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getLocationsResponse_ * SOAP_FMAC4 soap_in_ns2__getLocationsResponse_(struct soap *soap, const char *tag, struct ns2__getLocationsResponse_ *a, const char *type)
{
  size_t soap_flag__getLocationsReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getLocationsResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocationsResponse_, sizeof(struct ns2__getLocationsResponse_), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getLocationsResponse_(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getLocationsReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getLocationsReturn, "xsd:string"))
              {
                soap_flag__getLocationsReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getLocationsResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocationsResponse_, 0, sizeof(struct ns2__getLocationsResponse_), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getLocationsResponse_ * SOAP_FMAC6 soap_new_ns2__getLocationsResponse_(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getLocationsResponse_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocationsResponse_(struct soap *soap, struct ns2__getLocationsResponse_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocationsResponse_ * SOAP_FMAC4 soap_instantiate_ns2__getLocationsResponse_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocationsResponse_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocationsResponse_, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getLocationsResponse_;

      if (size)
        *size = sizeof(struct ns2__getLocationsResponse_);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getLocationsResponse_[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getLocationsResponse_);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getLocationsResponse_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocationsResponse_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocationsResponse_ %p -> %p\n", q, p));
  *(struct ns2__getLocationsResponse_*)p = *(struct ns2__getLocationsResponse_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocations(struct soap *soap, struct ns2__getLocations *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_nickname);
  soap_default_std__string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocations(struct soap *soap, const struct ns2__getLocations *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_nickname, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_nickname);
  soap_embedded(soap, &a->_id, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocations(struct soap *soap, const struct ns2__getLocations *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocations);

  if (soap_out_ns2__getLocations(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocations(struct soap *soap, const char *tag, int id, const struct ns2__getLocations *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocations), type))
    return soap->error;

  if (soap_out_std__string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;

  if (soap_out_std__string(soap, "id", -1, &a->_id, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocations * SOAP_FMAC4 soap_get_ns2__getLocations(struct soap *soap, struct ns2__getLocations *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getLocations(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getLocations * SOAP_FMAC4 soap_in_ns2__getLocations(struct soap *soap, const char *tag, struct ns2__getLocations *a, const char *type)
{
  size_t soap_flag__nickname = 1;
  size_t soap_flag__id = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getLocations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocations, sizeof(struct ns2__getLocations), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getLocations(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_nickname, "xsd:string"))
              {
                soap_flag__nickname--;
                continue;
              }

          if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_id, "xsd:string"))
              {
                soap_flag__id--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getLocations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocations, 0, sizeof(struct ns2__getLocations), 0, soap_copy_ns2__getLocations);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__nickname > 0 || soap_flag__id > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getLocations * SOAP_FMAC6 soap_new_ns2__getLocations(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getLocations(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocations(struct soap *soap, struct ns2__getLocations *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocations * SOAP_FMAC4 soap_instantiate_ns2__getLocations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocations(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocations, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getLocations;

      if (size)
        *size = sizeof(struct ns2__getLocations);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getLocations[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getLocations);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getLocations*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocations %p -> %p\n", q, p));
  *(struct ns2__getLocations*)p = *(struct ns2__getLocations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocationsResponse(struct soap *soap, struct ns2__getLocationsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getLocationsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocationsResponse(struct soap *soap, const struct ns2__getLocationsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getLocationsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocationsResponse(struct soap *soap, const struct ns2__getLocationsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocationsResponse);

  if (soap_out_ns2__getLocationsResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocationsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getLocationsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocationsResponse), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getLocationsReturn", -1, &a->_getLocationsReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocationsResponse * SOAP_FMAC4 soap_get_ns2__getLocationsResponse(struct soap *soap, struct ns2__getLocationsResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getLocationsResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getLocationsResponse * SOAP_FMAC4 soap_in_ns2__getLocationsResponse(struct soap *soap, const char *tag, struct ns2__getLocationsResponse *a, const char *type)
{
  size_t soap_flag__getLocationsReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getLocationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocationsResponse, sizeof(struct ns2__getLocationsResponse), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getLocationsResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getLocationsReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getLocationsReturn, "xsd:string"))
              {
                soap_flag__getLocationsReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getLocationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocationsResponse, 0, sizeof(struct ns2__getLocationsResponse), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getLocationsResponse * SOAP_FMAC6 soap_new_ns2__getLocationsResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getLocationsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocationsResponse(struct soap *soap, struct ns2__getLocationsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocationsResponse * SOAP_FMAC4 soap_instantiate_ns2__getLocationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocationsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocationsResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getLocationsResponse;

      if (size)
        *size = sizeof(struct ns2__getLocationsResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getLocationsResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getLocationsResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getLocationsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocationsResponse %p -> %p\n", q, p));
  *(struct ns2__getLocationsResponse*)p = *(struct ns2__getLocationsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeDef(struct soap *soap, struct ns2__getDataTypeDef *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_nickname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeDef(struct soap *soap, const struct ns2__getDataTypeDef *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_nickname, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_nickname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeDef(struct soap *soap, const struct ns2__getDataTypeDef *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeDef);

  if (soap_out_ns2__getDataTypeDef(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeDef(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeDef *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeDef), type))
    return soap->error;

  if (soap_out_std__string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeDef * SOAP_FMAC4 soap_get_ns2__getDataTypeDef(struct soap *soap, struct ns2__getDataTypeDef *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeDef(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeDef * SOAP_FMAC4 soap_in_ns2__getDataTypeDef(struct soap *soap, const char *tag, struct ns2__getDataTypeDef *a, const char *type)
{
  size_t soap_flag__nickname = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeDef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeDef, sizeof(struct ns2__getDataTypeDef), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeDef(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_nickname, "xsd:string"))
              {
                soap_flag__nickname--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeDef, 0, sizeof(struct ns2__getDataTypeDef), 0, soap_copy_ns2__getDataTypeDef);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__nickname > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeDef * SOAP_FMAC6 soap_new_ns2__getDataTypeDef(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeDef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeDef(struct soap *soap, struct ns2__getDataTypeDef *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeDef * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeDef(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeDef, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeDef;

      if (size)
        *size = sizeof(struct ns2__getDataTypeDef);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeDef[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeDef);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeDef*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeDef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeDef %p -> %p\n", q, p));
  *(struct ns2__getDataTypeDef*)p = *(struct ns2__getDataTypeDef*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeDefResponse(struct soap *soap, struct ns2__getDataTypeDefResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getDataTypeDefReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeDefResponse(struct soap *soap, const struct ns2__getDataTypeDefResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getDataTypeDefReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getDataTypeDefReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeDefResponse(struct soap *soap, const struct ns2__getDataTypeDefResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeDefResponse);

  if (soap_out_ns2__getDataTypeDefResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeDefResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeDefResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeDefResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getDataTypeDefReturn", -1, &a->_getDataTypeDefReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeDefResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeDefResponse(struct soap *soap, struct ns2__getDataTypeDefResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeDefResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeDefResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeDefResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeDefResponse *a, const char *type)
{
  size_t soap_flag__getDataTypeDefReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeDefResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeDefResponse, sizeof(struct ns2__getDataTypeDefResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeDefResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getDataTypeDefReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getDataTypeDefReturn, "xsd:string"))
              {
                soap_flag__getDataTypeDefReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeDefResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeDefResponse, 0, sizeof(struct ns2__getDataTypeDefResponse), 0, soap_copy_ns2__getDataTypeDefResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypeDefReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeDefResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeDefResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeDefResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeDefResponse(struct soap *soap, struct ns2__getDataTypeDefResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeDefResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeDefResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeDefResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeDefResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeDefResponse;

      if (size)
        *size = sizeof(struct ns2__getDataTypeDefResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeDefResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeDefResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeDefResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeDefResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeDefResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeDefResponse*)p = *(struct ns2__getDataTypeDefResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIs(struct soap *soap, struct ns2__getDataTypeURIs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIs(struct soap *soap, const struct ns2__getDataTypeURIs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_name, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIs(struct soap *soap, const struct ns2__getDataTypeURIs *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIs);

  if (soap_out_ns2__getDataTypeURIs(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIs(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIs *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIs), type))
    return soap->error;

  if (soap_out_std__string(soap, "name", -1, &a->_name, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIs * SOAP_FMAC4 soap_get_ns2__getDataTypeURIs(struct soap *soap, struct ns2__getDataTypeURIs *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeURIs(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeURIs * SOAP_FMAC4 soap_in_ns2__getDataTypeURIs(struct soap *soap, const char *tag, struct ns2__getDataTypeURIs *a, const char *type)
{
  size_t soap_flag__name = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeURIs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIs, sizeof(struct ns2__getDataTypeURIs), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeURIs(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_name, "xsd:string"))
              {
                soap_flag__name--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeURIs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIs, 0, sizeof(struct ns2__getDataTypeURIs), 0, soap_copy_ns2__getDataTypeURIs);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__name > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeURIs * SOAP_FMAC6 soap_new_ns2__getDataTypeURIs(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeURIs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIs(struct soap *soap, struct ns2__getDataTypeURIs *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIs * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIs(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIs, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURIs;

      if (size)
        *size = sizeof(struct ns2__getDataTypeURIs);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURIs[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeURIs);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeURIs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIs %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIs*)p = *(struct ns2__getDataTypeURIs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIsResponse(struct soap *soap, struct ns2__getDataTypeURIsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeURIsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIsResponse(struct soap *soap, const struct ns2__getDataTypeURIsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeURIsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIsResponse(struct soap *soap, const struct ns2__getDataTypeURIsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIsResponse);

  if (soap_out_ns2__getDataTypeURIsResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIsResponse), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeURIsReturn", -1, &a->_getDataTypeURIsReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURIsResponse(struct soap *soap, struct ns2__getDataTypeURIsResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeURIsResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURIsResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURIsResponse *a, const char *type)
{
  size_t soap_flag__getDataTypeURIsReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeURIsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIsResponse, sizeof(struct ns2__getDataTypeURIsResponse), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeURIsResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getDataTypeURIsReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeURIsReturn, "xsd:string"))
              {
                soap_flag__getDataTypeURIsReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeURIsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIsResponse, 0, sizeof(struct ns2__getDataTypeURIsResponse), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeURIsResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURIsResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeURIsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIsResponse(struct soap *soap, struct ns2__getDataTypeURIsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIsResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURIsResponse;

      if (size)
        *size = sizeof(struct ns2__getDataTypeURIsResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURIsResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeURIsResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeURIsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIsResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIsResponse*)p = *(struct ns2__getDataTypeURIsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURI(struct soap *soap, struct ns2__getDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURI(struct soap *soap, const struct ns2__getDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_name, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURI(struct soap *soap, const struct ns2__getDataTypeURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURI);

  if (soap_out_ns2__getDataTypeURI(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURI(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURI), type))
    return soap->error;

  if (soap_out_std__string(soap, "name", -1, &a->_name, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURI * SOAP_FMAC4 soap_get_ns2__getDataTypeURI(struct soap *soap, struct ns2__getDataTypeURI *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeURI(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeURI * SOAP_FMAC4 soap_in_ns2__getDataTypeURI(struct soap *soap, const char *tag, struct ns2__getDataTypeURI *a, const char *type)
{
  size_t soap_flag__name = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeURI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURI, sizeof(struct ns2__getDataTypeURI), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeURI(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_name, "xsd:string"))
              {
                soap_flag__name--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURI, 0, sizeof(struct ns2__getDataTypeURI), 0, soap_copy_ns2__getDataTypeURI);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__name > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeURI * SOAP_FMAC6 soap_new_ns2__getDataTypeURI(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURI(struct soap *soap, struct ns2__getDataTypeURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURI * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURI, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURI;

      if (size)
        *size = sizeof(struct ns2__getDataTypeURI);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURI[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeURI);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeURI*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURI %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURI*)p = *(struct ns2__getDataTypeURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIResponse(struct soap *soap, struct ns2__getDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getDataTypeURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIResponse(struct soap *soap, const struct ns2__getDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getDataTypeURIReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getDataTypeURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIResponse(struct soap *soap, const struct ns2__getDataTypeURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIResponse);

  if (soap_out_ns2__getDataTypeURIResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getDataTypeURIReturn", -1, &a->_getDataTypeURIReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURIResponse(struct soap *soap, struct ns2__getDataTypeURIResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataTypeURIResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataTypeURIResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURIResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURIResponse *a, const char *type)
{
  size_t soap_flag__getDataTypeURIReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataTypeURIResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIResponse, sizeof(struct ns2__getDataTypeURIResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataTypeURIResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getDataTypeURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getDataTypeURIReturn, "xsd:string"))
              {
                soap_flag__getDataTypeURIReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataTypeURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIResponse, 0, sizeof(struct ns2__getDataTypeURIResponse), 0, soap_copy_ns2__getDataTypeURIResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypeURIReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataTypeURIResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURIResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataTypeURIResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIResponse(struct soap *soap, struct ns2__getDataTypeURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURIResponse;

      if (size)
        *size = sizeof(struct ns2__getDataTypeURIResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataTypeURIResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataTypeURIResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataTypeURIResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIResponse*)p = *(struct ns2__getDataTypeURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getJavaLibraryVersion(struct soap *soap, struct ns2__getJavaLibraryVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getJavaLibraryVersion(struct soap *soap, const struct ns2__getJavaLibraryVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getJavaLibraryVersion(struct soap *soap, const struct ns2__getJavaLibraryVersion *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getJavaLibraryVersion);

  if (soap_out_ns2__getJavaLibraryVersion(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getJavaLibraryVersion(struct soap *soap, const char *tag, int id, const struct ns2__getJavaLibraryVersion *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getJavaLibraryVersion), type))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersion * SOAP_FMAC4 soap_get_ns2__getJavaLibraryVersion(struct soap *soap, struct ns2__getJavaLibraryVersion *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getJavaLibraryVersion(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersion * SOAP_FMAC4 soap_in_ns2__getJavaLibraryVersion(struct soap *soap, const char *tag, struct ns2__getJavaLibraryVersion *a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getJavaLibraryVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getJavaLibraryVersion, sizeof(struct ns2__getJavaLibraryVersion), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getJavaLibraryVersion(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getJavaLibraryVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getJavaLibraryVersion, 0, sizeof(struct ns2__getJavaLibraryVersion), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getJavaLibraryVersion * SOAP_FMAC6 soap_new_ns2__getJavaLibraryVersion(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getJavaLibraryVersion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getJavaLibraryVersion(struct soap *soap, struct ns2__getJavaLibraryVersion *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersion * SOAP_FMAC4 soap_instantiate_ns2__getJavaLibraryVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getJavaLibraryVersion(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getJavaLibraryVersion, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getJavaLibraryVersion;

      if (size)
        *size = sizeof(struct ns2__getJavaLibraryVersion);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getJavaLibraryVersion[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getJavaLibraryVersion);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getJavaLibraryVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getJavaLibraryVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getJavaLibraryVersion %p -> %p\n", q, p));
  *(struct ns2__getJavaLibraryVersion*)p = *(struct ns2__getJavaLibraryVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getJavaLibraryVersionResponse(struct soap *soap, struct ns2__getJavaLibraryVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->getJavaLibraryVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getJavaLibraryVersionResponse(struct soap *soap, const struct ns2__getJavaLibraryVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->getJavaLibraryVersionReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->getJavaLibraryVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getJavaLibraryVersionResponse(struct soap *soap, const struct ns2__getJavaLibraryVersionResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getJavaLibraryVersionResponse);

  if (soap_out_ns2__getJavaLibraryVersionResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getJavaLibraryVersionResponse(struct soap *soap, const char *tag, int id, const struct ns2__getJavaLibraryVersionResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getJavaLibraryVersionResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getJavaLibraryVersionReturn", -1, &a->getJavaLibraryVersionReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC4 soap_get_ns2__getJavaLibraryVersionResponse(struct soap *soap, struct ns2__getJavaLibraryVersionResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getJavaLibraryVersionResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC4 soap_in_ns2__getJavaLibraryVersionResponse(struct soap *soap, const char *tag, struct ns2__getJavaLibraryVersionResponse *a, const char *type)
{
  size_t soap_flag_getJavaLibraryVersionReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getJavaLibraryVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getJavaLibraryVersionResponse, sizeof(struct ns2__getJavaLibraryVersionResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getJavaLibraryVersionResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_getJavaLibraryVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, "getJavaLibraryVersionReturn", &a->getJavaLibraryVersionReturn, "xsd:string"))
              {
                soap_flag_getJavaLibraryVersionReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getJavaLibraryVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getJavaLibraryVersionResponse, 0, sizeof(struct ns2__getJavaLibraryVersionResponse), 0, soap_copy_ns2__getJavaLibraryVersionResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getJavaLibraryVersionReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC6 soap_new_ns2__getJavaLibraryVersionResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getJavaLibraryVersionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getJavaLibraryVersionResponse(struct soap *soap, struct ns2__getJavaLibraryVersionResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC4 soap_instantiate_ns2__getJavaLibraryVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getJavaLibraryVersionResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getJavaLibraryVersionResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getJavaLibraryVersionResponse;

      if (size)
        *size = sizeof(struct ns2__getJavaLibraryVersionResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getJavaLibraryVersionResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getJavaLibraryVersionResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getJavaLibraryVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getJavaLibraryVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getJavaLibraryVersionResponse %p -> %p\n", q, p));
  *(struct ns2__getJavaLibraryVersionResponse*)p = *(struct ns2__getJavaLibraryVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesVersion(struct soap *soap, struct ns2__getServicesVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesVersion(struct soap *soap, const struct ns2__getServicesVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesVersion(struct soap *soap, const struct ns2__getServicesVersion *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesVersion);

  if (soap_out_ns2__getServicesVersion(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesVersion(struct soap *soap, const char *tag, int id, const struct ns2__getServicesVersion *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesVersion), type))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesVersion * SOAP_FMAC4 soap_get_ns2__getServicesVersion(struct soap *soap, struct ns2__getServicesVersion *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getServicesVersion(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getServicesVersion * SOAP_FMAC4 soap_in_ns2__getServicesVersion(struct soap *soap, const char *tag, struct ns2__getServicesVersion *a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getServicesVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesVersion, sizeof(struct ns2__getServicesVersion), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getServicesVersion(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getServicesVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesVersion, 0, sizeof(struct ns2__getServicesVersion), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getServicesVersion * SOAP_FMAC6 soap_new_ns2__getServicesVersion(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getServicesVersion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesVersion(struct soap *soap, struct ns2__getServicesVersion *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesVersion * SOAP_FMAC4 soap_instantiate_ns2__getServicesVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesVersion(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesVersion, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getServicesVersion;

      if (size)
        *size = sizeof(struct ns2__getServicesVersion);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getServicesVersion[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getServicesVersion);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getServicesVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesVersion %p -> %p\n", q, p));
  *(struct ns2__getServicesVersion*)p = *(struct ns2__getServicesVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesVersionResponse(struct soap *soap, struct ns2__getServicesVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->getServicesVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesVersionResponse(struct soap *soap, const struct ns2__getServicesVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->getServicesVersionReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->getServicesVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesVersionResponse(struct soap *soap, const struct ns2__getServicesVersionResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesVersionResponse);

  if (soap_out_ns2__getServicesVersionResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesVersionResponse(struct soap *soap, const char *tag, int id, const struct ns2__getServicesVersionResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesVersionResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getServicesVersionReturn", -1, &a->getServicesVersionReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesVersionResponse * SOAP_FMAC4 soap_get_ns2__getServicesVersionResponse(struct soap *soap, struct ns2__getServicesVersionResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getServicesVersionResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getServicesVersionResponse * SOAP_FMAC4 soap_in_ns2__getServicesVersionResponse(struct soap *soap, const char *tag, struct ns2__getServicesVersionResponse *a, const char *type)
{
  size_t soap_flag_getServicesVersionReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getServicesVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesVersionResponse, sizeof(struct ns2__getServicesVersionResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getServicesVersionResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_getServicesVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, "getServicesVersionReturn", &a->getServicesVersionReturn, "xsd:string"))
              {
                soap_flag_getServicesVersionReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getServicesVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesVersionResponse, 0, sizeof(struct ns2__getServicesVersionResponse), 0, soap_copy_ns2__getServicesVersionResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getServicesVersionReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getServicesVersionResponse * SOAP_FMAC6 soap_new_ns2__getServicesVersionResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getServicesVersionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesVersionResponse(struct soap *soap, struct ns2__getServicesVersionResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesVersionResponse * SOAP_FMAC4 soap_instantiate_ns2__getServicesVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesVersionResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesVersionResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getServicesVersionResponse;

      if (size)
        *size = sizeof(struct ns2__getServicesVersionResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getServicesVersionResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getServicesVersionResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getServicesVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesVersionResponse %p -> %p\n", q, p));
  *(struct ns2__getServicesVersionResponse*)p = *(struct ns2__getServicesVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesInfo(struct soap *soap, struct ns2__getServicesInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesInfo(struct soap *soap, const struct ns2__getServicesInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesInfo(struct soap *soap, const struct ns2__getServicesInfo *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesInfo);

  if (soap_out_ns2__getServicesInfo(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesInfo(struct soap *soap, const char *tag, int id, const struct ns2__getServicesInfo *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesInfo), type))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesInfo * SOAP_FMAC4 soap_get_ns2__getServicesInfo(struct soap *soap, struct ns2__getServicesInfo *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getServicesInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getServicesInfo * SOAP_FMAC4 soap_in_ns2__getServicesInfo(struct soap *soap, const char *tag, struct ns2__getServicesInfo *a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getServicesInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesInfo, sizeof(struct ns2__getServicesInfo), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getServicesInfo(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getServicesInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesInfo, 0, sizeof(struct ns2__getServicesInfo), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getServicesInfo * SOAP_FMAC6 soap_new_ns2__getServicesInfo(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getServicesInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesInfo(struct soap *soap, struct ns2__getServicesInfo *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesInfo * SOAP_FMAC4 soap_instantiate_ns2__getServicesInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesInfo(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesInfo, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getServicesInfo;

      if (size)
        *size = sizeof(struct ns2__getServicesInfo);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getServicesInfo[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getServicesInfo);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getServicesInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesInfo %p -> %p\n", q, p));
  *(struct ns2__getServicesInfo*)p = *(struct ns2__getServicesInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesInfoResponse(struct soap *soap, struct ns2__getServicesInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->getServicesInfoReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesInfoResponse(struct soap *soap, const struct ns2__getServicesInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->getServicesInfoReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->getServicesInfoReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesInfoResponse(struct soap *soap, const struct ns2__getServicesInfoResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesInfoResponse);

  if (soap_out_ns2__getServicesInfoResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesInfoResponse(struct soap *soap, const char *tag, int id, const struct ns2__getServicesInfoResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesInfoResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getServicesInfoReturn", -1, &a->getServicesInfoReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesInfoResponse * SOAP_FMAC4 soap_get_ns2__getServicesInfoResponse(struct soap *soap, struct ns2__getServicesInfoResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getServicesInfoResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getServicesInfoResponse * SOAP_FMAC4 soap_in_ns2__getServicesInfoResponse(struct soap *soap, const char *tag, struct ns2__getServicesInfoResponse *a, const char *type)
{
  size_t soap_flag_getServicesInfoReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getServicesInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesInfoResponse, sizeof(struct ns2__getServicesInfoResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getServicesInfoResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag_getServicesInfoReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, "getServicesInfoReturn", &a->getServicesInfoReturn, "xsd:string"))
              {
                soap_flag_getServicesInfoReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getServicesInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesInfoResponse, 0, sizeof(struct ns2__getServicesInfoResponse), 0, soap_copy_ns2__getServicesInfoResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getServicesInfoReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getServicesInfoResponse * SOAP_FMAC6 soap_new_ns2__getServicesInfoResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getServicesInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesInfoResponse(struct soap *soap, struct ns2__getServicesInfoResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesInfoResponse * SOAP_FMAC4 soap_instantiate_ns2__getServicesInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesInfoResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesInfoResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getServicesInfoResponse;

      if (size)
        *size = sizeof(struct ns2__getServicesInfoResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getServicesInfoResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getServicesInfoResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getServicesInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesInfoResponse %p -> %p\n", q, p));
  *(struct ns2__getServicesInfoResponse*)p = *(struct ns2__getServicesInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataResources(struct soap *soap, struct ns2__getDataResources *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_nickname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataResources(struct soap *soap, const struct ns2__getDataResources *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_nickname, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_nickname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataResources(struct soap *soap, const struct ns2__getDataResources *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataResources);

  if (soap_out_ns2__getDataResources(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataResources(struct soap *soap, const char *tag, int id, const struct ns2__getDataResources *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataResources), type))
    return soap->error;

  if (soap_out_std__string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataResources * SOAP_FMAC4 soap_get_ns2__getDataResources(struct soap *soap, struct ns2__getDataResources *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataResources(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataResources * SOAP_FMAC4 soap_in_ns2__getDataResources(struct soap *soap, const char *tag, struct ns2__getDataResources *a, const char *type)
{
  size_t soap_flag__nickname = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataResources *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataResources, sizeof(struct ns2__getDataResources), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getDataResources(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_nickname, "xsd:string"))
              {
                soap_flag__nickname--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataResources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataResources, 0, sizeof(struct ns2__getDataResources), 0, soap_copy_ns2__getDataResources);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__nickname > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataResources * SOAP_FMAC6 soap_new_ns2__getDataResources(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataResources(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataResources(struct soap *soap, struct ns2__getDataResources *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataResources * SOAP_FMAC4 soap_instantiate_ns2__getDataResources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataResources(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataResources, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataResources;

      if (size)
        *size = sizeof(struct ns2__getDataResources);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataResources[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataResources);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataResources*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataResources(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataResources %p -> %p\n", q, p));
  *(struct ns2__getDataResources*)p = *(struct ns2__getDataResources*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataResourcesResponse(struct soap *soap, struct ns2__getDataResourcesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataResourcesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataResourcesResponse(struct soap *soap, const struct ns2__getDataResourcesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataResourcesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataResourcesResponse(struct soap *soap, const struct ns2__getDataResourcesResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataResourcesResponse);

  if (soap_out_ns2__getDataResourcesResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataResourcesResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataResourcesResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataResourcesResponse), type))
    return soap->error;

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataResourcesReturn", -1, &a->_getDataResourcesReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataResourcesResponse * SOAP_FMAC4 soap_get_ns2__getDataResourcesResponse(struct soap *soap, struct ns2__getDataResourcesResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getDataResourcesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getDataResourcesResponse * SOAP_FMAC4 soap_in_ns2__getDataResourcesResponse(struct soap *soap, const char *tag, struct ns2__getDataResourcesResponse *a, const char *type)
{
  size_t soap_flag__getDataResourcesReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getDataResourcesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataResourcesResponse, sizeof(struct ns2__getDataResourcesResponse), 0, NULL, NULL, NULL);

  if (!a)
    return NULL;

  soap_default_ns2__getDataResourcesResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getDataResourcesReturn && soap->error == SOAP_TAG_MISMATCH)
            if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataResourcesReturn, "xsd:string"))
              {
                soap_flag__getDataResourcesReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getDataResourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataResourcesResponse, 0, sizeof(struct ns2__getDataResourcesResponse), 0, NULL);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getDataResourcesResponse * SOAP_FMAC6 soap_new_ns2__getDataResourcesResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getDataResourcesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataResourcesResponse(struct soap *soap, struct ns2__getDataResourcesResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataResourcesResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataResourcesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataResourcesResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataResourcesResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getDataResourcesResponse;

      if (size)
        *size = sizeof(struct ns2__getDataResourcesResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getDataResourcesResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getDataResourcesResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getDataResourcesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataResourcesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataResourcesResponse %p -> %p\n", q, p));
  *(struct ns2__getDataResourcesResponse*)p = *(struct ns2__getDataResourcesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURI(struct soap *soap, struct ns2__getURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_name);
  soap_default_std__string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURI(struct soap *soap, const struct ns2__getURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_name, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_name);
  soap_embedded(soap, &a->_id, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURI(struct soap *soap, const struct ns2__getURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURI);

  if (soap_out_ns2__getURI(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURI(struct soap *soap, const char *tag, int id, const struct ns2__getURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURI), type))
    return soap->error;

  if (soap_out_std__string(soap, "name", -1, &a->_name, ""))
    return soap->error;

  if (soap_out_std__string(soap, "id", -1, &a->_id, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURI * SOAP_FMAC4 soap_get_ns2__getURI(struct soap *soap, struct ns2__getURI *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getURI(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getURI * SOAP_FMAC4 soap_in_ns2__getURI(struct soap *soap, const char *tag, struct ns2__getURI *a, const char *type)
{
  size_t soap_flag__name = 1;
  size_t soap_flag__id = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getURI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURI, sizeof(struct ns2__getURI), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getURI(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_name, "xsd:string"))
              {
                soap_flag__name--;
                continue;
              }

          if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_id, "xsd:string"))
              {
                soap_flag__id--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURI, 0, sizeof(struct ns2__getURI), 0, soap_copy_ns2__getURI);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__name > 0 || soap_flag__id > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getURI * SOAP_FMAC6 soap_new_ns2__getURI(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURI(struct soap *soap, struct ns2__getURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURI * SOAP_FMAC4 soap_instantiate_ns2__getURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURI, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getURI;

      if (size)
        *size = sizeof(struct ns2__getURI);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getURI[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getURI);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getURI*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURI %p -> %p\n", q, p));
  *(struct ns2__getURI*)p = *(struct ns2__getURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURIResponse(struct soap *soap, struct ns2__getURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURIResponse(struct soap *soap, const struct ns2__getURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getURIReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURIResponse(struct soap *soap, const struct ns2__getURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURIResponse);

  if (soap_out_ns2__getURIResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURIResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getURIReturn", -1, &a->_getURIReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURIResponse * SOAP_FMAC4 soap_get_ns2__getURIResponse(struct soap *soap, struct ns2__getURIResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getURIResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getURIResponse * SOAP_FMAC4 soap_in_ns2__getURIResponse(struct soap *soap, const char *tag, struct ns2__getURIResponse *a, const char *type)
{
  size_t soap_flag__getURIReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getURIResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURIResponse, sizeof(struct ns2__getURIResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getURIResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getURIReturn, "xsd:string"))
              {
                soap_flag__getURIReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURIResponse, 0, sizeof(struct ns2__getURIResponse), 0, soap_copy_ns2__getURIResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getURIReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getURIResponse * SOAP_FMAC6 soap_new_ns2__getURIResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getURIResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURIResponse(struct soap *soap, struct ns2__getURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURIResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getURIResponse;

      if (size)
        *size = sizeof(struct ns2__getURIResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getURIResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getURIResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getURIResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURIResponse %p -> %p\n", q, p));
  *(struct ns2__getURIResponse*)p = *(struct ns2__getURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocation(struct soap *soap, struct ns2__getLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_uri);
  soap_default_std__string(soap, &a->_resource);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocation(struct soap *soap, const struct ns2__getLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_uri, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_uri);
  soap_embedded(soap, &a->_resource, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_resource);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocation(struct soap *soap, const struct ns2__getLocation *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocation);

  if (soap_out_ns2__getLocation(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocation(struct soap *soap, const char *tag, int id, const struct ns2__getLocation *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocation), type))
    return soap->error;

  if (soap_out_std__string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;

  if (soap_out_std__string(soap, "resource", -1, &a->_resource, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocation * SOAP_FMAC4 soap_get_ns2__getLocation(struct soap *soap, struct ns2__getLocation *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getLocation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getLocation * SOAP_FMAC4 soap_in_ns2__getLocation(struct soap *soap, const char *tag, struct ns2__getLocation *a, const char *type)
{
  size_t soap_flag__uri = 1;
  size_t soap_flag__resource = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocation, sizeof(struct ns2__getLocation), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getLocation(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_uri, "xsd:string"))
              {
                soap_flag__uri--;
                continue;
              }

          if (soap_flag__resource && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_resource, "xsd:string"))
              {
                soap_flag__resource--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocation, 0, sizeof(struct ns2__getLocation), 0, soap_copy_ns2__getLocation);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__uri > 0 || soap_flag__resource > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getLocation * SOAP_FMAC6 soap_new_ns2__getLocation(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getLocation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocation(struct soap *soap, struct ns2__getLocation *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocation * SOAP_FMAC4 soap_instantiate_ns2__getLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocation(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocation, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getLocation;

      if (size)
        *size = sizeof(struct ns2__getLocation);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getLocation[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getLocation);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getLocation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocation %p -> %p\n", q, p));
  *(struct ns2__getLocation*)p = *(struct ns2__getLocation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocationResponse(struct soap *soap, struct ns2__getLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getLocationReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocationResponse(struct soap *soap, const struct ns2__getLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getLocationReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getLocationReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocationResponse(struct soap *soap, const struct ns2__getLocationResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocationResponse);

  if (soap_out_ns2__getLocationResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocationResponse(struct soap *soap, const char *tag, int id, const struct ns2__getLocationResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocationResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getLocationReturn", -1, &a->_getLocationReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocationResponse * SOAP_FMAC4 soap_get_ns2__getLocationResponse(struct soap *soap, struct ns2__getLocationResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getLocationResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getLocationResponse * SOAP_FMAC4 soap_in_ns2__getLocationResponse(struct soap *soap, const char *tag, struct ns2__getLocationResponse *a, const char *type)
{
  size_t soap_flag__getLocationReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getLocationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocationResponse, sizeof(struct ns2__getLocationResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getLocationResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getLocationReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getLocationReturn, "xsd:string"))
              {
                soap_flag__getLocationReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocationResponse, 0, sizeof(struct ns2__getLocationResponse), 0, soap_copy_ns2__getLocationResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getLocationReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getLocationResponse * SOAP_FMAC6 soap_new_ns2__getLocationResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getLocationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocationResponse(struct soap *soap, struct ns2__getLocationResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocationResponse * SOAP_FMAC4 soap_instantiate_ns2__getLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocationResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocationResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getLocationResponse;

      if (size)
        *size = sizeof(struct ns2__getLocationResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getLocationResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getLocationResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getLocationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocationResponse %p -> %p\n", q, p));
  *(struct ns2__getLocationResponse*)p = *(struct ns2__getLocationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getName(struct soap *soap, struct ns2__getName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getName(struct soap *soap, const struct ns2__getName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_uri, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getName(struct soap *soap, const struct ns2__getName *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getName);

  if (soap_out_ns2__getName(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getName(struct soap *soap, const char *tag, int id, const struct ns2__getName *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getName), type))
    return soap->error;

  if (soap_out_std__string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getName * SOAP_FMAC4 soap_get_ns2__getName(struct soap *soap, struct ns2__getName *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getName * SOAP_FMAC4 soap_in_ns2__getName(struct soap *soap, const char *tag, struct ns2__getName *a, const char *type)
{
  size_t soap_flag__uri = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getName, sizeof(struct ns2__getName), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getName(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_uri, "xsd:string"))
              {
                soap_flag__uri--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getName, 0, sizeof(struct ns2__getName), 0, soap_copy_ns2__getName);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__uri > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getName * SOAP_FMAC6 soap_new_ns2__getName(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getName(struct soap *soap, struct ns2__getName *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getName * SOAP_FMAC4 soap_instantiate_ns2__getName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getName(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getName, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getName;

      if (size)
        *size = sizeof(struct ns2__getName);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getName[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getName);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getName %p -> %p\n", q, p));
  *(struct ns2__getName*)p = *(struct ns2__getName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getNameResponse(struct soap *soap, struct ns2__getNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_std__string(soap, &a->_getNameReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getNameResponse(struct soap *soap, const struct ns2__getNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->_getNameReturn, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &a->_getNameReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getNameResponse(struct soap *soap, const struct ns2__getNameResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getNameResponse);

  if (soap_out_ns2__getNameResponse(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNameResponse(struct soap *soap, const char *tag, int id, const struct ns2__getNameResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNameResponse), type))
    return soap->error;

  if (soap_out_std__string(soap, "getNameReturn", -1, &a->_getNameReturn, ""))
    return soap->error;

  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getNameResponse * SOAP_FMAC4 soap_get_ns2__getNameResponse(struct soap *soap, struct ns2__getNameResponse *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns2__getNameResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct ns2__getNameResponse * SOAP_FMAC4 soap_in_ns2__getNameResponse(struct soap *soap, const char *tag, struct ns2__getNameResponse *a, const char *type)
{
  size_t soap_flag__getNameReturn = 1;

  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;

  a = (struct ns2__getNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNameResponse, sizeof(struct ns2__getNameResponse), soap->type, soap->arrayType);

  if (!a)
    return NULL;

  soap_default_ns2__getNameResponse(soap, a);

  if (soap->body && !*soap->href)
    {
      for (;;)
        {
          soap->error = SOAP_TAG_MISMATCH;

          if (soap_flag__getNameReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
            if (soap_in_std__string(soap, NULL, &a->_getNameReturn, "xsd:string"))
              {
                soap_flag__getNameReturn--;
                continue;
              }

          if (soap->error == SOAP_TAG_MISMATCH)
            soap->error = soap_ignore_element(soap);

          if (soap->error == SOAP_NO_TAG)
            break;

          if (soap->error)
            return NULL;
        }

      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (struct ns2__getNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNameResponse, 0, sizeof(struct ns2__getNameResponse), 0, soap_copy_ns2__getNameResponse);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getNameReturn > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }

  return a;
}

SOAP_FMAC5 struct ns2__getNameResponse * SOAP_FMAC6 soap_new_ns2__getNameResponse(struct soap *soap, int n)
{
  return soap_instantiate_ns2__getNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getNameResponse(struct soap *soap, struct ns2__getNameResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getNameResponse * SOAP_FMAC4 soap_instantiate_ns2__getNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNameResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNameResponse, n, soap_fdelete);

  if (!cp)
    return NULL;

  if (n < 0)
    {
      cp->ptr = (void*)new struct ns2__getNameResponse;

      if (size)
        *size = sizeof(struct ns2__getNameResponse);
    }
  else
    {
      cp->ptr = (void*)new struct ns2__getNameResponse[n];

      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }

      if (size)
        *size = n * sizeof(struct ns2__getNameResponse);
    }

  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct ns2__getNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getNameResponse %p -> %p\n", q, p));
  *(struct ns2__getNameResponse*)p = *(struct ns2__getNameResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
    soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);

  if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);

  if (id < 0)
    return soap->error;

  return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
  if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;

  if (!a)
    if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
      return NULL;

  *a = NULL;

  if (!soap->null && *soap->href != '#')
    {
      soap_revert(soap);

      if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
    soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);

  if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);

  if (id < 0)
    return soap->error;

  return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
  if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;

  if (!a)
    if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
      return NULL;

  *a = NULL;

  if (!soap->null && *soap->href != '#')
    {
      soap_revert(soap);

      if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
    soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);

  if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);

  if (id < 0)
    return soap->error;

  return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
  if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;

  if (!a)
    if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
      return NULL;

  *a = NULL;

  if (!soap->null && *soap->href != '#')
    {
      soap_revert(soap);

      if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
        return NULL;
    }
  else
    {
      a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *const*a)
{
  if (*a)
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring);

  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, ArrayOf_USCORExsd_USCOREstring *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, (struct soap_array*) & (*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);

  if (id < 0)
    return soap->error;

  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring **p, const char *tag, const char *type)
{
  if ((p = soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOf_USCORExsd_USCOREstring **a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;

  if (!a)
    if (!(a = (ArrayOf_USCORExsd_USCOREstring **)soap_malloc(soap, sizeof(ArrayOf_USCORExsd_USCOREstring *))))
      return NULL;

  *a = NULL;

  if (!soap->null && *soap->href != '#')
    {
      soap_revert(soap);

      if (!(*a = (ArrayOf_USCORExsd_USCOREstring *)soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, -1, soap->type, soap->arrayType, NULL)))
        return NULL;

      (*a)->soap_default(soap);

      if (!(*a)->soap_in(soap, tag, NULL))
        return NULL;
    }
  else
    {
      ArrayOf_USCORExsd_USCOREstring ** p = (ArrayOf_USCORExsd_USCOREstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOf_USCORExsd_USCOREstring), 0);
      a = p;

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
    soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);

  if (soap_out_PointerTostd__string(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);

  if (id < 0)
    return soap->error;

  return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
  if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;

  if (!a)
    if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
      return NULL;

  *a = NULL;

  if (!soap->null && *soap->href != '#')
    {
      soap_revert(soap);

      if (!(*a = soap_in_std__string(soap, tag, *a, type)))
        return NULL;
    }
  else
    {
      a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);

      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }

  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
  soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
  soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);

  if (soap_out__QName(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
  if ((p = soap_in__QName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
  *a = SOAP_DEFAULT_string;
#else
  *a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
  soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);

  if (soap_out_string(soap, tag, id, a, type))
    return soap->error;

  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
  if ((p = soap_in_string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;

  return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
  return p;
}

/* End of soapC.cpp */

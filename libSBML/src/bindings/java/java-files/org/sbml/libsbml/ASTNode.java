/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.40
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.sbml.libsbml;

/** 
 * Abstract Syntax Tree (AST) representation of a
 * mathematical expression.
 * <p>
 * <em style='color: #555'>
This class of objects is defined by libSBML only and has no direct
equivalent in terms of SBML components.  This class is not prescribed by
the SBML specifications, although it is used to implement features
defined in SBML.
</em>

 * <p>
 * Abstract Syntax Trees (ASTs) are a simple kind of data structure used in
 * libSBML for storing mathematical expressions.  The {@link ASTNode} is the
 * cornerstone of libSBML's AST representation.  ASTNodes represent the
 * most basic, indivisible part of a mathematical formula and come in many
 * types.  For instance, there are node types to represent numbers (with
 * subtypes to distinguish integer, real, and rational numbers), names
 * (e.g., constants or variables), simple mathematical operators, logical
 * or relational operators and functions. LibSBML ASTs provide a canonical,
 * in-memory representation for all mathematical formulas regardless of
 * their original format (which might be MathML or might be text strings).
 * <p>
 * An AST <em>node</em> in libSBML is a recursive structure containing a pointer
 * to the node's value (which might be, for example, a number or a symbol)
 * and a list of children nodes.  Each {@link ASTNode} node may have none, one,
 * two, or more child depending on its type. The following diagram
 * illustrates an example of how the mathematical expression <code>'1 +
 * 2'</code> is represented as an AST with one <em>plus</em> node having two 
 * <em>integer</em> children nodes for the numbers <code>1</code> and
 * <code>2</code>.  The figure also shows the corresponding MathML
 * representation:
 * <p>
 * <center><img src='astnode-illustration.jpg'></center><br>
 * 
 * <p>
 * The following are other noteworthy points about the AST representation
 * in libSBML:
 * <ul>
 * <li> A numerical value represented in MathML as a real number with an
 * exponent is preserved as such in the AST node representation, even if
 * the number could be stored in a <code>double</code> data type.  This is done
 * so that when an SBML model is read in and then written out again, the
 * amount of change introduced by libSBML to the SBML during the round-trip
 * activity is minimized.
 * <p>
 * <li> Rational numbers are represented in an AST node using separate
 * numerator and denominator values.  These can be retrieved using the
 * methods ASTNode.getNumerator() and ASTNode.getDenominator().
 * <p>
 * <li> The children of an {@link ASTNode} are other {@link ASTNode} objects.  The list of
 * children is empty for nodes that are leaf elements, such as numbers.
 * For nodes that are actually roots of expression subtrees, the list of
 * children points to the parsed objects that make up the rest of the
 * expression.
 * </ul>
 * <p>
 * <p>
 * <h3><a class='anchor'
 * name='ASTNodeType_t'>The set of possible ASTNode types</a></h3> 
 * <p>
 * Every {@link ASTNode} has an associated
 * type code to indicate, for example, whether it holds a number or stands for
 * an arithmetic operator.  The type is recorded as a value drawn from a
 * set of static integer constants defined in the class {@link
 * libsbmlConstants}.  Their names begin with the characters <code>AST_</code>.  The
 * list of possible types is quite long, because it covers all the
 * mathematical functions that are permitted in SBML.  The values are shown
 * in the following table: 
 * <p>
 * <div style='margin-left: 2em'>
<ul style='list-style-type: none'>
<li>AST_CONSTANT_E</li>
<li>AST_CONSTANT_FALSE</li>
<li>AST_CONSTANT_PI</li>
<li>AST_CONSTANT_TRUE</li>
<li>AST_DIVIDE</li>
<li>AST_FUNCTION</li>
<li>AST_FUNCTION_ABS</li>
<li>AST_FUNCTION_ARCCOS</li>
<li>AST_FUNCTION_ARCCOSH</li>
<li>AST_FUNCTION_ARCCOT</li>
<li>AST_FUNCTION_ARCCOTH</li>
<li>AST_FUNCTION_ARCCSC</li>
<li>AST_FUNCTION_ARCCSCH</li>
<li>AST_FUNCTION_ARCSEC</li>
<li>AST_FUNCTION_ARCSECH</li>
<li>AST_FUNCTION_ARCSIN</li>
<li>AST_FUNCTION_ARCSINH</li>
<li>AST_FUNCTION_ARCTAN</li>
<li>AST_FUNCTION_ARCTANH</li>
<li>AST_FUNCTION_CEILING</li>
<li>AST_FUNCTION_COS</li>
<li>AST_FUNCTION_COSH</li>
</ul>
</div>
<div style='margin-left: 18em; margin-top: -30.4em'>
<ul style='list-style-type: none'>
<li>AST_FUNCTION_COT</li>
<li>AST_FUNCTION_COTH</li>
<li>AST_FUNCTION_CSC</li>
<li>AST_FUNCTION_CSCH</li>
<li>AST_FUNCTION_DELAY</li>
<li>AST_FUNCTION_EXP</li>
<li>AST_FUNCTION_FACTORIAL</li>
<li>AST_FUNCTION_FLOOR</li>
<li>AST_FUNCTION_LN</li>
<li>AST_FUNCTION_LOG</li>
<li>AST_FUNCTION_PIECEWISE</li>
<li>AST_FUNCTION_POWER</li>
<li>AST_FUNCTION_ROOT</li>
<li>AST_FUNCTION_SEC</li>
<li>AST_FUNCTION_SECH</li>
<li>AST_FUNCTION_SIN</li>
<li>AST_FUNCTION_SINH</li>
<li>AST_FUNCTION_TAN</li>
<li>AST_FUNCTION_TANH</li>
<li>AST_INTEGER</li>
<li>AST_LAMBDA</li>
<li>AST_LOGICAL_AND</li>
</ul>
</div>
<div style='margin-left: 34em; margin-top: -30.4em'>
<ul style='list-style-type: none'>
<li>AST_LOGICAL_NOT</li>
<li>AST_LOGICAL_OR</li>
<li>AST_LOGICAL_XOR</li>
<li>AST_MINUS</li>
<li>AST_NAME</li>
<li><nobr>AST_NAME_AVOGADRO <em><span style='color: #c00'>(Level&nbsp;3 only)</span></em></nobr></li>
<li>AST_NAME_TIME</li>
<li>AST_PLUS</li>
<li>AST_POWER</li>
<li>AST_RATIONAL</li>
<li>AST_REAL</li>
<li>AST_REAL_E</li>
<li>AST_RELATIONAL_EQ</li>
<li>AST_RELATIONAL_GEQ</li>
<li>AST_RELATIONAL_GT</li>
<li>AST_RELATIONAL_LEQ</li>
<li>AST_RELATIONAL_LT</li>
<li>AST_RELATIONAL_NEQ</li>
<li>AST_TIMES</li>
<li>AST_UNKNOWN</li>
</ul>
</div>
<br style='clear: both'>

 * <p>
 * The types have the following meanings:
 * <ul>
 * <li> If the node is basic mathematical operator (e.g., <code>'+'</code>), then the
 * node's type will be <code>AST_PLUS</code>, <code>AST_MINUS</code>, <code>AST_TIMES</code>, <code>AST_DIVIDE</code>,
 * or <code>AST_POWER</code>, as appropriate.
 * <p>
 * <li> If the node is a predefined function or operator from SBML Level 1
 * (in the string-based formula syntax used in Level 1) or SBML Level 2
 * (in the subset of MathML used in SBML Level 2), then the node's type
 * will be either <code>AST_FUNCTION_</code><em><span
 * class='placeholder'>X</span></em>, <code>AST_LOGICAL_</code><em><span
 * class='placeholder'>X</span></em>, or
 * <code>AST_RELATIONAL_</code><em><span class='placeholder'>X</span></em>,
 * as appropriate.  (Examples: <code>AST_FUNCTION_LOG</code>, <code>AST_RELATIONAL_LEQ</code>.)
 * <p>
 * <li> If the node refers to a user-defined function, the node's type will
 * be <code>AST_NAME</code> (because it holds the name of the function).
 * <p>
 * <li> If the node is a lambda expression, its type will be <code>AST_LAMBDA</code>.
 * <p>
 * <li> If the node is a predefined constant (<code>'ExponentialE'</code>, <code>'Pi'</code>, 
 * <code>'True'</code> or <code>'False'</code>), then the node's type will be <code>AST_CONSTANT_E</code>,
 * <code>AST_CONSTANT_PI</code>, <code>AST_CONSTANT_TRUE</code>, or <code>AST_CONSTANT_FALSE</code>.
 * <p>
 * <li> (Level 2 only) If the node is the special MathML csymbol <code>time</code>,
 * the value of the node will be <code>AST_NAME_TIME</code>.  (Note, however, that the
 * MathML csymbol <code>delay</code> is translated into a node of type
 * <code>AST_FUNCTION_DELAY</code>.  The difference is due to the fact that <code>time</code> is a
 * single variable, whereas <code>delay</code> is actually a function taking
 * arguments.)
 * <p>
 * <li> If the node contains a numerical value, its type will be
 * <code>AST_INTEGER</code>, <code>AST_REAL</code>, <code>AST_REAL_E</code>, or <code>AST_RATIONAL</code>,
 * as appropriate.
 * </ul>
 * <p>
 * <p>
 * <h3><a class='anchor' name='math-convert'>Converting between ASTs and text strings</a></h3>
 * <p>
 * * The text-string form of mathematical formulas produced by <code><a
 * href='libsbml.html#formulaToString(org.sbml.libsbml.{@link ASTNode})'>
 * libsbml.formulaToString()</a></code> and read by <code><a
 * href='libsbml.html#parseFormula(java.lang.String)'>
 * libsbml.parseFormula()</a></code> are simple C-inspired
 * infix notation taken from SBML Level&nbsp;1.  A formula in this
 * text-string form can be handed to a program that understands SBML
 * Level&nbsp;1 mathematical expressions, or used as part of a translation
 * system.  The libSBML distribution comes with an example program in the
 * <code>'examples'</code> subdirectory called <code>translateMath</code> that implements an
 * interactive command-line demonstration of translating infix formulas
 * into MathML and vice-versa.
 * <p>
 * The formula strings may contain operators, function calls, symbols, and
 * white space characters.  The allowable white space characters are tab
 * and space.  The following are illustrative examples of formulas
 * expressed in the syntax:
 * <p>
 * <div class='fragment'><pre>
0.10 * k4^2
</pre></div>
 * <div class='fragment'><pre>
(vm * s1)/(km + s1)
</pre></div>
 * <p>
 * The following table shows the precedence rules in this syntax.  In the
 * Class column, <em>operand</em> implies the construct is an operand, 
 * <em>prefix</em> implies the operation is applied to the following arguments, 
 * <em>unary</em> implies there is one argument, and <em>binary</em> implies there are
 * two arguments.  The values in the Precedence column show how the order
 * of different types of operation are determined.  For example, the
 * expression <em>a * b + c</em> is evaluated as <em>(a * b) + c</em>
 * because the <code>*</code> operator has higher precedence.  The
 * Associates column shows how the order of similar precedence operations
 * is determined; for example, <em>a - b + c</em> is evaluated as <em>(a -
 * b) + c</em> because the <code>+</code> and <code>-</code> operators are
 * left-associative.  The precedence and associativity rules are taken from
 * the C programming language, except for the symbol <code>^</code>, which
 * is used in C for a different purpose.  (Exponentiation can be invoked
 * using either <code>^</code> or the function <code>power</code>.)
 * <p>
 * <center>
<table border='0' class='text-table width80 normal-font alt-row-colors'>
 <tr style='background: lightgray; font-size: 14px;'>
     <th align='left'>Token</th>
     <th align='left'>Operation</th>
     <th align='left'>Class</th>
     <th>Precedence</th>
     <th align='left'>Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align='center'>6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align='center'>6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align='center'>6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align='center'>5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align='center'>4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align='center'>3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align='center'>3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align='center'>2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align='center'>2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align='center'>1</td><td>left</td></tr>
<caption class='top-caption'>A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>
</center>

 * <p>
 * A program parsing a formula in an SBML model should assume that names
 * appearing in the formula are the identifiers of {@link Species}, {@link Parameter},
 * {@link Compartment}, {@link FunctionDefinition}, or {@link Reaction} objects defined in a model.
 * When a function call is involved, the syntax consists of a function
 * identifier, followed by optional white space, followed by an opening
 * parenthesis, followed by a sequence of zero or more arguments separated
 * by commas (with each comma optionally preceded and/or followed by zero
 * or more white space characters), followed by a closing parenthesis.
 * There is an almost one-to-one mapping between the list of predefined
 * functions available, and those defined in MathML.  All of the MathML
 * functions are recognized; this set is larger than the functions defined
 * in SBML Level&nbsp;1.  In the subset of functions that overlap between
 * MathML and SBML Level&nbsp;1, there exist a few differences.  The
 * following table summarizes the differences between the predefined
 * functions in SBML Level&nbsp;1 and the MathML equivalents in SBML
 * Level&nbsp;2:
 * <p>
 * <center>
<table border='0' class='text-table width80 normal-font alt-row-colors'>
 <tr style='background: lightgray; font-size: 14px;'>
     <th align='left'>Text string formula functions</th>
     <th align='left'>MathML equivalents in SBML Levels&nbsp;2 and&nbsp;3</th>
 </tr>
 <tr><td><code>acos</code></td><td><code>arccos</code></td></tr>
 <tr><td><code>asin</code></td><td><code>arcsin</code></td></tr>
 <tr><td><code>atan</code></td><td><code>arctan</code></td></tr>
 <tr><td><code>ceil</code></td><td><code>ceiling</code></td></tr>
 <tr><td><code>log</code></td><td><code>ln</code></td></tr>
 <tr><td><code>log10(x)</code></td><td><code>log(10, x)</code></td></tr>
 <tr><td><code>pow(x, y)</code></td><td><code>power(x, y)</code></td></tr>
 <tr><td><code>sqr(x)</code></td><td><code>power(x, 2)</code></td></tr>
 <tr><td><code>sqrt(x)</code></td><td><code>root(2, x)</code></td></tr>
<caption class='top-caption'>Table comparing the names of certain
functions in the SBML text-string formula syntax and MathML.  The left
column shows the names of functions recognized by SBML_parseFormula(); the
right column shows their equivalent function names in MathML&nbsp;2.0, used
in SBML Levels&nbsp;2 and&nbsp;3.</caption>
</table>
</center>

 */

public class ASTNode {
   private long swigCPtr;
   protected boolean swigCMemOwn;

   protected ASTNode(long cPtr, boolean cMemoryOwn)
   {
     swigCMemOwn = cMemoryOwn;
     swigCPtr    = cPtr;
   }

   protected static long getCPtr(ASTNode obj)
   {
     return (obj == null) ? 0 : obj.swigCPtr;
   }

   protected static long getCPtrAndDisown (ASTNode obj)
   {
     long ptr = 0;

     if (obj != null)
     {
       ptr             = obj.swigCPtr;
       obj.swigCMemOwn = false;
     }

     return ptr;
   }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libsbmlJNI.delete_ASTNode(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   * Equality comparison method for ASTNode.
   * <p>
   * Because the Java methods for libSBML are actually wrappers around code
   * implemented in C++ and C, certain operations will not behave as
   * expected.  Equality comparison is one such case.  An instance of a
   * libSBML object class is actually a <em>proxy object</em>
   * wrapping the real underlying C/C++ object.  The normal <code>==</code>
   * equality operator in Java will <em>only compare the Java proxy objects</em>,
   * not the underlying native object.  The result is almost never what you
   * want in practical situations.  Unfortunately, Java does not provide a
   * way to override <code>==</code>.
   *  <p>
   * The alternative that must be followed is to use the
   * <code>equals()</code> method.  The <code>equals</code> method on this
   * class overrides the default java.lang.Object one, and performs an
   * intelligent comparison of instances of objects of this class.  The
   * result is an assessment of whether two libSBML Java objects are truly 
   * the same underlying native-code objects.
   *  <p>
   * The use of this method in practice is the same as the use of any other
   * Java <code>equals</code> method.  For example,
   * <em>a</em><code>.equals(</code><em>b</em><code>)</code> returns
   * <code>true</code> if <em>a</em> and <em>b</em> are references to the
   * same underlying object.
   *
   * @param sb a reference to an object to which the current object
   * instance will be compared
   *
   * @return <code>true</code> if <code>sb</code> refers to the same underlying 
   * native object as this one, <code>false</code> otherwise
   */
  public boolean equals(Object sb)
  {
    if ( this == sb ) 
    {
      return true;
    }
    return swigCPtr == getCPtr((ASTNode)(sb));
  }

  /**
   * Returns a hashcode for this ASTNode object.
   *
   * @return a hash code usable by Java methods that need them.
   */
  public int hashCode()
  {
    return (int)(swigCPtr^(swigCPtr>>>32));
  }

  
  /**
   * Creates and returns a new {@link ASTNode}.
   * <p>
   * By default, the returned node will have a type of @link
   * ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink.  If a type isn't
   * supplied when caling this constructor, the calling code should set the
   * node type to something else as soon as possible using {@link ASTNode#setType(int)}.
   * <p>
   * @param type an optional @link #ASTNodeType_t ASTNodeType_t@endlink
   * code indicating the type of node to create.
   * <p>
   * @docnote The native C++ implementation of this method defines a default argument
value. In the documentation generated for different libSBML language
bindings, you may or may not see corresponding arguments in the method
declarations. For example, in Java, a default argument is handled by
declaring two separate methods, with one of them having the argument and
the other one lacking the argument. However, the libSBML documentation will
be <em>identical</em> for both methods. Consequently, if you are reading
this and do not see an argument even though one is described, please look
for descriptions of other variants of this method near where this one
appears in the documentation.

   */
 public ASTNode(int type) {
    this(libsbmlJNI.new_ASTNode__SWIG_0(type), true);
  }

  
  /**
   * Creates and returns a new {@link ASTNode}.
   * <p>
   * By default, the returned node will have a type of @link
   * ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink.  If a type isn't
   * supplied when caling this constructor, the calling code should set the
   * node type to something else as soon as possible using {@link ASTNode#setType(int)}.
   * <p>
   * @param type an optional @link #ASTNodeType_t ASTNodeType_t@endlink
   * code indicating the type of node to create.
   * <p>
   * @docnote The native C++ implementation of this method defines a default argument
value. In the documentation generated for different libSBML language
bindings, you may or may not see corresponding arguments in the method
declarations. For example, in Java, a default argument is handled by
declaring two separate methods, with one of them having the argument and
the other one lacking the argument. However, the libSBML documentation will
be <em>identical</em> for both methods. Consequently, if you are reading
this and do not see an argument even though one is described, please look
for descriptions of other variants of this method near where this one
appears in the documentation.

   */
 public ASTNode() {
    this(libsbmlJNI.new_ASTNode__SWIG_1(), true);
  }

  
  /**
   * Copy constructor; creates a deep copy of the given {@link ASTNode}.
   * <p>
   * @param orig the {@link ASTNode} to be copied.
   */
 public ASTNode(ASTNode orig) {
    this(libsbmlJNI.new_ASTNode__SWIG_2(ASTNode.getCPtr(orig), orig), true);
  }

  
  /**
   * Frees the name of this {@link ASTNode} and sets it to <code>NULL</code>.
   * <p>
   * This operation is only applicable to ASTNodes corresponding to
   * operators, numbers, or @link ASTNodeType_t#AST_UNKNOWN
   * AST_UNKNOWN@endlink.  This method has no effect on other types of
   * nodes.
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE }
   */
 public int freeName() {
    return libsbmlJNI.ASTNode_freeName(swigCPtr, this);
  }

  
  /**
   * Converts this {@link ASTNode} to a canonical form and returns <code>true</code> if
   * successful, <code>false</code> otherwise.
   * <p>
   * The rules determining the canonical form conversion are as follows:
   * <ul>
   * <p>
   * <li> If the node type is @link ASTNodeType_t#AST_NAME AST_NAME@endlink
   * and the node name matches <code>'ExponentialE'</code>, <code>'Pi'</code>, <code>'True'</code> or 
   * <code>'False'</code> the node type is converted to the corresponding 
   * <code>AST_CONSTANT_<em><span</code> class='placeholder'>X</span></em> type.
   * <p>
   * <li> If the node type is an @link ASTNodeType_t#AST_FUNCTION
   * AST_FUNCTION@endlink and the node name matches an SBML Level&nbsp;1 or
   * Level&nbsp;2 (MathML) function name, logical operator name, or
   * relational operator name, the node is converted to the corresponding
   * <code>AST_FUNCTION_</code><em><span class='placeholder'>X</span></em> or
   * <code>AST_LOGICAL_</code><em><span class='placeholder'>X</span></em> type.
   * <p>
   * </ul>
   * <p>
   * SBML Level&nbsp;1 function names are searched first; thus, for
   * example, canonicalizing <code>log</code> will result in a node type of @link
   * ASTNodeType_t#AST_FUNCTION_LN AST_FUNCTION_LN@endlink.  (See the SBML
   * Level&nbsp;1 Version&nbsp;2 Specification, Appendix C.)
   * <p>
   * Sometimes, canonicalization of a node results in a structural
   * conversion of the node as a result of adding a child.  For example, a
   * node with the SBML Level&nbsp;1 function name <code>sqr</code> and a single
   * child node (the argument) will be transformed to a node of type
   * @link ASTNodeType_t#AST_FUNCTION_POWER AST_FUNCTION_POWER@endlink with
   * two children.  The first child will remain unchanged, but the second
   * child will be an {@link ASTNode} of type @link ASTNodeType_t#AST_INTEGER
   * AST_INTEGER@endlink and a value of 2.  The function names that result
   * in structural changes are: <code>log10</code>, <code>sqr</code>, and <code>sqrt</code>.
   */
 public boolean canonicalize() {
    return libsbmlJNI.ASTNode_canonicalize(swigCPtr, this);
  }

  
  /**
   * Adds the given node as a child of this {@link ASTNode}.  Child nodes are added
   * in-order, from left to right.
   * <p>
   * @param child the {@link ASTNode} instance to add
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED }
   * <p>
   * @note Adding a child to an {@link ASTNode} may change the structure of
   * the mathematical formula being represented by the tree structure,
   * and may render the representation invalid.
   * <p>
   * @see #prependChild(ASTNode  child)
   * @see #replaceChild(long n, {@link ASTNode}  child)
   * @see #insertChild(long n, {@link ASTNode}  child)
   * @see #removeChild(long n)
   */
 public int addChild(ASTNode child) {
    return libsbmlJNI.ASTNode_addChild(swigCPtr, this, ASTNode.getCPtrAndDisown(child), child);
  }

  
  /**
   * Adds the given node as a child of this {@link ASTNode}.  This method adds
   * child nodes from right to left.
   * <p>
   * @param child the {@link ASTNode} instance to add
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED }
   * <p>
   * @note Prepending a child to an {@link ASTNode} may change the structure of the
   * mathematical formula being represented by the tree structure, and may
   * render the representation invalid.
   * <p>
   * @see #addChild(ASTNode  child)
   * @see #replaceChild(long n, {@link ASTNode}  child)
   * @see #insertChild(long n, {@link ASTNode}  child)
   * @see #removeChild(long n)
   */
 public int prependChild(ASTNode child) {
    return libsbmlJNI.ASTNode_prependChild(swigCPtr, this, ASTNode.getCPtrAndDisown(child), child);
  }

  
  /**
   * Removes the nth child of this {@link ASTNode} object.
   * <p>
   * @param n long the index of the child to remove
   * <p>
   * @return integer value indicating success/failure of the
   * function. The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE }
   * <p>
   * @note Removing a child from an {@link ASTNode} may change the structure of the
   * mathematical formula being represented by the tree structure, and may
   * render the representation invalid.
   * <p>
   * @see #addChild(ASTNode  child)
   * @see #prependChild(ASTNode  child)
   * @see #replaceChild(long n, {@link ASTNode}  child)
   * @see #insertChild(long n, {@link ASTNode}  child)
   */
 public int removeChild(long n) {
    return libsbmlJNI.ASTNode_removeChild(swigCPtr, this, n);
  }

  
  /**
   * Replaces the nth child of this {@link ASTNode} with the given {@link ASTNode}.
   * <p>
   * @param n long the index of the child to replace
   * @param newChild {@link ASTNode} to replace the nth child
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE }
   * <p>
   * @note Replacing a child from an {@link ASTNode} may change the structure of the
   * mathematical formula being represented by the tree structure, and may
   * render the representation invalid.
   * <p>
   * @see #addChild(ASTNode  child)
   * @see #prependChild(ASTNode  child)
   * @see #insertChild(long n, {@link ASTNode}  child)
   * @see #removeChild(long n)
   */
 public int replaceChild(long n, ASTNode newChild) {
    return libsbmlJNI.ASTNode_replaceChild(swigCPtr, this, n, ASTNode.getCPtrAndDisown(newChild), newChild);
  }

  
  /**
   * Insert the given {@link ASTNode} at point n in the list of children
   * of this {@link ASTNode}.
   * <p>
   * @param n long the index of the {@link ASTNode} being added
   * @param newChild {@link ASTNode} to insert as the nth child
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE }
   * <p>
   * @note Inserting a child into an {@link ASTNode} may change the structure of the
   * mathematical formula being represented by the tree structure, and may
   * render the representation invalid.
   * <p>
   * @see #addChild(ASTNode  child)
   * @see #prependChild(ASTNode  child)
   * @see #replaceChild(long n, {@link ASTNode}  child)
   * @see #removeChild(long n)
   */
 public int insertChild(long n, ASTNode newChild) {
    return libsbmlJNI.ASTNode_insertChild(swigCPtr, this, n, ASTNode.getCPtrAndDisown(newChild), newChild);
  }

  
  /**
   * Creates a recursive copy of this node and all its children.
   * <p>
   * @return a copy of this {@link ASTNode} and all its children.  The caller owns
   * the returned {@link ASTNode} and is reponsible for deleting it.
   */
 public ASTNode deepCopy() {
    long cPtr = libsbmlJNI.ASTNode_deepCopy(swigCPtr, this);
    return (cPtr == 0) ? null : new ASTNode(cPtr, true);
  }

  
  /**
   * Get a child of this node according to an index number.
   * <p>
   * @param n the index of the child to get
   * <p>
   * @return the nth child of this {@link ASTNode} or <code>NULL</code> if this node has no nth
   * child (<code>n &gt; getNumChildren() - 1</code>).
   */
 public ASTNode getChild(long n) {
    long cPtr = libsbmlJNI.ASTNode_getChild(swigCPtr, this, n);
    return (cPtr == 0) ? null : new ASTNode(cPtr, false);
  }

  
  /**
   * Get the left child of this node.
   * <p>
   * @return the left child of this {@link ASTNode}.  This is equivalent to
   * <code>getChild(0)</code>;
   */
 public ASTNode getLeftChild() {
    long cPtr = libsbmlJNI.ASTNode_getLeftChild(swigCPtr, this);
    return (cPtr == 0) ? null : new ASTNode(cPtr, false);
  }

  
  /**
   * Get the right child of this node.
   * <p>
   * @return the right child of this {@link ASTNode}, or <code>NULL</code> if this node has no
   * right child.  If <code>getNumChildren() &gt; 1</code>, then
   * this is equivalent to:
   * <div class='fragment'><pre>
   * getChild( getNumChildren() - 1 );</pre></div>
   */
 public ASTNode getRightChild() {
    long cPtr = libsbmlJNI.ASTNode_getRightChild(swigCPtr, this);
    return (cPtr == 0) ? null : new ASTNode(cPtr, false);
  }

  
  /**
   * Get the number of children that this node has.
   * <p>
   * @return the number of children of this {@link ASTNode}, or 0 is this node has
   * no children.
   */
 public long getNumChildren() {
    return libsbmlJNI.ASTNode_getNumChildren(swigCPtr, this);
  }

  
  /**
   * Adds the given {@link XMLNode} as a semantic annotation of this {@link ASTNode}.
   * <p>
   * @param sAnnotation the annotation to add.
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED }
   */
 public int addSemanticsAnnotation(XMLNode sAnnotation) {
    return libsbmlJNI.ASTNode_addSemanticsAnnotation(swigCPtr, this, XMLNode.getCPtrAndDisown(sAnnotation), sAnnotation);
  }

  
  /**
   * Get the number of semantic annotation elements inside this node.
   * <p>
   * @return the number of annotations of this {@link ASTNode}.  
   */
 public long getNumSemanticsAnnotations() {
    return libsbmlJNI.ASTNode_getNumSemanticsAnnotations(swigCPtr, this);
  }

  
  /**
   * Get the nth semantic annotation of this node.
   * <p>
   * @return the nth annotation of this {@link ASTNode}, or <code>NULL</code> if this node has
   * no nth annotation (<code>n &gt; getNumChildren() - 1</code>).
   */
 public XMLNode getSemanticsAnnotation(long n) {
    long cPtr = libsbmlJNI.ASTNode_getSemanticsAnnotation(swigCPtr, this, n);
    return (cPtr == 0) ? null : new XMLNode(cPtr, false);
  }

  
  /**
   * Get the value of this node as a single character.  This function
   * should be called only when getType() is one of @link
   * ASTNodeType_t#AST_PLUS AST_PLUS@endlink, @link ASTNodeType_t#AST_MINUS
   * AST_MINUS@endlink, @link ASTNodeType_t#AST_TIMES AST_TIMES@endlink,
   * @link ASTNodeType_t#AST_DIVIDE AST_DIVIDE@endlink or @link
   * ASTNodeType_t#AST_POWER AST_POWER@endlink.
   * <p>
   * @return the value of this {@link ASTNode} as a single character
   */
 public char getCharacter() {
    return libsbmlJNI.ASTNode_getCharacter(swigCPtr, this);
  }

  
  /**
   * Get the value of this node as an integer. This function should be
   * called only when <code>getType() == @link ASTNodeType_t#AST_INTEGER
   * AST_INTEGER@endlink</code>.
   * <p>
   * @return the value of this {@link ASTNode} as a (<code>long</code>) integer. 
   */
 public int getInteger() {
    return libsbmlJNI.ASTNode_getInteger(swigCPtr, this);
  }

  
  /**
   * Get the value of this node as a string.  This function may be called
   * on nodes that are not operators (<code>isOperator() == false</code>)
   * or numbers (<code>isNumber() == false</code>).
   * <p>
   * @return the value of this {@link ASTNode} as a string.
   */
 public String getName() {
    return libsbmlJNI.ASTNode_getName(swigCPtr, this);
  }

  
  /**
   * Get the value of the numerator of this node.  This function should be
   * called only when <code>getType() == @link ASTNodeType_t#AST_RATIONAL
   * AST_RATIONAL@endlink</code>.
   * <p>
   * @return the value of the numerator of this {@link ASTNode}.  
   */
 public int getNumerator() {
    return libsbmlJNI.ASTNode_getNumerator(swigCPtr, this);
  }

  
  /**
   * Get the value of the denominator of this node.  This function should
   * be called only when <code>getType() == @link
   * ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink</code>.
   * <p>
   * @return the value of the denominator of this {@link ASTNode}.
   */
 public int getDenominator() {
    return libsbmlJNI.ASTNode_getDenominator(swigCPtr, this);
  }

  
  /**
   * Get the real-numbered value of this node.  This function
   * should be called only when <code>isReal() == true</code>.
   * <p>
   * This function performs the necessary arithmetic if the node type is
   * @link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink (<em>mantissa *
   * 10<sup> exponent</sup></em>) or @link ASTNodeType_t#AST_RATIONAL
   * AST_RATIONAL@endlink (<em>numerator / denominator</em>).
   * <p>
   * @return the value of this {@link ASTNode} as a real (double).
   */
 public double getReal() {
    return libsbmlJNI.ASTNode_getReal(swigCPtr, this);
  }

  
  /**
   * Get the mantissa value of this node.  This function should be called
   * only when getType() returns @link ASTNodeType_t#AST_REAL_E
   * AST_REAL_E@endlink or @link ASTNodeType_t#AST_REAL AST_REAL@endlink.
   * If getType() returns @link ASTNodeType_t#AST_REAL AST_REAL@endlink,
   * this method is identical to getReal().
   * <p>
   * @return the value of the mantissa of this {@link ASTNode}. 
   */
 public double getMantissa() {
    return libsbmlJNI.ASTNode_getMantissa(swigCPtr, this);
  }

  
  /**
   * Get the exponent value of this {@link ASTNode}.  This function should be
   * called only when getType() returns @link ASTNodeType_t#AST_REAL_E
   * AST_REAL_E@endlink or @link ASTNodeType_t#AST_REAL AST_REAL@endlink.
   * <p>
   * @return the value of the exponent of this {@link ASTNode}.
   */
 public int getExponent() {
    return libsbmlJNI.ASTNode_getExponent(swigCPtr, this);
  }

  
  /**
   * Get the precedence of this node in the infix math syntax of SBML
   * Level&nbsp;1.  For more information about the infix syntax, see the
   * discussion about <a href='#math-convert'>text string formulas</a> at
   * the top of the documentation for {@link ASTNode}.
   * <p>
   * @return an integer indicating the precedence of this {@link ASTNode}
   */
 public int getPrecedence() {
    return libsbmlJNI.ASTNode_getPrecedence(swigCPtr, this);
  }

  
  /**
   * Get the type of this {@link ASTNode}.  The value returned is one of the
   * enumeration values such as @link ASTNodeType_t#AST_LAMBDA
   * AST_LAMBDA@endlink, @link ASTNodeType_t#AST_PLUS AST_PLUS@endlink,
   * etc.
   * <p>
   * @return the type of this {@link ASTNode}.
   */
 public int getType() {
    return libsbmlJNI.ASTNode_getType(swigCPtr, this);
  }

  
  /**
   * Get the units of this {@link ASTNode}.  
   * <p>
   * This operation only applies to MathML <code>&lt;cn&gt;</code> elements.
   * <p>
   * @return the units of this {@link ASTNode}.
   */
 public String getUnits() {
    return libsbmlJNI.ASTNode_getUnits(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node has a boolean type
   * (a logical operator, a relational operator, or the constants <code>true</code>
   * or <code>false</code>).
   * <p>
   * @return true if this {@link ASTNode} is a boolean, false otherwise.
   */
 public boolean isBoolean() {
    return libsbmlJNI.ASTNode_isBoolean(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents a MathML
   * constant (e.g., <code>true</code>, <code>Pi</code>).
   * <p>
   * @return true if this {@link ASTNode} is a MathML constant, false otherwise.
   */
 public boolean isConstant() {
    return libsbmlJNI.ASTNode_isConstant(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents a
   * MathML function (e.g., <code>abs()</code>), or an SBML Level&nbsp;1
   * function, or a user-defined function.
   * <p>
   * @return true if this {@link ASTNode} is a function, false otherwise.
   */
 public boolean isFunction() {
    return libsbmlJNI.ASTNode_isFunction(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents
   * the special IEEE 754 value infinity, <code>false</code> (zero) otherwise.
   * <p>
   * @return true if this {@link ASTNode} is the special IEEE 754 value infinity,
   * false otherwise.
   */
 public boolean isInfinity() {
    return libsbmlJNI.ASTNode_isInfinity(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node contains an
   * integer value, <code>false</code> (zero) otherwise.
   * <p>
   * @return true if this {@link ASTNode} is of type @link
   * ASTNodeType_t#AST_INTEGER AST_INTEGER@endlink, false otherwise.
   */
 public boolean isInteger() {
    return libsbmlJNI.ASTNode_isInteger(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node is a MathML
   * <code>&lt;lambda&gt;</code>, <code>false</code> (zero) otherwise.
   * <p>
   * @return true if this {@link ASTNode} is of type @link ASTNodeType_t#AST_LAMBDA
   * AST_LAMBDA@endlink, false otherwise.
   */
 public boolean isLambda() {
    return libsbmlJNI.ASTNode_isLambda(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents a 
   * <code>log10</code>() function, <code>false</code> (zero) otherwise.  More precisely, this
   * predicate returns <code>true</code> if the node type is @link
   * ASTNodeType_t#AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink with two
   * children, the first of which is an @link ASTNodeType_t#AST_INTEGER
   * AST_INTEGER@endlink equal to 10.
   * <p>
   * @return true if the given {@link ASTNode} represents a log10() function, false
   * otherwise.
   */
 public boolean isLog10() {
    return libsbmlJNI.ASTNode_isLog10(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node is a MathML
   * logical operator (i.e., <code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>).
   * <p>
   * @return true if this {@link ASTNode} is a MathML logical operator
   */
 public boolean isLogical() {
    return libsbmlJNI.ASTNode_isLogical(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node is a user-defined
   * variable name in SBML L1, L2 (MathML), or the special symbols <code>delay</code>
   * or <code>time</code>.  The predicate returns <code>false</code> (zero) otherwise.
   * <p>
   * @return true if this {@link ASTNode} is a user-defined variable name in SBML
   * L1, L2 (MathML) or the special symbols delay or time.
   */
 public boolean isName() {
    return libsbmlJNI.ASTNode_isName(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents the
   * special IEEE 754 value 'not a number' (NaN), <code>false</code> (zero)
   * otherwise.
   * <p>
   * @return true if this {@link ASTNode} is the special IEEE 754 NaN
   */
 public boolean isNaN() {
    return libsbmlJNI.ASTNode_isNaN(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents the
   * special IEEE 754 value 'negative infinity', <code>false</code> (zero) otherwise.
   * <p>
   * @return true if this {@link ASTNode} is the special IEEE 754 value negative
   * infinity, false otherwise.
   */
 public boolean isNegInfinity() {
    return libsbmlJNI.ASTNode_isNegInfinity(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node contains a number,
   * <code>false</code> (zero) otherwise.  This is functionally equivalent to the
   * following code:
   * <div class='fragment'><pre>
   *   isInteger() || isReal()</pre></div>
   * <p>
   * @return true if this {@link ASTNode} is a number, false otherwise.
   */
 public boolean isNumber() {
    return libsbmlJNI.ASTNode_isNumber(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node is a mathematical
   * operator, meaning, <code>+</code>, <code>-</code>, <code>*</code>, 
   * <code>/</code> or <code>^</code> (power).
   * <p>
   * @return true if this {@link ASTNode} is an operator.
   */
 public boolean isOperator() {
    return libsbmlJNI.ASTNode_isOperator(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node is the MathML
   * <code>&lt;piecewise&gt;</code> construct, <code>false</code> (zero) otherwise.
   * <p>
   * @return true if this {@link ASTNode} is a MathML <code>piecewise</code> function
   */
 public boolean isPiecewise() {
    return libsbmlJNI.ASTNode_isPiecewise(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents a rational
   * number, <code>false</code> (zero) otherwise.
   * <p>
   * @return true if this {@link ASTNode} is of type @link
   * ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink.
   */
 public boolean isRational() {
    return libsbmlJNI.ASTNode_isRational(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node can represent a
   * real number, <code>false</code> (zero) otherwise.  More precisely, this node
   * must be of one of the following types: @link ASTNodeType_t#AST_REAL
   * AST_REAL@endlink, @link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink or
   * @link ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink.
   * <p>
   * @return true if the value of this {@link ASTNode} can represented as a real
   * number, <code>false</code> otherwise.
   */
 public boolean isReal() {
    return libsbmlJNI.ASTNode_isReal(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node is a MathML
   * relational operator, meaning <code>==</code>, <code>&gt;=</code>, 
   * <code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>.
   * <p>
   * @return true if this {@link ASTNode} is a MathML relational operator, false
   * otherwise
   */
 public boolean isRelational() {
    return libsbmlJNI.ASTNode_isRelational(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node represents a
   * square root function, <code>false</code> (zero) otherwise.  More precisely, the
   * node type must be @link ASTNodeType_t#AST_FUNCTION_ROOT
   * AST_FUNCTION_ROOT@endlink with two children, the first of which is an
   * @link ASTNodeType_t#AST_INTEGER AST_INTEGER@endlink node having value
   * equal to 2.
   * <p>
   * @return true if the given {@link ASTNode} represents a sqrt() function, false
   * otherwise.
   */
 public boolean isSqrt() {
    return libsbmlJNI.ASTNode_isSqrt(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node is a unary minus
   * operator, <code>false</code> (zero) otherwise.  A node is defined as a unary
   * minus node if it is of type @link ASTNodeType_t#AST_MINUS
   * AST_MINUS@endlink and has exactly one child.
   * <p>
   * For numbers, unary minus nodes can be 'collapsed' by negating the
   * number.  In fact, SBML_parseFormula() does this during its parse.
   * However, unary minus nodes for symbols (@link ASTNodeType_t#AST_NAME
   * AST_NAME@endlink) cannot be 'collapsed', so this predicate function
   * is necessary.
   * <p>
   * @return true if this {@link ASTNode} is a unary minus, false otherwise.
   */
 public boolean isUMinus() {
    return libsbmlJNI.ASTNode_isUMinus(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node has an unknown type.
   * <p>
   * 'Unknown' nodes have the type @link ASTNodeType_t#AST_UNKNOWN
   * AST_UNKNOWN@endlink.  Nodes with unknown types will not appear in an
   * {@link ASTNode} tree returned by libSBML based upon valid SBML input; the only
   * situation in which a node with type @link ASTNodeType_t#AST_UNKNOWN
   * AST_UNKNOWN@endlink may appear is immediately after having create a
   * new, untyped node using the {@link ASTNode} constructor.  Callers creating
   * nodes should endeavor to set the type to a valid node type as soon as
   * possible after creating new nodes.
   * <p>
   * @return true if this {@link ASTNode} is of type @link
   * ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink, false otherwise.
   */
 public boolean isUnknown() {
    return libsbmlJNI.ASTNode_isUnknown(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node has the attribute
   * <code>sbml:units</code>.
   * <p>
   * Only applies to MathML <code>&lt;cn&gt;</code> elements.
   * <p>
   * @return true if this {@link ASTNode} has units, false otherwise.
   */
 public boolean isSetUnits() {
    return libsbmlJNI.ASTNode_isSetUnits(swigCPtr, this);
  }

  
  /**
   * Predicate returning <code>true</code> (non-zero) if this node or any of its
   * children nodes have the attribute <code>sbml:units</code>.
   * <p>
   * @return true if this {@link ASTNode} or its children has units, 
   * false otherwise.
   */
 public boolean hasUnits() {
    return libsbmlJNI.ASTNode_hasUnits(swigCPtr, this);
  }

  
  /**
   * Sets the value of this {@link ASTNode} to the given character.  If character
   * is one of <code>+</code>, <code>-</code>, @c *, @c / or <code>^</code>, the node type will be set
   * accordingly.  For all other characters, the node type will be set to
   * @link ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink.
   * <p>
   * @param value the character value to which the node's value should be
   * set.
   * <p>
   * @return integer value indicating success/failure of the function.  The
   * possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   */
 public int setCharacter(char value) {
    return libsbmlJNI.ASTNode_setCharacter(swigCPtr, this, value);
  }

  
  /**
   * Sets the value of this {@link ASTNode} to the given name.
   * <p>
   * As a side-effect, this {@link ASTNode} object's type will be reset to
   * @link ASTNodeType_t#AST_NAME AST_NAME@endlink if (and <em>only
   * if</em>) the {@link ASTNode} was previously an operator (<code>isOperator() ==
   * true</code>), number (<code>isNumber() == true</code>), or unknown.
   * This allows names to be set for @link ASTNodeType_t#AST_FUNCTION
   * AST_FUNCTION@endlink nodes and the like.
   * <p>
   * @param name the string containing the name to which this node's value
   * should be set
   * <p>
   * @return integer value indicating success/failure of the function.  The
   * possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   */
 public int setName(String name) {
    return libsbmlJNI.ASTNode_setName(swigCPtr, this, name);
  }

  
  /**
   * Sets the value of this {@link ASTNode} to the given (<code>long</code>) integer and sets
   * the node type to @link ASTNodeType_t#AST_INTEGER AST_INTEGER@endlink.
   * <p>
   * @param value the integer to which this node's value should be set
   * <p>
   * @return integer value indicating success/failure of the function.  The
   * possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   */
 public int setValue(int value) {
    return libsbmlJNI.ASTNode_setValue__SWIG_0(swigCPtr, this, value);
  }

  
  /**
   * Sets the value of this {@link ASTNode} to the given rational in two parts: the
   * numerator and denominator.  The node type is set to @link
   * ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink.
   * <p>
   * @param numerator the numerator value of the rational
   * @param denominator the denominator value of the rational
   * <p>
   * @return integer value indicating success/failure of the function.  The
   * possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   */
 public int setValue(int numerator, int denominator) {
    return libsbmlJNI.ASTNode_setValue__SWIG_1(swigCPtr, this, numerator, denominator);
  }

  
  /**
   * Sets the value of this {@link ASTNode} to the given real (<code>double</code>) and sets
   * the node type to @link ASTNodeType_t#AST_REAL AST_REAL@endlink.
   * <p>
   * This is functionally equivalent to:
   * <div class='fragment'><pre>
   * setValue(value, 0);</pre></div>
   * <p>
   * @param value the <code>double</code> format number to which this node's value
   * should be set
   * <p>
   * @return integer value indicating success/failure of the function.  The
   * possible values returned by this function are: <li> {@link 
   * libsbmlConstants#LIBSBML_OPERATION_SUCCESS
   * LIBSBML_OPERATION_SUCCESS }
   */
 public int setValue(double value) {
    return libsbmlJNI.ASTNode_setValue__SWIG_2(swigCPtr, this, value);
  }

  
  /**
   * Sets the value of this {@link ASTNode} to the given real (<code>double</code>) in two
   * parts: the mantissa and the exponent.  The node type is set to
   * @link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink.
   * <p>
   * @param mantissa the mantissa of this node's real-numbered value
   * @param exponent the exponent of this node's real-numbered value
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   */
 public int setValue(double mantissa, int exponent) {
    return libsbmlJNI.ASTNode_setValue__SWIG_3(swigCPtr, this, mantissa, exponent);
  }

  
  /**
   * Sets the type of this {@link ASTNode} to the given <a class='el'
   * href='#ASTNodeType_t'>ASTNodeType_t</a>.  A side-effect of doing this
   * is that any numerical values previously stored in this node are reset
   * to zero.
   * <p>
   * @param type the type to which this node should be set
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE }
   */
 public int setType(int type) {
    return libsbmlJNI.ASTNode_setType(swigCPtr, this, type);
  }

  
  /**
   * Sets the units of this {@link ASTNode} to units.
   * <p>
   * The units will be set <em>only if</em> the {@link ASTNode} represents a MathML
   * <code>&lt;cn&gt;</code> element, i.e., represents a number.  Callers
   * may use isNumber() to inquire whether the node is of that type.
   * <p>
   * @param units <code>string</code> representing the unit identifier.
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE }
   * <li> {@link  libsbmlConstants#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE }
   */
 public int setUnits(String units) {
    return libsbmlJNI.ASTNode_setUnits(swigCPtr, this, units);
  }

  
  /**
   * Swap the children of this {@link ASTNode} object with the children of the
   * given {@link ASTNode} object.
   * <p>
   * @param that the other node whose children should be used to replace
   * <em>this</em> node's children
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED }
   */
 public int swapChildren(ASTNode that) {
    return libsbmlJNI.ASTNode_swapChildren(swigCPtr, this, ASTNode.getCPtr(that), that);
  }

  
  /**
   * Unsets the units of this {@link ASTNode}.
   * <p>
   * @return integer value indicating success/failure of the
   * function.  The possible values returned by this function are:
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS }
   * <li> {@link  libsbmlConstants#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE }
   * <li> {@link  libsbmlConstants#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED }
   */
 public int unsetUnits() {
    return libsbmlJNI.ASTNode_unsetUnits(swigCPtr, this);
  }

  
  /**
   * Gets the MathML <code>definitionURL</code> attribute value.
   */
 public XMLAttributes getDefinitionURL() {
    long cPtr = libsbmlJNI.ASTNode_getDefinitionURL(swigCPtr, this);
    return (cPtr == 0) ? null : new XMLAttributes(cPtr, false);
  }

  
  /**
   * Replaces occurences of a given name within this {@link ASTNode} with the
   * name/value/formula represented by <code>arg</code>.
   * <p>
   * For example, if the formula in this {@link ASTNode} is <code>x + y</code>,
   * then the <code>&lt;bvar&gt;</code> is <code>x</code> and <code>arg</code> is an {@link ASTNode}
   * representing the real value <code>3</code>.  This method substitutes <code>3</code> for 
   * <code>x</code> within this {@link ASTNode} object.
   * <p>
   * @param bvar a string representing the variable name to be substituted
   * @param arg an {@link ASTNode} representing the name/value/formula to substitute
   */
 public void replaceArgument(String bvar, ASTNode arg) {
    libsbmlJNI.ASTNode_replaceArgument(swigCPtr, this, bvar, ASTNode.getCPtr(arg), arg);
  }

  
  /**
   * Returns the parent SBML object.
   * <p>
   * @return the parent SBML object of this {@link ASTNode}.
   */
 public SBase getParentSBMLObject() {
  return libsbml.DowncastSBase(libsbmlJNI.ASTNode_getParentSBMLObject(swigCPtr, this), false);
}

  
  /**
   * Reduces this {@link ASTNode} to a binary tree.
   * <p>
   * Example: if this {@link ASTNode} is <code>and(x, y, z)</code>, then the 
   * formula of the reduced node is <code>and(and(x, y), z)</code>.  The
   * operation replaces the formula stored in the current {@link ASTNode} object.
   */
 public void reduceToBinary() {
    libsbmlJNI.ASTNode_reduceToBinary(swigCPtr, this);
  }

  
 /**
  * Predicate returning <code>true</code> or <code>false</code> depending on whether this
  * {@link ASTNode} is well-formed.
  * <p>
  * @note An {@link ASTNode} may be well-formed, with each node and its children
  * having the appropriate number of children for the given type, but may
  * still be invalid in the context of its use within an SBML model.
  * <p>
  * @see #hasCorrectNumberArguments()
  * <p>
  * @return <code>true</code> if this {@link ASTNode} is well-formed, <code>false</code> otherwise.
  */
 public boolean isWellFormedASTNode() {
    return libsbmlJNI.ASTNode_isWellFormedASTNode(swigCPtr, this);
  }

  
 /**
  * Predicate returning <code>true</code> or <code>false</code> depending on whether this
  * {@link ASTNode} has the correct number of children for it's type.
  * <p>
  * For example, an {@link ASTNode} with type @link ASTNodeType_t#AST_PLUS
  * AST_PLUS@endlink expects 2 child nodes.
  * <p>
  * @note This function performs a check on the toplevel node only.
  * Child nodes are not checked.
  * <p>
  * @see #isWellFormedASTNode()
  * <p>
  * @return <code>true</code> if this {@link ASTNode} is has appropriate number of children
  * for it's type, <code>false</code> otherwise.
  */
 public boolean hasCorrectNumberArguments() {
    return libsbmlJNI.ASTNode_hasCorrectNumberArguments(swigCPtr, this);
  }

  public ASTNodeList getListOfNodes() {
    long cPtr = libsbmlJNI.ASTNode_getListOfNodes(swigCPtr, this);
    return (cPtr == 0) ? null : new ASTNodeList(cPtr, true);
  }

}

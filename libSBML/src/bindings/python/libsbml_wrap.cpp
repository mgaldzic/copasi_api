/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.40
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Python.h has to appear first */
#include <Python.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

/* Add PyObject_Del for old Pythons */
#if PY_VERSION_HEX < 0x01060000
# define PyObject_Del(op) PyMem_DEL((op))
#endif
#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *self, PyObject *func)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyInstanceMethod_New(func);
#else
  return NULL;
#endif
}

#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif


/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(ptr, type, flags)
#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule()
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, (char *) msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, (char*) name, obj);
  Py_DECREF(obj);                            
}

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN int
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    register Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      register int i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData* data)
{
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
} SwigPyObject;

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", name, v);
  if (v->next) {
#ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
#else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
#endif
#if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
#else
    PyString_ConcatAndDel(&repr,nrep);
#endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_print(SwigPyObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char *str;
#ifdef METH_NOARGS
  PyObject *repr = SwigPyObject_repr(v);
#else
  PyObject *repr = SwigPyObject_repr(v, NULL);
#endif
  if (repr) {
    str = SWIG_Python_str_AsChar(repr); 
    fputs(str, fp);
    SWIG_Python_str_DelForPy3(str);
    Py_DECREF(repr);
    return 0; 
  } else {
    return 1; 
  }
}

SWIGRUNTIME PyObject *
SwigPyObject_str(SwigPyObject *v)
{
  char result[SWIG_BUFFER_SIZE];
  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
    SWIG_Python_str_FromChar(result) : 0;
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) )
    res = Py_True;
  else
    res = Py_False;
  Py_INCREF(res);
  return res;  
}


SWIGRUNTIME PyTypeObject* _PySwigObject_type(void);

SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigObject_type();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;
      if (data->delargs) {
	/* we need to create a temporary object to carry the destroy operation */
	PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
	res = SWIG_Python_CallFunctor(destroy, tmp);
	Py_DECREF(tmp);
      } else {
	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
	PyObject *mself = PyCFunction_GET_SELF(destroy);
	res = ((*meth)(mself, v));
      }
      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#else
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"aquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
_PySwigObject_type(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
  
  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;  
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp
      = {
	/* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
	PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else    
	PyObject_HEAD_INIT(NULL)
	0,				    /* ob_size */
#endif
	(char *)"SwigPyObject",		    /* tp_name */
	sizeof(SwigPyObject),		    /* tp_basicsize */
	0,			            /* tp_itemsize */
	(destructor)SwigPyObject_dealloc,   /* tp_dealloc */
	(printfunc)SwigPyObject_print,	    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
	(getattrfunc)SwigPyObject_getattr,  /* tp_getattr */ 
#else
	(getattrfunc)0,			    /* tp_getattr */ 
#endif
	(setattrfunc)0,			    /* tp_setattr */ 
#if PY_VERSION_HEX >= 0x03000000
    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
	(cmpfunc)SwigPyObject_compare,	    /* tp_compare */
#endif
	(reprfunc)SwigPyObject_repr,	    /* tp_repr */    
	&SwigPyObject_as_number,	    /* tp_as_number */
	0,				    /* tp_as_sequence */
	0,				    /* tp_as_mapping */
	(hashfunc)0,			    /* tp_hash */
	(ternaryfunc)0,			    /* tp_call */
	(reprfunc)SwigPyObject_str,	    /* tp_str */
	PyObject_GenericGetAttr,            /* tp_getattro */
	0,				    /* tp_setattro */
	0,		                    /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
	swigobject_doc, 	            /* tp_doc */        
	0,                                  /* tp_traverse */
	0,                                  /* tp_clear */
	(richcmpfunc)SwigPyObject_richcompare,           /* tp_richcompare */
	0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
	0,                                  /* tp_iter */
	0,                                  /* tp_iternext */
	swigobject_methods,		    /* tp_methods */ 
	0,			            /* tp_members */
	0,				    /* tp_getset */	    	
	0,			            /* tp_base */	        
	0,				    /* tp_dict */	    	
	0,				    /* tp_descr_get */  	
	0,				    /* tp_descr_set */  	
	0,				    /* tp_dictoffset */ 	
	0,				    /* tp_init */	    	
	0,				    /* tp_alloc */	    	
	0,			            /* tp_new */	    	
	0,	                            /* tp_free */	   
	0,                                  /* tp_is_gc */  
	0,				    /* tp_bases */   
	0,				    /* tp_mro */
	0,				    /* tp_cache */   
	0,				    /* tp_subclasses */
	0,				    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
	0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
	0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
    swigpyobject_type = tmp;
    /* for Python 3 we already assigned ob_type in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
    swigpyobject_type.ob_type = &PyType_Type;
#endif
    type_init = 1;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* _PySwigPacked_type(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigPacked_type();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == _PySwigPacked_type()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
_PySwigPacked_type(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;  
  if (!type_init) {
    const PyTypeObject tmp
      = {
    /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX>=0x03000000
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
	PyObject_HEAD_INIT(NULL)
    0,				    /* ob_size */	
#endif
	(char *)"SwigPyPacked",		    /* tp_name */	
	sizeof(SwigPyPacked),		    /* tp_basicsize */	
	0,				    /* tp_itemsize */	
	(destructor)SwigPyPacked_dealloc,   /* tp_dealloc */	
	(printfunc)SwigPyPacked_print,	    /* tp_print */   	
	(getattrfunc)0,			    /* tp_getattr */ 	
	(setattrfunc)0,			    /* tp_setattr */ 	
#if PY_VERSION_HEX>=0x03000000
    0, /* tp_reserved in 3.0.1 */
#else
    (cmpfunc)SwigPyPacked_compare,	    /* tp_compare */
#endif
	(reprfunc)SwigPyPacked_repr,	    /* tp_repr */
	0,	                            /* tp_as_number */
	0,				    /* tp_as_sequence */
	0,				    /* tp_as_mapping */
	(hashfunc)0,			    /* tp_hash */
	(ternaryfunc)0,			    /* tp_call */
	(reprfunc)SwigPyPacked_str,	    /* tp_str */
	PyObject_GenericGetAttr,            /* tp_getattro */
	0,				    /* tp_setattro */
	0,		                    /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
	swigpacked_doc, 	            /* tp_doc */
	0,                                  /* tp_traverse */
	0,                                  /* tp_clear */
	0,                                  /* tp_richcompare */
	0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
	0,                                  /* tp_iter */
	0,                                  /* tp_iternext */
	0,		                    /* tp_methods */ 
	0,			            /* tp_members */
	0,				    /* tp_getset */	    	
	0,			            /* tp_base */	        
	0,				    /* tp_dict */	    	
	0,				    /* tp_descr_get */  	
	0,				    /* tp_descr_set */  	
	0,				    /* tp_dictoffset */ 	
	0,				    /* tp_init */	    	
	0,				    /* tp_alloc */	    	
	0,			            /* tp_new */	    	
	0, 	                            /* tp_free */	   
        0,                                  /* tp_is_gc */  
	0,				    /* tp_bases */   
	0,				    /* tp_mro */
	0,				    /* tp_cache */   
 	0,				    /* tp_subclasses */
	0,				    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
	0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
	0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
    swigpypacked_type = tmp;
    /* for Python 3 the ob_type already assigned in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
    swigpypacked_type.ob_type = &PyType_Type;
#endif
    type_init = 1;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  static PyObject *SWIG_STATIC_POINTER(swig_this) = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  if (SwigPyObject_Check(pyobj)) {
    return (SwigPyObject *) pyobj;
  } else {
    PyObject *obj = 0;
#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
    if (PyInstance_Check(pyobj)) {
      obj = _PyInstance_Lookup(pyobj, SWIG_This());      
    } else {
      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
      } else {
#ifdef PyWeakref_CheckProxy
	if (PyWeakref_CheckProxy(pyobj)) {
	  PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	  return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
	}
#endif
	obj = PyObject_GetAttr(pyobj,SWIG_This());
	if (obj) {
	  Py_DECREF(obj);
	} else {
	  if (PyErr_Occurred()) PyErr_Clear();
	  return 0;
	}
      }
    }
#else
    obj = PyObject_GetAttr(pyobj,SWIG_This());
    if (obj) {
      Py_DECREF(obj);
    } else {
      if (PyErr_Occurred()) PyErr_Clear();
      return 0;
    }
#endif
    if (obj && !SwigPyObject_Check(obj)) {
      /* a PyObject is called 'this', try to get the 'real this'
	 SwigPyObject from it */ 
      return SWIG_Python_GetSwigThis(obj);
    }
    return (SwigPyObject *)obj;
  }
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  if (!obj) return SWIG_ERROR;
  if (obj == Py_None) {
    if (ptr) *ptr = 0;
    return SWIG_OK;
  } else {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (own)
      *own = 0;
    while (sobj) {
      void *vptr = sobj->ptr;
      if (ty) {
	swig_type_info *to = sobj->ty;
	if (to == ty) {
	  /* no type cast needed */
	  if (ptr) *ptr = vptr;
	  break;
	} else {
	  swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
	  if (!tc) {
	    sobj = (SwigPyObject *)sobj->next;
	  } else {
	    if (ptr) {
              int newmemory = 0;
              *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
              if (newmemory == SWIG_CAST_NEW_MEMORY) {
                assert(own);
                if (own)
                  *own = *own | SWIG_CAST_NEW_MEMORY;
              }
            }
	    break;
	  }
	}
      } else {
	if (ptr) *ptr = vptr;
	break;
      }
    }
    if (sobj) {
      if (own)
        *own = *own | sobj->own;
      if (flags & SWIG_POINTER_DISOWN) {
	sobj->own = 0;
      }
      return SWIG_OK;
    } else {
      int res = SWIG_ERROR;
      if (flags & SWIG_POINTER_IMPLICIT_CONV) {
	SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
	if (data && !data->implicitconv) {
	  PyObject *klass = data->klass;
	  if (klass) {
	    PyObject *impconv;
	    data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
	    impconv = SWIG_Python_CallFunctor(klass, obj);
	    data->implicitconv = 0;
	    if (PyErr_Occurred()) {
	      PyErr_Clear();
	      impconv = 0;
	    }
	    if (impconv) {
	      SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
	      if (iobj) {
		void *vptr;
		res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
		if (SWIG_IsOK(res)) {
		  if (ptr) {
		    *ptr = vptr;
		    /* transfer the ownership to 'ptr' */
		    iobj->own = 0;
		    res = SWIG_AddCast(res);
		    res = SWIG_AddNewMask(res);
		  } else {
		    res = SWIG_AddCast(res);		    
		  }
		}
	      }
	      Py_DECREF(impconv);
	    }
	  }
	}
      }
      return res;
    }
  }
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = PyBaseObject_Type.tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    PyObject_SetAttr(inst, SWIG_This(), swig_this);
    Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
#else
    PyObject *dict = PyDict_New();
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst;
  PyObject *dict = PyDict_New();
  PyDict_SetItem(dict, SWIG_This(), swig_this);
  inst = PyInstance_NewRaw(data->newargs, dict);
  Py_DECREF(dict);
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args,(char*)"swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  if (!ptr) {
    return SWIG_Py_Void();
  } else {
    int own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
    PyObject *robj = SwigPyObject_New(ptr, type, own);
    SwigPyClientData *clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
    if (clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
      if (inst) {
	Py_DECREF(robj);
	robj = inst;
      }
    }
    return robj;
  }
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError,
		    "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError,
		    "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
SWIG_Python_DestroyModule(void *vptr)
{
  swig_module_info *swig_module = (swig_module_info *) vptr;
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */

#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				   swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
  } else {
    swig_module_info *swig_module = SWIG_Python_GetModule();
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : (char*)"";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}


#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_ASTNode swig_types[0]
#define SWIGTYPE_p_ASTNodeType_t swig_types[1]
#define SWIGTYPE_p_AlgebraicRule swig_types[2]
#define SWIGTYPE_p_AssignmentRule swig_types[3]
#define SWIGTYPE_p_BiolQualifierType_t swig_types[4]
#define SWIGTYPE_p_CVTerm swig_types[5]
#define SWIGTYPE_p_Compartment swig_types[6]
#define SWIGTYPE_p_CompartmentType swig_types[7]
#define SWIGTYPE_p_Constraint swig_types[8]
#define SWIGTYPE_p_Date swig_types[9]
#define SWIGTYPE_p_Delay swig_types[10]
#define SWIGTYPE_p_Event swig_types[11]
#define SWIGTYPE_p_EventAssignment swig_types[12]
#define SWIGTYPE_p_FunctionDefinition swig_types[13]
#define SWIGTYPE_p_InitialAssignment swig_types[14]
#define SWIGTYPE_p_KineticLaw swig_types[15]
#define SWIGTYPE_p_List swig_types[16]
#define SWIGTYPE_p_ListOf swig_types[17]
#define SWIGTYPE_p_ListOfCompartmentTypes swig_types[18]
#define SWIGTYPE_p_ListOfCompartments swig_types[19]
#define SWIGTYPE_p_ListOfConstraints swig_types[20]
#define SWIGTYPE_p_ListOfEventAssignments swig_types[21]
#define SWIGTYPE_p_ListOfEvents swig_types[22]
#define SWIGTYPE_p_ListOfFunctionDefinitions swig_types[23]
#define SWIGTYPE_p_ListOfInitialAssignments swig_types[24]
#define SWIGTYPE_p_ListOfLocalParameters swig_types[25]
#define SWIGTYPE_p_ListOfParameters swig_types[26]
#define SWIGTYPE_p_ListOfReactions swig_types[27]
#define SWIGTYPE_p_ListOfRules swig_types[28]
#define SWIGTYPE_p_ListOfSpecies swig_types[29]
#define SWIGTYPE_p_ListOfSpeciesReferences swig_types[30]
#define SWIGTYPE_p_ListOfSpeciesTypes swig_types[31]
#define SWIGTYPE_p_ListOfUnitDefinitions swig_types[32]
#define SWIGTYPE_p_ListOfUnits swig_types[33]
#define SWIGTYPE_p_ListWrapperT_ASTNode_t swig_types[34]
#define SWIGTYPE_p_ListWrapperT_CVTerm_t swig_types[35]
#define SWIGTYPE_p_ListWrapperT_Date_t swig_types[36]
#define SWIGTYPE_p_ListWrapperT_ModelCreator_t swig_types[37]
#define SWIGTYPE_p_LocalParameter swig_types[38]
#define SWIGTYPE_p_Model swig_types[39]
#define SWIGTYPE_p_ModelCreator swig_types[40]
#define SWIGTYPE_p_ModelHistory swig_types[41]
#define SWIGTYPE_p_ModelQualifierType_t swig_types[42]
#define SWIGTYPE_p_ModifierSpeciesReference swig_types[43]
#define SWIGTYPE_p_OperationReturnValues_t swig_types[44]
#define SWIGTYPE_p_Parameter swig_types[45]
#define SWIGTYPE_p_ParentMap__iterator swig_types[46]
#define SWIGTYPE_p_QualifierType_t swig_types[47]
#define SWIGTYPE_p_RDFAnnotationParser swig_types[48]
#define SWIGTYPE_p_RateRule swig_types[49]
#define SWIGTYPE_p_Reaction swig_types[50]
#define SWIGTYPE_p_Rule swig_types[51]
#define SWIGTYPE_p_RuleType_t swig_types[52]
#define SWIGTYPE_p_SBMLConstructorException swig_types[53]
#define SWIGTYPE_p_SBMLDocument swig_types[54]
#define SWIGTYPE_p_SBMLError swig_types[55]
#define SWIGTYPE_p_SBMLErrorCategory_t swig_types[56]
#define SWIGTYPE_p_SBMLErrorCode_t swig_types[57]
#define SWIGTYPE_p_SBMLErrorLog swig_types[58]
#define SWIGTYPE_p_SBMLErrorSeverity_t swig_types[59]
#define SWIGTYPE_p_SBMLNamespaces swig_types[60]
#define SWIGTYPE_p_SBMLReader swig_types[61]
#define SWIGTYPE_p_SBMLTransforms swig_types[62]
#define SWIGTYPE_p_SBMLTypeCode_t swig_types[63]
#define SWIGTYPE_p_SBMLWriter swig_types[64]
#define SWIGTYPE_p_SBO swig_types[65]
#define SWIGTYPE_p_SBase swig_types[66]
#define SWIGTYPE_p_SimpleSpeciesReference swig_types[67]
#define SWIGTYPE_p_Species swig_types[68]
#define SWIGTYPE_p_SpeciesReference swig_types[69]
#define SWIGTYPE_p_SpeciesType swig_types[70]
#define SWIGTYPE_p_StoichiometryMath swig_types[71]
#define SWIGTYPE_p_SyntaxChecker swig_types[72]
#define SWIGTYPE_p_Trigger swig_types[73]
#define SWIGTYPE_p_Unit swig_types[74]
#define SWIGTYPE_p_UnitDefinition swig_types[75]
#define SWIGTYPE_p_UnitKind_t swig_types[76]
#define SWIGTYPE_p_XMLAttributes swig_types[77]
#define SWIGTYPE_p_XMLError swig_types[78]
#define SWIGTYPE_p_XMLErrorCategory_t swig_types[79]
#define SWIGTYPE_p_XMLErrorCode_t swig_types[80]
#define SWIGTYPE_p_XMLErrorLog swig_types[81]
#define SWIGTYPE_p_XMLErrorSeverity_t swig_types[82]
#define SWIGTYPE_p_XMLInputStream swig_types[83]
#define SWIGTYPE_p_XMLNamespaces swig_types[84]
#define SWIGTYPE_p_XMLNode swig_types[85]
#define SWIGTYPE_p_XMLOutputFileStream swig_types[86]
#define SWIGTYPE_p_XMLOutputStream swig_types[87]
#define SWIGTYPE_p_XMLOutputStringStream swig_types[88]
#define SWIGTYPE_p_XMLToken swig_types[89]
#define SWIGTYPE_p_XMLTriple swig_types[90]
#define SWIGTYPE_p__CharT swig_types[91]
#define SWIGTYPE_p_allocator_type swig_types[92]
#define SWIGTYPE_p_char swig_types[93]
#define SWIGTYPE_p_char_type swig_types[94]
#define SWIGTYPE_p_const_reference swig_types[95]
#define SWIGTYPE_p_difference_type swig_types[96]
#define SWIGTYPE_p_int_type swig_types[97]
#define SWIGTYPE_p_off_type swig_types[98]
#define SWIGTYPE_p_p_PyObject swig_types[99]
#define SWIGTYPE_p_pos_type swig_types[100]
#define SWIGTYPE_p_reference swig_types[101]
#define SWIGTYPE_p_size_type swig_types[102]
#define SWIGTYPE_p_state_type swig_types[103]
#define SWIGTYPE_p_std__basic_iosT_char_std__char_traitsT_char_t_t swig_types[104]
#define SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t swig_types[105]
#define SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t swig_types[106]
#define SWIGTYPE_p_std__basic_streambufT_char_std__char_traitsT_char_t_t swig_types[107]
#define SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t swig_types[108]
#define SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator swig_types[109]
#define SWIGTYPE_p_std__invalid_argument swig_types[110]
#define SWIGTYPE_p_std__ios_base__openmode swig_types[111]
#define SWIGTYPE_p_std__multimapT_int_int_t swig_types[112]
#define SWIGTYPE_p_std__pairT_ParentMap__iterator_ParentMap__iterator_t swig_types[113]
#define SWIGTYPE_p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t swig_types[114]
#define SWIGTYPE_p_swig__SwigPyIterator swig_types[115]
#define SWIGTYPE_p_value_type swig_types[116]
static swig_type_info *swig_types[118];
static swig_module_info swig_module = {swig_types, 117, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif

/*-----------------------------------------------
              @(target):= _libsbml.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__libsbml

#else
#  define SWIG_init    init_libsbml

#endif
#define SWIG_name    "_libsbml"

#define SWIGVERSION 0x010340 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      Py_XINCREF(_obj);      
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        Py_XINCREF(_obj);
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      Py_XDECREF(_obj);
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include "libsbml.h"

LIBSBML_CPP_NAMESPACE_USE

#ifdef USE_LAYOUT
#include "../swig/layout.h"
#endif /* USE_LAYOUT */
#include "local.cpp"


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
  } else if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


  #define SWIG_From_long   PyInt_FromLong 


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value)); 
}


SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


#include <iostream>


#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>
#include <stdexcept>

  
namespace swig {
  struct stop_iteration {
  };

  struct SwigPyIterator {
  private:
    SwigPtr_PyObject _seq;

  protected:
    SwigPyIterator(PyObject *seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~SwigPyIterator() {}

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
    {
      throw stop_iteration();
    }

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next()     
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      PyObject *obj = value();
      incr();       
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
      return obj;     
    }

    /* Make an alias for Python 3.x */
    PyObject *__next__()
    {
      return next();
    }

    PyObject *previous()
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      decr();
      PyObject *obj = value();
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
      return obj;
    }

    SwigPyIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const SwigPyIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const SwigPyIterator& x) const
    {
      return ! operator==(x);
    }
      
    SwigPyIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    SwigPyIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    SwigPyIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    SwigPyIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const SwigPyIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
	init = 1;
      }	
      return desc;
    }    
  };
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}


SWIGINTERNINLINE PyObject *
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
  return SWIG_From_long  (static_cast< long >(value));
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  return res;
}


#include <stdexcept>


#include <algorithm>


#include <string>


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
  if (PyUnicode_Check(obj))
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    PyBytes_AsStringAndSize(obj, &cstr, &len);
    if(alloc) *alloc = SWIG_NEWOBJ;
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	  {
	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
	    *alloc = SWIG_NEWOBJ;
	  }
	else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
        #if PY_VERSION_HEX>=0x03000000
        assert(0); /* Should never reach here in Python 3 */
        #endif
	*cptr = SWIG_Python_str_AsChar(obj);
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000
    Py_XDECREF(obj);
#endif
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsCharArray(PyObject * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (PyObject * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
      return PyUnicode_FromStringAndSize(carray, static_cast< int >(size));
#else
      return PyString_FromStringAndSize(carray, static_cast< int >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject *
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}


namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static PyObject *from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static PyObject *from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static PyObject *from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static PyObject *from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline PyObject *from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline PyObject *from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(PyObject *obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(PyObject *obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(PyObject *obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(PyObject *obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(PyObject *obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	static Type *v_def = (Type*) malloc(sizeof(Type));
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(PyObject *obj, bool te = false) {
    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(PyObject *obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


namespace swig {
  template <> struct traits<char > {
    typedef value_category category;
    static const char* type_name() { return"char"; }
  };  
  template <>  struct traits_asval<char > {   
    typedef char value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_char (obj, val);
    }
  };
  template <>  struct traits_from<char > {
    typedef char value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_char  (val);
    }
  };
}





SWIGINTERN int
SWIG_AsPtr_std_basic_string_Sl_char_Sg_ (PyObject* obj, std::string **val)
{
  static swig_type_info* string_info = 
    SWIG_TypeQuery("std::basic_string<char> *");
  std::string *vptr;    
  if (SWIG_ConvertPtr(obj, (void**)&vptr, string_info, 0) == SWIG_OK) {
    if (val) *val = vptr;
    return SWIG_OLDOBJ;
  } else {
    PyErr_Clear();
    char* buf = 0 ; size_t size = 0; int alloc = 0;
    if (SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc) == SWIG_OK) {
      if (buf) {
	if (val) *val = new std::string(buf, size - 1);
	if (alloc == SWIG_NEWOBJ) delete[] buf;
	return SWIG_NEWOBJ;
      }
    } else {
      PyErr_Clear();
    }  
    if (val) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      PyErr_SetString(PyExc_TypeError,"a string is expected");
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    return 0;
  }
}  


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERNINLINE PyObject*
  SWIG_From_std_basic_string_Sl_char_Sg_  (const std::string& s)
  {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  }


#include <functional>

namespace std {
  template <>
  struct less <PyObject *>: public binary_function<PyObject *, PyObject *, bool>
  {
    bool
    operator()(PyObject * v, PyObject *w) const
    { 
      bool res;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      res = PyObject_RichCompareBool(v, w, Py_LT) ? true : false;
      /* This may fall into a case of inconsistent
               eg. ObjA > ObjX > ObjB
               but ObjA < ObjB
      */
      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
      {
        /* Objects can't be compared, this mostly occurred in Python 3.0 */
        /* Compare their ptr directly for a workaround */
        res = (v < w);
        PyErr_Clear();
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return res;
    }
  };

  template <>
  struct less <swig::SwigPtr_PyObject>: public binary_function<swig::SwigPtr_PyObject, swig::SwigPtr_PyObject, bool>
  {
    bool
    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

  template <>
  struct less <swig::SwigVar_PyObject>: public binary_function<swig::SwigVar_PyObject, swig::SwigVar_PyObject, bool>
  {
    bool
    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

}

namespace swig {
  template <> struct traits<PyObject *> {
    typedef value_category category;
    static const char* type_name() { return "PyObject *"; }
  };  

  template <>  struct traits_asval<PyObject * > {   
    typedef PyObject * value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };

  template <> 
  struct traits_check<PyObject *, value_category> {
    static bool check(PyObject *) {
      return true;
    }
  };

  template <>  struct traits_from<PyObject *> {
    typedef PyObject * value_type;
    static PyObject *from(const value_type& val) {
      Py_XINCREF(val);
      return val;
    }
  };
  
}

namespace swig {
  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {
  template<typename OutIterator>
  class SwigPyIterator_T :  public SwigPyIterator
  {
  public:
    typedef OutIterator out_iterator;
    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
    typedef SwigPyIterator_T<out_iterator> self_type;

    SwigPyIterator_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator(seq), current(curr)
    {
    }

    const out_iterator& get_current() const
    {
      return current;
    }

    
    bool equal (const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    ptrdiff_t distance(const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }    
    
  protected:
    out_iterator current;
  };
  
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef PyObject *result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq)
    {
    }
    
    PyObject *value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	++base::current;
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	--base::current;
      }
      return this;
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;    
    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    PyObject *value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  ++base::current;
	}
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	if (base::current == begin) {
	  throw stop_iteration();
	} else {
	  --base::current;
	}
      }
      return this;
    }

  private:
    out_iterator begin;
    out_iterator end;
  };

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
  {
    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, PyObject *seq = 0)
  {
    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
  }
}


namespace swig
{
  template <class T>
  struct SwigPySequence_Ref
  {
    SwigPySequence_Ref(PyObject* seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	SWIG_Python_AddErrorMsg(msg);
	SWIG_Python_AddErrorMsg(e.what());
	throw;
      }
    }

    SwigPySequence_Ref& operator=(const T& v)
    {
      PySequence_SetItem(_seq, _index, swig::from<T>(v));
      return *this;
    }

  private:
    PyObject* _seq;
    int _index;
  };

  template <class T>
  struct SwigPySequence_ArrowProxy
  {
    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };

  template <class T, class Reference >
  struct SwigPySequence_InputIterator
  {
    typedef SwigPySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;

    SwigPySequence_InputIterator()
    {
    }

    SwigPySequence_InputIterator(PyObject* seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    SwigPySequence_ArrowProxy<T>
    operator->() const {
      return SwigPySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    PyObject* _seq;
    difference_type _index;
  };

  template <class T>
  struct SwigPySequence_Cont
  {
    typedef SwigPySequence_Ref<T> reference;
    typedef const SwigPySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef SwigPySequence_InputIterator<T, reference> iterator;
    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;

    SwigPySequence_Cont(PyObject* seq) : _seq(0)
    {
      if (!PySequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
    }

    ~SwigPySequence_Cont()
    {
      Py_XDECREF(_seq);
    }

    size_type size() const
    {
      return static_cast<size_type>(PySequence_Size(_seq));
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = true) const
    {
      int s = size();
      for (int i = 0; i < s; ++i) {
	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    PyObject* _seq;
  };

}

SWIGINTERN swig::SwigPyIterator *std_basic_string_Sl_char_Sg__iterator(std::basic_string< char > *self,PyObject **PYTHON_SELF){
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }
SWIGINTERN bool std_basic_string_Sl_char_Sg____nonzero__(std::basic_string< char > const *self){
      return !(self->empty());
    }
SWIGINTERN bool std_basic_string_Sl_char_Sg____bool__(std::basic_string< char > const *self){
      return !(self->empty());
    }
SWIGINTERN std::basic_string< char >::size_type std_basic_string_Sl_char_Sg____len__(std::basic_string< char > const *self){
      return self->size();
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____getslice__(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j){
      return swig::getslice(self, i, j);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____setslice__(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &v){
      swig::setslice(self, i, j, v);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____delslice__(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j){
      swig::delslice(self, i, j);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____delitem____SWIG_0(std::basic_string< char > *self,std::basic_string< char >::difference_type i){
      self->erase(swig::getpos(self,i));
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____getitem____SWIG_0(std::basic_string< char > *self,PySliceObject *slice){
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return NULL;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      return swig::getslice(self, i, j);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____setitem____SWIG_0(std::basic_string< char > *self,PySliceObject *slice,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &v){
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::setslice(self, i, j, v);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____delitem____SWIG_1(std::basic_string< char > *self,PySliceObject *slice){
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::delslice(self, i,j);
    }
SWIGINTERN std::basic_string< char >::value_type std_basic_string_Sl_char_Sg____getitem____SWIG_1(std::basic_string< char > *self,std::basic_string< char >::difference_type i){
      return *(swig::cgetpos(self, i));
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____setitem____SWIG_1(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::value_type x){
      *(swig::getpos(self,i)) = x;
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____add__(std::basic_string< char > *self,std::basic_string< char > const &v){
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >* res = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >(*self);
	*res += v;      
	return res;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____radd__(std::basic_string< char > *self,std::basic_string< char > const &v){
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >* res = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >(v);
	*res += *self;      
	return res;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > std_basic_string_Sl_char_Sg____str__(std::basic_string< char > *self){
	return *self;
      }
SWIGINTERN std::basic_ostream< char,std::char_traits< char > > &std_basic_string_Sl_char_Sg____rlshift__(std::basic_string< char > *self,std::basic_ostream< char,std::char_traits< char > > &out){
	out << *self;
	return out;
      }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Se__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self == v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_SN__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self != v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sg_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self > v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sl_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self < v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sg__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self >= v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sl__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self <= v;
  }

  int ASTNode_true(const ASTNode *node)
  {
    return 1;
  }


SWIGINTERNINLINE PyObject *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}

SWIGINTERN int ListOf___len__(ListOf *self){
    return self->size();
  }

  #define SWIG_From_double   PyFloat_FromDouble 

SWIGINTERN ListWrapper< ASTNode > *ASTNode_getListOfNodes(ASTNode *self){
    List *list = self->getListOfNodes(ASTNode_true);
    return new ListWrapper<ASTNode>(list);
  }
SWIGINTERN void XMLOutputStream_writeAttributeBool__SWIG_0(XMLOutputStream *self,std::string const &name,bool const &value){
    self->writeAttribute(name, value);
  }
SWIGINTERN void XMLOutputStream_writeAttributeBool__SWIG_1(XMLOutputStream *self,XMLTriple const &name,bool const &value){
    self->writeAttribute(name, value);
  }
SWIGINTERN void RDFAnnotationParser_parseRDFAnnotation__SWIG_1(XMLNode const *annotation,ListWrapper< CVTerm > *CVTerms){
    if (!CVTerms) return;

    List *list = CVTerms->getList();
    RDFAnnotationParser::parseRDFAnnotation(annotation,list);
  }
#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_new_ModelCreatorList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ModelCreatorList")) SWIG_fail;
  result = (ListWrapper< ModelCreator > *)new ListWrapper< ModelCreator >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_ModelCreator_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModelCreatorList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModelCreatorList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModelCreatorList" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_add" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreatorList_add" "', argument " "2"" of type '" "ModelCreator *""'"); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_get" "', argument " "1"" of type '" "ListWrapper< ModelCreator > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelCreatorList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)((ListWrapper< ModelCreator > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_prepend" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreatorList_prepend" "', argument " "2"" of type '" "ModelCreator *""'"); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_remove" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelCreatorList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreatorList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_getSize" "', argument " "1"" of type '" "ListWrapper< ModelCreator > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  result = (unsigned int)((ListWrapper< ModelCreator > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModelCreatorList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_ModelCreator_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_DateList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_DateList")) SWIG_fail;
  result = (ListWrapper< Date > *)new ListWrapper< Date >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_Date_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DateList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_DateList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DateList" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_add" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DateList_add" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_get" "', argument " "1"" of type '" "ListWrapper< Date > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DateList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)((ListWrapper< Date > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_prepend" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DateList_prepend" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_remove" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DateList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DateList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_getSize" "', argument " "1"" of type '" "ListWrapper< Date > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  result = (unsigned int)((ListWrapper< Date > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DateList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_Date_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_CVTermList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_CVTermList")) SWIG_fail;
  result = (ListWrapper< CVTerm > *)new ListWrapper< CVTerm >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_CVTerm_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CVTermList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_CVTermList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CVTermList" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_add" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CVTermList_add" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_get" "', argument " "1"" of type '" "ListWrapper< CVTerm > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTermList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)((ListWrapper< CVTerm > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_prepend" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CVTermList_prepend" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_remove" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTermList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTermList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_getSize" "', argument " "1"" of type '" "ListWrapper< CVTerm > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  result = (unsigned int)((ListWrapper< CVTerm > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CVTermList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_CVTerm_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ASTNodeList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ASTNodeList")) SWIG_fail;
  result = (ListWrapper< ASTNode > *)new ListWrapper< ASTNode >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ASTNodeList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ASTNodeList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ASTNodeList" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_add" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNodeList_add" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_get" "', argument " "1"" of type '" "ListWrapper< ASTNode > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNodeList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((ListWrapper< ASTNode > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_prepend" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNodeList_prepend" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_remove" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNodeList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNodeList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_getSize" "', argument " "1"" of type '" "ListWrapper< ASTNode > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  result = (unsigned int)((ListWrapper< ASTNode > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ASTNodeList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_SwigPyIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SwigPyIterator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SwigPyIterator" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_value",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_value" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)((swig::SwigPyIterator const *)arg1)->value();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_incr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_incr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->incr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_incr",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (swig::SwigPyIterator *)(arg1)->incr();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SwigPyIterator_incr__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SwigPyIterator_incr__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SwigPyIterator_incr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    incr(swig::SwigPyIterator *,size_t)\n"
    "    incr(swig::SwigPyIterator *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_decr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_decr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->decr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_decr",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (swig::SwigPyIterator *)(arg1)->decr();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SwigPyIterator_decr__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SwigPyIterator_decr__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SwigPyIterator_decr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    decr(swig::SwigPyIterator *,size_t)\n"
    "    decr(swig::SwigPyIterator *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ptrdiff_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_distance",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_distance" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = ((swig::SwigPyIterator const *)arg1)->distance((swig::SwigPyIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_equal",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_equal" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = (bool)((swig::SwigPyIterator const *)arg1)->equal((swig::SwigPyIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_copy",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_copy" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->copy();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_next",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_next" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator___next__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___next__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->__next__();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_previous(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_previous",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_previous" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_advance",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_advance" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->advance(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___eq__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___eq__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator ==((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___ne__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___ne__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator !=((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___iadd__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___iadd__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___iadd__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator +=(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___isub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___isub__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___isub__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___isub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator -=(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___add__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___add__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___sub__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ptrdiff_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___sub__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = ((swig::SwigPyIterator const *)arg1)->operator -((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__SwigPyIterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SwigPyIterator___sub____SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SwigPyIterator___sub____SWIG_0(self, args);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *SwigPyIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_swig__SwigPyIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN int Swig_var_string_npos_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable string_npos is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_string_npos_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_size_t(static_cast< size_t >(std::basic_string< char >::npos));
  return pyobj;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_string",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_string" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_string" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = (std::basic_string< char > *)new std::basic_string< char >((char const *)arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_length(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_length",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_length" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->length();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_max_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_max_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_max_size" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->max_size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_assign",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->assign((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_assign",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_assign" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_assign" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = (std::basic_string< char > *) &(arg1)->assign((std::basic_string< char > const &)*arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_assign",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_assign" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_assign" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = (std::basic_string< char > *) &(arg1)->assign((char const *)arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_insert",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg3 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(std::basic_string< char > const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char > *arg3 = 0 ;
  std::basic_string< char >::size_type arg4 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_insert",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_insert" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(std::basic_string< char > const &)*arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  char *arg3 = (char *) 0 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_insert" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(char const *)arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "char""'");
  } 
  arg4 = static_cast< char >(val4);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_erase",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_erase" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = (std::basic_string< char > *) &(arg1)->erase(arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_erase",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = (std::basic_string< char > *) &(arg1)->erase(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_erase",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char > *) &(arg1)->erase();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_replace",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg4 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  std::basic_string< char >::size_type arg5 ;
  std::basic_string< char >::size_type arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  size_t val5 ;
  int ecode5 = 0 ;
  size_t val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  ecode6 = SWIG_AsVal_size_t(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "string_replace" "', argument " "6"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg6 = static_cast< std::basic_string< char >::size_type >(val6);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4,arg5,arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char *arg4 = (char *) 0 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  char arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_char(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "char""'");
  } 
  arg5 = static_cast< char >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_copy__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_copy",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_copy" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_copy" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_copy" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_copy" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->copy(arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_copy__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_copy",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_copy" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_copy" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_copy" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->copy(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_copy(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_copy__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_copy__SWIG_0(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_copy'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    copy(std::basic_string< char > const *,char *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    copy(std::basic_string< char > const *,char *,std::basic_string< char >::size_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_c_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_c_str",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_c_str" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (char *)((std::basic_string< char > const *)arg1)->c_str();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find__SWIG_0(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_rfind",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_rfind" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->rfind((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_rfind",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->rfind((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_rfind",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_rfind" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_rfind" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_rfind" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->rfind((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_rfind",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_rfind" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_rfind" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->rfind(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_rfind",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_rfind" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->rfind(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_rfind__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_rfind__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_rfind__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_rfind__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_rfind__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_rfind'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    rfind(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    rfind(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    rfind(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    rfind(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    rfind(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_first_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_first_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_first_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_first_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_first_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_first_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_first_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_first_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_first_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_first_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_first_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_first_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_first_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_first_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_last_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_last_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_last_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_last_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_last_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_last_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_last_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_last_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_last_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_last_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_last_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_last_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_last_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_last_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_first_not_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_first_not_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_first_not_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_first_not_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_not_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_not_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_first_not_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_first_not_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_first_not_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_first_not_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_first_not_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_first_not_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_first_not_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_last_not_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_last_not_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_last_not_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_last_not_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_not_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_not_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_last_not_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_last_not_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_last_not_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_last_not_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_last_not_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_last_not_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_last_not_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_substr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_substr" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_substr" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_substr" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->substr(arg2,arg3);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_substr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_substr" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_substr" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = ((std::basic_string< char > const *)arg1)->substr(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_substr",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_substr" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->substr();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_string_substr__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_substr__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_substr__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_substr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    substr(std::basic_string< char > const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    substr(std::basic_string< char > const *,std::basic_string< char >::size_type)\n"
    "    substr(std::basic_string< char > const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_string")) SWIG_fail;
  result = (std::basic_string< char > *)new std::basic_string< char >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_string",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_string" "', argument " "1"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_string" "', argument " "1"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg1 = ptr;
  }
  result = (std::basic_string< char > *)new std::basic_string< char >((std::basic_string< char > const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_empty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_empty" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (bool)((std::basic_string< char > const *)arg1)->empty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_size" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_swap",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_swap" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_swap" "', argument " "2"" of type '" "std::basic_string< char > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_swap" "', argument " "2"" of type '" "std::basic_string< char > &""'"); 
  }
  arg2 = reinterpret_cast< std::basic_string< char > * >(argp2);
  (arg1)->swap(*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_resize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_resize",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_resize" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_resize" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  (arg1)->resize(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_erase",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (arg1)->erase(arg2);
  resultobj = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_erase",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_erase" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_erase" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  result = (arg1)->erase(arg2,arg3);
  resultobj = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_string_erase__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_erase__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_erase__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string_erase__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_erase__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_erase'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::size_type)\n"
    "    erase(std::basic_string< char > *)\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::iterator)\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char >::size_type arg1 ;
  std::basic_string< char >::value_type arg2 ;
  size_t val1 ;
  int ecode1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_string",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_string" "', argument " "1"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg1 = static_cast< std::basic_string< char >::size_type >(val1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_string" "', argument " "2"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::value_type >(val2);
  result = (std::basic_string< char > *)new std::basic_string< char >(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_string__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_string__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_string__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_string__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_string'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::basic_string< char >(char const *,std::basic_string< char >::size_type)\n"
    "    std::basic_string< char >()\n"
    "    std::basic_string< char >(std::basic_string< char > const &)\n"
    "    std::basic_string< char >(std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_assign",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_assign" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  (arg1)->assign(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_assign__SWIG_0(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_assign__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_assign__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_assign__SWIG_1(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_assign'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    assign(std::basic_string< char > *,std::basic_string< char > const &)\n"
    "    assign(std::basic_string< char > *,std::basic_string< char > const &,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    assign(std::basic_string< char > *,char const *,std::basic_string< char >::size_type)\n"
    "    assign(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_resize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_resize",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_resize" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_resize" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_resize" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  (arg1)->resize(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_resize(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_resize__SWIG_0(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_resize__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_resize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    resize(std::basic_string< char > *,std::basic_string< char >::size_type)\n"
    "    resize(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_insert",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  result = (arg1)->insert(arg2,arg3);
  resultobj = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::value_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::value_type >(val4);
  (arg1)->insert(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_iterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PyObject **arg2 = (PyObject **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  arg2 = &obj0;
  if (!PyArg_ParseTuple(args,(char *)"O:string_iterator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_iterator" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (swig::SwigPyIterator *)std_basic_string_Sl_char_Sg__iterator(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___nonzero__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___nonzero__" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (bool)std_basic_string_Sl_char_Sg____nonzero__((std::basic_string< char > const *)arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___bool__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___bool__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___bool__" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (bool)std_basic_string_Sl_char_Sg____bool__((std::basic_string< char > const *)arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___len__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___len__" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = std_basic_string_Sl_char_Sg____len__((std::basic_string< char > const *)arg1);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___getslice__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___getslice__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___getslice__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___getslice__" "', argument " "3"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  try {
    result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____getslice__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string___setslice__",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___setslice__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___setslice__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___setslice__" "', argument " "3"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string___setslice__" "', argument " "4"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___setslice__" "', argument " "4"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    arg4 = ptr;
  }
  try {
    std_basic_string_Sl_char_Sg____setslice__(arg1,arg2,arg3,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg4);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___delslice__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___delslice__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___delslice__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___delslice__" "', argument " "3"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  try {
    std_basic_string_Sl_char_Sg____delslice__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___delitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___delitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___delitem__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  try {
    std_basic_string_Sl_char_Sg____delitem____SWIG_0(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PySliceObject *arg2 = (PySliceObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___getitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    arg2 = (PySliceObject *) obj1;
  }
  try {
    result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____getitem____SWIG_0(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PySliceObject *arg2 = (PySliceObject *) 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___setitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    arg2 = (PySliceObject *) obj1;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string___setitem__" "', argument " "3"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___setitem__" "', argument " "3"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    arg3 = ptr;
  }
  try {
    std_basic_string_Sl_char_Sg____setitem____SWIG_0(arg1,arg2,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PySliceObject *arg2 = (PySliceObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___delitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___delitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    arg2 = (PySliceObject *) obj1;
  }
  try {
    std_basic_string_Sl_char_Sg____delitem____SWIG_1(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delitem__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PySlice_Check(argv[1]);
      }
      if (_v) {
        return _wrap_string___delitem____SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string___delitem____SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string___delitem__'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    __delitem__(std::basic_string< char > *,std::basic_string< char >::difference_type)\n"
    "    __delitem__(std::basic_string< char > *,PySliceObject *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::value_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___getitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___getitem__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  try {
    result = (std::basic_string< char >::value_type)std_basic_string_Sl_char_Sg____getitem____SWIG_1(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_From_char(static_cast< char >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getitem__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PySlice_Check(argv[1]);
      }
      if (_v) {
        return _wrap_string___getitem____SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string___getitem____SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string___getitem__'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    __getitem__(std::basic_string< char > *,PySliceObject *)\n"
    "    __getitem__(std::basic_string< char > *,std::basic_string< char >::difference_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___setitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___setitem__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___setitem__" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  try {
    std_basic_string_Sl_char_Sg____setitem____SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setitem__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PySlice_Check(argv[1]);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string___setitem____SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string___setitem____SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string___setitem__'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    __setitem__(std::basic_string< char > *,PySliceObject *,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)\n"
    "    __setitem__(std::basic_string< char > *,std::basic_string< char >::difference_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "char""'");
  } 
  arg4 = static_cast< char >(val4);
  (arg1)->insert(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_insert__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string_insert__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_5(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_6(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_3(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_2(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_insert__SWIG_1(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_insert'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char > const &)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char > const &,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,char const *,std::basic_string< char >::size_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,char)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::value_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::size_type,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_replace",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg4 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  char *arg4 = (char *) 0 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char >::size_type arg4 ;
  char arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  size_t val4 ;
  int ecode4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_char(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "char""'");
  } 
  arg5 = static_cast< char >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  res5 = SWIG_AsCharPtrAndSize(obj4, &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "string_replace" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = reinterpret_cast< char * >(buf5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,(char const *)arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char >::const_iterator arg4 ;
  std::basic_string< char >::const_iterator arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  swig::SwigPyIterator *iter4 = 0 ;
  int res4 ;
  swig::SwigPyIterator *iter5 = 0 ;
  int res5 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res4 = SWIG_ConvertPtr(obj3, SWIG_as_voidptrptr(&iter4), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res4) || !iter4) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::const_iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter4);
    if (iter_t) {
      arg4 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::const_iterator""'");
    }
  }
  res5 = SWIG_ConvertPtr(obj4, SWIG_as_voidptrptr(&iter5), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res5) || !iter5) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::const_iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter5);
    if (iter_t) {
      arg5 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::const_iterator""'");
    }
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[7];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 6); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_string_replace__SWIG_4(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_string_replace__SWIG_0(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          swig::SwigPyIterator *iter = 0;
          int res = SWIG_ConvertPtr(argv[3], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
          _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter) != 0));
          if (_v) {
            swig::SwigPyIterator *iter = 0;
            int res = SWIG_ConvertPtr(argv[4], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
            _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter) != 0));
            if (_v) {
              return _wrap_string_replace__SWIG_8(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_6(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_5(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsCharPtrAndSize(argv[4], 0, NULL, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_string_replace__SWIG_7(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_3(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_2(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_size_t(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_string_replace__SWIG_1(self, args);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_replace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,std::basic_string< char > const &)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,std::basic_string< char > const &,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,char const *,std::basic_string< char >::size_type)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,std::basic_string< char >::size_type,char)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,std::basic_string< char > const &)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,char const *,std::basic_string< char >::size_type)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,std::basic_string< char >::size_type,char)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,char const *,char const *)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,std::basic_string< char >::const_iterator,std::basic_string< char >::const_iterator)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___iadd__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___iadd__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___iadd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___iadd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->operator +=((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___add__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___add__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___add__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___add__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____add__(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___radd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___radd__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___radd__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___radd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___radd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____radd__(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___str__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___str__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___str__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = std_basic_string_Sl_char_Sg____str__(arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___rlshift__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_ostream< char,std::char_traits< char > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___rlshift__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___rlshift__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___rlshift__" "', argument " "2"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___rlshift__" "', argument " "2"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  arg2 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp2);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std_basic_string_Sl_char_Sg____rlshift__(arg1,*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___eq__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___eq__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___eq__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___eq__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Se__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___ne__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___ne__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___ne__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___ne__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_SN__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___gt__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___gt__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___gt__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___gt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___gt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sg_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___lt__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___lt__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___lt__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___lt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___lt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sl_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___ge__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___ge__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___ge__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___ge__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___ge__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sg__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___le__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___le__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___le__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___le__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___le__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sl__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_string",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_string" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *string_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ostream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_streambuf< char,std::char_traits< char > > *arg1 = (std::basic_streambuf< char,std::char_traits< char > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostream< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ostream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_streambufT_char_std__char_traitsT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ostream" "', argument " "1"" of type '" "std::basic_streambuf< char,std::char_traits< char > > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_streambuf< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char > *)new std::basic_ostream< char >(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ostream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostream< char > *arg1 = (std::basic_ostream< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ostream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ostream" "', argument " "1"" of type '" "std::basic_ostream< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ostream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ostringstream__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ios_base::openmode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostringstream< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ostringstream",&obj0)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__ios_base__openmode,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ostringstream" "', argument " "1"" of type '" "std::ios_base::openmode""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ostringstream" "', argument " "1"" of type '" "std::ios_base::openmode""'");
    } else {
      std::ios_base::openmode * temp = reinterpret_cast< std::ios_base::openmode * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  result = (std::basic_ostringstream< char > *)new std::basic_ostringstream< char >(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ostringstream__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ostringstream")) SWIG_fail;
  result = (std::basic_ostringstream< char > *)new std::basic_ostringstream< char >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ostringstream(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ostringstream__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_std__ios_base__openmode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ostringstream__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ostringstream'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::basic_ostringstream< char >(std::ios_base::openmode)\n"
    "    std::basic_ostringstream< char >()\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ostringstream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ostringstream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ostringstream" "', argument " "1"" of type '" "std::basic_ostringstream< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ostringstream_str__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ostringstream_str",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ostringstream_str" "', argument " "1"" of type '" "std::basic_ostringstream< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  result = ((std::basic_ostringstream< char > const *)arg1)->str();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ostringstream_str__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ostringstream_str",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ostringstream_str" "', argument " "1"" of type '" "std::basic_ostringstream< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ostringstream_str" "', argument " "2"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ostringstream_str" "', argument " "2"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->str((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ostringstream_str(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ostringstream_str__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ostringstream_str__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ostringstream_str'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    str(std::basic_ostringstream< char > const *)\n"
    "    str(std::basic_ostringstream< char > *,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)\n");
  return NULL;
}


SWIGINTERN PyObject *ostringstream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_endl(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostream< char,std::char_traits< char > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:endl",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "endl" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "endl" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std::SWIGTEMPLATEDISAMBIGUATOR endl< char,std::char_traits< char > >(*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_flush(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostream< char,std::char_traits< char > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:flush",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "flush" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "flush" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std::SWIGTEMPLATEDISAMBIGUATOR flush< char,std::char_traits< char > >(*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int Swig_var_cout_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable cout is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_cout_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(&std::cout), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return pyobj;
}


SWIGINTERN int Swig_var_cerr_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable cerr is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_cerr_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(&std::cerr), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return pyobj;
}


SWIGINTERN int Swig_var_clog_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable clog is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_clog_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(&std::clog), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return pyobj;
}


SWIGINTERN PyObject *_wrap_ASTNode_true(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_true",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_true" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)ASTNode_true((ASTNode const *)arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_getLibSBMLVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)":getLibSBMLVersion")) SWIG_fail;
  result = (int)getLibSBMLVersion();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_getLibSBMLDottedVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":getLibSBMLDottedVersion")) SWIG_fail;
  result = (char *)getLibSBMLDottedVersion();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_getLibSBMLVersionString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":getLibSBMLVersionString")) SWIG_fail;
  result = (char *)getLibSBMLVersionString();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLReader(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLReader")) SWIG_fail;
  result = (SBMLReader *)new SBMLReader();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLReader, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLReader(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLReader",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLReader" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_readSBML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLReader_readSBML",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLReader_readSBML" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLReader_readSBML" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLReader_readSBML" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBML((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_readSBMLFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLReader_readSBMLFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLReader_readSBMLFromFile" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLReader_readSBMLFromFile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLReader_readSBMLFromFile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBMLFromFile((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_readSBMLFromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLReader_readSBMLFromString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLReader_readSBMLFromString" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLReader_readSBMLFromString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLReader_readSBMLFromString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBMLFromString((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_hasZlib(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLReader_hasZlib")) SWIG_fail;
  result = (bool)SBMLReader::hasZlib();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_hasBzip2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLReader_hasBzip2")) SWIG_fail;
  result = (bool)SBMLReader::hasBzip2();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLReader_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLReader, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_readSBMLFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:readSBMLFromFile",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "readSBMLFromFile" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (SBMLDocument_t *)readSBMLFromFile((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_readSBMLFromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:readSBMLFromString",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "readSBMLFromString" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (SBMLDocument_t *)readSBMLFromString((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLWriter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLWriter")) SWIG_fail;
  result = (SBMLWriter *)new SBMLWriter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLWriter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLWriter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLWriter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLWriter" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_setProgramName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_setProgramName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_setProgramName" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_setProgramName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_setProgramName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setProgramName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_setProgramVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_setProgramVersion",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_setProgramVersion" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_setProgramVersion" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_setProgramVersion" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setProgramVersion((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBML__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLWriter_writeSBML",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBML" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBML" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->writeSBML((SBMLDocument const *)arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBML__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::ostream *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLWriter_writeSBML",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBML" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBML" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::ostream &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::ostream &""'"); 
  }
  arg3 = reinterpret_cast< std::ostream * >(argp3);
  result = (bool)(arg1)->writeSBML((SBMLDocument const *)arg2,*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBML(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLWriter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLDocument, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SBMLWriter_writeSBML__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLWriter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLDocument, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SBMLWriter_writeSBML__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLWriter_writeSBML'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    writeSBML(SBMLWriter *,SBMLDocument const *,std::string const &)\n"
    "    writeSBML(SBMLWriter *,SBMLDocument const *,std::ostream &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_writeToString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeToString" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeToString" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  result = (char *)(arg1)->writeToString((SBMLDocument const *)arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBMLToFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLWriter_writeSBMLToFile",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->writeSBMLToFile((SBMLDocument const *)arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBMLToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_writeSBMLToString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBMLToString" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBMLToString" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  result = (char *)(arg1)->writeSBMLToString((SBMLDocument const *)arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_hasZlib(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLWriter_hasZlib")) SWIG_fail;
  result = (bool)SBMLWriter::hasZlib();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_hasBzip2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLWriter_hasBzip2")) SWIG_fail;
  result = (bool)SBMLWriter::hasBzip2();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLWriter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLWriter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_writeSBML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:writeSBML",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeSBML" "', argument " "1"" of type '" "SBMLDocument_t const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "writeSBML" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)writeSBML((SBMLDocument const *)arg1,(char const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_writeSBMLToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:writeSBMLToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeSBMLToString" "', argument " "1"" of type '" "SBMLDocument_t const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  result = (char *)writeSBMLToString((SBMLDocument const *)arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_writeSBMLToFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:writeSBMLToFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeSBMLToFile" "', argument " "1"" of type '" "SBMLDocument_t const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "writeSBMLToFile" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)writeSBMLToFile((SBMLDocument const *)arg1,(char const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLTypeCode_toString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLTypeCode_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLTypeCode_toString",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBMLTypeCode_toString" "', argument " "1"" of type '" "SBMLTypeCode_t""'");
  } 
  arg1 = static_cast< SBMLTypeCode_t >(val1);
  result = (char *)SBMLTypeCode_toString(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBase(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBase",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBase" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_clone" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBase *)((SBase const *)arg1)->clone();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getMetaId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getMetaId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getMetaId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getName" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNotes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNotes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)(arg1)->getNotes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNotesString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNotesString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNotesString" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (arg1)->getNotesString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)(arg1)->getAnnotation();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getAnnotationString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getAnnotationString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getAnnotationString" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (arg1)->getAnnotationString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNamespaces" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNamespaces *)((SBase const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBMLDocument__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBMLDocument" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLDocument *)((SBase const *)arg1)->getSBMLDocument();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBMLDocument__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBMLDocument" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLDocument *)(arg1)->getSBMLDocument();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBMLDocument(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getSBMLDocument__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getSBMLDocument__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_getSBMLDocument'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSBMLDocument(SBase const *)\n"
    "    getSBMLDocument(SBase *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getParentSBMLObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getParentSBMLObject",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getParentSBMLObject" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBase *)(arg1)->getParentSBMLObject();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getAncestorOfType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  SBMLTypeCode_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getAncestorOfType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getAncestorOfType" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBase_getAncestorOfType" "', argument " "2"" of type '" "SBMLTypeCode_t""'");
  } 
  arg2 = static_cast< SBMLTypeCode_t >(val2);
  result = (SBase *)(arg1)->getAncestorOfType(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBOTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBOTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBOTerm" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)((SBase const *)arg1)->getSBOTerm();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBOTermID(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBOTermID",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBOTermID" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = ((SBase const *)arg1)->getSBOTermID();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getLine",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getLine" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getLine();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getColumn",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getColumn" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getColumn();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModelHistory__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getModelHistory" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (ModelHistory *)((SBase const *)arg1)->getModelHistory();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModelHistory__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (ModelHistory *)(arg1)->getModelHistory();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModelHistory(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getModelHistory__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getModelHistory__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_getModelHistory'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModelHistory(SBase const *)\n"
    "    getModelHistory(SBase *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetMetaId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetMetaId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetMetaId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetName" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetNotes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetNotes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetNotes" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetNotes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetAnnotation" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetAnnotation();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetSBOTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetSBOTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetSBOTerm" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetSBOTerm();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setMetaId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setMetaId" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setMetaId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setMetaId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setMetaId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)(arg1)->isSetModelHistory();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setId" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setName" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_setAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setAnnotation(SBase *,XMLNode const *)\n"
    "    setAnnotation(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_appendAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendAnnotation(SBase *,XMLNode const *)\n"
    "    appendAnnotation(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNotes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setNotes" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setNotes((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNotes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setNotes((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNotes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setNotes__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setNotes__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_setNotes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setNotes(SBase *,XMLNode const *)\n"
    "    setNotes(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendNotes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendNotes" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendNotes((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendNotes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_appendNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendNotes((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendNotes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendNotes__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendNotes__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_appendNotes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendNotes(SBase *,XMLNode const *)\n"
    "    appendNotes(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  ModelHistory *arg2 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setModelHistory",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setModelHistory" "', argument " "2"" of type '" "ModelHistory *""'"); 
  }
  arg2 = reinterpret_cast< ModelHistory * >(argp2);
  result = (int)(arg1)->setModelHistory(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setSBOTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setSBOTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setSBOTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBase_setSBOTerm" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setSBOTerm(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setSBOTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setSBOTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setSBOTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setSBOTerm" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setSBOTerm" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSBOTerm((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setSBOTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SBase_setSBOTerm__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setSBOTerm__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_setSBOTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setSBOTerm(SBase *,int)\n"
    "    setSBOTerm(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setNamespaces",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setNamespaces" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setNamespaces" "', argument " "2"" of type '" "XMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (int)(arg1)->setNamespaces(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetMetaId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetMetaId" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetMetaId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetNotes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetNotes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetNotes();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetAnnotation();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetSBOTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetSBOTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetSBOTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetSBOTerm();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_addCVTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBase_addCVTerm",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_addCVTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_addCVTerm" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBase_addCVTerm" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (int)(arg1)->addCVTerm(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_addCVTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_addCVTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_addCVTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_addCVTerm" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  result = (int)(arg1)->addCVTerm(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_addCVTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CVTerm, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_addCVTerm__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CVTerm, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SBase_addCVTerm__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_addCVTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    addCVTerm(SBase *,CVTerm *,bool)\n"
    "    addCVTerm(SBase *,CVTerm *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerms__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getCVTerms" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (List *)(arg1)->getCVTerms();
  {
    ListWrapper<CVTerm> *listw = (result != 0) ? new ListWrapper<CVTerm>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_CVTerm_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerms__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getCVTerms" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (List *)((SBase const *)arg1)->getCVTerms();
  {
    ListWrapper<CVTerm> *listw = (result != 0) ? new ListWrapper<CVTerm>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_CVTerm_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerms(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getCVTerms__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getCVTerms__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_getCVTerms'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getCVTerms(SBase *)\n"
    "    getCVTerms(SBase const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNumCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNumCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNumCVTerms" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)(arg1)->getNumCVTerms();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getCVTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getCVTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBase_getCVTerm" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)(arg1)->getCVTerm(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetCVTerms" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetCVTerms();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetModelHistory();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getResourceBiologicalQualifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  BiolQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getResourceBiologicalQualifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getResourceBiologicalQualifier" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SBase_getResourceBiologicalQualifier" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (BiolQualifierType_t)(arg1)->getResourceBiologicalQualifier(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getResourceModelQualifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getResourceModelQualifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getResourceModelQualifier" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SBase_getResourceModelQualifier" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (ModelQualifierType_t)(arg1)->getResourceModelQualifier(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getModel" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (Model *)((SBase const *)arg1)->getModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getLevel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getLevel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getLevel" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getVersion",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getVersion" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getTypeCode" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLTypeCode_t)((SBase const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_hasValidLevelVersionNamespaceCombination(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_hasValidLevelVersionNamespaceCombination",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_hasValidLevelVersionNamespaceCombination" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)(arg1)->hasValidLevelVersionNamespaceCombination();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getElementName" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_toSBML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_toSBML",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_toSBML" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (char *)(arg1)->toSBML();
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_hasRequiredAttributes" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_hasRequiredElements" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBase_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBase, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ListOf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOf")) SWIG_fail;
  result = (ListOf *)new ListOf();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOf, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOf" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOf *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ListOf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ListOf,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ListOf" "', argument " "1"" of type '" "ListOf const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ListOf" "', argument " "1"" of type '" "ListOf const &""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (ListOf *)new ListOf((ListOf const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOf, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOf(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ListOf__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOf__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ListOf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ListOf()\n"
    "    ListOf(ListOf const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_clone" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (SBase *)((ListOf const *)arg1)->clone();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_append",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_append" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOf_append" "', argument " "2"" of type '" "SBase const *""'"); 
  }
  arg2 = reinterpret_cast< SBase * >(argp2);
  (arg1)->append((SBase const *)arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_appendAndOwn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_appendAndOwn",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_appendAndOwn" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOf_appendAndOwn" "', argument " "2"" of type '" "SBase *""'"); 
  }
  arg2 = reinterpret_cast< SBase * >(argp2);
  (arg1)->appendAndOwn(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_get" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)((ListOf const *)arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_get" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)(arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_get__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOf_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOf const *,unsigned int)\n"
    "    get(ListOf *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clear__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_clear",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_clear" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_clear" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->clear(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clear__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_clear" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  (arg1)->clear();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clear(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ListOf_clear__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_clear__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOf_clear'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    clear(ListOf *,bool)\n"
    "    clear(ListOf *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_remove" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)(arg1)->remove(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_size" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (unsigned int)((ListOf const *)arg1)->size();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_getTypeCode" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (SBMLTypeCode_t)((ListOf const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_getItemTypeCode" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (SBMLTypeCode_t)((ListOf const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_getElementName" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (std::string *) &((ListOf const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf___len__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf___len__" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (int)ListOf___len__(arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOf_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOf, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Model__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Model",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Model" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Model" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Model *)new Model(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Model__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Model",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Model" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Model *)new Model(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Model(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Model",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Model" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Model__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Model",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Model,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Model" "', argument " "1"" of type '" "Model const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Model" "', argument " "1"" of type '" "Model const &""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    try {
      result = (Model *)new Model((Model const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Model(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Model__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Model__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Model__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Model'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Model(unsigned int,unsigned int)\n"
    "    Model(SBMLNamespaces *)\n"
    "    Model(Model const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_clone" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Model *)((Model const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getId" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getName" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSubstanceUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getSubstanceUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getTimeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getTimeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getVolumeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getVolumeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getVolumeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getAreaUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getAreaUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getAreaUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getLengthUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getLengthUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getLengthUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getExtentUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getExtentUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getExtentUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getConversionFactor" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getConversionFactor();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetId" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetName" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetSubstanceUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetSubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetTimeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetTimeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetVolumeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetVolumeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetVolumeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetAreaUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetAreaUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetAreaUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetLengthUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetLengthUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetLengthUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetExtentUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetExtentUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetExtentUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetConversionFactor" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetConversionFactor();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setId" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setName" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setSubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSubstanceUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setTimeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setTimeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setVolumeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setVolumeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setVolumeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setVolumeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVolumeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setAreaUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setAreaUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setAreaUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setAreaUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAreaUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setLengthUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setLengthUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setLengthUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setLengthUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setLengthUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setExtentUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setExtentUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setExtentUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setExtentUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setExtentUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setConversionFactor",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setConversionFactor" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setConversionFactor((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetId" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetName" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetSubstanceUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetTimeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetVolumeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetVolumeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetVolumeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetAreaUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetAreaUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetAreaUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetLengthUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetLengthUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetLengthUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetExtentUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetExtentUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetExtentUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetConversionFactor" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetConversionFactor();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addFunctionDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  FunctionDefinition *arg2 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addFunctionDefinition" "', argument " "2"" of type '" "FunctionDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< FunctionDefinition * >(argp2);
  result = (int)(arg1)->addFunctionDefinition((FunctionDefinition const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addUnitDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addUnitDefinition" "', argument " "2"" of type '" "UnitDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (int)(arg1)->addUnitDefinition((UnitDefinition const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  CompartmentType *arg2 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addCompartmentType" "', argument " "2"" of type '" "CompartmentType const *""'"); 
  }
  arg2 = reinterpret_cast< CompartmentType * >(argp2);
  result = (int)(arg1)->addCompartmentType((CompartmentType const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  SpeciesType *arg2 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addSpeciesType" "', argument " "2"" of type '" "SpeciesType const *""'"); 
  }
  arg2 = reinterpret_cast< SpeciesType * >(argp2);
  result = (int)(arg1)->addSpeciesType((SpeciesType const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Compartment *arg2 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addCompartment" "', argument " "2"" of type '" "Compartment const *""'"); 
  }
  arg2 = reinterpret_cast< Compartment * >(argp2);
  result = (int)(arg1)->addCompartment((Compartment const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Species *arg2 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addSpecies" "', argument " "2"" of type '" "Species const *""'"); 
  }
  arg2 = reinterpret_cast< Species * >(argp2);
  result = (int)(arg1)->addSpecies((Species const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Parameter *arg2 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addParameter" "', argument " "2"" of type '" "Parameter const *""'"); 
  }
  arg2 = reinterpret_cast< Parameter * >(argp2);
  result = (int)(arg1)->addParameter((Parameter const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addInitialAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  InitialAssignment *arg2 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addInitialAssignment" "', argument " "2"" of type '" "InitialAssignment const *""'"); 
  }
  arg2 = reinterpret_cast< InitialAssignment * >(argp2);
  result = (int)(arg1)->addInitialAssignment((InitialAssignment const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Rule *arg2 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addRule" "', argument " "2"" of type '" "Rule const *""'"); 
  }
  arg2 = reinterpret_cast< Rule * >(argp2);
  result = (int)(arg1)->addRule((Rule const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addConstraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Constraint *arg2 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addConstraint" "', argument " "2"" of type '" "Constraint const *""'"); 
  }
  arg2 = reinterpret_cast< Constraint * >(argp2);
  result = (int)(arg1)->addConstraint((Constraint const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addReaction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Reaction *arg2 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addReaction" "', argument " "2"" of type '" "Reaction const *""'"); 
  }
  arg2 = reinterpret_cast< Reaction * >(argp2);
  result = (int)(arg1)->addReaction((Reaction const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Event *arg2 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addEvent" "', argument " "2"" of type '" "Event const *""'"); 
  }
  arg2 = reinterpret_cast< Event * >(argp2);
  result = (int)(arg1)->addEvent((Event const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createFunctionDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createFunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (FunctionDefinition *)(arg1)->createFunctionDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createUnitDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (UnitDefinition *)(arg1)->createUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createUnit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createUnit" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Unit *)(arg1)->createUnit();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (CompartmentType *)(arg1)->createCompartmentType();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesType *)(arg1)->createSpeciesType();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Compartment *)(arg1)->createCompartment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Species *)(arg1)->createSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Parameter *)(arg1)->createParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createInitialAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createInitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (InitialAssignment *)(arg1)->createInitialAssignment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createAlgebraicRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createAlgebraicRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createAlgebraicRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (AlgebraicRule *)(arg1)->createAlgebraicRule();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createAssignmentRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createAssignmentRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createAssignmentRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (AssignmentRule *)(arg1)->createAssignmentRule();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createRateRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createRateRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createRateRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (RateRule *)(arg1)->createRateRule();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createConstraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createConstraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Constraint *)(arg1)->createConstraint();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createReaction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createReaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Reaction *)(arg1)->createReaction();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createReactant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createReactant" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesReference *)(arg1)->createReactant();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createProduct",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createProduct" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesReference *)(arg1)->createProduct();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createModifier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createModifier" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ModifierSpeciesReference *)(arg1)->createModifier();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createKineticLaw" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (KineticLaw *)(arg1)->createKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createKineticLawParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createKineticLawParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createKineticLawParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Parameter *)(arg1)->createKineticLawParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createKineticLawLocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createKineticLawLocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createKineticLawLocalParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (LocalParameter *)(arg1)->createKineticLawLocalParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createEvent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Event *)(arg1)->createEvent();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createEventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createEventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createEventAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (EventAssignment *)(arg1)->createEventAssignment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createTrigger" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Trigger *)(arg1)->createTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createDelay" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Delay *)(arg1)->createDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_setAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_setAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_setAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setAnnotation(Model *,XMLNode const *)\n"
    "    setAnnotation(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_appendAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_appendAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_appendAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_appendAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_appendAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_appendAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_appendAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_appendAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_appendAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendAnnotation(Model *,XMLNode const *)\n"
    "    appendAnnotation(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfFunctionDefinitions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfFunctionDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfFunctionDefinitions *)((Model const *)arg1)->getListOfFunctionDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfFunctionDefinitions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfFunctionDefinitions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfFunctionDefinitions *)(arg1)->getListOfFunctionDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfFunctionDefinitions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfFunctionDefinitions__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfFunctionDefinitions__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfFunctionDefinitions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfFunctionDefinitions(Model const *)\n"
    "    getListOfFunctionDefinitions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfUnitDefinitions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfUnitDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfUnitDefinitions *)((Model const *)arg1)->getListOfUnitDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfUnitDefinitions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfUnitDefinitions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfUnitDefinitions *)(arg1)->getListOfUnitDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfUnitDefinitions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfUnitDefinitions__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfUnitDefinitions__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfUnitDefinitions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfUnitDefinitions(Model const *)\n"
    "    getListOfUnitDefinitions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartmentTypes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartmentTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartmentTypes *)((Model const *)arg1)->getListOfCompartmentTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartmentTypes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartmentTypes" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartmentTypes *)(arg1)->getListOfCompartmentTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartmentTypes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartmentTypes__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartmentTypes__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfCompartmentTypes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfCompartmentTypes(Model const *)\n"
    "    getListOfCompartmentTypes(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpeciesTypes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpeciesTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpeciesTypes *)((Model const *)arg1)->getListOfSpeciesTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpeciesTypes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpeciesTypes" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpeciesTypes *)(arg1)->getListOfSpeciesTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpeciesTypes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpeciesTypes__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpeciesTypes__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfSpeciesTypes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfSpeciesTypes(Model const *)\n"
    "    getListOfSpeciesTypes(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartments__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartments *)((Model const *)arg1)->getListOfCompartments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartments__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartments" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartments *)(arg1)->getListOfCompartments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartments(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartments__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartments__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfCompartments'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfCompartments(Model const *)\n"
    "    getListOfCompartments(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpecies__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpecies *)((Model const *)arg1)->getListOfSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpecies__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpecies *)(arg1)->getListOfSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpecies(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpecies__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpecies__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfSpecies'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfSpecies(Model const *)\n"
    "    getListOfSpecies(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfParameters__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfParameters" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfParameters *)((Model const *)arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfParameters__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfParameters" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfParameters *)(arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfParameters(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfParameters__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfParameters__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfParameters'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfParameters(Model const *)\n"
    "    getListOfParameters(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfInitialAssignments__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfInitialAssignments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfInitialAssignments *)((Model const *)arg1)->getListOfInitialAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfInitialAssignments__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfInitialAssignments" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfInitialAssignments *)(arg1)->getListOfInitialAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfInitialAssignments(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfInitialAssignments__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfInitialAssignments__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfInitialAssignments'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfInitialAssignments(Model const *)\n"
    "    getListOfInitialAssignments(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfRules__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfRules" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfRules *)((Model const *)arg1)->getListOfRules();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfRules__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfRules" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfRules *)(arg1)->getListOfRules();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfRules(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfRules__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfRules__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfRules'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfRules(Model const *)\n"
    "    getListOfRules(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfConstraints__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfConstraints" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfConstraints *)((Model const *)arg1)->getListOfConstraints();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfConstraints__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfConstraints" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfConstraints *)(arg1)->getListOfConstraints();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfConstraints(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfConstraints__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfConstraints__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfConstraints'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfConstraints(Model const *)\n"
    "    getListOfConstraints(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfReactions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfReactions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfReactions *)((Model const *)arg1)->getListOfReactions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfReactions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfReactions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfReactions *)(arg1)->getListOfReactions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfReactions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfReactions__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfReactions__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfReactions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfReactions(Model const *)\n"
    "    getListOfReactions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfEvents__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfEvents" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfEvents *)((Model const *)arg1)->getListOfEvents();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfEvents__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfEvents" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfEvents *)(arg1)->getListOfEvents();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfEvents(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfEvents__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfEvents__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfEvents'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfEvents(Model const *)\n"
    "    getListOfEvents(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)((Model const *)arg1)->getFunctionDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->getFunctionDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)((Model const *)arg1)->getFunctionDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->getFunctionDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getFunctionDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getFunctionDefinition(Model const *,unsigned int)\n"
    "    getFunctionDefinition(Model *,unsigned int)\n"
    "    getFunctionDefinition(Model const *,std::string const &)\n"
    "    getFunctionDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)((Model const *)arg1)->getUnitDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->getUnitDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)((Model const *)arg1)->getUnitDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->getUnitDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getUnitDefinition(Model const *,unsigned int)\n"
    "    getUnitDefinition(Model *,unsigned int)\n"
    "    getUnitDefinition(Model const *,std::string const &)\n"
    "    getUnitDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)((Model const *)arg1)->getCompartmentType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->getCompartmentType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)((Model const *)arg1)->getCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->getCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getCompartmentType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getCompartmentType(Model const *,unsigned int)\n"
    "    getCompartmentType(Model *,unsigned int)\n"
    "    getCompartmentType(Model const *,std::string const &)\n"
    "    getCompartmentType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)((Model const *)arg1)->getSpeciesType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->getSpeciesType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)((Model const *)arg1)->getSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->getSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getSpeciesType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSpeciesType(Model const *,unsigned int)\n"
    "    getSpeciesType(Model *,unsigned int)\n"
    "    getSpeciesType(Model const *,std::string const &)\n"
    "    getSpeciesType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)((Model const *)arg1)->getCompartment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->getCompartment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)((Model const *)arg1)->getCompartment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->getCompartment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getCompartment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getCompartment(Model const *,unsigned int)\n"
    "    getCompartment(Model *,unsigned int)\n"
    "    getCompartment(Model const *,std::string const &)\n"
    "    getCompartment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)((Model const *)arg1)->getSpecies(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->getSpecies(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)((Model const *)arg1)->getSpecies((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->getSpecies((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getSpecies'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSpecies(Model const *,unsigned int)\n"
    "    getSpecies(Model *,unsigned int)\n"
    "    getSpecies(Model const *,std::string const &)\n"
    "    getSpecies(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((Model const *)arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((Model const *)arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getParameter__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getParameter__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getParameter__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getParameter(Model const *,unsigned int)\n"
    "    getParameter(Model *,unsigned int)\n"
    "    getParameter(Model const *,std::string const &)\n"
    "    getParameter(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)((Model const *)arg1)->getInitialAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->getInitialAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)((Model const *)arg1)->getInitialAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->getInitialAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getInitialAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getInitialAssignment(Model const *,unsigned int)\n"
    "    getInitialAssignment(Model *,unsigned int)\n"
    "    getInitialAssignment(Model const *,std::string const &)\n"
    "    getInitialAssignment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)((Model const *)arg1)->getRule(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->getRule(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)((Model const *)arg1)->getRule((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->getRule((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getRule__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getRule__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getRule__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getRule__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getRule(Model const *,unsigned int)\n"
    "    getRule(Model *,unsigned int)\n"
    "    getRule(Model const *,std::string const &)\n"
    "    getRule(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConstraint__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getConstraint" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getConstraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)((Model const *)arg1)->getConstraint(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConstraint__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getConstraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->getConstraint(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConstraint(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getConstraint__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getConstraint__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getConstraint'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getConstraint(Model const *,unsigned int)\n"
    "    getConstraint(Model *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)((Model const *)arg1)->getReaction(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->getReaction(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)((Model const *)arg1)->getReaction((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->getReaction((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getReaction__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getReaction__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getReaction__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getReaction__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getReaction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getReaction(Model const *,unsigned int)\n"
    "    getReaction(Model *,unsigned int)\n"
    "    getReaction(Model const *,std::string const &)\n"
    "    getReaction(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesReference__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesReference",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesReference" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getSpeciesReference((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesReference__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesReference",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesReference" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Model const *)arg1)->getSpeciesReference((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesReference(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesReference__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesReference__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getSpeciesReference'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSpeciesReference(Model *,std::string const &)\n"
    "    getSpeciesReference(Model const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)((Model const *)arg1)->getEvent(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->getEvent(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)((Model const *)arg1)->getEvent((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->getEvent((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getEvent__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getEvent__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getEvent__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getEvent__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getEvent'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getEvent(Model const *,unsigned int)\n"
    "    getEvent(Model *,unsigned int)\n"
    "    getEvent(Model const *,std::string const &)\n"
    "    getEvent(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumFunctionDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumFunctionDefinitions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumUnitDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumUnitDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumUnitDefinitions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumCompartmentTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumCompartmentTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumCompartmentTypes();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumSpeciesTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumSpeciesTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpeciesTypes();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumCompartments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumCompartments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumCompartments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpecies();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumSpeciesWithBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumSpeciesWithBoundaryCondition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumSpeciesWithBoundaryCondition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpeciesWithBoundaryCondition();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumParameters" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumParameters();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumInitialAssignments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumInitialAssignments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumRules(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumRules" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumRules();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumConstraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumConstraints" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumConstraints();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumReactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumReactions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumReactions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumEvents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumEvents" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumEvents();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL1ToL2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL1ToL2",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL1ToL2" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL1ToL2();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL1ToL3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL1ToL3",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL1ToL3" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL1ToL3();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL2ToL3",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL2ToL3" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL2ToL3();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL1__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_convertL2ToL1",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL2ToL1" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_convertL2ToL1" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->convertL2ToL1(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL1__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL2ToL1",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL2ToL1" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL2ToL1();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL1(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_convertL2ToL1__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_convertL2ToL1__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_convertL2ToL1'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    convertL2ToL1(Model *,bool)\n"
    "    convertL2ToL1(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addModifiers(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_addModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addModifiers" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addModifiers();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addConstantAttribute(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_addConstantAttribute",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addConstantAttribute" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addConstantAttribute();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpatialDimensions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setSpatialDimensions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSpatialDimensions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_setSpatialDimensions" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->setSpatialDimensions(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpatialDimensions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_setSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSpatialDimensions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->setSpatialDimensions();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpatialDimensions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_setSpatialDimensions__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_setSpatialDimensions__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_setSpatialDimensions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setSpatialDimensions(Model *,double)\n"
    "    setSpatialDimensions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addDefinitionsForDefaultUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_addDefinitionsForDefaultUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addDefinitionsForDefaultUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addDefinitionsForDefaultUnits();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertParametersToLocals(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertParametersToLocals",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertParametersToLocals" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertParametersToLocals();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpeciesReferenceConstantValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_setSpeciesReferenceConstantValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSpeciesReferenceConstantValue" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->setSpeciesReferenceConstantValue();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameterRuleUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_removeParameterRuleUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeParameterRuleUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->removeParameterRuleUnits();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertStoichiometryMath" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertStoichiometryMath();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getTypeCode" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SBMLTypeCode_t)((Model const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getElementName" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_populateListFormulaUnitsData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_populateListFormulaUnitsData",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_populateListFormulaUnitsData" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->populateListFormulaUnitsData();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isPopulatedListFormulaUnitsData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isPopulatedListFormulaUnitsData",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isPopulatedListFormulaUnitsData" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)(arg1)->isPopulatedListFormulaUnitsData();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_hasRequiredElements" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeFunctionDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeFunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->removeFunctionDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeFunctionDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->removeFunctionDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeFunctionDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeFunctionDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeFunctionDefinition__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeFunctionDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeFunctionDefinition(Model *,unsigned int)\n"
    "    removeFunctionDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeUnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->removeUnitDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->removeUnitDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeUnitDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeUnitDefinition__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeUnitDefinition(Model *,unsigned int)\n"
    "    removeUnitDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartmentType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeCompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->removeCompartmentType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartmentType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->removeCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartmentType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeCompartmentType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeCompartmentType__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeCompartmentType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeCompartmentType(Model *,unsigned int)\n"
    "    removeCompartmentType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpeciesType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeSpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->removeSpeciesType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpeciesType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->removeSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpeciesType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeSpeciesType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeSpeciesType__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeSpeciesType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeSpeciesType(Model *,unsigned int)\n"
    "    removeSpeciesType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeCompartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->removeCompartment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->removeCompartment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeCompartment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeCompartment__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeCompartment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeCompartment(Model *,unsigned int)\n"
    "    removeCompartment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpecies__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeSpecies" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->removeSpecies(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpecies__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->removeSpecies((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpecies(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeSpecies__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeSpecies__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeSpecies'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeSpecies(Model *,unsigned int)\n"
    "    removeSpecies(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->removeParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->removeParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeParameter__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeParameter(Model *,unsigned int)\n"
    "    removeParameter(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeInitialAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeInitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->removeInitialAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeInitialAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->removeInitialAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeInitialAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeInitialAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeInitialAssignment__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeInitialAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeInitialAssignment(Model *,unsigned int)\n"
    "    removeInitialAssignment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->removeRule(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->removeRule((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeRule__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeRule__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeRule(Model *,unsigned int)\n"
    "    removeRule(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeConstraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeConstraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->removeConstraint(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeReaction__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeReaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->removeReaction(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeReaction__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->removeReaction((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeReaction(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeReaction__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeReaction__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeReaction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeReaction(Model *,unsigned int)\n"
    "    removeReaction(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeEvent__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeEvent" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->removeEvent(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeEvent__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->removeEvent((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeEvent(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeEvent__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeEvent__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeEvent'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeEvent(Model *,unsigned int)\n"
    "    removeEvent(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *Model_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Model, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBMLDocument_getDefaultLevel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLDocument_getDefaultLevel")) SWIG_fail;
  result = (unsigned int)SBMLDocument::getDefaultLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getDefaultVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLDocument_getDefaultVersion")) SWIG_fail;
  result = (unsigned int)SBMLDocument::getDefaultVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SBMLDocument",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLDocument" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLDocument *)new SBMLDocument(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLDocument",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (SBMLDocument *)new SBMLDocument(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLDocument")) SWIG_fail;
  result = (SBMLDocument *)new SBMLDocument();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLDocument(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLDocument" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SBMLDocument,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "SBMLDocument const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "SBMLDocument const &""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLDocument *)new SBMLDocument((SBMLDocument const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_SBMLDocument__SWIG_2(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_3(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLDocument__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SBMLDocument'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SBMLDocument(unsigned int,unsigned int)\n"
    "    SBMLDocument(unsigned int)\n"
    "    SBMLDocument()\n"
    "    SBMLDocument(SBMLDocument const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_clone" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLDocument *)((SBMLDocument const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getModel__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getModel" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)((SBMLDocument const *)arg1)->getModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getModel__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)(arg1)->getModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getModel(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_getModel__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_getModel__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_getModel'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModel(SBMLDocument const *)\n"
    "    getModel(SBMLDocument *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_expandFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_expandFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_expandFunctionDefinitions" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (bool)(arg1)->expandFunctionDefinitions();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_expandInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_expandInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_expandInitialAssignments" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (bool)(arg1)->expandInitialAssignments();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setLevelAndVersion__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:SBMLDocument_setLevelAndVersion",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_bool(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  result = (bool)(arg1)->setLevelAndVersion(arg2,arg3,arg4);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setLevelAndVersion__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLDocument_setLevelAndVersion",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->setLevelAndVersion(arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setLevelAndVersion(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SBMLDocument_setLevelAndVersion__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SBMLDocument_setLevelAndVersion__SWIG_0(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_setLevelAndVersion'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setLevelAndVersion(SBMLDocument *,unsigned int,unsigned int,bool)\n"
    "    setLevelAndVersion(SBMLDocument *,unsigned int,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setModel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  Model *arg2 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_setModel",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLDocument_setModel" "', argument " "2"" of type '" "Model const *""'"); 
  }
  arg2 = reinterpret_cast< Model * >(argp2);
  result = (int)(arg1)->setModel((Model const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_createModel__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_createModel",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_createModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLDocument_createModel" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLDocument_createModel" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Model *)(arg1)->createModel((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_createModel__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_createModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_createModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)(arg1)->createModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_createModel(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_createModel__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBMLDocument_createModel__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_createModel'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    createModel(SBMLDocument *,std::string const &)\n"
    "    createModel(SBMLDocument *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setConsistencyChecks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  SBMLErrorCategory_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLDocument_setConsistencyChecks",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setConsistencyChecks" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setConsistencyChecks" "', argument " "2"" of type '" "SBMLErrorCategory_t""'");
  } 
  arg2 = static_cast< SBMLErrorCategory_t >(val2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setConsistencyChecks" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setConsistencyChecks(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setConsistencyChecksForConversion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  SBMLErrorCategory_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLDocument_setConsistencyChecksForConversion",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setConsistencyChecksForConversion" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setConsistencyChecksForConversion" "', argument " "2"" of type '" "SBMLErrorCategory_t""'");
  } 
  arg2 = static_cast< SBMLErrorCategory_t >(val2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setConsistencyChecksForConversion" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setConsistencyChecksForConversion(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkConsistency(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkConsistency",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkConsistency" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkConsistency();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkInternalConsistency(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkInternalConsistency",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkInternalConsistency" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkInternalConsistency();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL1Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL1Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL1Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL1Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v1Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v1Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v1Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v1Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v2Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v2Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v2Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v2Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v3Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v3Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v3Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v3Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v4Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v4Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v4Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v4Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL3v1Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL3v1Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL3v1Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL3v1Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_getError",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getError" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_getError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)((SBMLDocument const *)arg1)->getError(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getNumErrors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getNumErrors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getNumErrors" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)((SBMLDocument const *)arg1)->getNumErrors();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_printErrors__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_printErrors",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_printErrors" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLDocument_printErrors" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLDocument_printErrors" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  ((SBMLDocument const *)arg1)->printErrors(*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_printErrors__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_printErrors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_printErrors" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ((SBMLDocument const *)arg1)->printErrors();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_printErrors(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_printErrors__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBMLDocument_printErrors__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_printErrors'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    printErrors(SBMLDocument const *,std::ostream &)\n"
    "    printErrors(SBMLDocument const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getTypeCode" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLTypeCode_t)((SBMLDocument const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getElementName" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (std::string *) &((SBMLDocument const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getErrorLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLErrorLog *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getErrorLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getErrorLog" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLErrorLog *)(arg1)->getErrorLog();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getNamespaces" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (XMLNamespaces *)((SBMLDocument const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLDocument_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLDocument, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_FunctionDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_FunctionDefinition",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_FunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_FunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_FunctionDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_FunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FunctionDefinition" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_FunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_FunctionDefinition,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "FunctionDefinition const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "FunctionDefinition const &""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition((FunctionDefinition const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FunctionDefinition__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FunctionDefinition__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_FunctionDefinition__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_FunctionDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    FunctionDefinition(unsigned int,unsigned int)\n"
    "    FunctionDefinition(SBMLNamespaces *)\n"
    "    FunctionDefinition(FunctionDefinition const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_clone" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (FunctionDefinition *)((FunctionDefinition const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getId" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getName" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getMath" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_isSetId" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_isSetName" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_isSetMath" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_setId" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FunctionDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_setName" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FunctionDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_setMath" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_unsetName" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getArgument__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_getArgument",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getArgument" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FunctionDefinition_getArgument" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getArgument(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getArgument__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_getArgument",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getArgument" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_getArgument" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FunctionDefinition_getArgument" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getArgument((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getArgument(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FunctionDefinition_getArgument__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FunctionDefinition_getArgument__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'FunctionDefinition_getArgument'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getArgument(FunctionDefinition const *,unsigned int)\n"
    "    getArgument(FunctionDefinition const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getBody__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getBody",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getBody" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getBody();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getBody__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getBody",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getBody" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)(arg1)->getBody();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getBody(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FunctionDefinition_getBody__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FunctionDefinition_getBody__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'FunctionDefinition_getBody'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getBody(FunctionDefinition const *)\n"
    "    getBody(FunctionDefinition *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getNumArguments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getNumArguments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getNumArguments" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (unsigned int)((FunctionDefinition const *)arg1)->getNumArguments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getTypeCode" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (SBMLTypeCode_t)((FunctionDefinition const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getElementName" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_hasRequiredAttributes" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_hasRequiredElements" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *FunctionDefinition_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_FunctionDefinition, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_clone" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (ListOfFunctionDefinitions *)((ListOfFunctionDefinitions const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_getTypeCode" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfFunctionDefinitions const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_getItemTypeCode" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfFunctionDefinitions const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_getElementName" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (std::string *) &((ListOfFunctionDefinitions const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)((ListOfFunctionDefinitions const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)((ListOfFunctionDefinitions const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfFunctionDefinitions_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfFunctionDefinitions *,unsigned int)\n"
    "    get(ListOfFunctionDefinitions const *,unsigned int)\n"
    "    get(ListOfFunctionDefinitions *,std::string const &)\n"
    "    get(ListOfFunctionDefinitions const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfFunctionDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfFunctionDefinitions_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfFunctionDefinitions *,unsigned int)\n"
    "    remove(ListOfFunctionDefinitions *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfFunctionDefinitions")) SWIG_fail;
  result = (ListOfFunctionDefinitions *)new ListOfFunctionDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfFunctionDefinitions" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfFunctionDefinitions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_UnitKind_equals(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitKind_t arg1 ;
  UnitKind_t arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitKind_equals",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "UnitKind_equals" "', argument " "1"" of type '" "UnitKind_t""'");
  } 
  arg1 = static_cast< UnitKind_t >(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitKind_equals" "', argument " "2"" of type '" "UnitKind_t""'");
  } 
  arg2 = static_cast< UnitKind_t >(val2);
  result = (int)UnitKind_equals(arg1,arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitKind_forName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitKind_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitKind_forName",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitKind_forName" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (UnitKind_t)UnitKind_forName((char const *)arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitKind_toString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitKind_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitKind_toString",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "UnitKind_toString" "', argument " "1"" of type '" "UnitKind_t""'");
  } 
  arg1 = static_cast< UnitKind_t >(val1);
  result = (char *)UnitKind_toString(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitKind_isValidUnitKindString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:UnitKind_isValidUnitKindString",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitKind_isValidUnitKindString" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitKind_isValidUnitKindString" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "UnitKind_isValidUnitKindString" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (int)UnitKind_isValidUnitKindString((char const *)arg1,arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Unit",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Unit" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Unit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Unit *)new Unit(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Unit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Unit" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Unit *)new Unit(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Unit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Unit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Unit" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Unit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Unit,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Unit" "', argument " "1"" of type '" "Unit const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Unit" "', argument " "1"" of type '" "Unit const &""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  {
    try {
      result = (Unit *)new Unit((Unit const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Unit__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Unit__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Unit__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Unit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Unit(unsigned int,unsigned int)\n"
    "    Unit(SBMLNamespaces *)\n"
    "    Unit(Unit const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_clone" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (Unit *)((Unit const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_initDefaults" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitKind_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getKind",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getKind" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (UnitKind_t)((Unit const *)arg1)->getKind();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getExponent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getExponent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getExponent" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)((Unit const *)arg1)->getExponent();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getExponentAsDouble(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getExponentAsDouble",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getExponentAsDouble" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getExponentAsDouble();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getScale",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getScale" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)((Unit const *)arg1)->getScale();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getMultiplier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getMultiplier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getMultiplier" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getMultiplier();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getOffset" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getOffset();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isAmpere(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isAmpere",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isAmpere" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isAmpere();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isAvogadro(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isAvogadro",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isAvogadro" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isAvogadro();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isBecquerel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isBecquerel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isBecquerel" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isBecquerel();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isCandela(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isCandela",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isCandela" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCandela();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isCelsius(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isCelsius",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isCelsius" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCelsius();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isCoulomb(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isCoulomb",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isCoulomb" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCoulomb();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isDimensionless(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isDimensionless",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isDimensionless" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isDimensionless();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isFarad(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isFarad",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isFarad" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isFarad();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isGram(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isGram",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isGram" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isGram();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isGray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isGray",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isGray" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isGray();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isHenry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isHenry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isHenry" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isHenry();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isHertz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isHertz",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isHertz" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isHertz();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isItem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isItem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isItem" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isItem();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isJoule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isJoule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isJoule" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isJoule();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isKatal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isKatal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isKatal" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKatal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isKelvin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isKelvin",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isKelvin" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKelvin();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isKilogram(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isKilogram",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isKilogram" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKilogram();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isLitre(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isLitre",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isLitre" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLitre();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isLumen(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isLumen",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isLumen" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLumen();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isLux(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isLux",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isLux" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLux();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isMetre(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isMetre",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isMetre" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isMetre();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isMole(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isMole",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isMole" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isMole();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isNewton(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isNewton",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isNewton" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isNewton();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isOhm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isOhm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isOhm" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isOhm();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isPascal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isPascal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isPascal" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isPascal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isRadian(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isRadian",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isRadian" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isRadian();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSecond(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSecond",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSecond" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSecond();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSiemens(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSiemens",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSiemens" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSiemens();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSievert(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSievert",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSievert" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSievert();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSteradian(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSteradian",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSteradian" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSteradian();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isTesla(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isTesla",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isTesla" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isTesla();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isVolt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isVolt",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isVolt" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isVolt();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isWatt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isWatt",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isWatt" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isWatt();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isWeber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isWeber",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isWeber" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isWeber();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetKind",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetKind" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetKind();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetExponent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetExponent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetExponent" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetExponent();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetScale",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetScale" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetScale();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetMultiplier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetMultiplier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetMultiplier" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetMultiplier();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  UnitKind_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setKind",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setKind" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setKind" "', argument " "2"" of type '" "UnitKind_t""'");
  } 
  arg2 = static_cast< UnitKind_t >(val2);
  result = (int)(arg1)->setKind(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setExponent__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setExponent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setExponent" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setExponent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setExponent(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setExponent__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setExponent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setExponent" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setExponent" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setExponent(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setExponent(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Unit_setExponent__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Unit_setExponent__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Unit_setExponent'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setExponent(Unit *,int)\n"
    "    setExponent(Unit *,double)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setScale",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setScale" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setScale" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setScale(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setMultiplier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setMultiplier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setMultiplier" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setMultiplier" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setMultiplier(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setOffset" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setOffset" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getTypeCode" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (SBMLTypeCode_t)((Unit const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getElementName" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (std::string *) &((Unit const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isBuiltIn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_isBuiltIn",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isBuiltIn" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Unit_isBuiltIn" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_isBuiltIn" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)Unit::isBuiltIn((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isUnitKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Unit_isUnitKind",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isUnitKind" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Unit_isUnitKind" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_isUnitKind" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Unit_isUnitKind" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)Unit::isUnitKind((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_areIdentical(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_areIdentical",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_areIdentical" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Unit_areIdentical" "', argument " "2"" of type '" "Unit *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (bool)Unit::areIdentical(arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_areEquivalent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_areEquivalent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_areEquivalent" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Unit_areEquivalent" "', argument " "2"" of type '" "Unit *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (bool)Unit::areEquivalent(arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_removeScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_removeScale",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_removeScale" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)Unit::removeScale(arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_merge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_merge",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_merge" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Unit_merge" "', argument " "2"" of type '" "Unit *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  Unit::merge(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_convertToSI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_convertToSI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_convertToSI" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (UnitDefinition *)Unit::convertToSI((Unit const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_hasRequiredAttributes" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Unit_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Unit, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfUnits_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_clone" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (ListOfUnits *)((ListOfUnits const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_getTypeCode" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnits const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_getItemTypeCode" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnits const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_getElementName" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (std::string *) &((ListOfUnits const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnits_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_get" "', argument " "1"" of type '" "ListOfUnits *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnits_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnits_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_get" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnits_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)((ListOfUnits const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnits, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnits_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnits, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnits_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfUnits_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfUnits *,unsigned int)\n"
    "    get(ListOfUnits const *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnits_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_remove" "', argument " "1"" of type '" "ListOfUnits *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnits_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfUnits")) SWIG_fail;
  result = (ListOfUnits *)new ListOfUnits();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfUnits" "', argument " "1"" of type '" "ListOfUnits *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfUnits_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfUnits, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_UnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_UnitDefinition",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_UnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_UnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_UnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_UnitDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_UnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_UnitDefinition" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_UnitDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_UnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_UnitDefinition,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "UnitDefinition const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "UnitDefinition const &""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition((UnitDefinition const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_UnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnitDefinition__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnitDefinition__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UnitDefinition__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_UnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    UnitDefinition(unsigned int,unsigned int)\n"
    "    UnitDefinition(SBMLNamespaces *)\n"
    "    UnitDefinition(UnitDefinition const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_clone" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (UnitDefinition *)((UnitDefinition const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getId" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getName" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isSetId" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isSetName" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_setId" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UnitDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_setName" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UnitDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_unsetName" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfArea(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfArea",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfArea" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfArea();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfLength" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfLength();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfSubstance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfSubstance",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfSubstance" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfSubstance();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfTime" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfVolume" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfVolume();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfDimensionless(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfDimensionless",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfDimensionless" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfDimensionless();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfMass(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfMass",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfMass" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfMass();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfSubstancePerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfSubstancePerTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfSubstancePerTime" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfSubstancePerTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_addUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_addUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_addUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_addUnit" "', argument " "2"" of type '" "Unit const *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (int)(arg1)->addUnit((Unit const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_createUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_createUnit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_createUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (Unit *)(arg1)->createUnit();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getListOfUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getListOfUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getListOfUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (ListOfUnits *)((UnitDefinition const *)arg1)->getListOfUnits();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getListOfUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getListOfUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getListOfUnits" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (ListOfUnits *)(arg1)->getListOfUnits();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getListOfUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_getListOfUnits__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_getListOfUnits__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'UnitDefinition_getListOfUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfUnits(UnitDefinition const *)\n"
    "    getListOfUnits(UnitDefinition *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getUnit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_getUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_getUnit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->getUnit(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getUnit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_getUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getUnit" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_getUnit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)((UnitDefinition const *)arg1)->getUnit(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getUnit(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_getUnit__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_getUnit__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'UnitDefinition_getUnit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getUnit(UnitDefinition *,unsigned int)\n"
    "    getUnit(UnitDefinition const *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getNumUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getNumUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getNumUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (unsigned int)((UnitDefinition const *)arg1)->getNumUnits();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_removeUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_removeUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_removeUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_removeUnit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->removeUnit(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getTypeCode" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (SBMLTypeCode_t)((UnitDefinition const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getElementName" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_simplify(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_simplify",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_simplify" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  UnitDefinition::simplify(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_reorder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_reorder",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_reorder" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  UnitDefinition::reorder(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_convertToSI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_convertToSI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_convertToSI" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (UnitDefinition *)UnitDefinition::convertToSI((UnitDefinition const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_areIdentical(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_areIdentical",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_areIdentical" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_areIdentical" "', argument " "2"" of type '" "UnitDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (bool)UnitDefinition::areIdentical((UnitDefinition const *)arg1,(UnitDefinition const *)arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_areEquivalent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_areEquivalent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_areEquivalent" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_areEquivalent" "', argument " "2"" of type '" "UnitDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (bool)UnitDefinition::areEquivalent((UnitDefinition const *)arg1,(UnitDefinition const *)arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_combine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_combine",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_combine" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_combine" "', argument " "2"" of type '" "UnitDefinition *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (UnitDefinition *)UnitDefinition::combine(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_printUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_printUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_printUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_printUnits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = UnitDefinition::printUnits((UnitDefinition const *)arg1,arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_printUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_printUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_printUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = UnitDefinition::printUnits((UnitDefinition const *)arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_printUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_printUnits__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_printUnits__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'UnitDefinition_printUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    printUnits(UnitDefinition const *,bool)\n"
    "    UnitDefinition::printUnits(UnitDefinition const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_hasRequiredAttributes" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_hasRequiredElements" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *UnitDefinition_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_UnitDefinition, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_clone" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (ListOfUnitDefinitions *)((ListOfUnitDefinitions const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_getTypeCode" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnitDefinitions const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_getItemTypeCode" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnitDefinitions const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_getElementName" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (std::string *) &((ListOfUnitDefinitions const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)((ListOfUnitDefinitions const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)((ListOfUnitDefinitions const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfUnitDefinitions_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfUnitDefinitions *,unsigned int)\n"
    "    get(ListOfUnitDefinitions const *,unsigned int)\n"
    "    get(ListOfUnitDefinitions *,std::string const &)\n"
    "    get(ListOfUnitDefinitions const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_remove" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnitDefinitions_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_remove" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfUnitDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfUnitDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfUnitDefinitions_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfUnitDefinitions *,unsigned int)\n"
    "    remove(ListOfUnitDefinitions *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfUnitDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfUnitDefinitions")) SWIG_fail;
  result = (ListOfUnitDefinitions *)new ListOfUnitDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfUnitDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfUnitDefinitions" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfUnitDefinitions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfUnitDefinitions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_CompartmentType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_CompartmentType",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CompartmentType" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (CompartmentType *)new CompartmentType(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CompartmentType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CompartmentType" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (CompartmentType *)new CompartmentType(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_CompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CompartmentType" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CompartmentType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_CompartmentType,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CompartmentType" "', argument " "1"" of type '" "CompartmentType const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CompartmentType" "', argument " "1"" of type '" "CompartmentType const &""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    try {
      result = (CompartmentType *)new CompartmentType((CompartmentType const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CompartmentType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CompartmentType__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_CompartmentType, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CompartmentType__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_CompartmentType__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_CompartmentType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    CompartmentType(unsigned int,unsigned int)\n"
    "    CompartmentType(SBMLNamespaces *)\n"
    "    CompartmentType(CompartmentType const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_clone" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (CompartmentType *)((CompartmentType const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getId" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getName" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_isSetId" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_isSetName" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CompartmentType_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_setId" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CompartmentType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompartmentType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CompartmentType_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_setName" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CompartmentType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompartmentType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_unsetName" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getTypeCode" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (SBMLTypeCode_t)((CompartmentType const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getElementName" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_hasRequiredAttributes" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CompartmentType_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_CompartmentType, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_clone" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (ListOfCompartmentTypes *)((ListOfCompartmentTypes const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_getTypeCode" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartmentTypes const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_getItemTypeCode" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartmentTypes const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_getElementName" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (std::string *) &((ListOfCompartmentTypes const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)((ListOfCompartmentTypes const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)((ListOfCompartmentTypes const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartmentTypes_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfCompartmentTypes *,unsigned int)\n"
    "    get(ListOfCompartmentTypes const *,unsigned int)\n"
    "    get(ListOfCompartmentTypes *,std::string const &)\n"
    "    get(ListOfCompartmentTypes const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_remove" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartmentTypes_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_remove" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartmentTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartmentTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartmentTypes_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfCompartmentTypes *,unsigned int)\n"
    "    remove(ListOfCompartmentTypes *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfCompartmentTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfCompartmentTypes")) SWIG_fail;
  result = (ListOfCompartmentTypes *)new ListOfCompartmentTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfCompartmentTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfCompartmentTypes" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfCompartmentTypes_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfCompartmentTypes, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SpeciesType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SpeciesType",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SpeciesType" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SpeciesType *)new SpeciesType(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesType" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SpeciesType *)new SpeciesType(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SpeciesType" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SpeciesType,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesType" "', argument " "1"" of type '" "SpeciesType const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpeciesType" "', argument " "1"" of type '" "SpeciesType const &""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    try {
      result = (SpeciesType *)new SpeciesType((SpeciesType const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesType__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SpeciesType, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesType__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SpeciesType__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SpeciesType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SpeciesType(unsigned int,unsigned int)\n"
    "    SpeciesType(SBMLNamespaces *)\n"
    "    SpeciesType(SpeciesType const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_clone" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (SpeciesType *)((SpeciesType const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getId" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getName" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_isSetId" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_isSetName" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesType_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_setId" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesType_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_setName" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_unsetName" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getTypeCode" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (SBMLTypeCode_t)((SpeciesType const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getElementName" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_hasRequiredAttributes" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SpeciesType_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SpeciesType, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_clone" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (ListOfSpeciesTypes *)((ListOfSpeciesTypes const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_getTypeCode" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesTypes const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_getItemTypeCode" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesTypes const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_getElementName" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (std::string *) &((ListOfSpeciesTypes const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)((ListOfSpeciesTypes const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)((ListOfSpeciesTypes const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesTypes_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfSpeciesTypes *,unsigned int)\n"
    "    get(ListOfSpeciesTypes const *,unsigned int)\n"
    "    get(ListOfSpeciesTypes *,std::string const &)\n"
    "    get(ListOfSpeciesTypes const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_remove" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesTypes_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_remove" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesTypes_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfSpeciesTypes *,unsigned int)\n"
    "    remove(ListOfSpeciesTypes *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfSpeciesTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfSpeciesTypes")) SWIG_fail;
  result = (ListOfSpeciesTypes *)new ListOfSpeciesTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfSpeciesTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfSpeciesTypes" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfSpeciesTypes_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfSpeciesTypes, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Compartment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Compartment",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Compartment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Compartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Compartment *)new Compartment(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Compartment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Compartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Compartment" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Compartment *)new Compartment(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Compartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Compartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Compartment" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Compartment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Compartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Compartment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Compartment" "', argument " "1"" of type '" "Compartment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Compartment" "', argument " "1"" of type '" "Compartment const &""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    try {
      result = (Compartment *)new Compartment((Compartment const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Compartment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Compartment__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Compartment__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Compartment__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Compartment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Compartment(unsigned int,unsigned int)\n"
    "    Compartment(SBMLNamespaces *)\n"
    "    Compartment(Compartment const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_clone" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (Compartment *)((Compartment const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_initDefaults" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getId" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getName" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getCompartmentType" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getCompartmentType();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getSpatialDimensions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getSpatialDimensions" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (unsigned int)((Compartment const *)arg1)->getSpatialDimensions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getSpatialDimensionsAsDouble(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getSpatialDimensionsAsDouble",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getSpatialDimensionsAsDouble" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getSpatialDimensionsAsDouble();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getSize" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getSize();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getVolume" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getVolume();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getUnits" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getOutside",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getOutside" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getOutside();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getConstant" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetId" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetName" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetCompartmentType" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetCompartmentType();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetSize" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetSize();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetVolume" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetVolume();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetUnits" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetOutside",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetOutside" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetOutside();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetSpatialDimensions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetSpatialDimensions" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetSpatialDimensions();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetConstant" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setId" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setName" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setCompartmentType" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSpatialDimensions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setSpatialDimensions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setSpatialDimensions" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setSpatialDimensions" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSpatialDimensions(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSpatialDimensions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setSpatialDimensions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setSpatialDimensions" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setSpatialDimensions" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setSpatialDimensions(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSpatialDimensions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Compartment_setSpatialDimensions__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Compartment_setSpatialDimensions__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Compartment_setSpatialDimensions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setSpatialDimensions(Compartment *,unsigned int)\n"
    "    setSpatialDimensions(Compartment *,double)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setSize",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setSize" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setSize" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setSize(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setVolume",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setVolume" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setVolume" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setVolume(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setUnits" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setOutside",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setOutside" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setOutside" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setOutside" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setOutside((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setConstant" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetName" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetCompartmentType" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetCompartmentType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetSize" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetSize();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetVolume" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetVolume();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetUnits" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetOutside",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetOutside" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetOutside();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetSpatialDimensions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetSpatialDimensions" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetSpatialDimensions();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getDerivedUnitDefinition" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getDerivedUnitDefinition" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (UnitDefinition *)((Compartment const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Compartment_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Compartment_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Compartment_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Compartment *)\n"
    "    getDerivedUnitDefinition(Compartment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getTypeCode" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (SBMLTypeCode_t)((Compartment const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getElementName" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_hasRequiredAttributes" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Compartment_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Compartment, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfCompartments_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_clone" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (ListOfCompartments *)((ListOfCompartments const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_getTypeCode" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartments const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_getItemTypeCode" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartments const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_getElementName" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (std::string *) &((ListOfCompartments const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)((ListOfCompartments const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)((ListOfCompartments const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartments_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfCompartments *,unsigned int)\n"
    "    get(ListOfCompartments const *,unsigned int)\n"
    "    get(ListOfCompartments *,std::string const &)\n"
    "    get(ListOfCompartments const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_remove" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartments_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_remove" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartments_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfCompartments *,unsigned int)\n"
    "    remove(ListOfCompartments *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfCompartments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfCompartments")) SWIG_fail;
  result = (ListOfCompartments *)new ListOfCompartments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfCompartments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfCompartments" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfCompartments_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfCompartments, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Species__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Species",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Species" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Species" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Species *)new Species(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Species__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Species",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Species" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Species *)new Species(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Species(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Species",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Species" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Species__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Species",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Species,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Species" "', argument " "1"" of type '" "Species const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Species" "', argument " "1"" of type '" "Species const &""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    try {
      result = (Species *)new Species((Species const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Species(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Species__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Species__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Species__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Species'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Species(unsigned int,unsigned int)\n"
    "    Species(SBMLNamespaces *)\n"
    "    Species(Species const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_clone" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (Species *)((Species const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_initDefaults" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getId" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getName" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getSpeciesType" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSpeciesType();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getCompartment" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getCompartment();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getInitialAmount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getInitialAmount" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (double)((Species const *)arg1)->getInitialAmount();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getInitialConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getInitialConcentration" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (double)((Species const *)arg1)->getInitialConcentration();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getSubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSubstanceUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getSpatialSizeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getSpatialSizeUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSpatialSizeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getHasOnlySubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getHasOnlySubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getHasOnlySubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getHasOnlySubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getBoundaryCondition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getBoundaryCondition" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getBoundaryCondition();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getCharge",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getCharge" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)((Species const *)arg1)->getCharge();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getConstant" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getConversionFactor" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getConversionFactor();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetId" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetName" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetSpeciesType" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSpeciesType();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetCompartment" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetCompartment();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetInitialAmount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetInitialAmount" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetInitialAmount();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetInitialConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetInitialConcentration" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetInitialConcentration();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetSubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetSpatialSizeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetSpatialSizeUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSpatialSizeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetCharge",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetCharge" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetCharge();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetConversionFactor" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetConversionFactor();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetBoundaryCondition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetBoundaryCondition" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetBoundaryCondition();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetHasOnlySubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetHasOnlySubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetHasOnlySubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetHasOnlySubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetConstant" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setId" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setName" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setSpeciesType" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setCompartment" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartment((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setInitialAmount",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setInitialAmount" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setInitialAmount" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setInitialAmount(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setInitialConcentration",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setInitialConcentration" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setInitialConcentration" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setInitialConcentration(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setSubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setSubstanceUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setSpatialSizeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setSpatialSizeUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setSpatialSizeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setSpatialSizeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpatialSizeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setHasOnlySubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setHasOnlySubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setHasOnlySubstanceUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setHasOnlySubstanceUnits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setHasOnlySubstanceUnits(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setBoundaryCondition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setBoundaryCondition" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setBoundaryCondition" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setBoundaryCondition(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setCharge",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setCharge" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setCharge(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setConstant" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setConversionFactor",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setConversionFactor" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setConversionFactor((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetName" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetSpeciesType" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSpeciesType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetInitialAmount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetInitialAmount" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetInitialAmount();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetInitialConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetInitialConcentration" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetInitialConcentration();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetSubstanceUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetSpatialSizeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetSpatialSizeUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSpatialSizeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetCharge",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetCharge" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetCharge();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetConversionFactor" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetConversionFactor();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getDerivedUnitDefinition" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getDerivedUnitDefinition" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (UnitDefinition *)((Species const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Species_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Species_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Species_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Species *)\n"
    "    getDerivedUnitDefinition(Species const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getTypeCode" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (SBMLTypeCode_t)((Species const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getElementName" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_hasRequiredAttributes" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Species_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Species, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfSpecies_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_clone" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (ListOfSpecies *)((ListOfSpecies const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_getTypeCode" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpecies const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_getItemTypeCode" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpecies const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_getElementName" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (std::string *) &((ListOfSpecies const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)((ListOfSpecies const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)((ListOfSpecies const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpecies_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfSpecies *,unsigned int)\n"
    "    get(ListOfSpecies const *,unsigned int)\n"
    "    get(ListOfSpecies *,std::string const &)\n"
    "    get(ListOfSpecies const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_remove" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpecies_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_remove" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpecies_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpecies_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpecies_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfSpecies *,unsigned int)\n"
    "    remove(ListOfSpecies *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfSpecies")) SWIG_fail;
  result = (ListOfSpecies *)new ListOfSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfSpecies" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfSpecies_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfSpecies, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Parameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Parameter",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Parameter" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Parameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Parameter *)new Parameter(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Parameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Parameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Parameter" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Parameter *)new Parameter(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Parameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Parameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Parameter" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Parameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Parameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Parameter,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Parameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Parameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    try {
      result = (Parameter *)new Parameter((Parameter const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Parameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Parameter__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Parameter__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Parameter__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Parameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Parameter(unsigned int,unsigned int)\n"
    "    Parameter(SBMLNamespaces *)\n"
    "    Parameter(Parameter const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_clone" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (Parameter *)((Parameter const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_initDefaults" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getId" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getName" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getValue" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (double)((Parameter const *)arg1)->getValue();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getUnits" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getConstant" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetId" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetName" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetValue" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetValue();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetUnits" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetConstant" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setId" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setName" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValue" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setUnits" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setConstant" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_unsetName" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_unsetValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_unsetValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_unsetValue" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetValue();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_unsetUnits" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (UnitDefinition *)((Parameter const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Parameter_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Parameter_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Parameter_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Parameter *)\n"
    "    getDerivedUnitDefinition(Parameter const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getTypeCode" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (SBMLTypeCode_t)((Parameter const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getElementName" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_hasRequiredAttributes" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Parameter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Parameter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfParameters_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_clone" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (ListOfParameters *)((ListOfParameters const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_getTypeCode" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfParameters const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_getItemTypeCode" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfParameters const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_getElementName" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (std::string *) &((ListOfParameters const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((ListOfParameters const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((ListOfParameters const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfParameters_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfParameters *,unsigned int)\n"
    "    get(ListOfParameters const *,unsigned int)\n"
    "    get(ListOfParameters *,std::string const &)\n"
    "    get(ListOfParameters const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_remove" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfParameters_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_remove" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfParameters_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfParameters *,unsigned int)\n"
    "    remove(ListOfParameters *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfParameters")) SWIG_fail;
  result = (ListOfParameters *)new ListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfParameters" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfParameters_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfParameters, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_LocalParameter",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_LocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (LocalParameter *)new LocalParameter(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_LocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LocalParameter" "', argument " "1"" of type '" "LocalParameter *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_LocalParameter,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "LocalParameter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LocalParameter" "', argument " "1"" of type '" "LocalParameter const &""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter((LocalParameter const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Parameter,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LocalParameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter((Parameter const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_3(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_LocalParameter__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_LocalParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    LocalParameter(unsigned int,unsigned int)\n"
    "    LocalParameter(SBMLNamespaces *)\n"
    "    LocalParameter(LocalParameter const &)\n"
    "    LocalParameter(Parameter const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_clone" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (LocalParameter *)((LocalParameter const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "LocalParameter *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (UnitDefinition *)((LocalParameter const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LocalParameter_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LocalParameter_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'LocalParameter_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(LocalParameter *)\n"
    "    getDerivedUnitDefinition(LocalParameter const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getTypeCode" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (SBMLTypeCode_t)((LocalParameter const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getElementName" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (std::string *) &((LocalParameter const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_hasRequiredAttributes" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (bool)((LocalParameter const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *LocalParameter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_LocalParameter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfLocalParameters_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_clone" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (ListOfLocalParameters *)((ListOfLocalParameters const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_getTypeCode" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfLocalParameters const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_getItemTypeCode" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfLocalParameters const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_getElementName" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (std::string *) &((ListOfLocalParameters const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)((ListOfLocalParameters const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)((ListOfLocalParameters const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfLocalParameters_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfLocalParameters *,unsigned int)\n"
    "    get(ListOfLocalParameters const *,unsigned int)\n"
    "    get(ListOfLocalParameters *,std::string const &)\n"
    "    get(ListOfLocalParameters const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_remove" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfLocalParameters_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_remove" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfLocalParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfLocalParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfLocalParameters_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfLocalParameters *,unsigned int)\n"
    "    remove(ListOfLocalParameters *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfLocalParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfLocalParameters")) SWIG_fail;
  result = (ListOfLocalParameters *)new ListOfLocalParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfLocalParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfLocalParameters" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfLocalParameters_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfLocalParameters, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_InitialAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_InitialAssignment",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InitialAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_InitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InitialAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_InitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InitialAssignment" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InitialAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_InitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_InitialAssignment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "InitialAssignment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "InitialAssignment const &""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment((InitialAssignment const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InitialAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InitialAssignment__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InitialAssignment__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_InitialAssignment__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_InitialAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    InitialAssignment(unsigned int,unsigned int)\n"
    "    InitialAssignment(SBMLNamespaces *)\n"
    "    InitialAssignment(InitialAssignment const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_clone" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (InitialAssignment *)((InitialAssignment const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getSymbol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getSymbol",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getSymbol" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (std::string *) &((InitialAssignment const *)arg1)->getSymbol();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getMath" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (ASTNode *)((InitialAssignment const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_isSetSymbol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_isSetSymbol",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_isSetSymbol" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->isSetSymbol();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_isSetMath" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_setSymbol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:InitialAssignment_setSymbol",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_setSymbol" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InitialAssignment_setSymbol" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InitialAssignment_setSymbol" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSymbol((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:InitialAssignment_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_setMath" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InitialAssignment_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (UnitDefinition *)((InitialAssignment const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'InitialAssignment_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(InitialAssignment *)\n"
    "    getDerivedUnitDefinition(InitialAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'InitialAssignment_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(InitialAssignment *)\n"
    "    containsUndeclaredUnits(InitialAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getTypeCode" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (SBMLTypeCode_t)((InitialAssignment const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getElementName" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (std::string *) &((InitialAssignment const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_hasRequiredAttributes" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_hasRequiredElements" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getId" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = ((InitialAssignment const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InitialAssignment_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_InitialAssignment, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_clone" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (ListOfInitialAssignments *)((ListOfInitialAssignments const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_getTypeCode" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfInitialAssignments const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_getItemTypeCode" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfInitialAssignments const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_getElementName" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (std::string *) &((ListOfInitialAssignments const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)((ListOfInitialAssignments const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)((ListOfInitialAssignments const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfInitialAssignments_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfInitialAssignments *,unsigned int)\n"
    "    get(ListOfInitialAssignments const *,unsigned int)\n"
    "    get(ListOfInitialAssignments *,std::string const &)\n"
    "    get(ListOfInitialAssignments const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_remove" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfInitialAssignments_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_remove" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfInitialAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfInitialAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfInitialAssignments_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfInitialAssignments *,unsigned int)\n"
    "    remove(ListOfInitialAssignments *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfInitialAssignments")) SWIG_fail;
  result = (ListOfInitialAssignments *)new ListOfInitialAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfInitialAssignments" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfInitialAssignments_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfInitialAssignments, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Rule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Rule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Rule" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Rule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Rule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Rule,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Rule" "', argument " "1"" of type '" "Rule const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Rule" "', argument " "1"" of type '" "Rule const &""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (Rule *)new Rule((Rule const &)*arg1);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_NEW |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_clone" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (Rule *)((Rule const *)arg1)->clone();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getFormula" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getFormula();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getMath" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (ASTNode *)((Rule const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getVariable" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getVariable();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getUnits" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetFormula" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetFormula();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetMath" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetVariable" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetVariable();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetUnits" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setFormula",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setFormula" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rule_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFormula((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setMath" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setVariable",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setVariable" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rule_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVariable((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setUnits" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rule_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_unsetUnits" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getDerivedUnitDefinition" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getDerivedUnitDefinition" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (UnitDefinition *)((Rule const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Rule_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Rule *)\n"
    "    getDerivedUnitDefinition(Rule const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_containsUndeclaredUnits" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_containsUndeclaredUnits" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Rule_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(Rule *)\n"
    "    containsUndeclaredUnits(Rule const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RuleType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getType" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (RuleType_t)((Rule const *)arg1)->getType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isAlgebraic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isAlgebraic",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isAlgebraic" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isAlgebraic();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isAssignment" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isAssignment();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isCompartmentVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isCompartmentVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isCompartmentVolume" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isCompartmentVolume();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isParameter" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isParameter();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isRate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isRate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isRate" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isRate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isScalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isScalar",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isScalar" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isScalar();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSpeciesConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSpeciesConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSpeciesConcentration" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSpeciesConcentration();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getTypeCode" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (SBMLTypeCode_t)((Rule const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getL1TypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getL1TypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getL1TypeCode" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (SBMLTypeCode_t)((Rule const *)arg1)->getL1TypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getElementName" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setL1TypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  SBMLTypeCode_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setL1TypeCode",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setL1TypeCode" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Rule_setL1TypeCode" "', argument " "2"" of type '" "SBMLTypeCode_t""'");
  } 
  arg2 = static_cast< SBMLTypeCode_t >(val2);
  result = (int)(arg1)->setL1TypeCode(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_hasRequiredElements" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_hasRequiredAttributes" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getId" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = ((Rule const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Rule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Rule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_AlgebraicRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_AlgebraicRule",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_AlgebraicRule" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_AlgebraicRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (AlgebraicRule *)new AlgebraicRule(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AlgebraicRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_AlgebraicRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AlgebraicRule" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (AlgebraicRule *)new AlgebraicRule(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AlgebraicRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AlgebraicRule__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_AlgebraicRule__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_AlgebraicRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    AlgebraicRule(unsigned int,unsigned int)\n"
    "    AlgebraicRule(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_AlgebraicRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_AlgebraicRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AlgebraicRule" "', argument " "1"" of type '" "AlgebraicRule *""'"); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AlgebraicRule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AlgebraicRule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AlgebraicRule_clone" "', argument " "1"" of type '" "AlgebraicRule const *""'"); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  result = (AlgebraicRule *)((AlgebraicRule const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AlgebraicRule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AlgebraicRule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AlgebraicRule_hasRequiredAttributes" "', argument " "1"" of type '" "AlgebraicRule const *""'"); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  result = (bool)((AlgebraicRule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *AlgebraicRule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_AlgebraicRule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_AssignmentRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_AssignmentRule",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_AssignmentRule" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_AssignmentRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (AssignmentRule *)new AssignmentRule(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AssignmentRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_AssignmentRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AssignmentRule" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (AssignmentRule *)new AssignmentRule(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AssignmentRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AssignmentRule__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_AssignmentRule__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_AssignmentRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    AssignmentRule(unsigned int,unsigned int)\n"
    "    AssignmentRule(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_AssignmentRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_AssignmentRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AssignmentRule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AssignmentRule" "', argument " "1"" of type '" "AssignmentRule *""'"); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AssignmentRule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AssignmentRule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AssignmentRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignmentRule_clone" "', argument " "1"" of type '" "AssignmentRule const *""'"); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  result = (AssignmentRule *)((AssignmentRule const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AssignmentRule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AssignmentRule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AssignmentRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignmentRule_hasRequiredAttributes" "', argument " "1"" of type '" "AssignmentRule const *""'"); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  result = (bool)((AssignmentRule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *AssignmentRule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_AssignmentRule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_RateRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_RateRule",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_RateRule" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_RateRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (RateRule *)new RateRule(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_RateRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_RateRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RateRule" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (RateRule *)new RateRule(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_RateRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RateRule__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_RateRule__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_RateRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    RateRule(unsigned int,unsigned int)\n"
    "    RateRule(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RateRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_RateRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RateRule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RateRule" "', argument " "1"" of type '" "RateRule *""'"); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RateRule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RateRule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RateRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RateRule_clone" "', argument " "1"" of type '" "RateRule const *""'"); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  result = (RateRule *)((RateRule const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RateRule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RateRule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RateRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RateRule_hasRequiredAttributes" "', argument " "1"" of type '" "RateRule const *""'"); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  result = (bool)((RateRule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RateRule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_RateRule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfRules_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_clone" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (ListOfRules *)((ListOfRules const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_getTypeCode" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (SBMLTypeCode_t)((ListOfRules const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_getItemTypeCode" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (SBMLTypeCode_t)((ListOfRules const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_getElementName" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (std::string *) &((ListOfRules const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)((ListOfRules const *)arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)((ListOfRules const *)arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfRules_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfRules *,unsigned int)\n"
    "    get(ListOfRules const *,unsigned int)\n"
    "    get(ListOfRules *,std::string const &)\n"
    "    get(ListOfRules const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_remove" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfRules_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->remove(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_remove" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfRules_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfRules_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->remove((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfRules_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfRules *,unsigned int)\n"
    "    remove(ListOfRules *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfRules(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfRules")) SWIG_fail;
  result = (ListOfRules *)new ListOfRules();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfRules(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfRules" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfRules_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfRules, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Constraint__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Constraint",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Constraint" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Constraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Constraint *)new Constraint(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Constraint__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Constraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Constraint" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Constraint *)new Constraint(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Constraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Constraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Constraint" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Constraint__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Constraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Constraint,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Constraint" "', argument " "1"" of type '" "Constraint const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Constraint" "', argument " "1"" of type '" "Constraint const &""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  {
    try {
      result = (Constraint *)new Constraint((Constraint const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Constraint(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Constraint__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Constraint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Constraint__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Constraint__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Constraint'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Constraint(unsigned int,unsigned int)\n"
    "    Constraint(SBMLNamespaces *)\n"
    "    Constraint(Constraint const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_clone" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (Constraint *)((Constraint const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getMessage" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (XMLNode *)((Constraint const *)arg1)->getMessage();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getMessageString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getMessageString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getMessageString" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = ((Constraint const *)arg1)->getMessageString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getMath" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (ASTNode *)((Constraint const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_isSetMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_isSetMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_isSetMessage" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->isSetMessage();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_isSetMath" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_setMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Constraint_setMessage",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_setMessage" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Constraint_setMessage" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setMessage((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Constraint_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_setMath" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Constraint_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_unsetMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_unsetMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_unsetMessage" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (int)(arg1)->unsetMessage();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getTypeCode" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (SBMLTypeCode_t)((Constraint const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getElementName" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (std::string *) &((Constraint const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_hasRequiredElements" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Constraint_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Constraint, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfConstraints_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_clone" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (ListOfConstraints *)((ListOfConstraints const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_getTypeCode" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (SBMLTypeCode_t)((ListOfConstraints const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_getItemTypeCode" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (SBMLTypeCode_t)((ListOfConstraints const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_getElementName" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (std::string *) &((ListOfConstraints const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfConstraints_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_get" "', argument " "1"" of type '" "ListOfConstraints *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfConstraints_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfConstraints_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_get" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfConstraints_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)((ListOfConstraints const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfConstraints, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfConstraints_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfConstraints, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfConstraints_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfConstraints_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfConstraints *,unsigned int)\n"
    "    get(ListOfConstraints const *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfConstraints_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_remove" "', argument " "1"" of type '" "ListOfConstraints *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfConstraints_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfConstraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfConstraints")) SWIG_fail;
  result = (ListOfConstraints *)new ListOfConstraints();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfConstraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfConstraints" "', argument " "1"" of type '" "ListOfConstraints *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfConstraints_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfConstraints, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Reaction__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Reaction",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Reaction" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Reaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Reaction *)new Reaction(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Reaction__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Reaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Reaction" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Reaction *)new Reaction(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Reaction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Reaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Reaction" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Reaction__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Reaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Reaction,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Reaction" "', argument " "1"" of type '" "Reaction const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Reaction" "', argument " "1"" of type '" "Reaction const &""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    try {
      result = (Reaction *)new Reaction((Reaction const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Reaction(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Reaction__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Reaction__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Reaction__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Reaction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Reaction(unsigned int,unsigned int)\n"
    "    Reaction(SBMLNamespaces *)\n"
    "    Reaction(Reaction const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_clone" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (Reaction *)((Reaction const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_initDefaults" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getId" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getName" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getKineticLaw__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getKineticLaw" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)((Reaction const *)arg1)->getKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getKineticLaw__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)(arg1)->getKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getKineticLaw(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getKineticLaw__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getKineticLaw__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getKineticLaw'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getKineticLaw(Reaction const *)\n"
    "    getKineticLaw(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReversible(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getReversible",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReversible" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->getReversible();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getFast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getFast" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->getFast();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getCompartment" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getCompartment();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetId" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetName" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetKineticLaw" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetKineticLaw();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetFast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetFast" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetFast();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetCompartment" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetCompartment();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetReversible(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetReversible",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetReversible" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetReversible();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setId" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setName" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  KineticLaw *arg2 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setKineticLaw",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setKineticLaw" "', argument " "2"" of type '" "KineticLaw const *""'"); 
  }
  arg2 = reinterpret_cast< KineticLaw * >(argp2);
  result = (int)(arg1)->setKineticLaw((KineticLaw const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setReversible(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setReversible",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setReversible" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_setReversible" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setReversible(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setFast",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setFast" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_setFast" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setFast(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setCompartment" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartment((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetName" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetKineticLaw();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetFast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetFast" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetFast();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetCompartment" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetCompartment();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_addReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  SpeciesReference *arg2 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_addReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_addReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_addReactant" "', argument " "2"" of type '" "SpeciesReference const *""'"); 
  }
  arg2 = reinterpret_cast< SpeciesReference * >(argp2);
  result = (int)(arg1)->addReactant((SpeciesReference const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_addProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  SpeciesReference *arg2 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_addProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_addProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_addProduct" "', argument " "2"" of type '" "SpeciesReference const *""'"); 
  }
  arg2 = reinterpret_cast< SpeciesReference * >(argp2);
  result = (int)(arg1)->addProduct((SpeciesReference const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_addModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  ModifierSpeciesReference *arg2 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_addModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_addModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_addModifier" "', argument " "2"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg2 = reinterpret_cast< ModifierSpeciesReference * >(argp2);
  result = (int)(arg1)->addModifier((ModifierSpeciesReference const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createReactant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SpeciesReference *)(arg1)->createReactant();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createProduct",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SpeciesReference *)(arg1)->createProduct();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createModifier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ModifierSpeciesReference *)(arg1)->createModifier();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)(arg1)->createKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfReactants__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfReactants",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfReactants" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfReactants();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfReactants__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfReactants",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfReactants" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfReactants();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfReactants(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfReactants__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfReactants__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getListOfReactants'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfReactants(Reaction const *)\n"
    "    getListOfReactants(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfProducts__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfProducts",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfProducts" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfProducts();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfProducts__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfProducts",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfProducts" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfProducts();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfProducts(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfProducts__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfProducts__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getListOfProducts'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfProducts(Reaction const *)\n"
    "    getListOfProducts(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfModifiers__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfModifiers" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfModifiers();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfModifiers__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfModifiers" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfModifiers();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfModifiers(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfModifiers__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfModifiers__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getListOfModifiers'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfModifiers(Reaction const *)\n"
    "    getListOfModifiers(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)((Reaction const *)arg1)->getReactant(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->getReactant(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Reaction const *)arg1)->getReactant((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getReactant((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getReactant'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getReactant(Reaction const *,unsigned int)\n"
    "    getReactant(Reaction *,unsigned int)\n"
    "    getReactant(Reaction const *,std::string const &)\n"
    "    getReactant(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)((Reaction const *)arg1)->getProduct(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->getProduct(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Reaction const *)arg1)->getProduct((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getProduct((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getProduct'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getProduct(Reaction const *,unsigned int)\n"
    "    getProduct(Reaction *,unsigned int)\n"
    "    getProduct(Reaction const *,std::string const &)\n"
    "    getProduct(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)((Reaction const *)arg1)->getModifier(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)(arg1)->getModifier(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)((Reaction const *)arg1)->getModifier((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)(arg1)->getModifier((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getModifier'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModifier(Reaction const *,unsigned int)\n"
    "    getModifier(Reaction *,unsigned int)\n"
    "    getModifier(Reaction const *,std::string const &)\n"
    "    getModifier(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getNumReactants(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getNumReactants",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getNumReactants" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumReactants();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getNumProducts(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getNumProducts",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getNumProducts" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumProducts();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getNumModifiers(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getNumModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getNumModifiers" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumModifiers();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeReactant__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_removeReactant" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->removeReactant(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeReactant__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_removeReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_removeReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->removeReactant((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeReactant(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeReactant__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeReactant__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_removeReactant'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeReactant(Reaction *,unsigned int)\n"
    "    removeReactant(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeProduct__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_removeProduct" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->removeProduct(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeProduct__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_removeProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_removeProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->removeProduct((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeProduct(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeProduct__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeProduct__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_removeProduct'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeProduct(Reaction *,unsigned int)\n"
    "    removeProduct(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeModifier__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_removeModifier" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)(arg1)->removeModifier(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeModifier__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_removeModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_removeModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)(arg1)->removeModifier((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeModifier(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeModifier__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeModifier__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_removeModifier'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeModifier(Reaction *,unsigned int)\n"
    "    removeModifier(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getTypeCode" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SBMLTypeCode_t)((Reaction const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getElementName" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_hasRequiredAttributes" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Reaction_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Reaction, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfReactions_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_clone" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (ListOfReactions *)((ListOfReactions const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_getTypeCode" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfReactions const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_getItemTypeCode" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfReactions const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_getElementName" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (std::string *) &((ListOfReactions const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)((ListOfReactions const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)((ListOfReactions const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfReactions_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfReactions *,unsigned int)\n"
    "    get(ListOfReactions const *,unsigned int)\n"
    "    get(ListOfReactions *,std::string const &)\n"
    "    get(ListOfReactions const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_remove" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfReactions_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_remove" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfReactions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfReactions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfReactions_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfReactions *,unsigned int)\n"
    "    remove(ListOfReactions *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfReactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfReactions")) SWIG_fail;
  result = (ListOfReactions *)new ListOfReactions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfReactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfReactions" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfReactions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfReactions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_KineticLaw__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_KineticLaw",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_KineticLaw" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_KineticLaw" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (KineticLaw *)new KineticLaw(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_KineticLaw__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_KineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_KineticLaw" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (KineticLaw *)new KineticLaw(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_KineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_KineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_KineticLaw" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_KineticLaw__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_KineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_KineticLaw,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_KineticLaw" "', argument " "1"" of type '" "KineticLaw const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KineticLaw" "', argument " "1"" of type '" "KineticLaw const &""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    try {
      result = (KineticLaw *)new KineticLaw((KineticLaw const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_KineticLaw(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_KineticLaw__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_KineticLaw__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_KineticLaw__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_KineticLaw'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    KineticLaw(unsigned int,unsigned int)\n"
    "    KineticLaw(SBMLNamespaces *)\n"
    "    KineticLaw(KineticLaw const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_clone" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (KineticLaw *)((KineticLaw const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getFormula" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getFormula();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getMath" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ASTNode *)((KineticLaw const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getTimeUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getTimeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getSubstanceUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getSubstanceUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetFormula" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetFormula();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetMath" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetTimeUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetTimeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetSubstanceUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetSubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setFormula",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setFormula" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFormula((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setMath" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setTimeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setTimeUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setSubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setSubstanceUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_unsetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_unsetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_unsetTimeUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_unsetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_unsetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_unsetSubstanceUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_addParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  Parameter *arg2 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_addParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_addParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_addParameter" "', argument " "2"" of type '" "Parameter const *""'"); 
  }
  arg2 = reinterpret_cast< Parameter * >(argp2);
  result = (int)(arg1)->addParameter((Parameter const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_addLocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  LocalParameter *arg2 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_addLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_addLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_addLocalParameter" "', argument " "2"" of type '" "LocalParameter const *""'"); 
  }
  arg2 = reinterpret_cast< LocalParameter * >(argp2);
  result = (int)(arg1)->addLocalParameter((LocalParameter const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_createParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_createParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_createParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (Parameter *)(arg1)->createParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_createLocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_createLocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_createLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (LocalParameter *)(arg1)->createLocalParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfParameters__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfParameters *)((KineticLaw const *)arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfParameters__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfParameters" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfParameters *)(arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfParameters(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfParameters__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfParameters__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getListOfParameters'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfParameters(KineticLaw const *)\n"
    "    getListOfParameters(KineticLaw *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfLocalParameters__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfLocalParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfLocalParameters *)((KineticLaw const *)arg1)->getListOfLocalParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfLocalParameters__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfLocalParameters" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfLocalParameters *)(arg1)->getListOfLocalParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfLocalParameters(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfLocalParameters__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfLocalParameters__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getListOfLocalParameters'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfLocalParameters(KineticLaw const *)\n"
    "    getListOfLocalParameters(KineticLaw *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((KineticLaw const *)arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)((KineticLaw const *)arg1)->getLocalParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->getLocalParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((KineticLaw const *)arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getParameter(KineticLaw const *,unsigned int)\n"
    "    getParameter(KineticLaw *,unsigned int)\n"
    "    getParameter(KineticLaw const *,std::string const &)\n"
    "    getParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)((KineticLaw const *)arg1)->getLocalParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->getLocalParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getLocalParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getLocalParameter(KineticLaw const *,unsigned int)\n"
    "    getLocalParameter(KineticLaw *,unsigned int)\n"
    "    getLocalParameter(KineticLaw const *,std::string const &)\n"
    "    getLocalParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getNumParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getNumParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getNumParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (unsigned int)((KineticLaw const *)arg1)->getNumParameters();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getNumLocalParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getNumLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getNumLocalParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (unsigned int)((KineticLaw const *)arg1)->getNumLocalParameters();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getDerivedUnitDefinition" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getDerivedUnitDefinition" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (UnitDefinition *)((KineticLaw const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(KineticLaw *)\n"
    "    getDerivedUnitDefinition(KineticLaw const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_containsUndeclaredUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_containsUndeclaredUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(KineticLaw *)\n"
    "    containsUndeclaredUnits(KineticLaw const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_removeParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->removeParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeLocalParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_removeLocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->removeLocalParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->removeParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_removeParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_removeParameter__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_removeParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeParameter(KineticLaw *,unsigned int)\n"
    "    removeParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeLocalParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_removeLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_removeLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->removeLocalParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeLocalParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_removeLocalParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_removeLocalParameter__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_removeLocalParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeLocalParameter(KineticLaw *,unsigned int)\n"
    "    removeLocalParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getTypeCode" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (SBMLTypeCode_t)((KineticLaw const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getElementName" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_hasRequiredAttributes" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_hasRequiredElements" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *KineticLaw_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_KineticLaw, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_SimpleSpeciesReference(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SimpleSpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SimpleSpeciesReference" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_getId" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_getName" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_getSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_getSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_getSpecies" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getSpecies();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isSetId" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isSetName" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isSetSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isSetSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isSetSpecies" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetSpecies();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_setSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SimpleSpeciesReference_setSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_setSpecies" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SimpleSpeciesReference_setSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SimpleSpeciesReference_setSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpecies((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SimpleSpeciesReference_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_setId" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SimpleSpeciesReference_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SimpleSpeciesReference_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SimpleSpeciesReference_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_setName" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SimpleSpeciesReference_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SimpleSpeciesReference_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_unsetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_unsetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_unsetId" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (int)(arg1)->unsetId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_unsetName" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isModifier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isModifier" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isModifier();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SimpleSpeciesReference_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SimpleSpeciesReference, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SpeciesReference__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SpeciesReference",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SpeciesReference" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesReference__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SpeciesReference(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SpeciesReference" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesReference__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SpeciesReference,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "SpeciesReference const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "SpeciesReference const &""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference((SpeciesReference const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesReference(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesReference__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesReference__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SpeciesReference__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SpeciesReference'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SpeciesReference(unsigned int,unsigned int)\n"
    "    SpeciesReference(SBMLNamespaces *)\n"
    "    SpeciesReference(SpeciesReference const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_clone" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (SpeciesReference *)((SpeciesReference const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_initDefaults" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getStoichiometry" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (double)((SpeciesReference const *)arg1)->getStoichiometry();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometryMath__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)((SpeciesReference const *)arg1)->getStoichiometryMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometryMath__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)(arg1)->getStoichiometryMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometryMath(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SpeciesReference_getStoichiometryMath__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SpeciesReference_getStoichiometryMath__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SpeciesReference_getStoichiometryMath'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getStoichiometryMath(SpeciesReference const *)\n"
    "    getStoichiometryMath(SpeciesReference *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getDenominator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getDenominator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getDenominator" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)((SpeciesReference const *)arg1)->getDenominator();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getConstant" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_isSetStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_isSetStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_isSetStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetStoichiometryMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_isSetConstant" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_isSetStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_isSetStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_isSetStoichiometry" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetStoichiometry();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setStoichiometry",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setStoichiometry" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpeciesReference_setStoichiometry" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setStoichiometry(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  StoichiometryMath *arg2 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setStoichiometryMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_setStoichiometryMath" "', argument " "2"" of type '" "StoichiometryMath const *""'"); 
  }
  arg2 = reinterpret_cast< StoichiometryMath * >(argp2);
  result = (int)(arg1)->setStoichiometryMath((StoichiometryMath const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setDenominator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setDenominator",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setDenominator" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpeciesReference_setDenominator" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setDenominator(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setConstant" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpeciesReference_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_unsetStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_unsetStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_unsetStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)(arg1)->unsetStoichiometryMath();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_unsetStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_unsetStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_unsetStoichiometry" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)(arg1)->unsetStoichiometry();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_createStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_createStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_createStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)(arg1)->createStoichiometryMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_setAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesReference_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_setAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_setAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SpeciesReference_setAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setAnnotation(SpeciesReference *,XMLNode const *)\n"
    "    setAnnotation(SpeciesReference *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_appendAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_appendAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_appendAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_appendAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_appendAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesReference_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_appendAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_appendAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_appendAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SpeciesReference_appendAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendAnnotation(SpeciesReference *,XMLNode const *)\n"
    "    appendAnnotation(SpeciesReference *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getTypeCode" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (SBMLTypeCode_t)((SpeciesReference const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getElementName" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (std::string *) &((SpeciesReference const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_initL2Stoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_initL2Stoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_initL2Stoichiometry" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  (arg1)->initL2Stoichiometry();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_hasRequiredAttributes" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SpeciesReference_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SpeciesReference, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ModifierSpeciesReference__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_ModifierSpeciesReference",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ModifierSpeciesReference" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_ModifierSpeciesReference" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (ModifierSpeciesReference *)new ModifierSpeciesReference(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModifierSpeciesReference__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModifierSpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModifierSpeciesReference" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (ModifierSpeciesReference *)new ModifierSpeciesReference(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModifierSpeciesReference(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModifierSpeciesReference__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ModifierSpeciesReference__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ModifierSpeciesReference'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ModifierSpeciesReference(unsigned int,unsigned int)\n"
    "    ModifierSpeciesReference(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModifierSpeciesReference(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModifierSpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModifierSpeciesReference" "', argument " "1"" of type '" "ModifierSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_clone" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (ModifierSpeciesReference *)((ModifierSpeciesReference const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_getTypeCode" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (SBMLTypeCode_t)((ModifierSpeciesReference const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_getElementName" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (std::string *) &((ModifierSpeciesReference const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_hasRequiredAttributes" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (bool)((ModifierSpeciesReference const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModifierSpeciesReference_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ModifierSpeciesReference, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ListOfSpeciesReferences(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfSpeciesReferences")) SWIG_fail;
  result = (ListOfSpeciesReferences *)new ListOfSpeciesReferences();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_clone" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (ListOfSpeciesReferences *)((ListOfSpeciesReferences const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_getTypeCode" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesReferences const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_getItemTypeCode" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesReferences const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_getElementName" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (std::string *) &((ListOfSpeciesReferences const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)(arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)((ListOfSpeciesReferences const *)arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)(arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)((ListOfSpeciesReferences const *)arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesReferences_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfSpeciesReferences *,unsigned int)\n"
    "    get(ListOfSpeciesReferences const *,unsigned int)\n"
    "    get(ListOfSpeciesReferences *,std::string const &)\n"
    "    get(ListOfSpeciesReferences const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_remove" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesReferences_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)(arg1)->remove(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_remove" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesReferences_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesReferences_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)(arg1)->remove((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesReferences_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfSpeciesReferences *,unsigned int)\n"
    "    remove(ListOfSpeciesReferences *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfSpeciesReferences(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfSpeciesReferences",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfSpeciesReferences" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfSpeciesReferences_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfSpeciesReferences, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Event__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Event",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Event" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Event" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Event *)new Event(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Event__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Event",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Event" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Event *)new Event(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Event(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Event",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Event" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Event__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Event",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Event,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Event" "', argument " "1"" of type '" "Event const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Event" "', argument " "1"" of type '" "Event const &""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    try {
      result = (Event *)new Event((Event const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Event(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Event__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Event__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Event__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Event'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Event(unsigned int,unsigned int)\n"
    "    Event(SBMLNamespaces *)\n"
    "    Event(Event const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_clone" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Event *)((Event const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getId" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getName" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTrigger__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTrigger" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)((Event const *)arg1)->getTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTrigger__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTrigger" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)(arg1)->getTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTrigger(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getTrigger__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getTrigger__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getTrigger'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getTrigger(Event const *)\n"
    "    getTrigger(Event *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getDelay__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getDelay" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)((Event const *)arg1)->getDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getDelay__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)(arg1)->getDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getDelay(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getDelay__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getDelay__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getDelay'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDelay(Event const *)\n"
    "    getDelay(Event *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTimeUnits" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getTimeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getUseValuesFromTriggerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getUseValuesFromTriggerTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getUseValuesFromTriggerTime" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->getUseValuesFromTriggerTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetId" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetName" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetTrigger" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetTrigger();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetDelay" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetDelay();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetTimeUnits" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetTimeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetUseValuesFromTriggerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetUseValuesFromTriggerTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetUseValuesFromTriggerTime" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetUseValuesFromTriggerTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setId" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setName" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  Trigger *arg2 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setTrigger",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setTrigger" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setTrigger" "', argument " "2"" of type '" "Trigger const *""'"); 
  }
  arg2 = reinterpret_cast< Trigger * >(argp2);
  result = (int)(arg1)->setTrigger((Trigger const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  Delay *arg2 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setDelay",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setDelay" "', argument " "2"" of type '" "Delay const *""'"); 
  }
  arg2 = reinterpret_cast< Delay * >(argp2);
  result = (int)(arg1)->setDelay((Delay const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setTimeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setTimeUnits" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setUseValuesFromTriggerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setUseValuesFromTriggerTime",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setUseValuesFromTriggerTime" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_setUseValuesFromTriggerTime" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setUseValuesFromTriggerTime(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetId" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetName" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetDelay();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetTimeUnits" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_addEventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  EventAssignment *arg2 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_addEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_addEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_addEventAssignment" "', argument " "2"" of type '" "EventAssignment const *""'"); 
  }
  arg2 = reinterpret_cast< EventAssignment * >(argp2);
  result = (int)(arg1)->addEventAssignment((EventAssignment const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_createEventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_createEventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_createEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (EventAssignment *)(arg1)->createEventAssignment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_createTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_createTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_createTrigger" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)(arg1)->createTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_createDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_createDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_createDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)(arg1)->createDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getListOfEventAssignments__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getListOfEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getListOfEventAssignments" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (ListOfEventAssignments *)((Event const *)arg1)->getListOfEventAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getListOfEventAssignments__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getListOfEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getListOfEventAssignments" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (ListOfEventAssignments *)(arg1)->getListOfEventAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getListOfEventAssignments(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getListOfEventAssignments__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getListOfEventAssignments__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getListOfEventAssignments'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfEventAssignments(Event const *)\n"
    "    getListOfEventAssignments(Event *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)((Event const *)arg1)->getEventAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->getEventAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)((Event const *)arg1)->getEventAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->getEventAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getEventAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getEventAssignment(Event const *,unsigned int)\n"
    "    getEventAssignment(Event *,unsigned int)\n"
    "    getEventAssignment(Event const *,std::string const &)\n"
    "    getEventAssignment(Event *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getNumEventAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getNumEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getNumEventAssignments" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (unsigned int)((Event const *)arg1)->getNumEventAssignments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_removeEventAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_removeEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_removeEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_removeEventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->removeEventAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_removeEventAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_removeEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_removeEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_removeEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_removeEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->removeEventAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_removeEventAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_removeEventAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_removeEventAssignment__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_removeEventAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeEventAssignment(Event *,unsigned int)\n"
    "    removeEventAssignment(Event *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTypeCode" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (SBMLTypeCode_t)((Event const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getElementName" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_hasRequiredAttributes" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_hasRequiredElements" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Event_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Event, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfEvents_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_clone" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (ListOfEvents *)((ListOfEvents const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_getTypeCode" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEvents const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_getItemTypeCode" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEvents const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_getElementName" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (std::string *) &((ListOfEvents const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)((ListOfEvents const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)((ListOfEvents const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEvents_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfEvents *,unsigned int)\n"
    "    get(ListOfEvents const *,unsigned int)\n"
    "    get(ListOfEvents *,std::string const &)\n"
    "    get(ListOfEvents const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_remove" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEvents_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_remove" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEvents_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEvents_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEvents_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfEvents *,unsigned int)\n"
    "    remove(ListOfEvents *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfEvents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfEvents")) SWIG_fail;
  result = (ListOfEvents *)new ListOfEvents();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfEvents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfEvents" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfEvents_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfEvents, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_EventAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_EventAssignment",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_EventAssignment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_EventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (EventAssignment *)new EventAssignment(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_EventAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_EventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_EventAssignment" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (EventAssignment *)new EventAssignment(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_EventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EventAssignment" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_EventAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_EventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_EventAssignment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_EventAssignment" "', argument " "1"" of type '" "EventAssignment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_EventAssignment" "', argument " "1"" of type '" "EventAssignment const &""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  {
    try {
      result = (EventAssignment *)new EventAssignment((EventAssignment const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_EventAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_EventAssignment__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_EventAssignment__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_EventAssignment__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_EventAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    EventAssignment(unsigned int,unsigned int)\n"
    "    EventAssignment(SBMLNamespaces *)\n"
    "    EventAssignment(EventAssignment const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_clone" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (EventAssignment *)((EventAssignment const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getVariable" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (std::string *) &((EventAssignment const *)arg1)->getVariable();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getMath" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (ASTNode *)((EventAssignment const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_isSetVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_isSetVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_isSetVariable" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->isSetVariable();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_isSetMath" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_setVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:EventAssignment_setVariable",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_setVariable" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventAssignment_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventAssignment_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVariable((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:EventAssignment_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_setMath" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventAssignment_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (UnitDefinition *)((EventAssignment const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'EventAssignment_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(EventAssignment *)\n"
    "    getDerivedUnitDefinition(EventAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'EventAssignment_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(EventAssignment *)\n"
    "    containsUndeclaredUnits(EventAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getTypeCode" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (SBMLTypeCode_t)((EventAssignment const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getElementName" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (std::string *) &((EventAssignment const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_hasRequiredAttributes" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_hasRequiredElements" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getId" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = ((EventAssignment const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *EventAssignment_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_EventAssignment, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfEventAssignments_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_clone" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (ListOfEventAssignments *)((ListOfEventAssignments const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_getTypeCode" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEventAssignments const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_getItemTypeCode" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEventAssignments const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_getElementName" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (std::string *) &((ListOfEventAssignments const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)((ListOfEventAssignments const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)((ListOfEventAssignments const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEventAssignments_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfEventAssignments *,unsigned int)\n"
    "    get(ListOfEventAssignments const *,unsigned int)\n"
    "    get(ListOfEventAssignments *,std::string const &)\n"
    "    get(ListOfEventAssignments const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_remove" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEventAssignments_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_remove" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEventAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEventAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEventAssignments_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfEventAssignments *,unsigned int)\n"
    "    remove(ListOfEventAssignments *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfEventAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfEventAssignments")) SWIG_fail;
  result = (ListOfEventAssignments *)new ListOfEventAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfEventAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfEventAssignments" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfEventAssignments_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfEventAssignments, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Trigger__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Trigger",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Trigger" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Trigger" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Trigger *)new Trigger(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Trigger__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Trigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Trigger" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Trigger *)new Trigger(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Trigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Trigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Trigger" "', argument " "1"" of type '" "Trigger *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Trigger__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Trigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Trigger,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Trigger" "', argument " "1"" of type '" "Trigger const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Trigger" "', argument " "1"" of type '" "Trigger const &""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  {
    try {
      result = (Trigger *)new Trigger((Trigger const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Trigger(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Trigger__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Trigger, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Trigger__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Trigger__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Trigger'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Trigger(unsigned int,unsigned int)\n"
    "    Trigger(SBMLNamespaces *)\n"
    "    Trigger(Trigger const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_clone" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (Trigger *)((Trigger const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getMath" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (ASTNode *)((Trigger const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_isSetMath" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Trigger_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_setMath" "', argument " "1"" of type '" "Trigger *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Trigger_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getTypeCode" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (SBMLTypeCode_t)((Trigger const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getElementName" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (std::string *) &((Trigger const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_hasRequiredElements" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Trigger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Trigger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Delay__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Delay",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Delay" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Delay" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Delay *)new Delay(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Delay__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Delay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Delay" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Delay *)new Delay(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Delay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Delay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Delay" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Delay__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Delay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Delay,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Delay" "', argument " "1"" of type '" "Delay const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Delay" "', argument " "1"" of type '" "Delay const &""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  {
    try {
      result = (Delay *)new Delay((Delay const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Delay(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Delay__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Delay__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Delay__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Delay'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Delay(unsigned int,unsigned int)\n"
    "    Delay(SBMLNamespaces *)\n"
    "    Delay(Delay const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_clone" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (Delay *)((Delay const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getMath" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (ASTNode *)((Delay const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_isSetMath" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Delay_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_setMath" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Delay_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getDerivedUnitDefinition" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getDerivedUnitDefinition" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (UnitDefinition *)((Delay const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Delay_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Delay *)\n"
    "    getDerivedUnitDefinition(Delay const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_containsUndeclaredUnits" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_containsUndeclaredUnits" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Delay_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(Delay *)\n"
    "    containsUndeclaredUnits(Delay const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getTypeCode" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (SBMLTypeCode_t)((Delay const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getElementName" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (std::string *) &((Delay const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_hasRequiredElements" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Delay_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Delay, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBO_isQuantitativeParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isQuantitativeParameter",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isQuantitativeParameter" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isQuantitativeParameter(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isParticipantRole(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isParticipantRole",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isParticipantRole" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isParticipantRole(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isModellingFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isModellingFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isModellingFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isModellingFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isMathematicalExpression(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isMathematicalExpression",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isMathematicalExpression" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isMathematicalExpression(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isKineticConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isKineticConstant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isKineticConstant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isKineticConstant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isReactant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isReactant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isReactant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isProduct",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isProduct" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isProduct(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isModifier",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isModifier" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isModifier(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isRateLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isRateLaw",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isRateLaw" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isRateLaw(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isEvent",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isEvent" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isEvent(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isPhysicalParticipant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isPhysicalParticipant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isPhysicalParticipant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isPhysicalParticipant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isParticipant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isParticipant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isParticipant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isParticipant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isInteraction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isInteraction",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isInteraction" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isInteraction(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isEntity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isEntity",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isEntity" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isEntity(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isFunctionalEntity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isFunctionalEntity",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isFunctionalEntity" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isFunctionalEntity(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isMaterialEntity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isMaterialEntity",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isMaterialEntity" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isMaterialEntity(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isConservationLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isConservationLaw",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isConservationLaw" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isConservationLaw(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isSteadyStateExpression(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isSteadyStateExpression",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isSteadyStateExpression" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isSteadyStateExpression(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isFunctionalCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isFunctionalCompartment",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isFunctionalCompartment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isFunctionalCompartment(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isContinuousFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isContinuousFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isContinuousFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isContinuousFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isDiscreteFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isDiscreteFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isDiscreteFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isDiscreteFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isLogicalFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isLogicalFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isLogicalFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isLogicalFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isObselete(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isObselete",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isObselete" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isObselete(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_intToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_intToString",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_intToString" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = SBO::intToString(arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_stringToInt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_stringToInt",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBO_stringToInt" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBO_stringToInt" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (int)SBO::stringToInt((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_checkTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_checkTerm",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBO_checkTerm" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBO_checkTerm" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (bool)SBO::checkTerm((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_checkTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_checkTerm",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_checkTerm" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = (bool)SBO::checkTerm(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_checkTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_SBO_checkTerm__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBO_checkTerm__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBO_checkTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    checkTerm(std::string const &)\n"
    "    SBO::checkTerm(int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBO(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBO *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBO")) SWIG_fail;
  result = (SBO *)new SBO();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBO, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBO(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBO *arg1 = (SBO *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBO",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBO, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBO" "', argument " "1"" of type '" "SBO *""'"); 
  }
  arg1 = reinterpret_cast< SBO * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBO_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBO, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidSBMLSId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidSBMLSId",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidSBMLSId" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidSBMLSId(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidXMLID(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidXMLID",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidXMLID" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidXMLID(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidUnitSId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidUnitSId",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidUnitSId" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidUnitSId(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SyntaxChecker_hasExpectedXHTMLSyntax",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SyntaxChecker_hasExpectedXHTMLSyntax" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SyntaxChecker_hasExpectedXHTMLSyntax" "', argument " "2"" of type '" "SBMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  result = (bool)SyntaxChecker::hasExpectedXHTMLSyntax((XMLNode const *)arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_hasExpectedXHTMLSyntax",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SyntaxChecker_hasExpectedXHTMLSyntax" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (bool)SyntaxChecker::hasExpectedXHTMLSyntax((XMLNode const *)arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_hasExpectedXHTMLSyntax(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SyntaxChecker_hasExpectedXHTMLSyntax'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    hasExpectedXHTMLSyntax(XMLNode const *,SBMLNamespaces *)\n"
    "    SyntaxChecker::hasExpectedXHTMLSyntax(XMLNode const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SyntaxChecker(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SyntaxChecker *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SyntaxChecker")) SWIG_fail;
  result = (SyntaxChecker *)new SyntaxChecker();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SyntaxChecker, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SyntaxChecker(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SyntaxChecker *arg1 = (SyntaxChecker *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SyntaxChecker",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SyntaxChecker, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SyntaxChecker" "', argument " "1"" of type '" "SyntaxChecker *""'"); 
  }
  arg1 = reinterpret_cast< SyntaxChecker * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SyntaxChecker_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SyntaxChecker, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_StoichiometryMath__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_StoichiometryMath",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_StoichiometryMath" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_StoichiometryMath__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_StoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_StoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StoichiometryMath" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_StoichiometryMath__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_StoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_StoichiometryMath,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "StoichiometryMath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "StoichiometryMath const &""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath((StoichiometryMath const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_StoichiometryMath(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StoichiometryMath__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StoichiometryMath__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_StoichiometryMath__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_StoichiometryMath'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    StoichiometryMath(unsigned int,unsigned int)\n"
    "    StoichiometryMath(SBMLNamespaces *)\n"
    "    StoichiometryMath(StoichiometryMath const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_clone" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (StoichiometryMath *)((StoichiometryMath const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getMath" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (ASTNode *)((StoichiometryMath const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_isSetMath" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:StoichiometryMath_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_setMath" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "StoichiometryMath_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getDerivedUnitDefinition" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getDerivedUnitDefinition" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (UnitDefinition *)((StoichiometryMath const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'StoichiometryMath_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(StoichiometryMath *)\n"
    "    getDerivedUnitDefinition(StoichiometryMath const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_containsUndeclaredUnits" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_containsUndeclaredUnits" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'StoichiometryMath_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(StoichiometryMath *)\n"
    "    containsUndeclaredUnits(StoichiometryMath const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getTypeCode" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (SBMLTypeCode_t)((StoichiometryMath const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getElementName" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (std::string *) &((StoichiometryMath const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_hasRequiredElements" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *StoichiometryMath_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_StoichiometryMath, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SBMLNamespaces",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLNamespaces" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLNamespaces",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLNamespaces")) SWIG_fail;
  result = (SBMLNamespaces *)new SBMLNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLNamespaces" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SBMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "SBMLNamespaces const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "SBMLNamespaces const &""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (SBMLNamespaces *)new SBMLNamespaces((SBMLNamespaces const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_SBMLNamespaces__SWIG_2(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLNamespaces__SWIG_3(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLNamespaces__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLNamespaces__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SBMLNamespaces'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SBMLNamespaces(unsigned int,unsigned int)\n"
    "    SBMLNamespaces(unsigned int)\n"
    "    SBMLNamespaces()\n"
    "    SBMLNamespaces(SBMLNamespaces const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_clone" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (SBMLNamespaces *)((SBMLNamespaces const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getSBMLNamespaceURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespaces_getSBMLNamespaceURI",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBMLNamespaces_getSBMLNamespaceURI" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLNamespaces_getSBMLNamespaceURI" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = SBMLNamespaces::getSBMLNamespaceURI(arg1,arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getLevel__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getLevel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getLevel" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)(arg1)->getLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getLevel__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getLevel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getLevel" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)((SBMLNamespaces const *)arg1)->getLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getLevel(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getLevel__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getLevel__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLNamespaces_getLevel'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getLevel(SBMLNamespaces *)\n"
    "    getLevel(SBMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getVersion__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getVersion",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getVersion" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)(arg1)->getVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getVersion__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getVersion",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getVersion" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)((SBMLNamespaces const *)arg1)->getVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getVersion(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getVersion__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getVersion__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLNamespaces_getVersion'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getVersion(SBMLNamespaces *)\n"
    "    getVersion(SBMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getNamespaces__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getNamespaces" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (XMLNamespaces *)(arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getNamespaces__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getNamespaces" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (XMLNamespaces *)((SBMLNamespaces const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getNamespaces(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getNamespaces__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getNamespaces__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLNamespaces_getNamespaces'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getNamespaces(SBMLNamespaces *)\n"
    "    getNamespaces(SBMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_addNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespaces_addNamespaces",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_addNamespaces" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLNamespaces_addNamespaces" "', argument " "2"" of type '" "XMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  (arg1)->addNamespaces(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLNamespaces_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLNamespaces, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SBMLTransforms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLTransforms *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLTransforms")) SWIG_fail;
  result = (SBMLTransforms *)new SBMLTransforms();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLTransforms, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLTransforms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLTransforms *arg1 = (SBMLTransforms *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLTransforms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLTransforms, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLTransforms" "', argument " "1"" of type '" "SBMLTransforms *""'"); 
  }
  arg1 = reinterpret_cast< SBMLTransforms * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLTransforms_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLTransforms, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_readMathMLFromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:readMathMLFromString",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "readMathMLFromString" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (ASTNode_t *)readMathMLFromString((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_writeMathMLToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode_t *arg1 = (ASTNode_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:writeMathMLToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeMathMLToString" "', argument " "1"" of type '" "ASTNode_t const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode_t * >(argp1);
  result = (char *)writeMathMLToString((ASTNode const *)arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNodeType_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ASTNode",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ASTNode" "', argument " "1"" of type '" "ASTNodeType_t""'");
  } 
  arg1 = static_cast< ASTNodeType_t >(val1);
  result = (ASTNode *)new ASTNode(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ASTNode")) SWIG_fail;
  result = (ASTNode *)new ASTNode();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ASTNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ASTNode,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ASTNode" "', argument " "1"" of type '" "ASTNode const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ASTNode" "', argument " "1"" of type '" "ASTNode const &""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)new ASTNode((ASTNode const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ASTNode__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ASTNode__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_ASTNode__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ASTNode'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ASTNode(ASTNodeType_t)\n"
    "    ASTNode()\n"
    "    ASTNode(ASTNode const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ASTNode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ASTNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ASTNode" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_freeName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_freeName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_freeName" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)(arg1)->freeName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_canonicalize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_canonicalize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_canonicalize" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)(arg1)->canonicalize();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_addChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_addChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_addChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_addChild" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->addChild(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_prependChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_prependChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_prependChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_prependChild" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->prependChild(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_removeChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_removeChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_removeChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_removeChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->removeChild(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_replaceChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_replaceChild",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_replaceChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_replaceChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ASTNode_replaceChild" "', argument " "3"" of type '" "ASTNode *""'"); 
  }
  arg3 = reinterpret_cast< ASTNode * >(argp3);
  result = (int)(arg1)->replaceChild(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_insertChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_insertChild",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_insertChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_insertChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ASTNode_insertChild" "', argument " "3"" of type '" "ASTNode *""'"); 
  }
  arg3 = reinterpret_cast< ASTNode * >(argp3);
  result = (int)(arg1)->insertChild(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_deepCopy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_deepCopy",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_deepCopy" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->deepCopy();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getChild" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_getChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((ASTNode const *)arg1)->getChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getLeftChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getLeftChild",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getLeftChild" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->getLeftChild();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getRightChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getRightChild",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getRightChild" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->getRightChild();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getNumChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getNumChildren",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getNumChildren" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (unsigned int)((ASTNode const *)arg1)->getNumChildren();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_addSemanticsAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_addSemanticsAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_addSemanticsAnnotation" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_addSemanticsAnnotation" "', argument " "2"" of type '" "XMLNode *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->addSemanticsAnnotation(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getNumSemanticsAnnotations(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getNumSemanticsAnnotations",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getNumSemanticsAnnotations" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (unsigned int)((ASTNode const *)arg1)->getNumSemanticsAnnotations();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getSemanticsAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_getSemanticsAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getSemanticsAnnotation" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_getSemanticsAnnotation" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)((ASTNode const *)arg1)->getSemanticsAnnotation(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getCharacter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getCharacter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getCharacter" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (char)((ASTNode const *)arg1)->getCharacter();
  resultobj = SWIG_From_char(static_cast< char >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getInteger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getInteger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getInteger" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getInteger();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getName" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (char *)((ASTNode const *)arg1)->getName();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getNumerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getNumerator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getNumerator" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getNumerator();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getDenominator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getDenominator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getDenominator" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getDenominator();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getReal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getReal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getReal" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (double)((ASTNode const *)arg1)->getReal();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getMantissa(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getMantissa",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getMantissa" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (double)((ASTNode const *)arg1)->getMantissa();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getExponent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getExponent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getExponent" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getExponent();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getPrecedence(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getPrecedence",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getPrecedence" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)((ASTNode const *)arg1)->getPrecedence();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNodeType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getType" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNodeType_t)((ASTNode const *)arg1)->getType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getUnits" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = ((ASTNode const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isBoolean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isBoolean",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isBoolean" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isBoolean();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isConstant" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isFunction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isFunction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isFunction" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isFunction();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isInfinity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isInfinity",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isInfinity" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isInfinity();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isInteger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isInteger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isInteger" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isInteger();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isLambda(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isLambda",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isLambda" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLambda();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isLog10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isLog10",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isLog10" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLog10();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isLogical(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isLogical",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isLogical" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLogical();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isName" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isNaN(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isNaN",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isNaN" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNaN();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isNegInfinity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isNegInfinity",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isNegInfinity" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNegInfinity();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isNumber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isNumber",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isNumber" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNumber();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isOperator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isOperator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isOperator" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isOperator();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isPiecewise(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isPiecewise",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isPiecewise" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isPiecewise();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isRational(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isRational",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isRational" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isRational();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isReal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isReal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isReal" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isReal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isRelational(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isRelational",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isRelational" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isRelational();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isSqrt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isSqrt",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isSqrt" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isSqrt();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isUMinus(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isUMinus",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isUMinus" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isUMinus();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isUnknown(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isUnknown",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isUnknown" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isUnknown();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isSetUnits" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_hasUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_hasUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_hasUnits" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->hasUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setCharacter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setCharacter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setCharacter" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setCharacter" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = (int)(arg1)->setCharacter(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setName" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_setName" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)(arg1)->setName((char const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = static_cast< long >(val2);
  result = (int)(arg1)->setValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  long arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_setValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = static_cast< long >(val2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ASTNode_setValue" "', argument " "3"" of type '" "long""'");
  } 
  arg3 = static_cast< long >(val3);
  result = (int)(arg1)->setValue(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  double arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_setValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ASTNode_setValue" "', argument " "3"" of type '" "long""'");
  } 
  arg3 = static_cast< long >(val3);
  result = (int)(arg1)->setValue(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ASTNode_setValue__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ASTNode_setValue__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_ASTNode_setValue__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_ASTNode_setValue__SWIG_3(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ASTNode_setValue'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setValue(ASTNode *,long)\n"
    "    setValue(ASTNode *,long,long)\n"
    "    setValue(ASTNode *,double)\n"
    "    setValue(ASTNode *,double,long)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNodeType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setType" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setType" "', argument " "2"" of type '" "ASTNodeType_t""'");
  } 
  arg2 = static_cast< ASTNodeType_t >(val2);
  result = (int)(arg1)->setType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setUnits" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ASTNode_setUnits" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setUnits(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_swapChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_swapChildren",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_swapChildren" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_swapChildren" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->swapChildren(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_unsetUnits" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getDefinitionURL(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getDefinitionURL",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getDefinitionURL" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (XMLAttributes *)((ASTNode const *)arg1)->getDefinitionURL();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_replaceArgument(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  std::string arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_replaceArgument",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_replaceArgument" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ASTNode_replaceArgument" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ASTNode_replaceArgument" "', argument " "3"" of type '" "ASTNode *""'"); 
  }
  arg3 = reinterpret_cast< ASTNode * >(argp3);
  (arg1)->replaceArgument(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getParentSBMLObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getParentSBMLObject",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getParentSBMLObject" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (SBase *)((ASTNode const *)arg1)->getParentSBMLObject();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_reduceToBinary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_reduceToBinary",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_reduceToBinary" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  (arg1)->reduceToBinary();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isWellFormedASTNode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isWellFormedASTNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isWellFormedASTNode" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isWellFormedASTNode();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_hasCorrectNumberArguments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_hasCorrectNumberArguments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_hasCorrectNumberArguments" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->hasCorrectNumberArguments();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getListOfNodes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListWrapper< ASTNode > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getListOfNodes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getListOfNodes" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ListWrapper< ASTNode > *)ASTNode_getListOfNodes(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ASTNode_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ASTNode, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_parseFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:parseFormula",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "parseFormula" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (ASTNode_t *)SBML_parseFormula((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_formulaToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode_t *arg1 = (ASTNode_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:formulaToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "formulaToString" "', argument " "1"" of type '" "ASTNode_t const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode_t * >(argp1);
  result = (char *)SBML_formulaToString((ASTNode const *)arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLAttributes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLAttributes")) SWIG_fail;
  result = (XMLAttributes *)new XMLAttributes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLAttributes" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLAttributes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLAttributes" "', argument " "1"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLAttributes" "', argument " "1"" of type '" "XMLAttributes const &""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (XMLAttributes *)new XMLAttributes((XMLAttributes const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLAttributes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLAttributes__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLAttributes__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLAttributes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLAttributes()\n"
    "    XMLAttributes(XMLAttributes const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_clone" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (XMLAttributes *)((XMLAttributes const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:XMLAttributes_add",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj4, &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "XMLAttributes_add" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:XMLAttributes_add",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_add",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_add",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((XMLTriple const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_add__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_add__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLAttributes_add__SWIG_1(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_XMLAttributes_add__SWIG_0(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_add'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    add(XMLAttributes *,std::string const &,std::string const &,std::string const &,std::string const &)\n"
    "    add(XMLAttributes *,std::string const &,std::string const &,std::string const &)\n"
    "    add(XMLAttributes *,std::string const &,std::string const &)\n"
    "    add(XMLAttributes *,XMLTriple const &,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_removeResource(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_removeResource",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_removeResource" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_removeResource" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeResource(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->remove(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_remove",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_remove" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->remove((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_remove__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(XMLAttributes *,int)\n"
    "    remove(XMLAttributes *,std::string const &,std::string const &)\n"
    "    remove(XMLAttributes *,std::string const &)\n"
    "    remove(XMLAttributes *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_clear" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (int)(arg1)->clear();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getIndex" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLAttributes const *)arg1)->getIndex((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_getIndex",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getIndex" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_getIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)((XMLAttributes const *)arg1)->getIndex((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getIndex" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)((XMLAttributes const *)arg1)->getIndex((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getIndex__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getIndex__SWIG_0(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_getIndex__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_getIndex'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getIndex(XMLAttributes const *,std::string const &)\n"
    "    getIndex(XMLAttributes const *,std::string const &,std::string const &)\n"
    "    getIndex(XMLAttributes const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_getLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getLength" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (int)((XMLAttributes const *)arg1)->getLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getName" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getPrefix" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getPrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getPrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getPrefixedName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getPrefixedName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getPrefixedName" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getPrefixedName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getPrefixedName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getURI" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLAttributes const *)arg1)->getValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_getValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_getValue" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLAttributes const *)arg1)->getValue(arg2,arg3);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = ((XMLAttributes const *)arg1)->getValue((XMLTriple const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_getValue__SWIG_2(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_getValue'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getValue(XMLAttributes const *,int)\n"
    "    getValue(XMLAttributes const *,std::string const)\n"
    "    getValue(XMLAttributes const *,std::string const,std::string const)\n"
    "    getValue(XMLAttributes const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_hasAttribute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_hasAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_hasAttribute" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_hasAttribute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_hasAttribute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute((XMLTriple const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_hasAttribute__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_hasAttribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    hasAttribute(XMLAttributes const *,int)\n"
    "    hasAttribute(XMLAttributes const *,std::string const,std::string const)\n"
    "    hasAttribute(XMLAttributes const *,std::string const)\n"
    "    hasAttribute(XMLAttributes const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_isEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_isEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_isEmpty" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (bool)((XMLAttributes const *)arg1)->isEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLAttributes_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLAttributes, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLNamespaces__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLNamespaces")) SWIG_fail;
  result = (XMLNamespaces *)new XMLNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLNamespaces" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNamespaces__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNamespaces" "', argument " "1"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNamespaces" "', argument " "1"" of type '" "XMLNamespaces const &""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (XMLNamespaces *)new XMLNamespaces((XMLNamespaces const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNamespaces(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLNamespaces__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNamespaces__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLNamespaces'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLNamespaces()\n"
    "    XMLNamespaces(XMLNamespaces const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_clone" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (XMLNamespaces *)((XMLNamespaces const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_add__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLNamespaces_add",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_add" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLNamespaces_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_add__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_add" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_add(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_add__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLNamespaces_add__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_add'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    add(XMLNamespaces *,std::string const &,std::string const &)\n"
    "    add(XMLNamespaces *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_remove" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNamespaces_remove" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->remove(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_remove" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(XMLNamespaces *,int)\n"
    "    remove(XMLNamespaces *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_clear" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (int)(arg1)->clear();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getIndex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getIndex" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLNamespaces_getIndex" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)((XMLNamespaces const *)arg1)->getIndex(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getIndexByPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getIndexByPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getIndexByPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLNamespaces_getIndexByPrefix" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)((XMLNamespaces const *)arg1)->getIndexByPrefix(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_getLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getLength" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (int)((XMLNamespaces const *)arg1)->getLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getPrefix__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNamespaces_getPrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLNamespaces const *)arg1)->getPrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getPrefix__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_getPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_getPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLNamespaces const *)arg1)->getPrefix((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getPrefix(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_getPrefix__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_getPrefix__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_getPrefix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getPrefix(XMLNamespaces const *,int)\n"
    "    getPrefix(XMLNamespaces const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNamespaces_getURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLNamespaces const *)arg1)->getURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_getURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_getURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLNamespaces const *)arg1)->getURI((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_getURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = ((XMLNamespaces const *)arg1)->getURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLNamespaces_getURI__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_getURI__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_getURI__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_getURI'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getURI(XMLNamespaces const *,int)\n"
    "    getURI(XMLNamespaces const *,std::string const &)\n"
    "    getURI(XMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_isEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_isEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_isEmpty" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (bool)((XMLNamespaces const *)arg1)->isEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_hasURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_hasURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_hasURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_hasURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasURI((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_hasPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_hasPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_hasPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_hasPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasPrefix((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_hasNS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLNamespaces_hasNS",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_hasNS" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_hasNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLNamespaces_hasNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasNS((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *XMLNamespaces_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLNamespaces, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLToken")) SWIG_fail;
  result = (XMLToken *)new XMLToken();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLToken",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLToken" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLToken" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLToken",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLToken" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLToken",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLToken" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLToken",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLToken",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLToken",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (XMLToken *)new XMLToken((std::string const &)*arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_11(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLToken",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLToken *)new XMLToken((std::string const &)*arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_12(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLToken",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (XMLToken *)new XMLToken((std::string const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLToken(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLToken",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLToken" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_13(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLToken",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLToken,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLToken *)new XMLToken((XMLToken const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLToken__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_9(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_13(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_12(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLToken__SWIG_6(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLToken__SWIG_8(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLToken__SWIG_11(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLToken__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_5(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_7(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_10(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLToken__SWIG_2(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLToken__SWIG_4(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLToken__SWIG_1(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLToken'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLToken()\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &)\n"
    "    XMLToken(XMLTriple const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,unsigned int const)\n"
    "    XMLToken(XMLTriple const &)\n"
    "    XMLToken(std::string const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(std::string const &,unsigned int const)\n"
    "    XMLToken(std::string const &)\n"
    "    XMLToken(XMLToken const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_clone" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLToken *)((XMLToken const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttributes" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLAttributes *) &((XMLToken const *)arg1)->getAttributes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_setAttributes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setAttributes" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_setAttributes" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_setAttributes" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  result = (int)(arg1)->setAttributes((XMLAttributes const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:XMLToken_addAttr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj4, &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "XMLToken_addAttr" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:XMLToken_addAttr",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_addAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_addAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addAttr((XMLTriple const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addAttr__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addAttr__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLToken_addAttr__SWIG_1(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_XMLToken_addAttr__SWIG_0(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_addAttr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    addAttr(XMLToken *,std::string const &,std::string const &,std::string const &,std::string const &)\n"
    "    addAttr(XMLToken *,std::string const &,std::string const &,std::string const &)\n"
    "    addAttr(XMLToken *,std::string const &,std::string const &)\n"
    "    addAttr(XMLToken *,XMLTriple const &,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeAttr(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_removeAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_removeAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->removeAttr((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->removeAttr((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->removeAttr((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_removeAttr__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_removeAttr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeAttr(XMLToken *,int)\n"
    "    removeAttr(XMLToken *,std::string const &,std::string const &)\n"
    "    removeAttr(XMLToken *,std::string const &)\n"
    "    removeAttr(XMLToken *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_clearAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_clearAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_clearAttributes" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->clearAttributes();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_getAttrIndex",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_getAttrIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getAttrIndex((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getAttrIndex((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)((XMLToken const *)arg1)->getAttrIndex((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrIndex__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrIndex__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_getAttrIndex__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getAttrIndex'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getAttrIndex(XMLToken const *,std::string const &,std::string const &)\n"
    "    getAttrIndex(XMLToken const *,std::string const &)\n"
    "    getAttrIndex(XMLToken const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttributesLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getAttributesLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttributesLength" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)((XMLToken const *)arg1)->getAttributesLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrName" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrPrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrPrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrPrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrPrefixedName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrPrefixedName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrPrefixedName" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrPrefixedName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrPrefixedName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_getAttrValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_getAttrValue" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLToken const *)arg1)->getAttrValue(arg2,arg3);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLToken const *)arg1)->getAttrValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = ((XMLToken const *)arg1)->getAttrValue((XMLTriple const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_getAttrValue__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getAttrValue'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getAttrValue(XMLToken const *,int)\n"
    "    getAttrValue(XMLToken const *,std::string const,std::string const)\n"
    "    getAttrValue(XMLToken const *,std::string const)\n"
    "    getAttrValue(XMLToken const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_hasAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_hasAttr" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (bool)((XMLToken const *)arg1)->hasAttr((XMLTriple const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_hasAttr__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_hasAttr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    hasAttr(XMLToken const *,int)\n"
    "    hasAttr(XMLToken const *,std::string const,std::string const)\n"
    "    hasAttr(XMLToken const *,std::string const)\n"
    "    hasAttr(XMLToken const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isAttributesEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isAttributesEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isAttributesEmpty" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isAttributesEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaces" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLNamespaces *) &((XMLToken const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLNamespaces *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_setNamespaces",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setNamespaces" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_setNamespaces" "', argument " "2"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_setNamespaces" "', argument " "2"" of type '" "XMLNamespaces const &""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (int)(arg1)->setNamespaces((XMLNamespaces const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addNamespace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_addNamespace",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addNamespace" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addNamespace" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addNamespace((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addNamespace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_addNamespace",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->addNamespace((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addNamespace(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_addNamespace__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addNamespace__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_addNamespace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    addNamespace(XMLToken *,std::string const &,std::string const &)\n"
    "    addNamespace(XMLToken *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeNamespace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeNamespace",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_removeNamespace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeNamespace(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeNamespace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeNamespace",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->removeNamespace((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeNamespace(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_removeNamespace__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeNamespace__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_removeNamespace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeNamespace(XMLToken *,int)\n"
    "    removeNamespace(XMLToken *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_clearNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_clearNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_clearNamespaces" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->clearNamespaces();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceIndex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespaceIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespaceIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getNamespaceIndex((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceIndexByPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceIndexByPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceIndexByPrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespaceIndexByPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespaceIndexByPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getNamespaceIndexByPrefix((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacesLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getNamespacesLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespacesLength" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)((XMLToken const *)arg1)->getNamespacesLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacePrefix__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespacePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespacePrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getNamespacePrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getNamespacePrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacePrefix__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespacePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespacePrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLToken const *)arg1)->getNamespacePrefix((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacePrefix(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getNamespacePrefix__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getNamespacePrefix__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getNamespacePrefix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getNamespacePrefix(XMLToken const *,int)\n"
    "    getNamespacePrefix(XMLToken const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getNamespaceURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getNamespaceURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLToken const *)arg1)->getNamespaceURI((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getNamespaceURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = ((XMLToken const *)arg1)->getNamespaceURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLToken_getNamespaceURI__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getNamespaceURI__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getNamespaceURI__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getNamespaceURI'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getNamespaceURI(XMLToken const *,int)\n"
    "    getNamespaceURI(XMLToken const *,std::string const &)\n"
    "    getNamespaceURI(XMLToken const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isNamespacesEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isNamespacesEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isNamespacesEmpty" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isNamespacesEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasNamespaceURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasNamespaceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespaceURI((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasNamespacePrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasNamespacePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasNamespacePrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespacePrefix((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasNamespaceNS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_hasNamespaceNS",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasNamespaceNS" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasNamespaceNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespaceNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_hasNamespaceNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespaceNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespaceNS((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setTriple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_setTriple",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setTriple" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_setTriple" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_setTriple" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->setTriple((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getName" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getPrefix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getPrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getPrefix();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getCharacters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getCharacters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getCharacters" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getCharacters();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_append",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_append" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_append" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_append" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->append((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getColumn",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getColumn" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (unsigned int)((XMLToken const *)arg1)->getColumn();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getLine",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getLine" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (unsigned int)((XMLToken const *)arg1)->getLine();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isElement(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isElement",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isElement" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isElement();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isEnd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isEnd" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isEnd();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isEndFor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLToken *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_isEndFor",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isEndFor" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLToken,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_isEndFor" "', argument " "2"" of type '" "XMLToken const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_isEndFor" "', argument " "2"" of type '" "XMLToken const &""'"); 
  }
  arg2 = reinterpret_cast< XMLToken * >(argp2);
  result = (bool)((XMLToken const *)arg1)->isEndFor((XMLToken const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isEOF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isEOF",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isEOF" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isEOF();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isStart(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isStart",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isStart" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isStart();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isText(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isText",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isText" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isText();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_setEnd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setEnd" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->setEnd();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setEOF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_setEOF",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setEOF" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->setEOF();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_unsetEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_unsetEnd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_unsetEnd" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->unsetEnd();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_toString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_toString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_toString" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (arg1)->toString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLToken_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLToken, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLNode")) SWIG_fail;
  result = (XMLNode *)new XMLNode();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLToken,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLNode *)new XMLNode((XMLToken const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLNode",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLNode" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLNode" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLNode",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLNode" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLNode",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLNode" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLNode",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLNode",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_11(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (XMLNode *)new XMLNode((std::string const &)*arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_12(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLNode",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)new XMLNode((std::string const &)*arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_13(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (XMLNode *)new XMLNode((std::string const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLNode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLNode" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_14(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNode,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLNode const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLNode const &""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (XMLNode *)new XMLNode((XMLNode const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLNode__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_14(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_10(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_13(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLNode__SWIG_7(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLNode__SWIG_9(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLNode__SWIG_12(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLNode__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_6(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_8(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_11(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLNode__SWIG_3(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLNode__SWIG_5(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLNode__SWIG_2(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLNode'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLNode()\n"
    "    XMLNode(XMLToken const &)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &)\n"
    "    XMLNode(XMLTriple const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,unsigned int const)\n"
    "    XMLNode(XMLTriple const &)\n"
    "    XMLNode(std::string const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(std::string const &,unsigned int const)\n"
    "    XMLNode(std::string const &)\n"
    "    XMLNode(XMLNode const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_clone" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (XMLNode *)((XMLNode const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_addChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  XMLNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_addChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_addChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLNode,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_addChild" "', argument " "2"" of type '" "XMLNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_addChild" "', argument " "2"" of type '" "XMLNode const &""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->addChild((XMLNode const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_insertChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  XMLNode *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLNode_insertChild",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_insertChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_insertChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNode,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLNode_insertChild" "', argument " "3"" of type '" "XMLNode const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_insertChild" "', argument " "3"" of type '" "XMLNode const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNode * >(argp3);
  result = (XMLNode *) &(arg1)->insertChild(arg2,(XMLNode const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_removeChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_removeChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_removeChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_removeChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)(arg1)->removeChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_removeChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_removeChildren",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_removeChildren" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (int)(arg1)->removeChildren();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *) &(arg1)->getChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getChild" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *) &((XMLNode const *)arg1)->getChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNode_getChild'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getChild(XMLNode *,unsigned int)\n"
    "    getChild(XMLNode const *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getNumChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_getNumChildren",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getNumChildren" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (unsigned int)((XMLNode const *)arg1)->getNumChildren();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_toXMLString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_toXMLString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_toXMLString" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = ((XMLNode const *)arg1)->toXMLString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertXMLNodeToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_convertXMLNodeToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_convertXMLNodeToString" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = XMLNode::convertXMLNodeToString((XMLNode const *)arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertStringToXMLNode__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_convertStringToXMLNode",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_convertStringToXMLNode" "', argument " "2"" of type '" "XMLNamespaces const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (XMLNode *)XMLNode::convertStringToXMLNode((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,(XMLNamespaces const *)arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertStringToXMLNode__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_convertStringToXMLNode",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (XMLNode *)XMLNode::convertStringToXMLNode((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertStringToXMLNode(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLNode_convertStringToXMLNode__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNode_convertStringToXMLNode__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNode_convertStringToXMLNode'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    convertStringToXMLNode(std::string const &,XMLNamespaces const *)\n"
    "    XMLNode::convertStringToXMLNode(std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *XMLNode_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLNode, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLTriple")) SWIG_fail;
  result = (XMLTriple *)new XMLTriple();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLTriple",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLTriple" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLTriple" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  char arg2 ;
  int res1 = SWIG_OLDOBJ ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLTriple",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLTriple" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLTriple",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLTriple",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLTriple *)new XMLTriple((XMLTriple const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLTriple__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTriple__SWIG_4(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTriple__SWIG_3(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLTriple__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLTriple__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLTriple'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLTriple()\n"
    "    XMLTriple(std::string const &,std::string const &,std::string const &)\n"
    "    XMLTriple(std::string const &,char const)\n"
    "    XMLTriple(std::string const &)\n"
    "    XMLTriple(XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_clone" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLTriple *)((XMLTriple const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getName" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getPrefix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getPrefix" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getPrefix();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getURI" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getPrefixedName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getPrefixedName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getPrefixedName" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = ((XMLTriple const *)arg1)->getPrefixedName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_isEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_isEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_isEmpty" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (bool)((XMLTriple const *)arg1)->isEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLTriple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLTriple",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLTriple" "', argument " "1"" of type '" "XMLTriple *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLTriple_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLTriple, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLOutputStream",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLOutputStream" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj4, &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_XMLOutputStream" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLOutputStream",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLOutputStream" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLOutputStream",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLOutputStream" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLOutputStream",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLOutputStream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  result = (XMLOutputStream *)new XMLOutputStream(*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLOutputStream__SWIG_4(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLOutputStream__SWIG_3(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLOutputStream__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_XMLOutputStream__SWIG_1(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_XMLOutputStream__SWIG_0(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLOutputStream'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLOutputStream(std::ostream &,std::string const &,bool,std::string const &,std::string const &)\n"
    "    XMLOutputStream(std::ostream &,std::string const &,bool,std::string const &)\n"
    "    XMLOutputStream(std::ostream &,std::string const &,bool)\n"
    "    XMLOutputStream(std::ostream &,std::string const &)\n"
    "    XMLOutputStream(std::ostream &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_endElement__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_endElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_endElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->endElement((std::string const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_endElement__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_endElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_endElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->endElement((XMLTriple const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_endElement(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_endElement__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_endElement__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_endElement'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    endElement(XMLOutputStream *,std::string const &)\n"
    "    endElement(XMLOutputStream *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_setAutoIndent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_setAutoIndent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_setAutoIndent" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLOutputStream_setAutoIndent" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setAutoIndent(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startElement__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->startElement((std::string const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startElement__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->startElement((XMLTriple const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startElement(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startElement__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startElement__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_startElement'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    startElement(XMLOutputStream *,std::string const &)\n"
    "    startElement(XMLOutputStream *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startEndElement__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startEndElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startEndElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->startEndElement((std::string const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startEndElement__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startEndElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startEndElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->startEndElement((XMLTriple const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startEndElement(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startEndElement__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startEndElement__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_startEndElement'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    startEndElement(XMLOutputStream *,std::string const &)\n"
    "    startEndElement(XMLOutputStream *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  double *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "double""'");
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(double const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  double *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "double""'");
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(double const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  long *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  long temp3 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "long""'");
  } 
  temp3 = static_cast< long >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(long const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  long *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long temp3 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "long""'");
  } 
  temp3 = static_cast< long >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(long const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  int *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int temp3 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "int""'");
  } 
  temp3 = static_cast< int >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(int const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  int *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int temp3 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "int""'");
  } 
  temp3 = static_cast< int >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(int const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_9(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_7(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_5(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_8(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_6(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_2(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_writeAttribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,std::string const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,std::string const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,bool const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,bool const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,double const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,double const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,long const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,long const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,int const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,int const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeXMLDecl(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLOutputStream_writeXMLDecl",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeXMLDecl" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->writeXMLDecl();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeComment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeComment",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeComment" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeComment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeComment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLOutputStream_writeComment" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeComment" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->writeComment((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_downIndent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLOutputStream_downIndent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_downIndent" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->downIndent();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_upIndent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLOutputStream_upIndent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_upIndent" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->upIndent();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttributeBool__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttributeBool",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  XMLOutputStream_writeAttributeBool__SWIG_0(arg1,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttributeBool__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttributeBool",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  XMLOutputStream_writeAttributeBool__SWIG_1(arg1,(XMLTriple const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttributeBool(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttributeBool__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttributeBool__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_writeAttributeBool'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    writeAttributeBool(XMLOutputStream *,std::string const &,bool const &)\n"
    "    writeAttributeBool(XMLOutputStream *,XMLTriple const &,bool const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLOutputStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLOutputStream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLOutputStream" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLOutputStream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLOutputStream, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:new_XMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLError" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_XMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLError",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLError" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLError",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLError" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLError",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLError",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLError",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = (XMLError *)new XMLError(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLError")) SWIG_fail;
  result = (XMLError *)new XMLError();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLError,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLError" "', argument " "1"" of type '" "XMLError const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "1"" of type '" "XMLError const &""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (XMLError *)new XMLError((XMLError const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[7];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 6); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLError__SWIG_6(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLError, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLError__SWIG_7(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_XMLError__SWIG_5(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLError__SWIG_4(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLError__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLError__SWIG_2(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLError__SWIG_1(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_XMLError__SWIG_0(self, args);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLError'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLError(int const,std::string const &,unsigned int const,unsigned int const,unsigned int const,unsigned int const)\n"
    "    XMLError(int const,std::string const &,unsigned int const,unsigned int const,unsigned int const)\n"
    "    XMLError(int const,std::string const &,unsigned int const,unsigned int const)\n"
    "    XMLError(int const,std::string const &,unsigned int const)\n"
    "    XMLError(int const,std::string const &)\n"
    "    XMLError(int const)\n"
    "    XMLError()\n"
    "    XMLError(XMLError const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLError" "', argument " "1"" of type '" "XMLError *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getErrorId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getErrorId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getErrorId" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getErrorId();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getMessage" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getMessage();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getShortMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getShortMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getShortMessage" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getShortMessage();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getLine",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getLine" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getLine();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getColumn",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getColumn" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getColumn();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getSeverity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getSeverity",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getSeverity" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getSeverity();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getSeverityAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getSeverityAsString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getSeverityAsString" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getSeverityAsString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getCategory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getCategory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getCategory" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getCategory();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getCategoryAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getCategoryAsString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getCategoryAsString" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getCategoryAsString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isInfo",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isInfo" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isInfo();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isWarning(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isWarning",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isWarning" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isWarning();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isError" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isError();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isFatal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isFatal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isFatal" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isFatal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isInternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isInternal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isInternal" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isInternal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isSystem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isSystem" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isSystem();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isXML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isXML",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isXML" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isXML();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_setLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLError_setLine",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_setLine" "', argument " "1"" of type '" "XMLError *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLError_setLine" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setLine(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_setColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLError_setColumn",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_setColumn" "', argument " "1"" of type '" "XMLError *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLError_setColumn" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setColumn(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getStandardMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getStandardMessage",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "XMLError_getStandardMessage" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = XMLError::getStandardMessage(arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_XMLErrorLog_getNumErrors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLErrorLog_getNumErrors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLErrorLog_getNumErrors" "', argument " "1"" of type '" "XMLErrorLog const *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  result = (unsigned int)((XMLErrorLog const *)arg1)->getNumErrors();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLErrorLog_getError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLErrorLog_getError",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLErrorLog_getError" "', argument " "1"" of type '" "XMLErrorLog const *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLErrorLog_getError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLError *)((XMLErrorLog const *)arg1)->getError(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLErrorLog_clearLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLErrorLog_clearLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLErrorLog_clearLog" "', argument " "1"" of type '" "XMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  (arg1)->clearLog();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLErrorLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLErrorLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLErrorLog" "', argument " "1"" of type '" "XMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLErrorLog_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLErrorLog, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBMLErrorLog_getError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLErrorLog_getError",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLErrorLog_getError" "', argument " "1"" of type '" "SBMLErrorLog const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLErrorLog_getError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)((SBMLErrorLog const *)arg1)->getError(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLErrorLog_getNumFailsWithSeverity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLErrorLog_getNumFailsWithSeverity",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLErrorLog_getNumFailsWithSeverity" "', argument " "1"" of type '" "SBMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLErrorLog_getNumFailsWithSeverity" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (unsigned int)(arg1)->getNumFailsWithSeverity(arg2);
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLErrorLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLErrorLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLErrorLog, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLErrorLog" "', argument " "1"" of type '" "SBMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLErrorLog_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLErrorLog, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_SBMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_SBMLError" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_SBMLError" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = static_cast< unsigned int >(val8);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6,arg7,arg8);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_SBMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_SBMLError" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6,arg7);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_SBMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_SBMLError",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SBMLError",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)new SBMLError(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLError",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (SBMLError *)new SBMLError(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLError")) SWIG_fail;
  result = (SBMLError *)new SBMLError();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLError *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SBMLError,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "SBMLError const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "1"" of type '" "SBMLError const &""'"); 
  }
  arg1 = reinterpret_cast< SBMLError * >(argp1);
  result = (SBMLError *)new SBMLError((SBMLError const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[9];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 8); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_SBMLError__SWIG_8(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SBMLError, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLError__SWIG_9(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLError__SWIG_7(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLError__SWIG_6(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_SBMLError__SWIG_5(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SBMLError__SWIG_4(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_SBMLError__SWIG_3(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_SBMLError__SWIG_2(self, args);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_SBMLError__SWIG_1(self, args);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_SBMLError__SWIG_0(self, args);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SBMLError'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const,unsigned int const,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const)\n"
    "    SBMLError()\n"
    "    SBMLError(SBMLError const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLError *arg1 = (SBMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLError" "', argument " "1"" of type '" "SBMLError *""'"); 
  }
  arg1 = reinterpret_cast< SBMLError * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  QualifierType_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CVTerm",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CVTerm" "', argument " "1"" of type '" "QualifierType_t""'");
  } 
  arg1 = static_cast< QualifierType_t >(val1);
  result = (CVTerm *)new CVTerm(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_CVTerm")) SWIG_fail;
  result = (CVTerm *)new CVTerm();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CVTerm",&obj0)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNode,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CVTerm" "', argument " "1"" of type '" "XMLNode const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CVTerm" "', argument " "1"" of type '" "XMLNode const""'");
    } else {
      XMLNode * temp = reinterpret_cast< XMLNode * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  result = (CVTerm *)new CVTerm(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CVTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_CVTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CVTerm" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CVTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_CVTerm,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CVTerm" "', argument " "1"" of type '" "CVTerm const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CVTerm" "', argument " "1"" of type '" "CVTerm const &""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (CVTerm *)new CVTerm((CVTerm const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_CVTerm__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CVTerm__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CVTerm__SWIG_3(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CVTerm__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_CVTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    CVTerm(QualifierType_t)\n"
    "    CVTerm()\n"
    "    CVTerm(XMLNode const)\n"
    "    CVTerm(CVTerm const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_clone" "', argument " "1"" of type '" "CVTerm const *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (CVTerm *)((CVTerm const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  QualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getQualifierType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (QualifierType_t)(arg1)->getQualifierType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getModelQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getModelQualifierType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getModelQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (ModelQualifierType_t)(arg1)->getModelQualifierType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getBiologicalQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  BiolQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getBiologicalQualifierType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getBiologicalQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (BiolQualifierType_t)(arg1)->getBiologicalQualifierType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResources__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getResources",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getResources" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (XMLAttributes *)(arg1)->getResources();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResources__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getResources",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getResources" "', argument " "1"" of type '" "CVTerm const *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (XMLAttributes *)((CVTerm const *)arg1)->getResources();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResources(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CVTerm_getResources__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CVTerm_getResources__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'CVTerm_getResources'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getResources(CVTerm *)\n"
    "    getResources(CVTerm const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getNumResources(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getNumResources",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getNumResources" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (unsigned int)(arg1)->getNumResources();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResourceURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_getResourceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getResourceURI" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_getResourceURI" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (arg1)->getResourceURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_setQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  QualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_setQualifierType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_setQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_setQualifierType" "', argument " "2"" of type '" "QualifierType_t""'");
  } 
  arg2 = static_cast< QualifierType_t >(val2);
  result = (int)(arg1)->setQualifierType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_setModelQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  ModelQualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_setModelQualifierType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_setModelQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_setModelQualifierType" "', argument " "2"" of type '" "ModelQualifierType_t""'");
  } 
  arg2 = static_cast< ModelQualifierType_t >(val2);
  result = (int)(arg1)->setModelQualifierType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_setBiologicalQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  BiolQualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_setBiologicalQualifierType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_setBiologicalQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_setBiologicalQualifierType" "', argument " "2"" of type '" "BiolQualifierType_t""'");
  } 
  arg2 = static_cast< BiolQualifierType_t >(val2);
  result = (int)(arg1)->setBiologicalQualifierType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_addResource(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_addResource",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_addResource" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CVTerm_addResource" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CVTerm_addResource" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->addResource((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_removeResource(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_removeResource",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_removeResource" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "CVTerm_removeResource" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->removeResource(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_hasRequiredAttributes" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CVTerm_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_CVTerm, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Date__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  unsigned int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Date" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Date" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = static_cast< unsigned int >(val8);
  ecode9 = SWIG_AsVal_unsigned_SS_int(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_Date" "', argument " "9"" of type '" "unsigned int""'");
  } 
  arg9 = static_cast< unsigned int >(val9);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Date" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Date" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = static_cast< unsigned int >(val8);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Date" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_Date",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (Date *)new Date(arg1,arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_Date",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (Date *)new Date(arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Date",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)new Date(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Date",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (Date *)new Date(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_Date")) SWIG_fail;
  result = (Date *)new Date();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Date",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_Date" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (Date *)new Date(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Date(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Date",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Date" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_11(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Date",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Date,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Date" "', argument " "1"" of type '" "Date const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Date" "', argument " "1"" of type '" "Date const &""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (Date *)new Date((Date const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[10];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 9); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_Date__SWIG_9(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Date, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Date__SWIG_11(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Date__SWIG_8(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Date__SWIG_10(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Date__SWIG_7(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Date__SWIG_6(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_Date__SWIG_5(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_Date__SWIG_4(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_Date__SWIG_3(self, args);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_Date__SWIG_2(self, args);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_Date__SWIG_1(self, args);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_unsigned_SS_int(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_Date__SWIG_0(self, args);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Date'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int)\n"
    "    Date(unsigned int)\n"
    "    Date()\n"
    "    Date(std::string)\n"
    "    Date(Date const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_clone" "', argument " "1"" of type '" "Date const *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (Date *)((Date const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getYear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getYear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getYear" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getYear();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getMonth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getMonth",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getMonth" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMonth();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getDay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getDay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getDay" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getDay();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getHour(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getHour",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getHour" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getHour();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getMinute(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getMinute",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getMinute" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMinute();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getSecond(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getSecond",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getSecond" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getSecond();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getSignOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getSignOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getSignOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getSignOffset();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getHoursOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getHoursOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getHoursOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getHoursOffset();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getMinutesOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getMinutesOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getMinutesOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMinutesOffset();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getDateAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getDateAsString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getDateAsString" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (std::string *) &(arg1)->getDateAsString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setYear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setYear",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setYear" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setYear" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setYear(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setMonth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setMonth",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setMonth" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setMonth" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMonth(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setDay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setDay",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setDay" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setDay" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setDay(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setHour(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setHour",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setHour" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setHour" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setHour(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setMinute(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setMinute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setMinute" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setMinute" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMinute(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setSecond(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setSecond",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setSecond" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setSecond" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSecond(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setSignOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setSignOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setSignOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setSignOffset" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSignOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setHoursOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setHoursOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setHoursOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setHoursOffset" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setHoursOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setMinutesOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setMinutesOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setMinutesOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setMinutesOffset" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMinutesOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setDateAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setDateAsString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setDateAsString" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Date_setDateAsString" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setDateAsString(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_representsValidDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_representsValidDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_representsValidDate" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (bool)(arg1)->representsValidDate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Date_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Date, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ModelCreator__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ModelCreator")) SWIG_fail;
  result = (ModelCreator *)new ModelCreator();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelCreator__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModelCreator",&obj0)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNode,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModelCreator" "', argument " "1"" of type '" "XMLNode const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ModelCreator" "', argument " "1"" of type '" "XMLNode const""'");
    } else {
      XMLNode * temp = reinterpret_cast< XMLNode * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  result = (ModelCreator *)new ModelCreator(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModelCreator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModelCreator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModelCreator" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelCreator__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModelCreator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ModelCreator,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModelCreator" "', argument " "1"" of type '" "ModelCreator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ModelCreator" "', argument " "1"" of type '" "ModelCreator const &""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (ModelCreator *)new ModelCreator((ModelCreator const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelCreator(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ModelCreator__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelCreator__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ModelCreator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelCreator__SWIG_2(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ModelCreator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ModelCreator()\n"
    "    ModelCreator(XMLNode const)\n"
    "    ModelCreator(ModelCreator const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_clone" "', argument " "1"" of type '" "ModelCreator const *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (ModelCreator *)((ModelCreator const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getFamilyName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getFamilyName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (arg1)->getFamilyName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getGivenName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getGivenName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (arg1)->getGivenName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getEmail",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getEmail" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (arg1)->getEmail();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getOrganization",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getOrganization" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (arg1)->getOrganization();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getOrganisation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getOrganisation" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (arg1)->getOrganisation();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetFamilyName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetFamilyName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetFamilyName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetGivenName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetGivenName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetGivenName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetEmail",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetEmail" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetEmail();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetOrganization",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetOrganization" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetOrganization();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetOrganisation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetOrganisation" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetOrganisation();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setFamilyName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setFamilyName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelCreator_setFamilyName" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setFamilyName(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setGivenName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setGivenName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelCreator_setGivenName" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setGivenName(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setEmail",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setEmail" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelCreator_setEmail" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setEmail(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setOrganization",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setOrganization" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelCreator_setOrganization" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setOrganization(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setOrganisation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setOrganisation" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelCreator_setOrganisation" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setOrganisation(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetFamilyName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetFamilyName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetFamilyName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetGivenName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetGivenName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetGivenName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetEmail",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetEmail" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetEmail();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetOrganization",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetOrganization" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetOrganization();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetOrganisation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetOrganisation" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetOrganisation();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_hasRequiredAttributes" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModelCreator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ModelCreator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ModelHistory__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ModelHistory")) SWIG_fail;
  result = (ModelHistory *)new ModelHistory();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModelHistory" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelHistory__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ModelHistory,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModelHistory" "', argument " "1"" of type '" "ModelHistory const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ModelHistory" "', argument " "1"" of type '" "ModelHistory const &""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (ModelHistory *)new ModelHistory((ModelHistory const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelHistory(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ModelHistory__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelHistory__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ModelHistory'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ModelHistory()\n"
    "    ModelHistory(ModelHistory const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_clone" "', argument " "1"" of type '" "ModelHistory const *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (ModelHistory *)((ModelHistory const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getCreatedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getCreatedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getCreatedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (Date *)(arg1)->getCreatedDate();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getModifiedDate__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getModifiedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (Date *)(arg1)->getModifiedDate();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_isSetCreatedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_isSetCreatedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_isSetCreatedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->isSetCreatedDate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_isSetModifiedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_isSetModifiedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_isSetModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->isSetModifiedDate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_setCreatedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_setCreatedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_setCreatedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_setCreatedDate" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->setCreatedDate(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_setModifiedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_setModifiedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_setModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_setModifiedDate" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->setModifiedDate(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_addModifiedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_addModifiedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_addModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_addModifiedDate" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->addModifiedDate(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getListModifiedDates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getListModifiedDates",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getListModifiedDates" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (List *)(arg1)->getListModifiedDates();
  {
    ListWrapper<Date> *listw = (result != 0) ? new ListWrapper<Date>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_Date_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getModifiedDate__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_getModifiedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelHistory_getModifiedDate" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)(arg1)->getModifiedDate(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getModifiedDate(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ModelHistory_getModifiedDate__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ModelHistory_getModifiedDate__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ModelHistory_getModifiedDate'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModifiedDate(ModelHistory *)\n"
    "    getModifiedDate(ModelHistory *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getNumModifiedDates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getNumModifiedDates",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getNumModifiedDates" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (unsigned int)(arg1)->getNumModifiedDates();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_addCreator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_addCreator",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_addCreator" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_addCreator" "', argument " "2"" of type '" "ModelCreator *""'"); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  result = (int)(arg1)->addCreator(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getListCreators(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getListCreators",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getListCreators" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (List *)(arg1)->getListCreators();
  {
    ListWrapper<ModelCreator> *listw = (result != 0) ? new ListWrapper<ModelCreator>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_ModelCreator_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getCreator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_getCreator",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getCreator" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelHistory_getCreator" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)(arg1)->getCreator(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getNumCreators(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getNumCreators",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getNumCreators" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (unsigned int)(arg1)->getNumCreators();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_hasRequiredAttributes" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModelHistory_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ModelHistory, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_parseRDFAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseRDFAnnotation" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (ModelHistory *)RDFAnnotationParser::parseRDFAnnotation((XMLNode const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":RDFAnnotationParser_createAnnotation")) SWIG_fail;
  result = (XMLNode *)RDFAnnotationParser::createAnnotation();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createRDFAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":RDFAnnotationParser_createRDFAnnotation")) SWIG_fail;
  result = (XMLNode *)RDFAnnotationParser::createRDFAnnotation();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_deleteRDFAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_deleteRDFAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_deleteRDFAnnotation" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::deleteRDFAnnotation((XMLNode const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createRDFDescription(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_createRDFDescription",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_createRDFDescription" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::createRDFDescription((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_createCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_createCVTerms" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::createCVTerms((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_parseCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseCVTerms" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::parseCVTerms((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_parseModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseModelHistory" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::parseModelHistory((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  ListWrapper< CVTerm > *arg2 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:RDFAnnotationParser_parseRDFAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseRDFAnnotation" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RDFAnnotationParser_parseRDFAnnotation" "', argument " "2"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg2 = reinterpret_cast< ListWrapper< CVTerm > * >(argp2);
  RDFAnnotationParser_parseRDFAnnotation__SWIG_1((XMLNode const *)arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseRDFAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_ListWrapperT_CVTerm_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'RDFAnnotationParser_parseRDFAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    parseRDFAnnotation(XMLNode const *)\n"
    "    RDFAnnotationParser_parseRDFAnnotation__SWIG_1(XMLNode const *,ListWrapper< CVTerm > *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_RDFAnnotationParser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RDFAnnotationParser *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_RDFAnnotationParser")) SWIG_fail;
  result = (RDFAnnotationParser *)new RDFAnnotationParser();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RDFAnnotationParser, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RDFAnnotationParser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RDFAnnotationParser *arg1 = (RDFAnnotationParser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_RDFAnnotationParser",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RDFAnnotationParser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RDFAnnotationParser" "', argument " "1"" of type '" "RDFAnnotationParser *""'"); 
  }
  arg1 = reinterpret_cast< RDFAnnotationParser * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RDFAnnotationParser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_RDFAnnotationParser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"new_ModelCreatorList", _wrap_new_ModelCreatorList, METH_VARARGS, NULL},
	 { (char *)"delete_ModelCreatorList", _wrap_delete_ModelCreatorList, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_add", _wrap_ModelCreatorList_add, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_get", _wrap_ModelCreatorList_get, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_prepend", _wrap_ModelCreatorList_prepend, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_remove", _wrap_ModelCreatorList_remove, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_getSize", _wrap_ModelCreatorList_getSize, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_swigregister", ModelCreatorList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_DateList", _wrap_new_DateList, METH_VARARGS, NULL},
	 { (char *)"delete_DateList", _wrap_delete_DateList, METH_VARARGS, NULL},
	 { (char *)"DateList_add", _wrap_DateList_add, METH_VARARGS, NULL},
	 { (char *)"DateList_get", _wrap_DateList_get, METH_VARARGS, NULL},
	 { (char *)"DateList_prepend", _wrap_DateList_prepend, METH_VARARGS, NULL},
	 { (char *)"DateList_remove", _wrap_DateList_remove, METH_VARARGS, NULL},
	 { (char *)"DateList_getSize", _wrap_DateList_getSize, METH_VARARGS, NULL},
	 { (char *)"DateList_swigregister", DateList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_CVTermList", _wrap_new_CVTermList, METH_VARARGS, NULL},
	 { (char *)"delete_CVTermList", _wrap_delete_CVTermList, METH_VARARGS, NULL},
	 { (char *)"CVTermList_add", _wrap_CVTermList_add, METH_VARARGS, NULL},
	 { (char *)"CVTermList_get", _wrap_CVTermList_get, METH_VARARGS, NULL},
	 { (char *)"CVTermList_prepend", _wrap_CVTermList_prepend, METH_VARARGS, NULL},
	 { (char *)"CVTermList_remove", _wrap_CVTermList_remove, METH_VARARGS, NULL},
	 { (char *)"CVTermList_getSize", _wrap_CVTermList_getSize, METH_VARARGS, NULL},
	 { (char *)"CVTermList_swigregister", CVTermList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ASTNodeList", _wrap_new_ASTNodeList, METH_VARARGS, NULL},
	 { (char *)"delete_ASTNodeList", _wrap_delete_ASTNodeList, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_add", _wrap_ASTNodeList_add, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_get", _wrap_ASTNodeList_get, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_prepend", _wrap_ASTNodeList_prepend, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_remove", _wrap_ASTNodeList_remove, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_getSize", _wrap_ASTNodeList_getSize, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_swigregister", ASTNodeList_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SwigPyIterator", _wrap_delete_SwigPyIterator, METH_VARARGS, (char *)"delete_SwigPyIterator(SwigPyIterator self)"},
	 { (char *)"SwigPyIterator_value", _wrap_SwigPyIterator_value, METH_VARARGS, (char *)"SwigPyIterator_value(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator_incr", _wrap_SwigPyIterator_incr, METH_VARARGS, (char *)"\n"
		"incr(size_t n = 1) -> SwigPyIterator\n"
		"SwigPyIterator_incr(SwigPyIterator self) -> SwigPyIterator\n"
		""},
	 { (char *)"SwigPyIterator_decr", _wrap_SwigPyIterator_decr, METH_VARARGS, (char *)"\n"
		"decr(size_t n = 1) -> SwigPyIterator\n"
		"SwigPyIterator_decr(SwigPyIterator self) -> SwigPyIterator\n"
		""},
	 { (char *)"SwigPyIterator_distance", _wrap_SwigPyIterator_distance, METH_VARARGS, (char *)"SwigPyIterator_distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"},
	 { (char *)"SwigPyIterator_equal", _wrap_SwigPyIterator_equal, METH_VARARGS, (char *)"SwigPyIterator_equal(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { (char *)"SwigPyIterator_copy", _wrap_SwigPyIterator_copy, METH_VARARGS, (char *)"SwigPyIterator_copy(SwigPyIterator self) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator_next", _wrap_SwigPyIterator_next, METH_VARARGS, (char *)"SwigPyIterator_next(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator___next__", _wrap_SwigPyIterator___next__, METH_VARARGS, (char *)"SwigPyIterator___next__(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator_previous", _wrap_SwigPyIterator_previous, METH_VARARGS, (char *)"SwigPyIterator_previous(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator_advance", _wrap_SwigPyIterator_advance, METH_VARARGS, (char *)"SwigPyIterator_advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___eq__", _wrap_SwigPyIterator___eq__, METH_VARARGS, (char *)"SwigPyIterator___eq__(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { (char *)"SwigPyIterator___ne__", _wrap_SwigPyIterator___ne__, METH_VARARGS, (char *)"SwigPyIterator___ne__(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { (char *)"SwigPyIterator___iadd__", _wrap_SwigPyIterator___iadd__, METH_VARARGS, (char *)"SwigPyIterator___iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___isub__", _wrap_SwigPyIterator___isub__, METH_VARARGS, (char *)"SwigPyIterator___isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___add__", _wrap_SwigPyIterator___add__, METH_VARARGS, (char *)"SwigPyIterator___add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___sub__", _wrap_SwigPyIterator___sub__, METH_VARARGS, (char *)"\n"
		"__sub__(ptrdiff_t n) -> SwigPyIterator\n"
		"SwigPyIterator___sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t\n"
		""},
	 { (char *)"SwigPyIterator_swigregister", SwigPyIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"string_length", _wrap_string_length, METH_VARARGS, (char *)"string_length(string self) -> size_type"},
	 { (char *)"string_max_size", _wrap_string_max_size, METH_VARARGS, (char *)"string_max_size(string self) -> size_type"},
	 { (char *)"string_copy", _wrap_string_copy, METH_VARARGS, (char *)"\n"
		"copy(char __s, size_type __n, size_type __pos = 0) -> size_type\n"
		"string_copy(string self, char __s, size_type __n) -> size_type\n"
		""},
	 { (char *)"string_c_str", _wrap_string_c_str, METH_VARARGS, (char *)"string_c_str(string self) -> char"},
	 { (char *)"string_find", _wrap_string_find, METH_VARARGS, (char *)"\n"
		"find(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find(string __str, size_type __pos = 0) -> size_type\n"
		"find(string __str) -> size_type\n"
		"find(char __c, size_type __pos = 0) -> size_type\n"
		"string_find(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_rfind", _wrap_string_rfind, METH_VARARGS, (char *)"\n"
		"rfind(string __str, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"rfind(string __str) -> size_type\n"
		"rfind(char __s, size_type __pos, size_type __n) -> size_type\n"
		"rfind(char __c, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"string_rfind(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_first_of", _wrap_string_find_first_of, METH_VARARGS, (char *)"\n"
		"find_first_of(string __str, size_type __pos = 0) -> size_type\n"
		"find_first_of(string __str) -> size_type\n"
		"find_first_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_first_of(char __c, size_type __pos = 0) -> size_type\n"
		"string_find_first_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_last_of", _wrap_string_find_last_of, METH_VARARGS, (char *)"\n"
		"find_last_of(string __str, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"find_last_of(string __str) -> size_type\n"
		"find_last_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_last_of(char __c, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"string_find_last_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_first_not_of", _wrap_string_find_first_not_of, METH_VARARGS, (char *)"\n"
		"find_first_not_of(string __str, size_type __pos = 0) -> size_type\n"
		"find_first_not_of(string __str) -> size_type\n"
		"find_first_not_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_first_not_of(char __c, size_type __pos = 0) -> size_type\n"
		"string_find_first_not_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_last_not_of", _wrap_string_find_last_not_of, METH_VARARGS, (char *)"\n"
		"find_last_not_of(string __str, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"find_last_not_of(string __str) -> size_type\n"
		"find_last_not_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_last_not_of(char __c, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"string_find_last_not_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_substr", _wrap_string_substr, METH_VARARGS, (char *)"\n"
		"substr(size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string\n"
		"substr(size_type __pos = 0) -> string\n"
		"string_substr(string self) -> string\n"
		""},
	 { (char *)"string_empty", _wrap_string_empty, METH_VARARGS, (char *)"string_empty(string self) -> bool"},
	 { (char *)"string_size", _wrap_string_size, METH_VARARGS, (char *)"string_size(string self) -> size_type"},
	 { (char *)"string_swap", _wrap_string_swap, METH_VARARGS, (char *)"string_swap(string self, string v)"},
	 { (char *)"string_erase", _wrap_string_erase, METH_VARARGS, (char *)"\n"
		"erase(size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string\n"
		"erase(size_type __pos = 0) -> string\n"
		"erase() -> string\n"
		"erase(iterator pos) -> iterator\n"
		"string_erase(string self, iterator first, iterator last) -> iterator\n"
		""},
	 { (char *)"new_string", _wrap_new_string, METH_VARARGS, (char *)"\n"
		"string(char __s, size_type __n)\n"
		"string()\n"
		"string(string arg0)\n"
		"new_string(size_type size, value_type value) -> string\n"
		""},
	 { (char *)"string_assign", _wrap_string_assign, METH_VARARGS, (char *)"\n"
		"assign(string __str) -> string\n"
		"assign(string __str, size_type __pos, size_type __n) -> string\n"
		"assign(char __s, size_type __n) -> string\n"
		"string_assign(string self, size_type n, value_type x)\n"
		""},
	 { (char *)"string_resize", _wrap_string_resize, METH_VARARGS, (char *)"\n"
		"resize(size_type new_size)\n"
		"string_resize(string self, size_type new_size, value_type x)\n"
		""},
	 { (char *)"string_iterator", _wrap_string_iterator, METH_VARARGS, (char *)"string_iterator(string self) -> SwigPyIterator"},
	 { (char *)"string___nonzero__", _wrap_string___nonzero__, METH_VARARGS, (char *)"string___nonzero__(string self) -> bool"},
	 { (char *)"string___bool__", _wrap_string___bool__, METH_VARARGS, (char *)"string___bool__(string self) -> bool"},
	 { (char *)"string___len__", _wrap_string___len__, METH_VARARGS, (char *)"string___len__(string self) -> size_type"},
	 { (char *)"string___getslice__", _wrap_string___getslice__, METH_VARARGS, (char *)"string___getslice__(string self, difference_type i, difference_type j) -> string"},
	 { (char *)"string___setslice__", _wrap_string___setslice__, METH_VARARGS, (char *)"\n"
		"string___setslice__(string self, difference_type i, difference_type j, \n"
		"    string v)\n"
		""},
	 { (char *)"string___delslice__", _wrap_string___delslice__, METH_VARARGS, (char *)"string___delslice__(string self, difference_type i, difference_type j)"},
	 { (char *)"string___delitem__", _wrap_string___delitem__, METH_VARARGS, (char *)"\n"
		"__delitem__(difference_type i)\n"
		"string___delitem__(string self, PySliceObject slice)\n"
		""},
	 { (char *)"string___getitem__", _wrap_string___getitem__, METH_VARARGS, (char *)"\n"
		"__getitem__(PySliceObject slice) -> string\n"
		"string___getitem__(string self, difference_type i) -> value_type\n"
		""},
	 { (char *)"string___setitem__", _wrap_string___setitem__, METH_VARARGS, (char *)"\n"
		"__setitem__(PySliceObject slice, string v)\n"
		"string___setitem__(string self, difference_type i, value_type x)\n"
		""},
	 { (char *)"string_insert", _wrap_string_insert, METH_VARARGS, (char *)"\n"
		"insert(size_type __pos1, string __str) -> string\n"
		"insert(size_type __pos1, string __str, size_type __pos2, size_type __n) -> string\n"
		"insert(size_type __pos, char __s, size_type __n) -> string\n"
		"insert(size_type __pos, size_type __n, char __c) -> string\n"
		"insert(iterator pos, value_type x) -> iterator\n"
		"insert(iterator pos, size_type n, value_type x)\n"
		"string_insert(string self, iterator __p, size_type __n, char __c)\n"
		""},
	 { (char *)"string_replace", _wrap_string_replace, METH_VARARGS, (char *)"\n"
		"replace(size_type __pos, size_type __n, string __str) -> string\n"
		"replace(size_type __pos1, size_type __n1, string __str, size_type __pos2, \n"
		"    size_type __n2) -> string\n"
		"replace(size_type __pos, size_type __n1, char __s, size_type __n2) -> string\n"
		"replace(size_type __pos, size_type __n1, size_type __n2, char __c) -> string\n"
		"replace(iterator __i1, iterator __i2, string __str) -> string\n"
		"replace(iterator __i1, iterator __i2, char __s, size_type __n) -> string\n"
		"replace(iterator __i1, iterator __i2, size_type __n, char __c) -> string\n"
		"replace(iterator __i1, iterator __i2, char __k1, char __k2) -> string\n"
		"string_replace(string self, iterator __i1, iterator __i2, const_iterator __k1, \n"
		"    const_iterator __k2) -> string\n"
		""},
	 { (char *)"string___iadd__", _wrap_string___iadd__, METH_VARARGS, (char *)"string___iadd__(string self, string v) -> string"},
	 { (char *)"string___add__", _wrap_string___add__, METH_VARARGS, (char *)"string___add__(string self, string v) -> string"},
	 { (char *)"string___radd__", _wrap_string___radd__, METH_VARARGS, (char *)"string___radd__(string self, string v) -> string"},
	 { (char *)"string___str__", _wrap_string___str__, METH_VARARGS, (char *)"string___str__(string self) -> string"},
	 { (char *)"string___rlshift__", _wrap_string___rlshift__, METH_VARARGS, (char *)"string___rlshift__(string self, ostream out) -> ostream"},
	 { (char *)"string___eq__", _wrap_string___eq__, METH_VARARGS, (char *)"string___eq__(string self, string v) -> bool"},
	 { (char *)"string___ne__", _wrap_string___ne__, METH_VARARGS, (char *)"string___ne__(string self, string v) -> bool"},
	 { (char *)"string___gt__", _wrap_string___gt__, METH_VARARGS, (char *)"string___gt__(string self, string v) -> bool"},
	 { (char *)"string___lt__", _wrap_string___lt__, METH_VARARGS, (char *)"string___lt__(string self, string v) -> bool"},
	 { (char *)"string___ge__", _wrap_string___ge__, METH_VARARGS, (char *)"string___ge__(string self, string v) -> bool"},
	 { (char *)"string___le__", _wrap_string___le__, METH_VARARGS, (char *)"string___le__(string self, string v) -> bool"},
	 { (char *)"delete_string", _wrap_delete_string, METH_VARARGS, (char *)"delete_string(string self)"},
	 { (char *)"string_swigregister", string_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ostream", _wrap_new_ostream, METH_VARARGS, (char *)"new_ostream(std::basic_streambuf<(char,std::char_traits<(char)>)> __sb) -> ostream"},
	 { (char *)"delete_ostream", _wrap_delete_ostream, METH_VARARGS, (char *)"delete_ostream(ostream self)"},
	 { (char *)"ostream_swigregister", ostream_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ostringstream", _wrap_new_ostringstream, METH_VARARGS, (char *)"\n"
		"ostringstream(std::ios_base::openmode __mode = std::ios_base::out)\n"
		"new_ostringstream() -> ostringstream\n"
		""},
	 { (char *)"delete_ostringstream", _wrap_delete_ostringstream, METH_VARARGS, (char *)"delete_ostringstream(ostringstream self)"},
	 { (char *)"ostringstream_str", _wrap_ostringstream_str, METH_VARARGS, (char *)"\n"
		"str() -> string\n"
		"ostringstream_str(ostringstream self, string __s)\n"
		""},
	 { (char *)"ostringstream_swigregister", ostringstream_swigregister, METH_VARARGS, NULL},
	 { (char *)"endl", _wrap_endl, METH_VARARGS, (char *)"endl(ostream arg0) -> ostream"},
	 { (char *)"flush", _wrap_flush, METH_VARARGS, (char *)"flush(ostream arg0) -> ostream"},
	 { (char *)"ASTNode_true", _wrap_ASTNode_true, METH_VARARGS, (char *)"ASTNode_true(ASTNode node) -> int"},
	 { (char *)"getLibSBMLVersion", _wrap_getLibSBMLVersion, METH_VARARGS, (char *)"\n"
		"getLibSBMLVersion() -> int\n"
		"\n"
		"Returns the libSBML version as an integer: version 1.2.3 becomes 10203.\n"
		"\n"
		"@return the libSBML version as an integer: version 1.2.3 becomes 10203.\n"
		"\n"
		"\n"
		""},
	 { (char *)"getLibSBMLDottedVersion", _wrap_getLibSBMLDottedVersion, METH_VARARGS, (char *)"\n"
		"getLibSBMLDottedVersion() -> char\n"
		"\n"
		"Returns the libSBML version as a string of the form '1.2.3'.\n"
		"\n"
		"@return the libSBML version as a string of the form '1.2.3'.\n"
		"\n"
		"\n"
		""},
	 { (char *)"getLibSBMLVersionString", _wrap_getLibSBMLVersionString, METH_VARARGS, (char *)"\n"
		"getLibSBMLVersionString() -> char\n"
		"\n"
		"Returns the libSBML version as a string: version 1.2.3 becomes '10203'.\n"
		"\n"
		"@return the libSBML version as a string: version 1.2.3 becomes '10203'.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_SBMLReader", _wrap_new_SBMLReader, METH_VARARGS, (char *)"\n"
		"new_SBMLReader() -> SBMLReader\n"
		"\n"
		"Creates a new SBMLReader and returns it. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLReader", _wrap_delete_SBMLReader, METH_VARARGS, (char *)"delete_SBMLReader(SBMLReader self)"},
	 { (char *)"SBMLReader_readSBML", _wrap_SBMLReader_readSBML, METH_VARARGS, (char *)"\n"
		"SBMLReader_readSBML(SBMLReader self, string filename) -> SBMLDocument\n"
		"\n"
		"Reads an SBML document from a file.\n"
		"\n"
		"If the file named @p filename does not exist or its content is not\n"
		"valid SBML, one or more errors will be logged with the SBMLDocument\n"
		"object returned by this method.  Callers can use the methods on\n"
		"SBMLDocument such as SBMLDocument::getNumErrors() and\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif to get the errors.  The object returned by\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif is an SBMLError object, and it has methods to\n"
		"get the error code, category, and severity level of the problem, as\n"
		"well as a textual description of the problem.  The possible severity\n"
		"levels range from informational messages to fatal errors; see the\n"
		"documentation for SBMLError for more information.\n"
		"\n"
		"If the file @p filename could not be read, the file-reading error will\n"
		"appear first.  The error code (a value drawn from the enumeration\n"
		"#XMLErrorCode_t) can provide a clue about what happened.  For example,\n"
		"a file might be unreadable (either because it does not actually exist\n"
		"or because the user does not have the necessary access priviledges to\n"
		"read it) or some sort of file operation error may have been reported\n"
		"by the underlying operating system.  Callers can check for these\n"
		"situations using a program fragment such as the following:\n"
		"@code\n"
		"SBMLReader* reader = new SBMLReader();\n"
		"SBMLDocument* doc  = reader.readSBML(filename);\n"
		"\n"
		"if (doc->getNumErrors() > 0)\n"
		"{\n"
		"  if (doc->getError(0)->getId() == XMLError::FileUnreadable)\n"
		"  {\n"
		"    // Handle case of unreadable file here.\n"
		"  } \n"
		"  else if (doc->getError(0)->getId() == XMLError::FileOperationError)\n"
		"  {\n"
		"    // Handle case of other file error here.\n"
		"  }\n"
		"  else\n"
		"  {\n"
		"    // Handle other cases -- see error codes defined in XMLErrorCode_t\n"
		"    // for other possible cases to check.\n"
		"  }\n"
		"}\n"
		"@endcode\n"
		"\n"
		"If the given filename ends with the suffix @c '.gz' (for example, @c\n"
		"'myfile.xml.gz'), the file is assumed to be compressed in @em gzip\n"
		"format and will be automatically decompressed upon reading.\n"
		"Similarly, if the given filename ends with @c '.zip' or @c '.bz2', the\n"
		"file is assumed to be compressed in @em zip or @em bzip2 format\n"
		"(respectively).  Files whose names lack these suffixes will be read\n"
		"uncompressed.  Note that if the file is in @em zip format but the\n"
		"archive contains more than one file, only the first file in the\n"
		"archive will be read and the rest ignored.\n"
		"\n"
		"@param filename the name or full pathname of the file to be read.\n"
		"\n"
		"@return a pointer to the SBMLDocument created from the SBML content.\n"
		"\n"
		"@see SBMLError\n"
		"\n"
		"@note LibSBML versions 2.x and later versions behave differently in\n"
		"error handling in several respects.  One difference is how early some\n"
		"errors are caught and whether libSBML continues processing a file in\n"
		"the face of some early errors.  In general, libSBML versions after 2.x\n"
		"stop parsing SBML inputs sooner than libSBML version 2.x in the face\n"
		"of XML errors, because the errors may invalidate any further SBML\n"
		"content.  For example, a missing XML declaration at the beginning of\n"
		"the file was ignored by libSBML 2.x but in version 3.x and later, it\n"
		"will cause libSBML to stop parsing the rest of the input altogether.\n"
		"While this behavior may seem more severe and intolerant, it was\n"
		"necessary in order to provide uniform behavior regardless of which\n"
		"underlying XML parser (Expat, Xerces, libxml2) is being used by\n"
		"libSBML.  The XML parsers themselves behave differently in their error\n"
		"reporting, and sometimes libSBML has to resort to the lowest common\n"
		"denominator.\n"
		"<br><br>\n"
		"@note To read a gzip/zip file, libSBML needs to be configured and\n"
		"linked with the <a href='http://www.zlib.net/'>zlib</a> library at\n"
		"compile time.  It also needs to be linked with the <a\n"
		"href=''>bzip2</a> library to read files in @em bzip2 format.  (Both of\n"
		"these are the default configurations for libSBML.)  Errors about\n"
		"unreadable files will be logged if a compressed filename is given and\n"
		"libSBML was @em not linked with the corresponding required library.\n"
		"<br><br>\n"
		"@note SBMLReader::hasZlib() and SBMLReader::hasBzip2() can be used to\n"
		"check whether libSBML has been linked with each library.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_readSBMLFromFile", _wrap_SBMLReader_readSBMLFromFile, METH_VARARGS, (char *)"\n"
		"SBMLReader_readSBMLFromFile(SBMLReader self, string filename) -> SBMLDocument\n"
		"\n"
		"Reads an SBML document from a file.\n"
		"\n"
		"If the file named @p filename does not exist or its content is not\n"
		"valid SBML, one or more errors will be logged with the SBMLDocument\n"
		"object returned by this method.  Callers can use the methods on\n"
		"SBMLDocument such as SBMLDocument::getNumErrors() and\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif to get the errors.  The object returned by\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif is an SBMLError object, and it has methods to\n"
		"get the error code, category, and severity level of the problem, as\n"
		"well as a textual description of the problem.  The possible severity\n"
		"levels range from informational messages to fatal errors; see the\n"
		"documentation for SBMLError for more information.\n"
		"\n"
		"If the file @p filename could not be read, the file-reading error will\n"
		"appear first.  The error code (a value drawn from the enumeration\n"
		"#XMLErrorCode_t) can provide a clue about what happened.  For example,\n"
		"a file might be unreadable (either because it does not actually exist\n"
		"or because the user does not have the necessary access priviledges to\n"
		"read it) or some sort of file operation error may have been reported\n"
		"by the underlying operating system.  Callers can check for these\n"
		"situations using a program fragment such as the following:\n"
		"@code\n"
		"SBMLReader* reader = new SBMLReader();\n"
		"SBMLDocument* doc  = reader.readSBML(filename);\n"
		"\n"
		"if (doc->getNumErrors() > 0)\n"
		"{\n"
		"  if (doc->getError(0)->getId() == XMLError::FileUnreadable)\n"
		"  {\n"
		"    // Handle case of unreadable file here.\n"
		"  } \n"
		"  else if (doc->getError(0)->getId() == XMLError::FileOperationError)\n"
		"  {\n"
		"    // Handle case of other file error here.\n"
		"  }\n"
		"  else\n"
		"  {\n"
		"    // Handle other cases -- see error codes defined in XMLErrorCode_t\n"
		"    // for other possible cases to check.\n"
		"  }\n"
		"}\n"
		"@endcode\n"
		"\n"
		"If the given filename ends with the suffix @c '.gz' (for example, @c\n"
		"'myfile.xml.gz'), the file is assumed to be compressed in @em gzip\n"
		"format and will be automatically decompressed upon reading.\n"
		"Similarly, if the given filename ends with @c '.zip' or @c '.bz2', the\n"
		"file is assumed to be compressed in @em zip or @em bzip2 format\n"
		"(respectively).  Files whose names lack these suffixes will be read\n"
		"uncompressed.  Note that if the file is in @em zip format but the\n"
		"archive contains more than one file, only the first file in the\n"
		"archive will be read and the rest ignored.\n"
		"\n"
		"@param filename the name or full pathname of the file to be read.\n"
		"\n"
		"@return a pointer to the SBMLDocument created from the SBML content.\n"
		"\n"
		"@see SBMLError\n"
		"\n"
		"@note LibSBML versions 2.x and later versions behave differently in\n"
		"error handling in several respects.  One difference is how early some\n"
		"errors are caught and whether libSBML continues processing a file in\n"
		"the face of some early errors.  In general, libSBML versions after 2.x\n"
		"stop parsing SBML inputs sooner than libSBML version 2.x in the face\n"
		"of XML errors, because the errors may invalidate any further SBML\n"
		"content.  For example, a missing XML declaration at the beginning of\n"
		"the file was ignored by libSBML 2.x but in version 3.x and later, it\n"
		"will cause libSBML to stop parsing the rest of the input altogether.\n"
		"While this behavior may seem more severe and intolerant, it was\n"
		"necessary in order to provide uniform behavior regardless of which\n"
		"underlying XML parser (Expat, Xerces, libxml2) is being used by\n"
		"libSBML.  The XML parsers themselves behave differently in their error\n"
		"reporting, and sometimes libSBML has to resort to the lowest common\n"
		"denominator.\n"
		"<br><br>\n"
		"@note To read a gzip/zip file, libSBML needs to be configured and\n"
		"linked with the <a href='http://www.zlib.net/'>zlib</a> library at\n"
		"compile time.  It also needs to be linked with the <a\n"
		"href=''>bzip2</a> library to read files in @em bzip2 format.  (Both of\n"
		"these are the default configurations for libSBML.)  Errors about\n"
		"unreadable files will be logged if a compressed filename is given and\n"
		"libSBML was @em not linked with the corresponding required library.\n"
		"<br><br>\n"
		"@note SBMLReader::hasZlib() and SBMLReader::hasBzip2() can be used to\n"
		"check whether libSBML has been linked with each library.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_readSBMLFromString", _wrap_SBMLReader_readSBMLFromString, METH_VARARGS, (char *)"\n"
		"SBMLReader_readSBMLFromString(SBMLReader self, string xml) -> SBMLDocument\n"
		"\n"
		"Reads an SBML document from the given XML string.\n"
		"\n"
		"This method is flexible with respect to the presence of an XML\n"
		"declaration at the beginning of the string.  In particular, if the\n"
		"string in @p xml does not begin with the XML declaration\n"
		"<code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</code>, then this\n"
		"method will automatically prepend the declaration to @p xml.\n"
		"\n"
		"This method will log a fatal error if the content given in the\n"
		"parameter @p xml is not SBML.  See the method documentation for\n"
		"@if clike SBMLReader::readSBML() @endif@if java SBMLReader::readSBML(String filename) @endif for an example of code for testing the returned\n"
		"error code.\n"
		"\n"
		"@param xml a string containing a full SBML model\n"
		"\n"
		"@return a pointer to the SBMLDocument created from the SBML content.\n"
		"\n"
		"@if clike @see SBMLReader::readSBML() @endif@if java @see SBMLReader::readSBML(String filename) @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_hasZlib", _wrap_SBMLReader_hasZlib, METH_VARARGS, (char *)"\n"
		"SBMLReader_hasZlib() -> bool\n"
		"\n"
		"Predicate returning @c true if this copy\n"
		"of libSBML supports <i>gzip</I> and <i>zip</i> format compression.\n"
		"\n"
		"@return @c true if libSBML has been linked with the <i>zlib</i>\n"
		"library, @c false otherwise.\n"
		"\n"
		"@see hasBzip2()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_hasBzip2", _wrap_SBMLReader_hasBzip2, METH_VARARGS, (char *)"\n"
		"SBMLReader_hasBzip2() -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this copy of libSBML supports <i>bzip2</i> format compression.\n"
		"\n"
		"@return @c true if libSBML has been linked with the <i>bzip2</i>\n"
		"libraries, @c false otherwise.\n"
		"\n"
		"@see hasZlib()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_swigregister", SBMLReader_swigregister, METH_VARARGS, NULL},
	 { (char *)"readSBMLFromFile", _wrap_readSBMLFromFile, METH_VARARGS, (char *)"\n"
		"readSBMLFromFile(char filename) -> SBMLDocument_t\n"
		"\n"
		"Reads an SBML document from the given file @p filename.\n"
		"\n"
		"If @p filename does not exist, or it is not an SBML file, an error will\n"
		"be logged in the error log of the SBMLDocument object returned by this\n"
		"method.  Calling programs can inspect this error log to determine\n"
		"the nature of the problem.  Please refer to the definition of\n"
		"SBMLDocument for more information about the error reporting mechanism.\n"
		"\n"
		"@return a pointer to the SBMLDocument read.\n"
		"\n"
		"\n"
		""},
	 { (char *)"readSBMLFromString", _wrap_readSBMLFromString, METH_VARARGS, (char *)"\n"
		"readSBMLFromString(char xml) -> SBMLDocument_t\n"
		"\n"
		"Reads an SBML document from a string assumed to be in XML format.\n"
		"\n"
		"If the string does not begin with XML declaration,\n"
		" @verbatim\n"
		" <?xml version='1.0' encoding='UTF-8'?>\n"
		" @endverbatim\n"
		"\n"
		"an XML declaration string will be prepended.\n"
		"\n"
		"This method will report an error if the given string @p xml is not SBML.\n"
		"The error will be logged in the error log of the SBMLDocument object\n"
		"returned by this method.  Calling programs can inspect this error log to\n"
		"determine the nature of the problem.  Please refer to the definition of\n"
		"SBMLDocument for more information about the error reporting mechanism.\n"
		"\n"
		"@return a pointer to the SBMLDocument read.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_SBMLWriter", _wrap_new_SBMLWriter, METH_VARARGS, (char *)"\n"
		"new_SBMLWriter() -> SBMLWriter\n"
		"\n"
		"Creates a new SBMLWriter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLWriter", _wrap_delete_SBMLWriter, METH_VARARGS, (char *)"delete_SBMLWriter(SBMLWriter self)"},
	 { (char *)"SBMLWriter_setProgramName", _wrap_SBMLWriter_setProgramName, METH_VARARGS, (char *)"\n"
		"SBMLWriter_setProgramName(SBMLWriter self, string name) -> int\n"
		"\n"
		"Sets the name of this program, i.e., the program that is about to\n"
		"write out the SBMLDocument.\n"
		"\n"
		"If the program name and version are set (setProgramVersion()), the\n"
		"following XML comment, intended for human consumption, will be written\n"
		"at the beginning of the document:\n"
		"  @verbatim\n"
		"    <!-- Created by <program name> version <program version>\n"
		"    on yyyy-MM-dd HH:mm with libsbml version <libsbml version>. -->\n"
		" @endverbatim\n"
		"\n"
		"@param name the name of this program (where 'this program' refers to\n"
		"program in which libSBML is embedded, not libSBML itself!)\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setProgramVersion(const std::string& version)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_setProgramVersion", _wrap_SBMLWriter_setProgramVersion, METH_VARARGS, (char *)"\n"
		"SBMLWriter_setProgramVersion(SBMLWriter self, string version) -> int\n"
		"\n"
		"Sets the version of this program, i.e., the program that is about to\n"
		"write out the SBMLDocument.\n"
		"\n"
		"If the program version and name are set (setProgramName()), the\n"
		"following XML comment, intended for human consumption, will be written\n"
		"at the beginning of the document:\n"
		"  @verbatim\n"
		"    <!-- Created by <program name> version <program version>\n"
		"    on yyyy-MM-dd HH:mm with libsbml version <libsbml version>. -->\n"
		" @endverbatim\n"
		"\n"
		"@param version the version of this program (where 'this program'\n"
		"refers to program in which libSBML is embedded, not libSBML itself!)\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setProgramName(const std::string& name)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeSBML", _wrap_SBMLWriter_writeSBML, METH_VARARGS, (char *)"\n"
		"writeSBML(SBMLDocument d, string filename) -> bool\n"
		"SBMLWriter_writeSBML(SBMLWriter self, SBMLDocument d, ostream stream) -> bool\n"
		"\n"
		"Writes the given SBML document to the output stream.\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@param stream the stream object where the SBML is to be written.\n"
		"\n"
		"@return @c true on success and @c false if one of the underlying\n"
		"parser components fail (rare).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeToString", _wrap_SBMLWriter_writeToString, METH_VARARGS, (char *)"\n"
		"SBMLWriter_writeToString(SBMLWriter self, SBMLDocument d) -> char\n"
		"\n"
		"Writes the given SBML document to an in-memory string and returns a\n"
		"pointer to it.\n"
		"\n"
		"The string is owned by the caller and should be freed (with @c free())\n"
		"when no longer needed.\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@return the string on success and @c 0 if one of the underlying parser\n"
		"components fail.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeSBMLToFile", _wrap_SBMLWriter_writeSBMLToFile, METH_VARARGS, (char *)"\n"
		"SBMLWriter_writeSBMLToFile(SBMLWriter self, SBMLDocument d, string filename) -> bool\n"
		"\n"
		"Writes the given SBML document to filename.\n"
		"\n"
		"If the given filename ends with the suffix @c '.gz' (for example, @c\n"
		"'myfile.xml.gz'), libSBML assumes the caller wants the file to be\n"
		"written compressed in @em gzip.  Similarly, if the given filename ends\n"
		"with @c '.zip' or @c '.bz2', libSBML assumes the caller wants the file\n"
		"to be compressed in @em zip or @em bzip2 format (respectively).  Files\n"
		"whose names lack these suffixes will be written uncompressed.\n"
		"<em>Special considerations for the zip format</em>: If the given\n"
		"filename ends with @c '.zip', the file placed in the zip archive will\n"
		"have the suffix @c '.xml' or @c '.sbml'.  For example, the file in\n"
		"the zip archive will be named @c 'test.xml' if the given filename is\n"
		"@c 'test.xml.zip' or @c 'test.zip'.  Similarly, the filename in the\n"
		"archive will be @c 'test.sbml' if the given filename is @c\n"
		"'test.sbml.zip'.\n"
		"\n"
		"@note To write a gzip/zip file, libSBML needs to be configured and\n"
		"linked with the <a href='http://www.zlib.net/'>zlib</a> library at\n"
		"compile time.  It also needs to be linked with the <a\n"
		"href=''>bzip2</a> library to write files in @em bzip2 format.  (Both\n"
		"of these are the default configurations for libSBML.)  Errors about\n"
		"unreadable files will be logged and this method will return @c false\n"
		"if a compressed filename is given and libSBML was @em not linked with\n"
		"the corresponding required library.\n"
		"\n"
		"@note SBMLReader::hasZlib() and SBMLReader::hasBzip2() can be used to\n"
		"check whether libSBML has been linked with each library.\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@param filename the name or full pathname of the file where the SBML\n"
		"is to be written. \n"
		"\n"
		"@return @c true on success and @c false if the filename could not be\n"
		"opened for writing.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeSBMLToString", _wrap_SBMLWriter_writeSBMLToString, METH_VARARGS, (char *)"\n"
		"SBMLWriter_writeSBMLToString(SBMLWriter self, SBMLDocument d) -> char\n"
		"\n"
		"Writes the given SBML document to an in-memory string and returns a\n"
		"pointer to it.\n"
		"\n"
		"The string is owned by the caller and should be freed (with @c free())\n"
		"when no longer needed.\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@return the string on success and @c 0 if one of the underlying parser\n"
		"components fail.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_hasZlib", _wrap_SBMLWriter_hasZlib, METH_VARARGS, (char *)"\n"
		"SBMLWriter_hasZlib() -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"underlying libSBML is linked with zlib.\n"
		"\n"
		"LibSBML supports reading and writing files compressed with either\n"
		"bzip2 or zip/gzip compression.  The facility depends on libSBML having\n"
		"been compiled with the necessary support libraries.  This method\n"
		"allows a calling program to inquire whether that is the case for the\n"
		"copy of libSBML it is running.\n"
		"\n"
		"@return @c true if libSBML is linked with zlib, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_hasBzip2", _wrap_SBMLWriter_hasBzip2, METH_VARARGS, (char *)"\n"
		"SBMLWriter_hasBzip2() -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"underlying libSBML is linked with bzip2.\n"
		"\n"
		"LibSBML supports reading and writing files compressed with either\n"
		"bzip2 or zip/gzip compression.  The facility depends on libSBML having\n"
		"been compiled with the necessary support libraries.  This method\n"
		"allows a calling program to inquire whether that is the case for the\n"
		"copy of libSBML it is running.\n"
		"\n"
		"@return @c true if libSBML is linked with bzip2, @c false otherwise.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBMLWriter_swigregister", SBMLWriter_swigregister, METH_VARARGS, NULL},
	 { (char *)"writeSBML", _wrap_writeSBML, METH_VARARGS, (char *)"\n"
		"writeSBML(SBMLDocument_t d, char filename) -> int\n"
		"\n"
		"Writes the given SBML document to filename.  This convenience function\n"
		"is functionally equivalent to:\n"
		"\n"
		"  SBMLWriter_writeSBML(SBMLWriter_create(), d, filename);\n"
		"\n"
		"@return non-zero on success and zero if the filename could not be opened\n"
		"for writing.\n"
		"\n"
		"\n"
		""},
	 { (char *)"writeSBMLToString", _wrap_writeSBMLToString, METH_VARARGS, (char *)"\n"
		"writeSBMLToString(SBMLDocument_t d) -> char\n"
		"\n"
		"Writes the given SBML document to an in-memory string and returns a\n"
		"pointer to it.  The string is owned by the caller and should be freed\n"
		"(with free()) when no longer needed.  This convenience function is\n"
		"functionally equivalent to:\n"
		"\n"
		"  SBMLWriter_writeSBMLToString(SBMLWriter_create(), d);\n"
		"\n"
		"@return the string on success and @c NULL if one of the underlying parser\n"
		"components fail (rare).\n"
		"\n"
		"\n"
		""},
	 { (char *)"writeSBMLToFile", _wrap_writeSBMLToFile, METH_VARARGS, (char *)"\n"
		"writeSBMLToFile(SBMLDocument_t d, char filename) -> int\n"
		"\n"
		"Writes the given SBML document to an in-memory string and returns a\n"
		"pointer to it.  The string is owned by the caller and should be freed\n"
		"(with free()) when no longer needed.  This convenience function is\n"
		"functionally equivalent to:\n"
		"\n"
		"  SBMLWriter_writeSBMLToString(SBMLWriter_create(), d);\n"
		"\n"
		"@return the string on success and @c NULL if one of the underlying parser\n"
		"components fail (rare).\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBMLTypeCode_toString", _wrap_SBMLTypeCode_toString, METH_VARARGS, (char *)"\n"
		"SBMLTypeCode_toString(SBMLTypeCode_t tc) -> char\n"
		"\n"
		"This method takes an SBML type code and returns a string representing\n"
		"the code.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"This method takes a type code as argument, and returns a string name\n"
		"corresponding to that code.  For example, passing it the type code\n"
		"<code>SBML_COMPARTMENT</code> will return the string\n"
		"'<code>Compartment</code>'. \n"
		"\n"
		"@return a human readable name for the given #SBMLTypeCode_t.\n"
		"\n"
		"@note The caller does not own the returned string and is therefore not\n"
		"allowed to modify it.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SBase", _wrap_delete_SBase, METH_VARARGS, (char *)"delete_SBase(SBase self)"},
	 { (char *)"SBase_clone", _wrap_SBase_clone, METH_VARARGS, (char *)"\n"
		"SBase_clone(SBase self) -> SBase\n"
		"\n"
		"Creates and returns a deep copy of this SBase object.\n"
		"\n"
		"@return a (deep) copy of this SBase object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getMetaId", _wrap_SBase_getMetaId, METH_VARARGS, (char *)"\n"
		"SBase_getMetaId(SBase self) -> string\n"
		"\n"
		"Returns the value of the 'metaid' attribute of this object.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format).  The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model\n"
		"component for purposes such as referencing that component from\n"
		"metadata placed within 'annotation' subelements.\n"
		" \n"
		"@return the metaid of this SBML object, as a string.\n"
		"\n"
		"@see isSetMetaId()\n"
		"@see setMetaId(const std::string& metaid)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getId", _wrap_SBase_getId, METH_VARARGS, (char *)"\n"
		"SBase_getId(SBase self) -> string\n"
		"\n"
		"Returns the value of the 'metaid' attribute of this object.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format).  The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model\n"
		"component for purposes such as referencing that component from\n"
		"metadata placed within 'annotation' subelements.\n"
		" \n"
		"@return the metaid of this SBML object, as a string.\n"
		"\n"
		"@see isSetMetaId()\n"
		"@see setMetaId(const std::string& metaid)\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_getName", _wrap_SBase_getName, METH_VARARGS, (char *)"\n"
		"SBase_getName(SBase self) -> string\n"
		"\n"
		"Returns the value of the 'metaid' attribute of this object.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format).  The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model\n"
		"component for purposes such as referencing that component from\n"
		"metadata placed within 'annotation' subelements.\n"
		" \n"
		"@return the metaid of this SBML object, as a string.\n"
		"\n"
		"@see isSetMetaId()\n"
		"@see setMetaId(const std::string& metaid)\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_getNotes", _wrap_SBase_getNotes, METH_VARARGS, (char *)"\n"
		"SBase_getNotes(SBase self) -> XMLNode\n"
		"\n"
		"Returns the content of the 'notes' subelement of this object as\n"
		"a tree of XMLNode objects.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"The 'notes' element content returned by this method will be in XML\n"
		"form, but libSBML does not provide an object model specifically for\n"
		"the content of notes.  Callers will need to traverse the XML tree\n"
		"structure using the facilities available on XMLNode and related\n"
		"objects.  For an alternative method of accessing the notes, see\n"
		"getNotesString().\n"
		"\n"
		"@return the content of the 'notes' subelement of this SBML object as a\n"
		"tree structure composed of XMLNode objects.\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes(const XMLNode* notes)\n"
		"@see setNotes(const std::string& notes)\n"
		"@see appendNotes(const XMLNode* notes)\n"
		"@see appendNotes(const std::string& notes)\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker::hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getNotesString", _wrap_SBase_getNotesString, METH_VARARGS, (char *)"\n"
		"SBase_getNotesString(SBase self) -> string\n"
		"\n"
		"Returns the content of the 'notes' subelement of this object as a\n"
		"string.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"For an alternative method of accessing the notes, see getNotes(),\n"
		"which returns the content as an XMLNode tree structure.  Depending on\n"
		"an application's needs, one or the other method may be more\n"
		"convenient.\n"
		"\n"
		"@return the content of the 'notes' subelement of this SBML object as a\n"
		"string.\n"
		"\n"
		"@see getNotes()\n"
		"@see isSetNotes()\n"
		"@see setNotes(const XMLNode* notes)\n"
		"@see setNotes(const std::string& notes)\n"
		"@see appendNotes(const XMLNode* notes)\n"
		"@see appendNotes(const std::string& notes)\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker::hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getAnnotation", _wrap_SBase_getAnnotation, METH_VARARGS, (char *)"\n"
		"SBase_getAnnotation(SBase self) -> XMLNode\n"
		"\n"
		"Returns the content of the 'annotation' subelement of this object as\n"
		"a tree of XMLNode objects.\n"
		"\n"
		"Whereas the SBML 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"The annotations returned by this method will be in XML form.  LibSBML\n"
		"provides an object model and related interfaces for certain specific\n"
		"kinds of annotations, namely model history information and RDF\n"
		"content.  See the ModelHistory, CVTerm and RDFAnnotationParser classes\n"
		"for more information about the facilities available.\n"
		"\n"
		"@return the annotation of this SBML object as a tree of XMLNode objects.\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation(const XMLNode* annotation)\n"
		"@see setAnnotation(const std::string& annotation)\n"
		"@see appendAnnotation(const XMLNode* annotation)\n"
		"@see appendAnnotation(const std::string& annotation)\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getAnnotationString", _wrap_SBase_getAnnotationString, METH_VARARGS, (char *)"\n"
		"SBase_getAnnotationString(SBase self) -> string\n"
		"\n"
		"Returns the content of the 'annotation' subelement of this object as a\n"
		"character string.\n"
		"\n"
		"Whereas the SBML 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"The annotations returned by this method will be in string form.\n"
		"\n"
		"@return the annotation of this SBML object as a character string.\n"
		"\n"
		"@see getAnnotation()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation(const XMLNode* annotation)\n"
		"@see setAnnotation(const std::string& annotation)\n"
		"@see appendAnnotation(const XMLNode* annotation)\n"
		"@see appendAnnotation(const std::string& annotation)\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getNamespaces", _wrap_SBase_getNamespaces, METH_VARARGS, (char *)"\n"
		"SBase_getNamespaces(SBase self) -> XMLNamespaces\n"
		"\n"
		"Returns a list of the XML Namespaces declared on this SBML document.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in SBML Level&nbsp;3) packages used in addition to SBML Level&nbsp;3\n"
		"Core.\n"
		"\n"
		"@return the XML Namespaces associated with this SBML object\n"
		"\n"
		"@see getLevel()\n"
		"@see getVersion()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getSBMLDocument", _wrap_SBase_getSBMLDocument, METH_VARARGS, (char *)"\n"
		"getSBMLDocument() -> SBMLDocument\n"
		"SBase_getSBMLDocument(SBase self) -> SBMLDocument\n"
		"\n"
		"Returns the SBMLDocument object containing @em this object instance.\n"
		"\n"
		"LibSBML uses the class SBMLDocument as a top-level container for\n"
		"storing SBML content and data associated with it (such as warnings and\n"
		"error messages).  An SBML model in libSBML is contained inside an\n"
		"SBMLDocument object.  SBMLDocument corresponds roughly to the class\n"
		"<i>SBML</i> defined in the SBML Level&nbsp;3 and Level&nbsp;2\n"
		"specifications, but it does not have a direct correspondence in SBML\n"
		"Level&nbsp;1.  (But, it is created by libSBML no matter whether the\n"
		"model is Level&nbsp;1, Level&nbsp;2 or Level&nbsp;3.)\n"
		"\n"
		"This method allows the caller to obtain the SBMLDocument for the\n"
		"current object.\n"
		"\n"
		"@return the parent SBMLDocument object of this SBML object.\n"
		"\n"
		"@see getParentSBMLObject()\n"
		"@see getModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getParentSBMLObject", _wrap_SBase_getParentSBMLObject, METH_VARARGS, (char *)"\n"
		"SBase_getParentSBMLObject(SBase self) -> SBase\n"
		"\n"
		"Returns the parent SBML object containing this object.\n"
		"\n"
		"This returns the immediately-containing object.  This method is\n"
		"convenient when holding an object nested inside other objects in an\n"
		"SBML model.  \n"
		"\n"
		"@return the parent SBML object of this SBML object.\n"
		"\n"
		"@see getSBMLDocument()\n"
		"@see getModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getAncestorOfType", _wrap_SBase_getAncestorOfType, METH_VARARGS, (char *)"\n"
		"SBase_getAncestorOfType(SBase self, SBMLTypeCode_t type) -> SBase\n"
		"\n"
		"Returns the ancestor SBML object that corresponds to the given\n"
		"#SBMLTypeCode_t value.\n"
		"\n"
		"This function allows any object to determine its exact\n"
		"location/function within a model.  For example, in SBML Level&nbsp;2 a\n"
		"StoichiometryMath object has ancestors (in order) of type\n"
		"SpeciesReference, ListOfSpeciesReferences, Reaction, ListOfReactions\n"
		"and Model, any of which can be accessed via this function.\n"
		"\n"
		"@param type the #SBMLTypeCode_t of the ancestor being sought.\n"
		"\n"
		"@return the ancestor SBML object of this SBML object that corresponds\n"
		"to the given #SBMLTypeCode_t, or @c NULL if none exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getSBOTerm", _wrap_SBase_getSBOTerm, METH_VARARGS, (char *)"\n"
		"SBase_getSBOTerm(SBase self) -> int\n"
		"\n"
		"Returns the integer portion of the value of the 'sboTerm' attribute of\n"
		"this object.\n"
		"\n"
		"Beginning with SBML Level 2 Version 3, objects derived from SBase have\n"
		"an optional attribute named 'sboTerm' for supporting the use of the\n"
		"Systems Biology Ontology.  In SBML proper, the data type of the\n"
		"attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a\n"
		"seven digit integer number; libSBML simplifies the representation by\n"
		"only storing the NNNNNNN integer portion.  Thus, in libSBML, the\n"
		"'sboTerm' attribute on SBase has data type @c int, and SBO identifiers\n"
		"are stored simply as integers.  (For convenience, libSBML offers\n"
		"methods for returning both the integer form and a text-string form of\n"
		"the SBO identifier.)\n"
		"\n"
		"SBO terms are a type of optional annotation, and each different class\n"
		"of SBML object derived from SBase imposes its own requirements about\n"
		"the values permitted for 'sboTerm'.  Please consult the SBML\n"
		"Level&nbsp;2 Version&nbsp;4 specification for more information about\n"
		"the use of SBO and the 'sboTerm' attribute.\n"
		"\n"
		"@return the value of the 'sboTerm' attribute as an integer, or @c -1\n"
		"if the value is not set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getSBOTermID", _wrap_SBase_getSBOTermID, METH_VARARGS, (char *)"\n"
		"SBase_getSBOTermID(SBase self) -> string\n"
		"\n"
		"Returns the string representation of the 'sboTerm' attribute of\n"
		"this object.\n"
		"\n"
		"Beginning with SBML Level 2 Version 3, objects derived from SBase have\n"
		"an optional attribute named 'sboTerm' for supporting the use of the\n"
		"Systems Biology Ontology.  In SBML proper, the data type of the\n"
		"attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a\n"
		"seven digit integer number; libSBML simplifies the representation by\n"
		"only storing the NNNNNNN integer portion.  Thus, in libSBML, the\n"
		"'sboTerm' attribute on SBase has data type @c int, and SBO identifiers\n"
		"are stored simply as integers.  This method returns the entire SBO\n"
		"identifier as a text string in the form 'SBO:NNNNNNN'.\n"
		"\n"
		"SBO terms are a type of optional annotation, and each different class\n"
		"of SBML object derived from SBase imposes its own requirements about\n"
		"the values permitted for 'sboTerm'.  Please consult the SBML\n"
		"Level&nbsp;2 Version&nbsp;4 specification for more information about\n"
		"the use of SBO and the 'sboTerm' attribute.\n"
		"\n"
		"@return the value of the 'sboTerm' attribute as a string (its value\n"
		"will be of the form <code>SBO:NNNNNNN</code>), or an empty string if\n"
		"the value is not set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getLine", _wrap_SBase_getLine, METH_VARARGS, (char *)"\n"
		"SBase_getLine(SBase self) -> unsigned int\n"
		"\n"
		"Returns the line number on which this object first appears in the XML\n"
		"representation of the SBML document.\n"
		"\n"
		"@return the line number of this SBML object.\n"
		"\n"
		"@see getColumn()\n"
		"\n"
		"@note The line number for each construct in an SBML model is set upon\n"
		"reading the model.  The accuracy of the line number depends on the\n"
		"correctness of the XML representation of the model, and on the\n"
		"particular XML parser library being used.  The former limitation\n"
		"relates to the following problem: if the model is actually invalid\n"
		"XML, then the parser may not be able to interpret the data correctly\n"
		"and consequently may not be able to establish the real line number.\n"
		"The latter limitation is simply that different parsers seem to have\n"
		"their own accuracy limitations, and out of all the parsers supported\n"
		"by libSBML, none have been 100% accurate in all situations. (At this\n"
		"time, libSBML supports the use of <a target='_blank'\n"
		"href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'\n"
		"href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'\n"
		"href='http://http://xerces.apache.org/xerces-c/'>Xerces</a>.)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getColumn", _wrap_SBase_getColumn, METH_VARARGS, (char *)"\n"
		"SBase_getColumn(SBase self) -> unsigned int\n"
		"\n"
		"Returns the column number on which this object first appears in the XML\n"
		"representation of the SBML document.\n"
		"\n"
		"@return the column number of this SBML object.\n"
		"\n"
		"@see getLine()\n"
		"\n"
		"@note The column number for each construct in an SBML model is set\n"
		"upon reading the model.  The accuracy of the column number depends on\n"
		"the correctness of the XML representation of the model, and on the\n"
		"particular XML parser library being used.  The former limitation\n"
		"relates to the following problem: if the model is actually invalid\n"
		"XML, then the parser may not be able to interpret the data correctly\n"
		"and consequently may not be able to establish the real column number.\n"
		"The latter limitation is simply that different parsers seem to have\n"
		"their own accuracy limitations, and out of all the parsers supported\n"
		"by libSBML, none have been 100% accurate in all situations. (At this\n"
		"time, libSBML supports the use of <a target='_blank'\n"
		"href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'\n"
		"href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'\n"
		"href='http://http://xerces.apache.org/xerces-c/'>Xerces</a>.)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getModelHistory", _wrap_SBase_getModelHistory, METH_VARARGS, (char *)"\n"
		"getModelHistory() -> ModelHistory\n"
		"SBase_getModelHistory(SBase self) -> ModelHistory\n"
		"\n"
		"Returns the ModelHistory object, if any, attached to this object.\n"
		"\n"
		"@return the ModelHistory object attached to this object, or @c NULL if\n"
		"none exist.\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetMetaId", _wrap_SBase_isSetMetaId, METH_VARARGS, (char *)"\n"
		"SBase_isSetMetaId(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'metaid' attribute has been set.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format). The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model component for purposes\n"
		"such as referencing that component from metadata placed within\n"
		"'annotation' subelements.\n"
		"\n"
		"@return @c true if the 'metaid' attribute of this SBML object has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@see getMetaId()\n"
		"@see setMetaId(const std::string& metaid)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetId", _wrap_SBase_isSetId, METH_VARARGS, (char *)"\n"
		"SBase_isSetId(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'metaid' attribute has been set.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format). The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model component for purposes\n"
		"such as referencing that component from metadata placed within\n"
		"'annotation' subelements.\n"
		"\n"
		"@return @c true if the 'metaid' attribute of this SBML object has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@see getMetaId()\n"
		"@see setMetaId(const std::string& metaid)\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_isSetName", _wrap_SBase_isSetName, METH_VARARGS, (char *)"\n"
		"SBase_isSetName(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'metaid' attribute has been set.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format). The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model component for purposes\n"
		"such as referencing that component from metadata placed within\n"
		"'annotation' subelements.\n"
		"\n"
		"@return @c true if the 'metaid' attribute of this SBML object has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@see getMetaId()\n"
		"@see setMetaId(const std::string& metaid)\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_isSetNotes", _wrap_SBase_isSetNotes, METH_VARARGS, (char *)"\n"
		"SBase_isSetNotes(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'notes' subelement exists and has content.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@return @c true if a 'notes' subelement exists, @c false otherwise.\n"
		"\n"
		"@see getNotes()\n"
		"@see getNotesString()\n"
		"@see setNotes(const XMLNode* notes)\n"
		"@see setNotes(const std::string& notes)\n"
		"@see appendNotes(const XMLNode* notes)\n"
		"@see appendNotes(const std::string& notes)\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker::hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetAnnotation", _wrap_SBase_isSetAnnotation, METH_VARARGS, (char *)"\n"
		"SBase_isSetAnnotation(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'annotation' subelement exists and has content.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"@return @c true if a 'annotation' subelement exists, @c false\n"
		"otherwise.\n"
		"\n"
		"@see getAnnotation()\n"
		"@see getAnnotationString()\n"
		"@see setAnnotation(const XMLNode* annotation)\n"
		"@see setAnnotation(const std::string& annotation)\n"
		"@see appendAnnotation(const XMLNode* annotation)\n"
		"@see appendAnnotation(const std::string& annotation)\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetSBOTerm", _wrap_SBase_isSetSBOTerm, METH_VARARGS, (char *)"\n"
		"SBase_isSetSBOTerm(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'sboTerm' attribute has been set.\n"
		"\n"
		"@return @c true if the 'sboTerm' attribute of this SBML object has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setMetaId", _wrap_SBase_setMetaId, METH_VARARGS, (char *)"\n"
		"SBase_setMetaId(SBase self, string metaid) -> int\n"
		"\n"
		"Sets the value of the 'metaid' attribute of this object.\n"
		"\n"
		"The string @p metaid is copied.  The value of @p metaid must be an\n"
		"identifier conforming to the syntax defined by the XML 1.0 data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>ID</a>.  Among other\n"
		"things, this type requires that a value is unique among all the values\n"
		"of type XML ID in an SBMLDocument.  Although SBML only uses <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a> for the 'metaid'\n"
		"attribute, callers should be careful if they use\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>'s in XML\n"
		"portions of a model that are not defined by SBML, such as in the\n"
		"application-specific content of the 'annotation' subelement.\n"
		"\n"
		"@param metaid the identifier string to use as the value of the\n"
		"'metaid' attribute\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@see getMetaId()\n"
		"@see isSetMetaId()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetModelHistory", _wrap_SBase_isSetModelHistory, METH_VARARGS, (char *)"\n"
		"SBase_isSetModelHistory(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object has a ModelHistory object attached to it.\n"
		"\n"
		"@return @c true if the ModelHistory of this object has been set, @c\n"
		"false otherwise.\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setId", _wrap_SBase_setId, METH_VARARGS, (char *)"\n"
		"SBase_setId(SBase self, string sid) -> int\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object has a ModelHistory object attached to it.\n"
		"\n"
		"@return @c true if the ModelHistory of this object has been set, @c\n"
		"false otherwise.\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_setName", _wrap_SBase_setName, METH_VARARGS, (char *)"\n"
		"SBase_setName(SBase self, string name) -> int\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object has a ModelHistory object attached to it.\n"
		"\n"
		"@return @c true if the ModelHistory of this object has been set, @c\n"
		"false otherwise.\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_setAnnotation", _wrap_SBase_setAnnotation, METH_VARARGS, (char *)"\n"
		"setAnnotation(XMLNode annotation) -> int\n"
		"SBase_setAnnotation(SBase self, string annotation) -> int\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object.\n"
		"\n"
		"The content of @p annotation is copied, and any previous content of\n"
		"this object's 'annotation' subelement is deleted.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"Call this method will result in any existing content of the\n"
		"'annotation' subelement to be discarded.  Unless you have taken steps\n"
		"to first copy and reconstitute any existing annotations into the @p\n"
		"annotation that is about to be assigned, it is likely that performing\n"
		"such wholesale replacement is unfriendly towards other software\n"
		"applications whose annotations are discarded.  An alternative may be\n"
		"to use SBase::appendAnnotation(const XMLNode* annotation) or\n"
		"SBase::appendAnnotation(const std::string& annotation).\n"
		"\n"
		"@param annotation an XML string that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation(const XMLNode* annotation)\n"
		"@see appendAnnotation(const XMLNode* annotation)\n"
		"@see appendAnnotation(const std::string& annotation)\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_appendAnnotation", _wrap_SBase_appendAnnotation, METH_VARARGS, (char *)"\n"
		"appendAnnotation(XMLNode annotation) -> int\n"
		"SBase_appendAnnotation(SBase self, string annotation) -> int\n"
		"\n"
		"Appends the given @p annotation to the 'annotation' subelement of this\n"
		"object.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a\n"
		"target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type 'any'</a>,\n"
		"allowing essentially arbitrary well-formed XML data content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"Unlike SBase::setAnnotation(const XMLNode* annotation) or\n"
		"SBase::setAnnotation(const std::string& annotation), this method\n"
		"allows other annotations to be preserved when an application adds its\n"
		"own data.\n"
		"\n"
		"@param annotation an XML string that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation(const XMLNode* annotation)\n"
		"@see setAnnotation(const std::string& annotation)\n"
		"@see appendAnnotation(const XMLNode* annotation)\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setNotes", _wrap_SBase_setNotes, METH_VARARGS, (char *)"\n"
		"setNotes(XMLNode notes) -> int\n"
		"SBase_setNotes(SBase self, string notes) -> int\n"
		"\n"
		"Sets the value of the 'notes' subelement of this SBML object to a copy\n"
		"of the string @p notes.\n"
		"\n"
		"The content of @p notes is copied, and any existing content of this\n"
		"object's 'notes' subelement is deleted.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@param notes an XML string that is to be used as the content of the\n"
		"'notes' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes(const XMLNode* notes)\n"
		"@see appendNotes(const XMLNode* notes)\n"
		"@see appendNotes(const std::string& notes)\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker::hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_appendNotes", _wrap_SBase_appendNotes, METH_VARARGS, (char *)"\n"
		"appendNotes(XMLNode notes) -> int\n"
		"SBase_appendNotes(SBase self, string notes) -> int\n"
		"\n"
		"Appends the given @p notes to the 'notes' subelement of this object.\n"
		"\n"
		"The content of the parameter @p notes is copied.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@param notes an XML string that is to appended to the content of\n"
		"the 'notes' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes(const XMLNode* notes)\n"
		"@see setNotes(const std::string& notes)\n"
		"@see appendNotes(const XMLNode* notes)\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker::hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setModelHistory", _wrap_SBase_setModelHistory, METH_VARARGS, (char *)"\n"
		"SBase_setModelHistory(SBase self, ModelHistory history) -> int\n"
		"\n"
		"Sets the ModelHistory of this object.\n"
		"\n"
		"The content of @p history is copied, and this object's existing model\n"
		"history content is deleted.\n"
		"\n"
		"@param history ModelHistory of this object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setSBOTerm", _wrap_SBase_setSBOTerm, METH_VARARGS, (char *)"\n"
		"setSBOTerm(int value) -> int\n"
		"SBase_setSBOTerm(SBase self, string sboid) -> int\n"
		"\n"
		"Sets the value of the 'sboTerm' attribute by string.\n"
		"\n"
		"Beginning with SBML Level 2 Version 3, objects derived from SBase have\n"
		"an optional attribute named 'sboTerm' for supporting the use of the\n"
		"Systems Biology Ontology.  In SBML proper, the data type of the\n"
		"attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a\n"
		"seven digit integer number; libSBML simplifies the representation by\n"
		"only storing the NNNNNNN integer portion.  Thus, in libSBML, the\n"
		"'sboTerm' attribute on SBase has data type @c int, and SBO identifiers\n"
		"are stored simply as integers.  This method lets you set the value of\n"
		"'sboTerm' as a complete string of the form 'SBO:NNNNNNN', whereas\n"
		"setSBOTerm(int value) allows you to set it using the integer form.\n"
		"\n"
		"SBO terms are a type of optional annotation, and each different class\n"
		"of SBML object derived from SBase imposes its own requirements about\n"
		"the values permitted for 'sboTerm'.  Please consult the SBML\n"
		"Level&nbsp;2 Version&nbsp;4 specification for more information about\n"
		"the use of SBO and the 'sboTerm' attribute.\n"
		"\n"
		"@param sboid the SBO identifier string of the form SBO:NNNNNNN\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@see setSBOTerm(int value)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setNamespaces", _wrap_SBase_setNamespaces, METH_VARARGS, (char *)"\n"
		"SBase_setNamespaces(SBase self, XMLNamespaces xmlns) -> int\n"
		"\n"
		"Sets the namespaces relevant of this SBML object.\n"
		"\n"
		"The content of @p xmlns is copied, and this object's existing\n"
		"namespace content is deleted.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"\n"
		"@param xmlns the namespaces to set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetMetaId", _wrap_SBase_unsetMetaId, METH_VARARGS, (char *)"\n"
		"SBase_unsetMetaId(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'metaid' attribute of this SBML object.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format). The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model component for purposes\n"
		"such as referencing that component from metadata placed within\n"
		"'annotation' subelements.\n"
		" \n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetNotes", _wrap_SBase_unsetNotes, METH_VARARGS, (char *)"\n"
		"SBase_unsetNotes(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'notes' subelement of this SBML object.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes(const XMLNode* notes)\n"
		"@see setNotes(const std::string& notes)\n"
		"@see appendNotes(const XMLNode* notes)\n"
		"@see appendNotes(const std::string& notes)\n"
		"@see SyntaxChecker::hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetAnnotation", _wrap_SBase_unsetAnnotation, METH_VARARGS, (char *)"\n"
		"SBase_unsetAnnotation(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'annotation' subelement of this SBML object.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see getAnnotation()\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation(const XMLNode* annotation)\n"
		"@see setAnnotation(const std::string& annotation)\n"
		"@see appendAnnotation(const XMLNode* annotation)\n"
		"@see appendAnnotation(const std::string& annotation)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetSBOTerm", _wrap_SBase_unsetSBOTerm, METH_VARARGS, (char *)"\n"
		"SBase_unsetSBOTerm(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'sboTerm' attribute of this SBML object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_addCVTerm", _wrap_SBase_addCVTerm, METH_VARARGS, (char *)"\n"
		"addCVTerm(CVTerm term, bool newBag = False) -> int\n"
		"SBase_addCVTerm(SBase self, CVTerm term) -> int\n"
		"\n"
		"Adds a copy of the given CVTerm object to this SBML object.\n"
		"\n"
		"@param term the CVTerm to assign\n"
		"\n"
		"@param newBag if @c true, creates a new RDF bag with the same identifier\n"
		"as a previous bag, and if @c false, adds the term to an existing\n"
		"RDF bag with the same type of qualifier as the term being added.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink, if\n"
		"this object lacks a 'metaid' attribute\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note Since the CV Term uses the 'metaid' attribute of the object as a\n"
		"reference, if the object has no 'metaid' attribute value set, then the\n"
		"CVTerm will not be added.\n"
		"\n"
		"@warning The fact that this method @em copies the object passed to it\n"
		"means that the caller will be left holding a physically different\n"
		"object instance than the one contained in @em this object.  Changes\n"
		"made to the original object instance (such as resetting attribute\n"
		"values) will <em>not affect the instance added here</em>.  In\n"
		"addition, the caller should make sure to free the original object if\n"
		"it is no longer being used, or else a memory leak will result.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getCVTerms", _wrap_SBase_getCVTerms, METH_VARARGS, (char *)"\n"
		"getCVTerms() -> List\n"
		"SBase_getCVTerms(SBase self) -> List\n"
		"\n"
		"Returns a list of CVTerm objects in the annotations of this SBML\n"
		"object.\n"
		"\n"
		"@return the list of CVTerms for this SBML object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getNumCVTerms", _wrap_SBase_getNumCVTerms, METH_VARARGS, (char *)"\n"
		"SBase_getNumCVTerms(SBase self) -> unsigned int\n"
		"\n"
		"Returns the number of CVTerm objects in the annotations of this SBML\n"
		"object.\n"
		"\n"
		"@return the number of CVTerms for this SBML object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getCVTerm", _wrap_SBase_getCVTerm, METH_VARARGS, (char *)"\n"
		"SBase_getCVTerm(SBase self, unsigned int n) -> CVTerm\n"
		"\n"
		"Returns the nth CVTerm in the list of CVTerms of this SBML\n"
		"object.\n"
		"\n"
		"@param n unsigned int the index of the CVTerm to retrieve\n"
		"\n"
		"@return the nth CVTerm in the list of CVTerms for this SBML object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetCVTerms", _wrap_SBase_unsetCVTerms, METH_VARARGS, (char *)"\n"
		"SBase_unsetCVTerms(SBase self) -> int\n"
		"\n"
		"Clears the list of CVTerm objects attached to this SBML object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetModelHistory", _wrap_SBase_unsetModelHistory, METH_VARARGS, (char *)"\n"
		"SBase_unsetModelHistory(SBase self) -> int\n"
		"\n"
		"Unsets the ModelHistory object attached to this object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getResourceBiologicalQualifier", _wrap_SBase_getResourceBiologicalQualifier, METH_VARARGS, (char *)"\n"
		"SBase_getResourceBiologicalQualifier(SBase self, string resource) -> BiolQualifierType_t\n"
		"\n"
		"Returns the MIRIAM <em>biological qualifier</em> associated with the\n"
		"given resource.\n"
		"\n"
		"In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,\n"
		"qualifiers are an optional means of indicating the relationship\n"
		"between a model component and its annotations.  There are two broad\n"
		"kinds of annotations: <em>model</em> and <em>biological</em>.  The\n"
		"latter kind is used to qualify the relationship between a model\n"
		"component and a biological entity which it represents.  Examples of\n"
		"relationships include 'is' and 'has part', but many others are\n"
		"possible.  MIRIAM defines <a target='_blank'\n"
		"href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous\n"
		"relationship qualifiers</a> to enable different software tools to\n"
		"qualify biological annotations in the same standardized way.  In\n"
		"libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model\n"
		"element are represented using lists of CVTerm objects, and the\n"
		"enumeration #BiolQualifierType_t corresponds to the list of MIRIAM\n"
		"biological qualifiers.\n"
		"\n"
		"This method method searches the controlled-vocabulary annotations\n"
		"(i.e., the list of CVTerm objects) on the present object, then out of\n"
		"those that have biological qualifiers, looks for an annotation to the\n"
		"given @p resource.  If such an annotation is found, it returns the\n"
		"type of biological qualifier associated with that resource as a \n"
		"value from  #BiolQualifierType_t.\n"
		"\n"
		"@param resource string representing the resource; e.g.,\n"
		"@c 'http://www.geneontology.org/#GO:0005892'\n"
		"\n"
		"@return the #BiolQualifierType_t value associated with the resource,\n"
		"or @link BiolQualifierType_t#BQB_UNKNOWN BQB_UNKNOWN@endlink if the\n"
		"resource does not exist.\n"
		"\n"
		"@note The set of MIRIAM biological qualifiers grows over time,\n"
		"although relatively slowly.  The values in the enumeration\n"
		"#BiolQualifierType_t are up to date with MIRIAM at the time of a given\n"
		"libSBML release.  The set of values may be expanded in later libSBML\n"
		"releases, to match the values defined by MIRIAM at that later time.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getResourceModelQualifier", _wrap_SBase_getResourceModelQualifier, METH_VARARGS, (char *)"\n"
		"SBase_getResourceModelQualifier(SBase self, string resource) -> ModelQualifierType_t\n"
		"\n"
		"Returns the MIRIAM <em>model qualifier</em> associated with the\n"
		"given resource.\n"
		"\n"
		"In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,\n"
		"qualifiers are an optional means of indicating the relationship\n"
		"between a model component and its annotations.  There are two broad\n"
		"kinds of annotations: <em>model</em> and <em>biological</em>.  The\n"
		"former kind is used to qualify the relationship between a model\n"
		"component and another modeling object.  An example qualifier is\n"
		"'isDerivedFrom', to indicate that a given component of the model is\n"
		"derived from the modeling object represented by the referenced\n"
		"resource.  MIRIAM defines <a target='_blank'\n"
		"href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous\n"
		"relationship qualifiers</a> to enable different software tools to\n"
		"qualify model annotations in the same standardized way.  In libSBML,\n"
		"the MIRIAM controlled-vocabulary annotations on an SBML model element\n"
		"are represented using lists of CVTerm objects, and the enumeration\n"
		"#ModelQualifierType_t corresponds to the list of MIRIAM model\n"
		"qualifiers.\n"
		"\n"
		"This method method searches the controlled-vocabulary annotations\n"
		"(i.e., the list of CVTerm objects) on the present object, then out of\n"
		"those that have model qualifiers, looks for an annotation to the given\n"
		"@p resource.  If such an annotation is found, it returns the type of\n"
		"model qualifier associated with that resource as a value from\n"
		"#ModelQualifierType_t.\n"
		"\n"
		"@param resource string representing the resource; e.g., @c\n"
		"'http://www.geneontology.org/#GO:0005892'\n"
		"\n"
		"@return the #ModelQualifierType_t value associated with the resource,\n"
		"or @link ModelQualifierType_t#BQM_UNKNOWN BQM_UNKNOWN@endlink if the\n"
		"resource does not exist.\n"
		"\n"
		"@note The set of MIRIAM model qualifiers grows over time,\n"
		"although relatively slowly.  The values in the enumeration\n"
		"#ModelQualifierType_t are up to date with MIRIAM at the time of a given\n"
		"libSBML release.  The set of values may be expanded in later libSBML\n"
		"releases, to match the values defined by MIRIAM at that later time.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getModel", _wrap_SBase_getModel, METH_VARARGS, (char *)"\n"
		"SBase_getModel(SBase self) -> Model\n"
		"\n"
		"Returns the Model object in which the current object is located.\n"
		"\n"
		"@return the parent Model of this SBML object.\n"
		"\n"
		"@see getParentSBMLObject()\n"
		"@see getSBMLDocument()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getLevel", _wrap_SBase_getLevel, METH_VARARGS, (char *)"\n"
		"SBase_getLevel(SBase self) -> unsigned int\n"
		"\n"
		"Returns the SBML Level of the SBMLDocument object containing this\n"
		"object.\n"
		"\n"
		"@return the SBML level of this SBML object.\n"
		"\n"
		"@see getVersion()\n"
		"@see getNamespaces()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getVersion", _wrap_SBase_getVersion, METH_VARARGS, (char *)"\n"
		"SBase_getVersion(SBase self) -> unsigned int\n"
		"\n"
		"Returns the Version within the SBML Level of the SBMLDocument object\n"
		"containing this object.\n"
		"\n"
		"@return the SBML version of this SBML object.\n"
		"\n"
		"@see getLevel()\n"
		"@see getNamespaces()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getTypeCode", _wrap_SBase_getTypeCode, METH_VARARGS, (char *)"\n"
		"SBase_getTypeCode(SBase self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this object.\n"
		"\n"
		"This method may return the type code of this SBML object, or it may\n"
		"return @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink.  This\n"
		"is because subclasses of SBase are not required to implement this\n"
		"method to return a type code.  This method is meant primarily for the\n"
		"LibSBML C interface, in which class and subclass information is not\n"
		"readily available.\n"
		"\n"
		"@return the #SBMLTypeCode_t value of this SBML object or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_hasValidLevelVersionNamespaceCombination", _wrap_SBase_hasValidLevelVersionNamespaceCombination, METH_VARARGS, (char *)"\n"
		"SBase_hasValidLevelVersionNamespaceCombination(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's level/version and namespace values correspond to a valid\n"
		"SBML specification.\n"
		"\n"
		"The valid combinations of SBML Level, Version and Namespace as of this\n"
		"release of libSBML are the following:\n"
		"<ul>\n"
		"<li> Level&nbsp;1 Version&nbsp;2: <code>'http://www.sbml.org/sbml/level1'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;1: <code>'http://www.sbml.org/sbml/level2'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;2: <code>'http://www.sbml.org/sbml/level2/version2'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;3: <code>'http://www.sbml.org/sbml/level2/version3'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;4: <code>'http://www.sbml.org/sbml/level2/version4'</code>\n"
		"<li> Level&nbsp;3 Version&nbsp;1 Core: <code>'http://www.sbml.org/sbml/level3/version1/core'</code>\n"
		"</ul>\n"
		"\n"
		"@return @c true if the level, version and namespace values of this \n"
		"SBML object correspond to a valid set of values, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getElementName", _wrap_SBase_getElementName, METH_VARARGS, (char *)"\n"
		"SBase_getElementName(SBase self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"This is overridden by subclasses to return a string appropriate to the\n"
		"SBML component.  For example, Model defines it as returning @c\n"
		"'model', CompartmentType defines it as returning @c 'compartmentType',\n"
		"and so on.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_toSBML", _wrap_SBase_toSBML, METH_VARARGS, (char *)"\n"
		"SBase_toSBML(SBase self) -> char\n"
		"\n"
		"Returns a string consisting of a partial SBML corresponding to just\n"
		"this object.\n"
		"\n"
		"@return the partial SBML that describes this SBML object.\n"
		"\n"
		"@warning This is primarily provided for testing and debugging\n"
		"purposes.  It may be removed in a future version of libSBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_hasRequiredAttributes", _wrap_SBase_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"SBase_hasRequiredAttributes(SBase self) -> bool\n"
		"\n"
		"Subclasses should override this method to write out their contained\n"
		"SBML objects as XML elements.  Be sure to call your parents\n"
		"implementation of this method as well.  For example:\n"
		"\n"
		"  SBase::writeElements(stream);\n"
		"  mReactans.write(stream);\n"
		"  mProducts.write(stream);\n"
		"  ...\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_hasRequiredElements", _wrap_SBase_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"SBase_hasRequiredElements(SBase self) -> bool\n"
		"\n"
		"Subclasses should override this method to write out their contained\n"
		"SBML objects as XML elements.  Be sure to call your parents\n"
		"implementation of this method as well.  For example:\n"
		"\n"
		"  SBase::writeElements(stream);\n"
		"  mReactans.write(stream);\n"
		"  mProducts.write(stream);\n"
		"  ...\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBase_swigregister", SBase_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_ListOf", _wrap_delete_ListOf, METH_VARARGS, (char *)"delete_ListOf(ListOf self)"},
	 { (char *)"new_ListOf", _wrap_new_ListOf, METH_VARARGS, (char *)"\n"
		"ListOf()\n"
		"new_ListOf(ListOf orig) -> ListOf\n"
		"\n"
		"Copy constructor.  Creates a copy of this ListOf.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_clone", _wrap_ListOf_clone, METH_VARARGS, (char *)"\n"
		"ListOf_clone(ListOf self) -> SBase\n"
		"\n"
		"Creates and returns a deep copy of this ListOf.\n"
		"\n"
		"@return a (deep) copy of this ListOf.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_append", _wrap_ListOf_append, METH_VARARGS, (char *)"\n"
		"ListOf_append(ListOf self, SBase item)\n"
		"\n"
		"Adds item to the end of this ListOf.\n"
		"\n"
		"This variant of the method makes a clone of the @p item handed to it.\n"
		"This means that when the ListOf is destroyed, the original items will\n"
		"not be destroyed.\n"
		"\n"
		"@param item the item to be added to the list.\n"
		"\n"
		"@see appendAndOwn(SBase* item)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_appendAndOwn", _wrap_ListOf_appendAndOwn, METH_VARARGS, (char *)"\n"
		"ListOf_appendAndOwn(ListOf self, SBase item)\n"
		"\n"
		"Adds item to the end of this ListOf.\n"
		"\n"
		"This variant of the method does not clone the @p item handed to it;\n"
		"instead, it assumes ownership of it.  This means that when the ListOf\n"
		"is destroyed, the item will be destroyed along with it.\n"
		"\n"
		"@param item the item to be added to the list.\n"
		"\n"
		"@see append(const SBase* item)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_get", _wrap_ListOf_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> SBase\n"
		"ListOf_get(ListOf self, unsigned int n) -> SBase\n"
		"\n"
		"Get an item from the list based on its identifier.\n"
		"\n"
		"@param sid a string representing the the identifier of the item to get.\n"
		"\n"
		"@return item in this ListOf items with the given id or NULL if no such\n"
		"item exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_clear", _wrap_ListOf_clear, METH_VARARGS, (char *)"\n"
		"clear(bool doDelete = True)\n"
		"ListOf_clear(ListOf self)\n"
		"\n"
		"Removes all items in this ListOf object.\n"
		"\n"
		"If doDelete is true (default), all items in this ListOf object are deleted\n"
		"and cleared, and thus the caller doesn't have to delete those items.\n"
		"Otherwise, all items are just cleared from this ListOf object and the caller \n"
		"is responsible for deleting all items (In this case, pointers to all items \n"
		"should be stored elsewhere before calling this function by the caller).\n"
		"\n"
		"@param doDelete if true (default), all items are deleted and cleared.\n"
		"Otherwise, all items are just cleared and not deleted. \n"
		"   \n"
		"\n"
		""},
	 { (char *)"ListOf_remove", _wrap_ListOf_remove, METH_VARARGS, (char *)"\n"
		"ListOf_remove(ListOf self, unsigned int n) -> SBase\n"
		"\n"
		"Removes item in this ListOf items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_size", _wrap_ListOf_size, METH_VARARGS, (char *)"\n"
		"ListOf_size(ListOf self) -> unsigned int\n"
		"\n"
		"Get the size of this ListOf.\n"
		"\n"
		"@return the number of items in this ListOf items.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_getTypeCode", _wrap_ListOf_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOf_getTypeCode(ListOf self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this object, namely, @c\n"
		"SBML_LIST_OF.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_getItemTypeCode", _wrap_ListOf_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOf_getItemTypeCode(ListOf self) -> SBMLTypeCode_t\n"
		"\n"
		"Get the type code of the objects contained in this ListOf.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_getElementName", _wrap_ListOf_getElementName, METH_VARARGS, (char *)"\n"
		"ListOf_getElementName(ListOf self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for ListOf, is\n"
		"always @c 'listOf'.\n"
		"\n"
		"@return the XML name of this element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf___len__", _wrap_ListOf___len__, METH_VARARGS, (char *)"ListOf___len__(ListOf self) -> int"},
	 { (char *)"ListOf_swigregister", ListOf_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Model", _wrap_delete_Model, METH_VARARGS, (char *)"delete_Model(Model self)"},
	 { (char *)"new_Model", _wrap_new_Model, METH_VARARGS, (char *)"\n"
		"Model(unsigned int level, unsigned int version)\n"
		"Model(SBMLNamespaces sbmlns)\n"
		"new_Model(Model orig) -> Model\n"
		"\n"
		"Removes the Event object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Event objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the Event object to remove\n"
		"\n"
		"@return the Event object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Event\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_clone", _wrap_Model_clone, METH_VARARGS, (char *)"\n"
		"Model_clone(Model self) -> Model\n"
		"\n"
		"Creates and returns a deep copy of this Model object.\n"
		"\n"
		"@return a (deep) copy of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getId", _wrap_Model_getId, METH_VARARGS, (char *)"\n"
		"Model_getId(Model self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Model.\n"
		"\n"
		"@return the id of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getName", _wrap_Model_getName, METH_VARARGS, (char *)"\n"
		"Model_getName(Model self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Model.\n"
		"\n"
		"@return the name of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSubstanceUnits", _wrap_Model_getSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_getSubstanceUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'substanceUnits' attribute of this Model.\n"
		"\n"
		"@return the substanceUnits of this Model.\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in\n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getTimeUnits", _wrap_Model_getTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_getTimeUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'timeUnits' attribute of this Model.\n"
		"\n"
		"@return the timeUnits of this Model.\n"
		"\n"
		"@note The 'timeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getVolumeUnits", _wrap_Model_getVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_getVolumeUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'volumeUnits' attribute of this Model.\n"
		"\n"
		"@return the volumeUnits of this Model.\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getAreaUnits", _wrap_Model_getAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_getAreaUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'areaUnits' attribute of this Model.\n"
		"\n"
		"@return the areaUnits of this Model.\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getLengthUnits", _wrap_Model_getLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_getLengthUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'lengthUnits' attribute of this Model.\n"
		"\n"
		"@return the lengthUnits of this Model.\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getExtentUnits", _wrap_Model_getExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_getExtentUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'extentUnits' attribute of this Model.\n"
		"\n"
		"@return the extentUnits of this Model.\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getConversionFactor", _wrap_Model_getConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_getConversionFactor(Model self) -> string\n"
		"\n"
		"Returns the value of the 'conversionFactor' attribute of this Model.\n"
		"\n"
		"@return the conversionFactor of this Model.\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetId", _wrap_Model_isSetId, METH_VARARGS, (char *)"\n"
		"Model_isSetId(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetName", _wrap_Model_isSetName, METH_VARARGS, (char *)"\n"
		"Model_isSetName(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetSubstanceUnits", _wrap_Model_isSetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetSubstanceUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'substanceUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'substanceUnits' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetTimeUnits", _wrap_Model_isSetTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetTimeUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'timeUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'timeUnits' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetVolumeUnits", _wrap_Model_isSetVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetVolumeUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'volumeUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'volumeUnits' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetAreaUnits", _wrap_Model_isSetAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetAreaUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'areaUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'areaUnits' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetLengthUnits", _wrap_Model_isSetLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetLengthUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'lengthUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'lengthUnits' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetExtentUnits", _wrap_Model_isSetExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetExtentUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'extentUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'extentUnits' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetConversionFactor", _wrap_Model_isSetConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_isSetConversionFactor(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'conversionFactor' attribute has been set.\n"
		"\n"
		"@return @c true if the 'conversionFactor' attribute of this Model has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setId", _wrap_Model_setId, METH_VARARGS, (char *)"\n"
		"Model_setId(Model self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Model.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setName", _wrap_Model_setName, METH_VARARGS, (char *)"\n"
		"Model_setName(Model self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Model.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setSubstanceUnits", _wrap_Model_setSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_setSubstanceUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'substanceUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new substanceUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setTimeUnits", _wrap_Model_setTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_setTimeUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'timeUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new timeUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'timeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setVolumeUnits", _wrap_Model_setVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_setVolumeUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'volumeUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new volumeUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setAreaUnits", _wrap_Model_setAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_setAreaUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'areaUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new areaUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setLengthUnits", _wrap_Model_setLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_setLengthUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'lengthUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new lengthUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setExtentUnits", _wrap_Model_setExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_setExtentUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'extentUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new extentUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setConversionFactor", _wrap_Model_setConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_setConversionFactor(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'conversionFactor' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new conversionFactor for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetId", _wrap_Model_unsetId, METH_VARARGS, (char *)"\n"
		"Model_unsetId(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'id' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetName", _wrap_Model_unsetName, METH_VARARGS, (char *)"\n"
		"Model_unsetName(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetSubstanceUnits", _wrap_Model_unsetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetSubstanceUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'substanceUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetTimeUnits", _wrap_Model_unsetTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetTimeUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'timeUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'timeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetVolumeUnits", _wrap_Model_unsetVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetVolumeUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'volumeUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetAreaUnits", _wrap_Model_unsetAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetAreaUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'areaUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetLengthUnits", _wrap_Model_unsetLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetLengthUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'lengthUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetExtentUnits", _wrap_Model_unsetExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetExtentUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'extentUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetConversionFactor", _wrap_Model_unsetConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_unsetConversionFactor(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'conversionFactor' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addFunctionDefinition", _wrap_Model_addFunctionDefinition, METH_VARARGS, (char *)"\n"
		"Model_addFunctionDefinition(Model self, FunctionDefinition fd) -> int\n"
		"\n"
		"Adds a copy of the given FunctionDefinition object to this Model.\n"
		"\n"
		"@param fd the FunctionDefinition to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createFunctionDefinition()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createFunctionDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addUnitDefinition", _wrap_Model_addUnitDefinition, METH_VARARGS, (char *)"\n"
		"Model_addUnitDefinition(Model self, UnitDefinition ud) -> int\n"
		"\n"
		"Adds a copy of the given UnitDefinition object to this Model.\n"
		"\n"
		"@param ud the UnitDefinition object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createUnitDefinition() for\n"
		"a method that does not lead to these issues.\n"
		"\n"
		"@see createUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addCompartmentType", _wrap_Model_addCompartmentType, METH_VARARGS, (char *)"\n"
		"Model_addCompartmentType(Model self, CompartmentType ct) -> int\n"
		"\n"
		"Adds a copy of the given CompartmentType object to this Model.\n"
		"\n"
		"@param ct the CompartmentType object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createCompartmentType()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createCompartmentType()\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addSpeciesType", _wrap_Model_addSpeciesType, METH_VARARGS, (char *)"\n"
		"Model_addSpeciesType(Model self, SpeciesType st) -> int\n"
		"\n"
		"Adds a copy of the given SpeciesType object to this Model.\n"
		"\n"
		"@param st the SpeciesType object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createSpeciesType() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createSpeciesType()\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addCompartment", _wrap_Model_addCompartment, METH_VARARGS, (char *)"\n"
		"Model_addCompartment(Model self, Compartment c) -> int\n"
		"\n"
		"Adds a copy of the given Compartment object to this Model.\n"
		"\n"
		"@param c the Compartment object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createCompartment() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createCompartment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addSpecies", _wrap_Model_addSpecies, METH_VARARGS, (char *)"\n"
		"Model_addSpecies(Model self, Species s) -> int\n"
		"\n"
		"Adds a copy of the given Species object to this Model.\n"
		"\n"
		"@param s the Species object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createSpecies() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createSpecies()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addParameter", _wrap_Model_addParameter, METH_VARARGS, (char *)"\n"
		"Model_addParameter(Model self, Parameter p) -> int\n"
		"\n"
		"Adds a copy of the given Parameter object to this Model.\n"
		"\n"
		"@param p the Parameter object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createParameter() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addInitialAssignment", _wrap_Model_addInitialAssignment, METH_VARARGS, (char *)"\n"
		"Model_addInitialAssignment(Model self, InitialAssignment ia) -> int\n"
		"\n"
		"Adds a copy of the given InitialAssignment object to this Model.\n"
		"\n"
		"@param ia the InitialAssignment object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createInitialAssignment()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createInitialAssignment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addRule", _wrap_Model_addRule, METH_VARARGS, (char *)"\n"
		"Model_addRule(Model self, Rule r) -> int\n"
		"\n"
		"Adds a copy of the given Rule object to this Model.\n"
		"\n"
		"@param r the Rule object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see the methods\n"
		"Model::createAlgebraicRule(), Model::createAssignmentRule() and\n"
		"Model::createRateRule() for methods that do not lead to these issues.\n"
		"\n"
		"@see createAlgebraicRule()\n"
		"@see createAssignmentRule()\n"
		"@see createRateRule()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addConstraint", _wrap_Model_addConstraint, METH_VARARGS, (char *)"\n"
		"Model_addConstraint(Model self, Constraint c) -> int\n"
		"\n"
		"Adds a copy of the given Constraint object to this Model.\n"
		"\n"
		"@param c the Constraint object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createConstraint() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createConstraint()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addReaction", _wrap_Model_addReaction, METH_VARARGS, (char *)"\n"
		"Model_addReaction(Model self, Reaction r) -> int\n"
		"\n"
		"Adds a copy of the given Reaction object to this Model.\n"
		"\n"
		"@param r the Reaction object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createReaction() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createReaction()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addEvent", _wrap_Model_addEvent, METH_VARARGS, (char *)"\n"
		"Model_addEvent(Model self, Event e) -> int\n"
		"\n"
		"Adds a copy of the given Event object to this Model.\n"
		"\n"
		"@param e the Event object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model::createEvent() for a method\n"
		"that does not lead to these issues.\n"
		"\n"
		"@see createEvent()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createFunctionDefinition", _wrap_Model_createFunctionDefinition, METH_VARARGS, (char *)"\n"
		"Model_createFunctionDefinition(Model self) -> FunctionDefinition\n"
		"\n"
		"Creates a new FunctionDefinition inside this Model and returns it.\n"
		"\n"
		"@return the FunctionDefinition object created\n"
		"\n"
		"@see addFunctionDefinition(const FunctionDefinition* fd)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createUnitDefinition", _wrap_Model_createUnitDefinition, METH_VARARGS, (char *)"\n"
		"Model_createUnitDefinition(Model self) -> UnitDefinition\n"
		"\n"
		"Creates a new UnitDefinition inside this Model and returns it.\n"
		"\n"
		"@return the UnitDefinition object created\n"
		"\n"
		"@see addUnitDefinition(const UnitDefinition* ud)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createUnit", _wrap_Model_createUnit, METH_VARARGS, (char *)"\n"
		"Model_createUnit(Model self) -> Unit\n"
		"\n"
		"Creates a new Unit object within the last UnitDefinition object\n"
		"created in this model and returns a pointer to it.\n"
		"\n"
		"The mechanism by which the UnitDefinition was created is not\n"
		"significant.  If a UnitDefinition object does not exist in this model,\n"
		"a new Unit is @em not created and @c NULL is returned instead.\n"
		"\n"
		"@return the Unit object created\n"
		"\n"
		"@see addUnitDefinition(const UnitDefinition* ud)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createCompartmentType", _wrap_Model_createCompartmentType, METH_VARARGS, (char *)"\n"
		"Model_createCompartmentType(Model self) -> CompartmentType\n"
		"\n"
		"Creates a new CompartmentType inside this Model and returns it.\n"
		"\n"
		"@return the CompartmentType object created\n"
		"\n"
		"@see addCompartmentType(const CompartmentType* ct)\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createSpeciesType", _wrap_Model_createSpeciesType, METH_VARARGS, (char *)"\n"
		"Model_createSpeciesType(Model self) -> SpeciesType\n"
		"\n"
		"Creates a new SpeciesType inside this Model and returns it.\n"
		"\n"
		"@return the SpeciesType object created\n"
		"\n"
		"@see addSpeciesType(const SpeciesType* st)\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createCompartment", _wrap_Model_createCompartment, METH_VARARGS, (char *)"\n"
		"Model_createCompartment(Model self) -> Compartment\n"
		"\n"
		"Creates a new Compartment inside this Model and returns it.\n"
		"\n"
		"@return the Compartment object created\n"
		"\n"
		"@see addCompartment(const Compartment *c)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createSpecies", _wrap_Model_createSpecies, METH_VARARGS, (char *)"\n"
		"Model_createSpecies(Model self) -> Species\n"
		"\n"
		"Creates a new Species inside this Model and returns it.\n"
		"\n"
		"@return the Species object created\n"
		"\n"
		"@see addSpecies(const Species *s)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createParameter", _wrap_Model_createParameter, METH_VARARGS, (char *)"\n"
		"Model_createParameter(Model self) -> Parameter\n"
		"\n"
		"Creates a new Parameter inside this Model and returns it.\n"
		"\n"
		"@return the Parameter object created\n"
		"\n"
		"@see addParameter(const Parameter *p)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createInitialAssignment", _wrap_Model_createInitialAssignment, METH_VARARGS, (char *)"\n"
		"Model_createInitialAssignment(Model self) -> InitialAssignment\n"
		"\n"
		"Creates a new InitialAssignment inside this Model and returns it.\n"
		"\n"
		"@return the InitialAssignment object created\n"
		"\n"
		"@see addInitialAssignment(const InitialAssignment* ia)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createAlgebraicRule", _wrap_Model_createAlgebraicRule, METH_VARARGS, (char *)"\n"
		"Model_createAlgebraicRule(Model self) -> AlgebraicRule\n"
		"\n"
		"Creates a new AlgebraicRule inside this Model and returns it.\n"
		"\n"
		"@return the AlgebraicRule object created\n"
		"\n"
		"@see addRule(const Rule* r)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createAssignmentRule", _wrap_Model_createAssignmentRule, METH_VARARGS, (char *)"\n"
		"Model_createAssignmentRule(Model self) -> AssignmentRule\n"
		"\n"
		"Creates a new AssignmentRule inside this Model and returns it.\n"
		"\n"
		"@return the AssignmentRule object created\n"
		"\n"
		"@see addRule(const Rule* r)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createRateRule", _wrap_Model_createRateRule, METH_VARARGS, (char *)"\n"
		"Model_createRateRule(Model self) -> RateRule\n"
		"\n"
		"Creates a new RateRule inside this Model and returns it.\n"
		"\n"
		"@return the RateRule object created\n"
		"\n"
		"@see addRule(const Rule* r)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createConstraint", _wrap_Model_createConstraint, METH_VARARGS, (char *)"\n"
		"Model_createConstraint(Model self) -> Constraint\n"
		"\n"
		"Creates a new Constraint inside this Model and returns it.\n"
		"\n"
		"@return the Constraint object created\n"
		"\n"
		"@see addConstraint(const Constraint *c)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createReaction", _wrap_Model_createReaction, METH_VARARGS, (char *)"\n"
		"Model_createReaction(Model self) -> Reaction\n"
		"\n"
		"Creates a new Reaction inside this Model and returns it.\n"
		"\n"
		"@return the Reaction object created\n"
		"\n"
		"@see addReaction(const Reaction *r)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createReactant", _wrap_Model_createReactant, METH_VARARGS, (char *)"\n"
		"Model_createReactant(Model self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference object for a reactant inside the last\n"
		"Reaction object in this Model, and returns a pointer to it.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, a new SpeciesReference is @em not\n"
		"created and @c NULL is returned instead.\n"
		"\n"
		"@return the SpeciesReference object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createProduct", _wrap_Model_createProduct, METH_VARARGS, (char *)"\n"
		"Model_createProduct(Model self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference object for a product inside the last\n"
		"Reaction object in this Model, and returns a pointer to it.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, a new SpeciesReference is @em not\n"
		"created and @c NULL is returned instead.\n"
		"\n"
		"@return the SpeciesReference object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createModifier", _wrap_Model_createModifier, METH_VARARGS, (char *)"\n"
		"Model_createModifier(Model self) -> ModifierSpeciesReference\n"
		"\n"
		"Creates a new ModifierSpeciesReference object for a modifier species\n"
		"inside the last Reaction object in this Model, and returns a pointer\n"
		"to it.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, a new ModifierSpeciesReference is @em\n"
		"not created and @c NULL is returned instead.\n"
		"\n"
		"@return the SpeciesReference object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createKineticLaw", _wrap_Model_createKineticLaw, METH_VARARGS, (char *)"\n"
		"Model_createKineticLaw(Model self) -> KineticLaw\n"
		"\n"
		"Creates a new KineticLaw inside the last Reaction object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, or a Reaction exists but already has a\n"
		"KineticLaw, a new KineticLaw is @em not created and @c NULL is returned\n"
		"instead.\n"
		"\n"
		"@return the KineticLaw object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createKineticLawParameter", _wrap_Model_createKineticLawParameter, METH_VARARGS, (char *)"\n"
		"Model_createKineticLawParameter(Model self) -> Parameter\n"
		"\n"
		"Creates a new local Parameter inside the KineticLaw object of the last\n"
		"Reaction created inside this Model, and returns a pointer to it.\n"
		"\n"
		"The last KineticLaw object in this Model could have been created in a\n"
		"variety of ways.  For example, it could have been added using\n"
		"createKineticLaw(), or it could be the result of using\n"
		"Reaction::createKineticLaw() on the Reaction object created by a\n"
		"createReaction().  If a Reaction does not exist for this model, or the\n"
		"last Reaction does not contain a KineticLaw object, a new Parameter is\n"
		"@em not created and @c NULL is returned instead.\n"
		"\n"
		"@return the Parameter object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createKineticLawLocalParameter", _wrap_Model_createKineticLawLocalParameter, METH_VARARGS, (char *)"\n"
		"Model_createKineticLawLocalParameter(Model self) -> LocalParameter\n"
		"\n"
		"Creates a new LocalParameter inside the KineticLaw object of the last\n"
		"Reaction created inside this Model, and returns a pointer to it.\n"
		"\n"
		"The last KineticLaw object in this Model could have been created in a\n"
		"variety of ways.  For example, it could have been added using\n"
		"createKineticLaw(), or it could be the result of using\n"
		"Reaction::createKineticLaw() on the Reaction object created by a\n"
		"createReaction().  If a Reaction does not exist for this model, or the\n"
		"last Reaction does not contain a KineticLaw object, a new Parameter is\n"
		"@em not created and @c NULL is returned instead.\n"
		"\n"
		"@return the Parameter object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createEvent", _wrap_Model_createEvent, METH_VARARGS, (char *)"\n"
		"Model_createEvent(Model self) -> Event\n"
		"\n"
		"Creates a new Event inside this Model and returns it.\n"
		"\n"
		"@return the Event object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createEventAssignment", _wrap_Model_createEventAssignment, METH_VARARGS, (char *)"\n"
		"Model_createEventAssignment(Model self) -> EventAssignment\n"
		"\n"
		"Creates a new EventAssignment inside the last Event object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The mechanism by which the last Event object in this model was created\n"
		"is not significant.  It could have been created in a variety of ways,\n"
		"for example by using createEvent().  If no Event object exists in this\n"
		"Model object, a new EventAssignment is @em not created and @c NULL is\n"
		"returned instead.\n"
		"\n"
		"@return the EventAssignment object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createTrigger", _wrap_Model_createTrigger, METH_VARARGS, (char *)"\n"
		"Model_createTrigger(Model self) -> Trigger\n"
		"\n"
		"Creates a new Trigger inside the last Event object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The mechanism by which the last Event object in this model was created\n"
		"is not significant.  It could have been created in a variety of ways,\n"
		"for example by using createEvent().  If no Event object exists in this\n"
		"Model object, a new Trigger is @em not created and @c NULL is\n"
		"returned instead.\n"
		"\n"
		"@return the Trigger object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createDelay", _wrap_Model_createDelay, METH_VARARGS, (char *)"\n"
		"Model_createDelay(Model self) -> Delay\n"
		"\n"
		"Creates a new Delay inside the last Event object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The mechanism by which the last Event object in this model was created\n"
		"is not significant.  It could have been created in a variety of ways,\n"
		"for example by using createEvent().  If no Event object exists in this\n"
		"Model object, a new Delay is @em not created and @c NULL is\n"
		"returned instead.\n"
		"\n"
		"@return the Delay object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setAnnotation", _wrap_Model_setAnnotation, METH_VARARGS, (char *)"\n"
		"setAnnotation(XMLNode annotation) -> int\n"
		"Model_setAnnotation(Model self, string annotation) -> int\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object to a\n"
		"copy of @p annotation.\n"
		"\n"
		"Any existing content of the 'annotation' subelement is discarded.\n"
		"Unless you have taken steps to first copy and reconstitute any\n"
		"existing annotations into the @p annotation that is about to be\n"
		"assigned, it is likely that performing such wholesale replacement is\n"
		"unfriendly towards other software applications whose annotations are\n"
		"discarded.  An alternative may be to use appendAnnotation().\n"
		"\n"
		"@param annotation an XML string that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see appendAnnotation(const std::string& annotation)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_appendAnnotation", _wrap_Model_appendAnnotation, METH_VARARGS, (char *)"\n"
		"appendAnnotation(XMLNode annotation) -> int\n"
		"Model_appendAnnotation(Model self, string annotation) -> int\n"
		"\n"
		"Appends annotation content to any existing content in the 'annotation'\n"
		"subelement of this object.\n"
		"\n"
		"The content in @p annotation is copied.  Unlike setAnnotation(), this \n"
		"method allows other annotations to be preserved when an application\n"
		"adds its own data.\n"
		"\n"
		"@param annotation an XML string that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see setAnnotation(const std::string& annotation)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfFunctionDefinitions", _wrap_Model_getListOfFunctionDefinitions, METH_VARARGS, (char *)"\n"
		"getListOfFunctionDefinitions() -> ListOfFunctionDefinitions\n"
		"Model_getListOfFunctionDefinitions(Model self) -> ListOfFunctionDefinitions\n"
		"\n"
		"Get the ListOfFunctionDefinitions object in this Model.\n"
		"\n"
		"@return the list of FunctionDefinitions for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfUnitDefinitions", _wrap_Model_getListOfUnitDefinitions, METH_VARARGS, (char *)"\n"
		"getListOfUnitDefinitions() -> ListOfUnitDefinitions\n"
		"Model_getListOfUnitDefinitions(Model self) -> ListOfUnitDefinitions\n"
		"\n"
		"Get the ListOfUnitDefinitions object in this Model.\n"
		"\n"
		"@return the list of UnitDefinitions for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfCompartmentTypes", _wrap_Model_getListOfCompartmentTypes, METH_VARARGS, (char *)"\n"
		"getListOfCompartmentTypes() -> ListOfCompartmentTypes\n"
		"Model_getListOfCompartmentTypes(Model self) -> ListOfCompartmentTypes\n"
		"\n"
		"Get the ListOfCompartmentTypes object in this Model.\n"
		"\n"
		"@return the list of CompartmentTypes for this Model.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfSpeciesTypes", _wrap_Model_getListOfSpeciesTypes, METH_VARARGS, (char *)"\n"
		"getListOfSpeciesTypes() -> ListOfSpeciesTypes\n"
		"Model_getListOfSpeciesTypes(Model self) -> ListOfSpeciesTypes\n"
		"\n"
		"Get the ListOfSpeciesTypes object in this Model.\n"
		"\n"
		"@return the list of SpeciesTypes for this Model.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfCompartments", _wrap_Model_getListOfCompartments, METH_VARARGS, (char *)"\n"
		"getListOfCompartments() -> ListOfCompartments\n"
		"Model_getListOfCompartments(Model self) -> ListOfCompartments\n"
		"\n"
		"Get the ListOfCompartments object in this Model.\n"
		"\n"
		"@return the list of Compartments for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfSpecies", _wrap_Model_getListOfSpecies, METH_VARARGS, (char *)"\n"
		"getListOfSpecies() -> ListOfSpecies\n"
		"Model_getListOfSpecies(Model self) -> ListOfSpecies\n"
		"\n"
		"Get the ListOfSpecies object in this Model.\n"
		"\n"
		"@return the list of Species for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfParameters", _wrap_Model_getListOfParameters, METH_VARARGS, (char *)"\n"
		"getListOfParameters() -> ListOfParameters\n"
		"Model_getListOfParameters(Model self) -> ListOfParameters\n"
		"\n"
		"Get the ListOfParameters object in this Model.\n"
		"\n"
		"@return the list of Parameters for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfInitialAssignments", _wrap_Model_getListOfInitialAssignments, METH_VARARGS, (char *)"\n"
		"getListOfInitialAssignments() -> ListOfInitialAssignments\n"
		"Model_getListOfInitialAssignments(Model self) -> ListOfInitialAssignments\n"
		"\n"
		"Get the ListOfInitialAssignments object in this Model.\n"
		"\n"
		"@return the list of InitialAssignment for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfRules", _wrap_Model_getListOfRules, METH_VARARGS, (char *)"\n"
		"getListOfRules() -> ListOfRules\n"
		"Model_getListOfRules(Model self) -> ListOfRules\n"
		"\n"
		"Get the ListOfRules object in this Model.\n"
		"\n"
		"@return the list of Rules for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfConstraints", _wrap_Model_getListOfConstraints, METH_VARARGS, (char *)"\n"
		"getListOfConstraints() -> ListOfConstraints\n"
		"Model_getListOfConstraints(Model self) -> ListOfConstraints\n"
		"\n"
		"Get the ListOfConstraints object in this Model.\n"
		"\n"
		"@return the list of Constraints for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfReactions", _wrap_Model_getListOfReactions, METH_VARARGS, (char *)"\n"
		"getListOfReactions() -> ListOfReactions\n"
		"Model_getListOfReactions(Model self) -> ListOfReactions\n"
		"\n"
		"Get the ListOfReactions object in this Model.\n"
		"\n"
		"@return the list of Reactions for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfEvents", _wrap_Model_getListOfEvents, METH_VARARGS, (char *)"\n"
		"getListOfEvents() -> ListOfEvents\n"
		"Model_getListOfEvents(Model self) -> ListOfEvents\n"
		"\n"
		"Get the ListOfEvents object in this Model.\n"
		"\n"
		"@return the list of Events for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getFunctionDefinition", _wrap_Model_getFunctionDefinition, METH_VARARGS, (char *)"\n"
		"getFunctionDefinition(unsigned int n) -> FunctionDefinition\n"
		"getFunctionDefinition(unsigned int n) -> FunctionDefinition\n"
		"getFunctionDefinition(string sid) -> FunctionDefinition\n"
		"Model_getFunctionDefinition(Model self, string sid) -> FunctionDefinition\n"
		"\n"
		"Get a FunctionDefinition object based on its identifier.\n"
		"\n"
		"@return the FunctionDefinition in this Model with the identifier\n"
		"@p sid or @c NULL if no such FunctionDefinition exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getUnitDefinition", _wrap_Model_getUnitDefinition, METH_VARARGS, (char *)"\n"
		"getUnitDefinition(unsigned int n) -> UnitDefinition\n"
		"getUnitDefinition(unsigned int n) -> UnitDefinition\n"
		"getUnitDefinition(string sid) -> UnitDefinition\n"
		"Model_getUnitDefinition(Model self, string sid) -> UnitDefinition\n"
		"\n"
		"Get a UnitDefinition based on its identifier.\n"
		"\n"
		"@return the UnitDefinition in this Model with the identifier @p sid or\n"
		"@c NULL if no such UnitDefinition exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getCompartmentType", _wrap_Model_getCompartmentType, METH_VARARGS, (char *)"\n"
		"getCompartmentType(unsigned int n) -> CompartmentType\n"
		"getCompartmentType(unsigned int n) -> CompartmentType\n"
		"getCompartmentType(string sid) -> CompartmentType\n"
		"Model_getCompartmentType(Model self, string sid) -> CompartmentType\n"
		"\n"
		"Get a CompartmentType object based on its identifier.\n"
		"\n"
		"@return the CompartmentType in this Model with the identifier @p sid\n"
		"or @c NULL if no such CompartmentType exists.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSpeciesType", _wrap_Model_getSpeciesType, METH_VARARGS, (char *)"\n"
		"getSpeciesType(unsigned int n) -> SpeciesType\n"
		"getSpeciesType(unsigned int n) -> SpeciesType\n"
		"getSpeciesType(string sid) -> SpeciesType\n"
		"Model_getSpeciesType(Model self, string sid) -> SpeciesType\n"
		"\n"
		"Get a SpeciesType object based on its identifier.\n"
		"\n"
		"@return the SpeciesType in this Model with the identifier @p sid or\n"
		"@c NULL if no such SpeciesType exists.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getCompartment", _wrap_Model_getCompartment, METH_VARARGS, (char *)"\n"
		"getCompartment(unsigned int n) -> Compartment\n"
		"getCompartment(unsigned int n) -> Compartment\n"
		"getCompartment(string sid) -> Compartment\n"
		"Model_getCompartment(Model self, string sid) -> Compartment\n"
		"\n"
		"Get a Compartment object based on its identifier.\n"
		"\n"
		"@return the Compartment in this Model with the identifier @p sid or\n"
		"@c NULL if no such Compartment exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSpecies", _wrap_Model_getSpecies, METH_VARARGS, (char *)"\n"
		"getSpecies(unsigned int n) -> Species\n"
		"getSpecies(unsigned int n) -> Species\n"
		"getSpecies(string sid) -> Species\n"
		"Model_getSpecies(Model self, string sid) -> Species\n"
		"\n"
		"Get a Species object based on its identifier.\n"
		"\n"
		"@return the Species in this Model with the identifier @p sid or @c NULL\n"
		"if no such Species exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getParameter", _wrap_Model_getParameter, METH_VARARGS, (char *)"\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(string sid) -> Parameter\n"
		"Model_getParameter(Model self, string sid) -> Parameter\n"
		"\n"
		"Get a Parameter object based on its identifier.\n"
		"\n"
		"@return the Parameter in this Model with the identifier @p sid or @c NULL\n"
		"if no such Parameter exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getInitialAssignment", _wrap_Model_getInitialAssignment, METH_VARARGS, (char *)"\n"
		"getInitialAssignment(unsigned int n) -> InitialAssignment\n"
		"getInitialAssignment(unsigned int n) -> InitialAssignment\n"
		"getInitialAssignment(string symbol) -> InitialAssignment\n"
		"Model_getInitialAssignment(Model self, string symbol) -> InitialAssignment\n"
		"\n"
		"Get an InitialAssignment object based on the symbol to which it\n"
		"assigns a value.\n"
		"\n"
		"@return the InitialAssignment in this Model with the given 'symbol'\n"
		"attribute value or @c NULL if no such InitialAssignment exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getRule", _wrap_Model_getRule, METH_VARARGS, (char *)"\n"
		"getRule(unsigned int n) -> Rule\n"
		"getRule(unsigned int n) -> Rule\n"
		"getRule(string variable) -> Rule\n"
		"Model_getRule(Model self, string variable) -> Rule\n"
		"\n"
		"Get a Rule object based on the variable to which it assigns a value.\n"
		"\n"
		"@return the Rule in this Model with the given 'variable' attribute\n"
		"value or @c NULL if no such Rule exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getConstraint", _wrap_Model_getConstraint, METH_VARARGS, (char *)"\n"
		"getConstraint(unsigned int n) -> Constraint\n"
		"Model_getConstraint(Model self, unsigned int n) -> Constraint\n"
		"\n"
		"Get the nth Constraint object in this Model.\n"
		"\n"
		"@return the nth Constraint of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getReaction", _wrap_Model_getReaction, METH_VARARGS, (char *)"\n"
		"getReaction(unsigned int n) -> Reaction\n"
		"getReaction(unsigned int n) -> Reaction\n"
		"getReaction(string sid) -> Reaction\n"
		"Model_getReaction(Model self, string sid) -> Reaction\n"
		"\n"
		"Get a Reaction object based on its identifier.\n"
		"\n"
		"@return the Reaction in this Model with the identifier @p sid or @c NULL\n"
		"if no such Reaction exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSpeciesReference", _wrap_Model_getSpeciesReference, METH_VARARGS, (char *)"\n"
		"getSpeciesReference(string sid) -> SpeciesReference\n"
		"Model_getSpeciesReference(Model self, string sid) -> SpeciesReference\n"
		"\n"
		"Get a SpeciesReference object based on its identifier.\n"
		"\n"
		"@return the SpeciesReference in this Model with the identifier @p sid or @c NULL\n"
		"if no such SpeciesReference exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getEvent", _wrap_Model_getEvent, METH_VARARGS, (char *)"\n"
		"getEvent(unsigned int n) -> Event\n"
		"getEvent(unsigned int n) -> Event\n"
		"getEvent(string sid) -> Event\n"
		"Model_getEvent(Model self, string sid) -> Event\n"
		"\n"
		"Get an Event object based on its identifier.\n"
		"\n"
		"@return the Event in this Model with the identifier @p sid or @c NULL if\n"
		"no such Event exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumFunctionDefinitions", _wrap_Model_getNumFunctionDefinitions, METH_VARARGS, (char *)"\n"
		"Model_getNumFunctionDefinitions(Model self) -> unsigned int\n"
		"\n"
		"Get the number of FunctionDefinition objects in this Model.\n"
		"\n"
		"@return the number of FunctionDefinitions in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumUnitDefinitions", _wrap_Model_getNumUnitDefinitions, METH_VARARGS, (char *)"\n"
		"Model_getNumUnitDefinitions(Model self) -> unsigned int\n"
		"\n"
		"Get the number of UnitDefinition objects in this Model.\n"
		"\n"
		"@return the number of UnitDefinitions in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumCompartmentTypes", _wrap_Model_getNumCompartmentTypes, METH_VARARGS, (char *)"\n"
		"Model_getNumCompartmentTypes(Model self) -> unsigned int\n"
		"\n"
		"Get the number of CompartmentType objects in this Model.\n"
		"\n"
		"@return the number of CompartmentTypes in this Model.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumSpeciesTypes", _wrap_Model_getNumSpeciesTypes, METH_VARARGS, (char *)"\n"
		"Model_getNumSpeciesTypes(Model self) -> unsigned int\n"
		"\n"
		"Get the number of SpeciesType objects in this Model.\n"
		"\n"
		"@return the number of SpeciesTypes in this Model.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumCompartments", _wrap_Model_getNumCompartments, METH_VARARGS, (char *)"\n"
		"Model_getNumCompartments(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Compartment objects in this Model.\n"
		"\n"
		"@return the number of Compartments in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumSpecies", _wrap_Model_getNumSpecies, METH_VARARGS, (char *)"\n"
		"Model_getNumSpecies(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Specie objects in this Model.\n"
		"\n"
		"@return the number of Species in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumSpeciesWithBoundaryCondition", _wrap_Model_getNumSpeciesWithBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Model_getNumSpeciesWithBoundaryCondition(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Species in this Model having their\n"
		"'boundaryCondition' attribute value set to @c true.\n"
		"\n"
		"@return the number of Species in this Model with boundaryCondition set\n"
		"to true.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumParameters", _wrap_Model_getNumParameters, METH_VARARGS, (char *)"\n"
		"Model_getNumParameters(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Parameter objects in this Model.\n"
		"\n"
		"@return the number of Parameters in this Model.  Parameters defined in\n"
		"KineticLaws are not included.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumInitialAssignments", _wrap_Model_getNumInitialAssignments, METH_VARARGS, (char *)"\n"
		"Model_getNumInitialAssignments(Model self) -> unsigned int\n"
		"\n"
		"Get the number of InitialAssignment objects in this Model.\n"
		"\n"
		"@return the number of InitialAssignments in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumRules", _wrap_Model_getNumRules, METH_VARARGS, (char *)"\n"
		"Model_getNumRules(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Rule objects in this Model.\n"
		"\n"
		"@return the number of Rules in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumConstraints", _wrap_Model_getNumConstraints, METH_VARARGS, (char *)"\n"
		"Model_getNumConstraints(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Constraint objects in this Model.\n"
		"\n"
		"@return the number of Constraints in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumReactions", _wrap_Model_getNumReactions, METH_VARARGS, (char *)"\n"
		"Model_getNumReactions(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Reaction objects in this Model.\n"
		"\n"
		"@return the number of Reactions in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumEvents", _wrap_Model_getNumEvents, METH_VARARGS, (char *)"\n"
		"Model_getNumEvents(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Event objects in this Model.\n"
		"\n"
		"@return the number of Events in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_convertL1ToL2", _wrap_Model_convertL1ToL2, METH_VARARGS, (char *)"\n"
		"Model_convertL1ToL2(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_convertL1ToL3", _wrap_Model_convertL1ToL3, METH_VARARGS, (char *)"\n"
		"Model_convertL1ToL3(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_convertL2ToL3", _wrap_Model_convertL2ToL3, METH_VARARGS, (char *)"\n"
		"Model_convertL2ToL3(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_convertL2ToL1", _wrap_Model_convertL2ToL1, METH_VARARGS, (char *)"\n"
		"convertL2ToL1(bool strict = False)\n"
		"Model_convertL2ToL1(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_addModifiers", _wrap_Model_addModifiers, METH_VARARGS, (char *)"\n"
		"Model_addModifiers(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_addConstantAttribute", _wrap_Model_addConstantAttribute, METH_VARARGS, (char *)"\n"
		"Model_addConstantAttribute(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_setSpatialDimensions", _wrap_Model_setSpatialDimensions, METH_VARARGS, (char *)"\n"
		"setSpatialDimensions(double dims = 3.0)\n"
		"Model_setSpatialDimensions(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_addDefinitionsForDefaultUnits", _wrap_Model_addDefinitionsForDefaultUnits, METH_VARARGS, (char *)"\n"
		"Model_addDefinitionsForDefaultUnits(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_convertParametersToLocals", _wrap_Model_convertParametersToLocals, METH_VARARGS, (char *)"\n"
		"Model_convertParametersToLocals(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_setSpeciesReferenceConstantValue", _wrap_Model_setSpeciesReferenceConstantValue, METH_VARARGS, (char *)"\n"
		"Model_setSpeciesReferenceConstantValue(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_removeParameterRuleUnits", _wrap_Model_removeParameterRuleUnits, METH_VARARGS, (char *)"\n"
		"Model_removeParameterRuleUnits(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_convertStoichiometryMath", _wrap_Model_convertStoichiometryMath, METH_VARARGS, (char *)"\n"
		"Model_convertStoichiometryMath(Model self)\n"
		"\n"
		"Predicate returning @c true if the\n"
		"given ASTNode is a boolean.\n"
		"\n"
		"Often times, this question can be answered with the ASTNode's own\n"
		"isBoolean() method, but if the AST is an expression that calls a\n"
		"function defined in the Model's ListOfFunctionDefinitions, the model\n"
		"is needed for lookup context.\n"
		"\n"
		"@return true if the given ASTNode is a boolean.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Model_getTypeCode", _wrap_Model_getTypeCode, METH_VARARGS, (char *)"\n"
		"Model_getTypeCode(Model self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getElementName", _wrap_Model_getElementName, METH_VARARGS, (char *)"\n"
		"Model_getElementName(Model self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Model, is\n"
		"always @c 'model'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'model'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_populateListFormulaUnitsData", _wrap_Model_populateListFormulaUnitsData, METH_VARARGS, (char *)"\n"
		"Model_populateListFormulaUnitsData(Model self)\n"
		"\n"
		"Populates the list of FormulaDataUnits with the units derived \n"
		"for the model. The list contains elements of class\n"
		"FormulaUnitsData. \n"
		"\n"
		"The first element of the list refers to the default units\n"
		"of 'substance per time' derived from the model and has the\n"
		"unitReferenceId 'subs_per_time'. This facilitates the comparison of units\n"
		"derived from mathematical formula with the expected units.\n"
		"\n"
		"The next elements of the list record the units of the \n"
		"compartments and species established from either explicitly\n"
		"declared or default units.\n"
		"\n"
		"The next elements record the units of any parameters.\n"
		"\n"
		"Subsequent elements of the list record the units derived for\n"
		"each mathematical expression encountered within the model.\n"
		"\n"
		"@note This function is utilised by the Unit Consistency Validator.\n"
		"The list is populated prior to running the validation and thus\n"
		"the consistency of units can be checked by accessing the members\n"
		"of the list and comparing the appropriate data.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isPopulatedListFormulaUnitsData", _wrap_Model_isPopulatedListFormulaUnitsData, METH_VARARGS, (char *)"\n"
		"Model_isPopulatedListFormulaUnitsData(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the list of FormulaUnitsData has been populated.\n"
		"\n"
		"@return @c true if the list of FormulaUnitsData has been populated, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_hasRequiredElements", _wrap_Model_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Model_hasRequiredElements(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Model object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Model object are:\n"
		"listOfCompartments (L1 only); listOfSpecies (L1V1 only);\n"
		"listOfReactions(L1V1 only)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeFunctionDefinition", _wrap_Model_removeFunctionDefinition, METH_VARARGS, (char *)"\n"
		"removeFunctionDefinition(unsigned int n) -> FunctionDefinition\n"
		"Model_removeFunctionDefinition(Model self, string sid) -> FunctionDefinition\n"
		"\n"
		"Removes the FunctionDefinition object with the given identifier from this Model \n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the FunctionDefinition objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the FunctionDefinition object to remove\n"
		"\n"
		"@return the FunctionDefinition object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no FunctionDefinition\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeUnitDefinition", _wrap_Model_removeUnitDefinition, METH_VARARGS, (char *)"\n"
		"removeUnitDefinition(unsigned int n) -> UnitDefinition\n"
		"Model_removeUnitDefinition(Model self, string sid) -> UnitDefinition\n"
		"\n"
		"Removes the UnitDefinition object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the UnitDefinition objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the UnitDefinition object to remove\n"
		"\n"
		"@return the UnitDefinition object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no UnitDefinition\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeCompartmentType", _wrap_Model_removeCompartmentType, METH_VARARGS, (char *)"\n"
		"removeCompartmentType(unsigned int n) -> CompartmentType\n"
		"Model_removeCompartmentType(Model self, string sid) -> CompartmentType\n"
		"\n"
		"Removes the CompartmentType object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the CompartmentType objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the object to remove\n"
		"\n"
		"@return the CompartmentType object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no CompartmentType\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeSpeciesType", _wrap_Model_removeSpeciesType, METH_VARARGS, (char *)"\n"
		"removeSpeciesType(unsigned int n) -> SpeciesType\n"
		"Model_removeSpeciesType(Model self, string sid) -> SpeciesType\n"
		"\n"
		"Removes the SpeciesType object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the SpeciesType objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the SpeciesType object to remove\n"
		"\n"
		"@return the SpeciesType object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no SpeciesType\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeCompartment", _wrap_Model_removeCompartment, METH_VARARGS, (char *)"\n"
		"removeCompartment(unsigned int n) -> Compartment\n"
		"Model_removeCompartment(Model self, string sid) -> Compartment\n"
		"\n"
		"Removes the Compartment object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Compartment objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the Compartment object to remove\n"
		"\n"
		"@return the Compartment object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Compartment\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeSpecies", _wrap_Model_removeSpecies, METH_VARARGS, (char *)"\n"
		"removeSpecies(unsigned int n) -> Species\n"
		"Model_removeSpecies(Model self, string sid) -> Species\n"
		"\n"
		"Removes the Species object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Species objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the Species object to remove\n"
		"\n"
		"@return the Species object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Species\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeParameter", _wrap_Model_removeParameter, METH_VARARGS, (char *)"\n"
		"removeParameter(unsigned int n) -> Parameter\n"
		"Model_removeParameter(Model self, string sid) -> Parameter\n"
		"\n"
		"Removes the Parameter object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Parameter objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the Parameter object to remove\n"
		"\n"
		"@return the Parameter object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Parameter\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeInitialAssignment", _wrap_Model_removeInitialAssignment, METH_VARARGS, (char *)"\n"
		"removeInitialAssignment(unsigned int n) -> InitialAssignment\n"
		"Model_removeInitialAssignment(Model self, string symbol) -> InitialAssignment\n"
		"\n"
		"Removes the InitialAssignment object with the given 'symbol' attribute \n"
		"from this Model object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the InitialAssignment objects in this Model object have the\n"
		"'symbol' attribute @p symbol, then @c NULL is returned.\n"
		"\n"
		"@param symbol the 'symbol' attribute of the InitialAssignment object to remove\n"
		"\n"
		"@return the InitialAssignment object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no InitialAssignment\n"
		"object with the 'symbol' attribute exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeRule", _wrap_Model_removeRule, METH_VARARGS, (char *)"\n"
		"removeRule(unsigned int n) -> Rule\n"
		"Model_removeRule(Model self, string variable) -> Rule\n"
		"\n"
		"Removes the Rule object with the given 'variable' attribute from this Model \n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Rule objects in this Model object have the 'variable' attribute\n"
		"@p variable, then @c NULL is returned.\n"
		"\n"
		"@param variable the 'variable' attribute of the Rule object to remove\n"
		"\n"
		"@return the Rule object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Rule\n"
		"object with the 'variable' attribute exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeConstraint", _wrap_Model_removeConstraint, METH_VARARGS, (char *)"\n"
		"Model_removeConstraint(Model self, unsigned int n) -> Constraint\n"
		"\n"
		"Removes the nth Constraint object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Constraint object to remove\n"
		"\n"
		"@return the Constraint object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c NULL is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeReaction", _wrap_Model_removeReaction, METH_VARARGS, (char *)"\n"
		"removeReaction(unsigned int n) -> Reaction\n"
		"Model_removeReaction(Model self, string sid) -> Reaction\n"
		"\n"
		"Removes the Reaction object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Reaction objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the Reaction object to remove\n"
		"\n"
		"@return the Reaction object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Reaction\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeEvent", _wrap_Model_removeEvent, METH_VARARGS, (char *)"\n"
		"removeEvent(unsigned int n) -> Event\n"
		"Model_removeEvent(Model self, string sid) -> Event\n"
		"\n"
		"Removes the Event object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Event objects in this Model object have the identifier \n"
		"@p sid, then @c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the Event object to remove\n"
		"\n"
		"@return the Event object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Event\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_swigregister", Model_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBMLDocument_getDefaultLevel", _wrap_SBMLDocument_getDefaultLevel, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getDefaultLevel() -> unsigned int\n"
		"\n"
		"The default SBML Level of new SBMLDocument objects.\n"
		"\n"
		"This 'default level' corresponds to the most recent SBML specification\n"
		"Level available at the time this version of libSBML was released.  For\n"
		"this copy of libSBML, the value is <code>2</code>.  The default Level\n"
		"is used by SBMLDocument if no Level is explicitly specified at the\n"
		"time of the construction of an SBMLDocument instance. \n"
		"\n"
		"@return an integer indicating the most recent SBML specification Level\n"
		"\n"
		"@see getDefaultVersion()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getDefaultVersion", _wrap_SBMLDocument_getDefaultVersion, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getDefaultVersion() -> unsigned int\n"
		"\n"
		"The default Version of new SBMLDocument objects.\n"
		"\n"
		"This 'default version' corresponds to the most recent SBML Version\n"
		"within the most recent Level of SBML available at the time this\n"
		"version of libSBML was released.  For this copy of libSBML, the value\n"
		"is <code>4</code>.  The default Version is used by SBMLDocument if no\n"
		"Version is explicitly specified at the time of the construction of an\n"
		"SBMLDocument instance.\n"
		"\n"
		"@return an integer indicating the most recent SBML specification\n"
		"Version\n"
		"\n"
		"@see getDefaultLevel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLDocument", _wrap_delete_SBMLDocument, METH_VARARGS, (char *)"delete_SBMLDocument(SBMLDocument self)"},
	 { (char *)"new_SBMLDocument", _wrap_new_SBMLDocument, METH_VARARGS, (char *)"\n"
		"SBMLDocument(unsigned int level = 0, unsigned int version = 0)\n"
		"SBMLDocument(unsigned int level = 0)\n"
		"SBMLDocument()\n"
		"new_SBMLDocument(SBMLDocument rhs) -> SBMLDocument\n"
		"\n"
		"Copy constructor; creates a copy of this SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_clone", _wrap_SBMLDocument_clone, METH_VARARGS, (char *)"\n"
		"SBMLDocument_clone(SBMLDocument self) -> SBMLDocument\n"
		"\n"
		"Creates and returns a deep copy of this SBMLDocument.\n"
		"\n"
		"@return a (deep) copy of this SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getModel", _wrap_SBMLDocument_getModel, METH_VARARGS, (char *)"\n"
		"getModel() -> Model\n"
		"SBMLDocument_getModel(SBMLDocument self) -> Model\n"
		"\n"
		"Returns the Model object stored in this SBMLDocument.\n"
		"\n"
		"It is important to note that this method <em>does not create</em> a\n"
		"Model instance.  The model in the SBMLDocument must have been created\n"
		"at some prior time, for example using SBMLDocument::createModel() \n"
		"or @if clike SBMLDocument::setModel() @endif@if java SBMLDocument::setModel(Model m) @endif.\n"
		"This method returns @c NULL if a model does not yet exist.\n"
		"\n"
		"@return the Model contained in this SBMLDocument.\n"
		"\n"
		"@see createModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_expandFunctionDefinitions", _wrap_SBMLDocument_expandFunctionDefinitions, METH_VARARGS, (char *)"\n"
		"SBMLDocument_expandFunctionDefinitions(SBMLDocument self) -> bool\n"
		"\n"
		"Removes any FunctionDefinitions from the document and expands\n"
		"any instances of their use within &lt;math&gt; elements.\n"
		"\n"
		"For example a Model contains a FunctionDefinition with id f\n"
		"representing the math expression: f(x, y) = x * y.\n"
		"The math element of the KineticLaw uses f(s, p).\n"
		"The outcome of the function is that the math of the KineticLaw\n"
		"now represents the math expression: s * p and the model no longer\n"
		"contains any FunctionDefinitions.\n"
		"\n"
		"@return bool @c true if the transformation was successful, \n"
		"@c false, otherwise.\n"
		"\n"
		"@note This function will check the consistency of a model\n"
		"before attemptimg the transformation.  In the case of a model\n"
		"with invalid SBML the transformation will not be done and the\n"
		"function will return @c false.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_expandInitialAssignments", _wrap_SBMLDocument_expandInitialAssignments, METH_VARARGS, (char *)"\n"
		"SBMLDocument_expandInitialAssignments(SBMLDocument self) -> bool\n"
		"\n"
		"Removes any InitialAssignments from the document and replaces\n"
		"the appropriate values.\n"
		"\n"
		"For example a Model contains a InitialAssignment with symbol k\n"
		"where k is the id of a Parameter.\n"
		"The outcome of the function is that the value attribute of\n"
		"the Parameter is the value calculated using the math expression\n"
		"of the InitialAssignment and the corresponding InitialAssignment\n"
		"has been removed from the Model.\n"
		"\n"
		"@return bool @c true if the transformation was successful, \n"
		"@c false, otherwise.\n"
		"\n"
		"@note This function will check the consistency of a model\n"
		"before attemptimg the transformation.  In the case of a model\n"
		"with invalid SBML the transformation will not be done and the\n"
		"function will return @c false.  As part of the process the \n"
		"function will check that it has values for any components\n"
		"referred to by the math elements of InitialAssignments.  In\n"
		"the case where not all values have been declared the particular\n"
		"InitialAssignment will not be removed and the function will \n"
		"return @c false.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setLevelAndVersion", _wrap_SBMLDocument_setLevelAndVersion, METH_VARARGS, (char *)"\n"
		"setLevelAndVersion(unsigned int level, unsigned int version, bool strict = True) -> bool\n"
		"SBMLDocument_setLevelAndVersion(SBMLDocument self, unsigned int level, unsigned int version) -> bool\n"
		"\n"
		"Sets the SBML Level and Version of this SBMLDocument instance,\n"
		"attempting to convert the model as needed.\n"
		"\n"
		"This method is the principal way in libSBML to convert models between\n"
		"Levels and Versions of SBML.  Generally, models can be converted\n"
		"upward without difficulty (e.g., from SBML Level&nbsp;1 to\n"
		"Level&nbsp;2, or from an earlier Version of Level&nbsp;2 to the latest\n"
		"Version of Level&nbsp;2).  Sometimes models can be translated downward\n"
		"as well, if they do not use constructs specific to more advanced\n"
		"Levels of SBML.\n"
		"\n"
		"Before calling this method, callers may check compatibility directly\n"
		"using the methods SBMLDocument::checkL1Compatibility(),\n"
		"SBMLDocument::checkL2v1Compatibility(),\n"
		"SBMLDocument::checkL2v2Compatibility(),\n"
		"SBMLDocument::checkL2v3Compatibility() and\n"
		"SBMLDocument::checkL2v4Compatibility().\n"
		"\n"
		"The valid combinations of SBML Level and Version as of this release\n"
		"of libSBML are the following: \n"
		"<ul>\n"
		"<li> Level&nbsp;1 Version&nbsp;2\n"
		"<li> Level&nbsp;2 Version&nbsp;1\n"
		"<li> Level&nbsp;2 Version&nbsp;2\n"
		"<li> Level&nbsp;2 Version&nbsp;3\n"
		"<li> Level&nbsp;2 Version&nbsp;4\n"
		"</ul>\n"
		"\n"
		"@param level the desired SBML Level\n"
		" \n"
		"@param version the desired Version within the SBML Level\n"
		"\n"
		"@param strict boolean indicating whether to check consistency\n"
		"of both the source and target model when performing\n"
		"conversion (defaults to <code> true </code>)\n"
		"\n"
		"@note Calling this method will not @em necessarily lead to a successful\n"
		"conversion.  If the conversion fails, it will be logged in the error\n"
		"list associated with this SBMLDocument.  Callers should consult\n"
		"getNumErrors() to find out if the conversion succeeded without\n"
		"problems.  For conversions from Level&nbsp;2 to Level&nbsp;1, callers\n"
		"can also check the Level of the model after calling this method to\n"
		"find out whether it is Level&nbsp;1.  (If the conversion to\n"
		"Level&nbsp;1 failed, the Level of this model will be left unchanged.)\n"
		"\n"
		"@see checkL1Compatibility()\n"
		"@see checkL2v1Compatibility()\n"
		"@see checkL2v2Compatibility()\n"
		"@see checkL2v3Compatibility()\n"
		"@see checkL2v4Compatibility()\n"
		"\n"
		"Strict conversion applies the additional criteria that both the source\n"
		"and the target model must be consistent SBML.  Users can control the\n"
		"consistency checks that are applied using the \n"
		"SBMLDocument::setConsistencyChecksForConversion function.  If either \n"
		"the source\n"
		"or the potential target model have validation errors, the conversion\n"
		"is not performed.  When a strict conversion is successful, the\n"
		"underlying SBML object model is altered to reflect the new level\n"
		"and version.  Thus information that cannot be converted (e.g. sboTerms)\n"
		"will be lost.   \n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setModel", _wrap_SBMLDocument_setModel, METH_VARARGS, (char *)"\n"
		"SBMLDocument_setModel(SBMLDocument self, Model m) -> int\n"
		"\n"
		"Sets the Model for this SBMLDocument to a copy of the given Model.\n"
		"\n"
		"@param m the new Model to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"\n"
		"@see createModel()\n"
		"@see getModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_createModel", _wrap_SBMLDocument_createModel, METH_VARARGS, (char *)"\n"
		"createModel(string sid = \"\") -> Model\n"
		"SBMLDocument_createModel(SBMLDocument self) -> Model\n"
		"\n"
		"Creates a new Model inside this SBMLDocument, and returns a pointer to\n"
		"it.\n"
		"\n"
		"In SBML Level&nbsp;2, the use of an identifier on a Model object is\n"
		"optional.  This method takes an optional argument, @p sid, for setting\n"
		"the identifier.  If not supplied, the identifier attribute on the\n"
		"Model instance is not set.\n"
		"\n"
		"@param sid the identifier of the new Model to create.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"\n"
		"@see getModel()\n"
		"@see @if clike SBMLDocument::setModel() @endif@if java SBMLDocument::setModel(Model m) @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setConsistencyChecks", _wrap_SBMLDocument_setConsistencyChecks, METH_VARARGS, (char *)"\n"
		"SBMLDocument_setConsistencyChecks(SBMLDocument self, SBMLErrorCategory_t category, bool apply)\n"
		"\n"
		"Controls the consistency checks that are performed when\n"
		"SBMLDocument::checkConsistency() is called.\n"
		"\n"
		"This method works by adding or subtracting consistency checks from the\n"
		"set of all possible checks that SBMLDocument::checkConsistency() knows\n"
		"how to perform.  This method may need to be called multiple times in\n"
		"order to achieve the desired combination of checks.  The first\n"
		"argument (@p category) in a call to this method indicates the category\n"
		"of consistency/error checks that are to be turned on or off, and the\n"
		"second argument (@p apply, a boolean) indicates whether to turn it on\n"
		"(value of @c true) or off (value of @c false).\n"
		"\n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of values from the enumeration #SBMLErrorCategory_t.  The\n"
		"following are the possible choices in libSBML version&nbsp;3.3.x:\n"
		"\n"
		"@li @c LIBSBML_CAT_GENERAL_CONSISTENCY: Correctness and consistency of\n"
		"specific SBML language constructs.  Performing this set of checks is\n"
		"highly recommended.  With respect to the SBML specification, these\n"
		"concern failures in applying the validation rules numbered 2xxxx in\n"
		"the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4 specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_IDENTIFIER_CONSISTENCY: Correctness and consistency\n"
		"of identifiers used for model entities.  An example of inconsistency\n"
		"would be using a species identifier in a reaction rate formula without\n"
		"first having declared the species.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 103xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4\n"
		"specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_UNITS_CONSISTENCY: Consistency of measurement units\n"
		"associated with quantities in a model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 105xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4\n"
		"specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_MATHML_CONSISTENCY: Syntax of MathML constructs.\n"
		"With respect to the SBML specification, these concern failures in\n"
		"applying the validation rules numbered 102xx in the Level&nbsp;2\n"
		"Versions&nbsp;2, 3 and&nbsp;4 specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_SBO_CONSISTENCY: Consistency and validity of SBO\n"
		"identifiers (if any) used in the model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 107xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4\n"
		"specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_OVERDETERMINED_MODEL: Static analysis of\n"
		"whether the system of equations implied by a model is mathematically\n"
		"overdetermined.  With respect to the SBML specification, this is\n"
		"validation rule #10601 in the SBML Level&nbsp;2 Versions&nbsp;2, 3\n"
		"and&nbsp;4 specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_MODELING_PRACTICE: Additional checks for\n"
		"recommended good modeling practice. (These are tests performed by\n"
		"libSBML and do not have equivalent SBML validation rules.)\n"
		"\n"
		"<em>By default, all validation checks are applied</em> to the model in\n"
		"an SBMLDocument object @em unless @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif is called to\n"
		"indicate that only a subset should be applied.  Further, this default\n"
		"(i.e., performing all checks) applies separately to <em>each new\n"
		"SBMLDocument object</em> created.  In other words, each time a model\n"
		"is read using @if clike SBMLReader::readSBML() @endif@if java SBMLReader::readSBML(String filename) @endif, @if clike SBMLReader::readSBMLFromString() @endif@if java SBMLReader::readSBMLFromString(String xml) @endif,\n"
		"or the global functions readSBML() and readSBMLFromString(), a new\n"
		"SBMLDocument is created and for that document, a call to\n"
		"SBMLDocument::checkConsistency() will default to applying all possible checks.\n"
		"Calling programs must invoke @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif for each such new\n"
		"model if they wish to change the consistency checks applied.\n"
		"\n"
		"@param category a value drawn from #SBMLErrorCategory_t indicating the\n"
		"consistency checking/validation to be turned on or off\n"
		"\n"
		"@param apply a boolean indicating whether the checks indicated by\n"
		"@p category should be applied or not.\n"
		"\n"
		"@see SBMLDocument::checkConsistency()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setConsistencyChecksForConversion", _wrap_SBMLDocument_setConsistencyChecksForConversion, METH_VARARGS, (char *)"\n"
		"SBMLDocument_setConsistencyChecksForConversion(SBMLDocument self, SBMLErrorCategory_t category, bool apply)\n"
		"\n"
		"Controls the consistency checks that are performed when\n"
		"SBMLDocument::setLevelAndVersion() is called.\n"
		"\n"
		"This method works by adding or subtracting consistency checks from the\n"
		"set of all possible checks that may be performed to avoid conversion\n"
		"to or from an invalid document.  This method may need to be called \n"
		"multiple times in\n"
		"order to achieve the desired combination of checks.  The first\n"
		"argument (@p category) in a call to this method indicates the category\n"
		"of consistency/error checks that are to be turned on or off, and the\n"
		"second argument (@p apply, a boolean) indicates whether to turn it on\n"
		"(value of @c true) or off (value of @c false).\n"
		"\n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of values from the enumeration #SBMLErrorCategory_t.  The\n"
		"following are the possible choices in libSBML version&nbsp;4.x.x:\n"
		"\n"
		"@li @c LIBSBML_CAT_GENERAL_CONSISTENCY: Correctness and consistency of\n"
		"specific SBML language constructs.  Performing this set of checks is\n"
		"highly recommended.  With respect to the SBML specification, these\n"
		"concern failures in applying the validation rules numbered 2xxxx in\n"
		"the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4 specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_IDENTIFIER_CONSISTENCY: Correctness and consistency\n"
		"of identifiers used for model entities.  An example of inconsistency\n"
		"would be using a species identifier in a reaction rate formula without\n"
		"first having declared the species.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 103xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4\n"
		"specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_UNITS_CONSISTENCY: Consistency of measurement units\n"
		"associated with quantities in a model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 105xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4\n"
		"specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_MATHML_CONSISTENCY: Syntax of MathML constructs.\n"
		"With respect to the SBML specification, these concern failures in\n"
		"applying the validation rules numbered 102xx in the Level&nbsp;2\n"
		"Versions&nbsp;2, 3 and&nbsp;4 specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_SBO_CONSISTENCY: Consistency and validity of SBO\n"
		"identifiers (if any) used in the model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 107xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4\n"
		"specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_OVERDETERMINED_MODEL: Static analysis of\n"
		"whether the system of equations implied by a model is mathematically\n"
		"overdetermined.  With respect to the SBML specification, this is\n"
		"validation rule #10601 in the SBML Level&nbsp;2 Versions&nbsp;2, 3\n"
		"and&nbsp;4 specifications.\n"
		"\n"
		"@li @c LIBSBML_CAT_MODELING_PRACTICE: Additional checks for\n"
		"recommended good modeling practice. (These are tests performed by\n"
		"libSBML and do not have equivalent SBML validation rules.)\n"
		"\n"
		"<em>By default, all validation checks are applied</em> to the model in\n"
		"an SBMLDocument object @em unless @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif is called to\n"
		"indicate that only a subset should be applied.  Further, this default\n"
		"(i.e., performing all checks) applies separately to <em>each new\n"
		"SBMLDocument object</em> created.  In other words, each time a model\n"
		"is read using @if clike SBMLReader::readSBML() @endif@if java SBMLReader::readSBML(String filename) @endif, @if clike SBMLReader::readSBMLFromString() @endif@if java SBMLReader::readSBMLFromString(String xml) @endif,\n"
		"or the global functions readSBML() and readSBMLFromString(), a new\n"
		"SBMLDocument is created and for that document, a call to\n"
		"SBMLDocument::checkConsistency() will default to applying all possible checks.\n"
		"Calling programs must invoke @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif for each such new\n"
		"model if they wish to change the consistency checks applied.\n"
		"\n"
		"@param category a value drawn from #SBMLErrorCategory_t indicating the\n"
		"consistency checking/validation to be turned on or off\n"
		"\n"
		"@param apply a boolean indicating whether the checks indicated by\n"
		"@p category should be applied or not.\n"
		"\n"
		"@see @if clike SBMLDocument::setLevelAndVersion() @endif@if java SBMLDocument::setLevelAndVersion(long lev, long ver, boolean strict) @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkConsistency", _wrap_SBMLDocument_checkConsistency, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkConsistency(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs consistency checking and validation on this SBML document.\n"
		"\n"
		"If this method returns a nonzero value (meaning, one or more\n"
		"consistency checks have failed for SBML document), the failures may be\n"
		"due to warnings @em or errors.  Callers should inspect the severity\n"
		"flag in the individual SBMLError objects returned by\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif to determine the nature of the failures.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"\n"
		"@see SBMLDocument::checkInternalConsistency()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkInternalConsistency", _wrap_SBMLDocument_checkInternalConsistency, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkInternalConsistency(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs consistency checking on libSBML's internal representation of \n"
		"an SBML Model.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"\n"
		"The distinction between this method and\n"
		"SBMLDocument::checkConsistency() is that this method reports on\n"
		"fundamental syntactic and structural errors that violate the XML\n"
		"Schema for SBML; by contrast, SBMLDocument::checkConsistency()\n"
		"performs more elaborate model verifications and also validation\n"
		"according to the validation rules written in the appendices of the\n"
		"SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 specification documents.\n"
		"\n"
		"@see SBMLDocument::checkConsistency()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL1Compatibility", _wrap_SBMLDocument_checkL1Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL1Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;1 and can be converted\n"
		"to Level&nbsp;1.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v1Compatibility", _wrap_SBMLDocument_checkL2v1Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v1Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;1 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;1.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v2Compatibility", _wrap_SBMLDocument_checkL2v2Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v2Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;2 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;2.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v3Compatibility", _wrap_SBMLDocument_checkL2v3Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v3Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;3 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;3.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v4Compatibility", _wrap_SBMLDocument_checkL2v4Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v4Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;4 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;4.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL3v1Compatibility", _wrap_SBMLDocument_checkL3v1Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL3v1Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;3 Version&nbsp;1 and can\n"
		"be converted to Level&nbsp;3 Version&nbsp;1.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"@if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getError", _wrap_SBMLDocument_getError, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getError(SBMLDocument self, unsigned int n) -> SBMLError\n"
		"\n"
		"Returns the nth error or warning encountered during parsing,\n"
		"consistency checking, or attempted translation of this model.\n"
		"\n"
		"Callers can use method XMLError::getSeverity() on the result to assess\n"
		"the severity of the problem.  The possible severity levels range from\n"
		"informational messages to fatal errors.\n"
		"\n"
		"@return the error or warning indexed by integer @p n, or return @c\n"
		"NULL if <code>n &gt; (getNumErrors() - 1)</code>.\n"
		"\n"
		"@param n the integer index of the error sought.\n"
		"\n"
		"@see SBMLDocument::getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getNumErrors", _wrap_SBMLDocument_getNumErrors, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getNumErrors(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Returns the number of errors or warnings encountered during parsing,\n"
		"consistency checking, or attempted translation of this model.\n"
		"\n"
		"@return the number of errors or warnings encountered\n"
		"\n"
		"@see SBMLDocument::getError(unsigned int n)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_printErrors", _wrap_SBMLDocument_printErrors, METH_VARARGS, (char *)"\n"
		"printErrors(ostream stream = cerr)\n"
		"SBMLDocument_printErrors(SBMLDocument self)\n"
		"\n"
		"Prints to the given output stream all the errors or warnings\n"
		"encountered during parsing, consistency checking, or attempted\n"
		"translation of this model.\n"
		"\n"
		"If no errors have occurred, i.e., <code>getNumErrors() == 0</code>, no\n"
		"output will be sent to the stream.\n"
		"\n"
		"The format of the output is:\n"
		"  @verbatim\n"
		"    N error(s):\n"
		"      line NNN: (id) message\n"
		" @endverbatim\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getTypeCode", _wrap_SBMLDocument_getTypeCode, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getTypeCode(SBMLDocument self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see SBMLDocument::getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getElementName", _wrap_SBMLDocument_getElementName, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getElementName(SBMLDocument self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for SBMLDocument,\n"
		"is always @c 'sbml'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'sbml'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getErrorLog", _wrap_SBMLDocument_getErrorLog, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getErrorLog(SBMLDocument self) -> SBMLErrorLog\n"
		"\n"
		"Returns the list of errors or warnings logged during parsing, \n"
		"consistency checking, or attempted translation of this model.\n"
		"\n"
		"@return the SBMLErrorLog used for this SBMLDocument\n"
		"\n"
		"@see SBMLDocument::getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getNamespaces", _wrap_SBMLDocument_getNamespaces, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getNamespaces(SBMLDocument self) -> XMLNamespaces\n"
		"\n"
		"Returns a list of XML Namespaces associated with the XML content\n"
		"of this SBML document.\n"
		"\n"
		"@return the XML Namespaces associated with this SBML object\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_swigregister", SBMLDocument_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_FunctionDefinition", _wrap_delete_FunctionDefinition, METH_VARARGS, (char *)"delete_FunctionDefinition(FunctionDefinition self)"},
	 { (char *)"new_FunctionDefinition", _wrap_new_FunctionDefinition, METH_VARARGS, (char *)"\n"
		"FunctionDefinition(unsigned int level, unsigned int version)\n"
		"FunctionDefinition(SBMLNamespaces sbmlns)\n"
		"new_FunctionDefinition(FunctionDefinition orig) -> FunctionDefinition\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this FunctionDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a FunctionDefinition object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_clone", _wrap_FunctionDefinition_clone, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_clone(FunctionDefinition self) -> FunctionDefinition\n"
		"\n"
		"Creates and returns a deep copy of this FunctionDefinition.\n"
		"\n"
		"@return a (deep) copy of this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getId", _wrap_FunctionDefinition_getId, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getId(FunctionDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this FunctionDefinition.\n"
		"\n"
		"@return the id of this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getName", _wrap_FunctionDefinition_getName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getName(FunctionDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this FunctionDefinition.\n"
		"\n"
		"@return the name of this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getMath", _wrap_FunctionDefinition_getMath, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getMath(FunctionDefinition self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula of this FunctionDefinition.\n"
		"\n"
		"@return an ASTNode, the value of the 'math' subelement of this\n"
		"FunctionDefinition\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_isSetId", _wrap_FunctionDefinition_isSetId, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_isSetId(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"FunctionDefinition's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this FunctionDefinition has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_isSetName", _wrap_FunctionDefinition_isSetName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_isSetName(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"FunctionDefinition's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this FunctionDefinition has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_isSetMath", _wrap_FunctionDefinition_isSetMath, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_isSetMath(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"FunctionDefinition's 'math' subelement contains a value.\n"
		"\n"
		"@return @c true if the 'math' for this FunctionDefinition has been set,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_setId", _wrap_FunctionDefinition_setId, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_setId(FunctionDefinition self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this FunctionDefinition.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this FunctionDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_setName", _wrap_FunctionDefinition_setName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_setName(FunctionDefinition self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this FunctionDefinition.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the FunctionDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_setMath", _wrap_FunctionDefinition_setMath, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_setMath(FunctionDefinition self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this FunctionDefinition to the Abstract\n"
		"Syntax Tree given in @p math.\n"
		"\n"
		"@param math an AST containing the mathematical expression to\n"
		"be used as the formula for this FunctionDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_unsetName", _wrap_FunctionDefinition_unsetName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_unsetName(FunctionDefinition self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this FunctionDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getArgument", _wrap_FunctionDefinition_getArgument, METH_VARARGS, (char *)"\n"
		"getArgument(unsigned int n) -> ASTNode\n"
		"FunctionDefinition_getArgument(FunctionDefinition self, string name) -> ASTNode\n"
		"\n"
		"Get the argument named @p name to this FunctionDefinition.\n"
		"\n"
		"@param name the exact name (case-sensitive) of the sought-after\n"
		"argument\n"
		"\n"
		"@return the argument (bound variable) having the given name, or @c NULL if\n"
		"no such argument exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getBody", _wrap_FunctionDefinition_getBody, METH_VARARGS, (char *)"\n"
		"getBody() -> ASTNode\n"
		"FunctionDefinition_getBody(FunctionDefinition self) -> ASTNode\n"
		"\n"
		"Get the mathematical expression that is the body of this\n"
		"FunctionDefinition object.\n"
		"\n"
		"@return the body of this FunctionDefinition as an Abstract Syntax\n"
		"Tree, or @c NULL if no body is defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getNumArguments", _wrap_FunctionDefinition_getNumArguments, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getNumArguments(FunctionDefinition self) -> unsigned int\n"
		"\n"
		"Get the number of arguments (bound variables) taken by this\n"
		"FunctionDefinition.\n"
		"\n"
		"@return the number of arguments (bound variables) that must be passed\n"
		"to this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getTypeCode", _wrap_FunctionDefinition_getTypeCode, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getTypeCode(FunctionDefinition self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getElementName", _wrap_FunctionDefinition_getElementName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getElementName(FunctionDefinition self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"FunctionDefinition, is always @c 'functionDefinition'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'functionDefinition'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_hasRequiredAttributes", _wrap_FunctionDefinition_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_hasRequiredAttributes(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this FunctionDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a FunctionDefinition object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_hasRequiredElements", _wrap_FunctionDefinition_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_hasRequiredElements(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this FunctionDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a FunctionDefinition object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_swigregister", FunctionDefinition_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfFunctionDefinitions_clone", _wrap_ListOfFunctionDefinitions_clone, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_clone(ListOfFunctionDefinitions self) -> ListOfFunctionDefinitions\n"
		"\n"
		"Creates and returns a deep copy of this ListOfFunctionDefinitions instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfFunctionDefinitions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_getTypeCode", _wrap_ListOfFunctionDefinitions_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_getTypeCode(ListOfFunctionDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_getItemTypeCode", _wrap_ListOfFunctionDefinitions_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_getItemTypeCode(ListOfFunctionDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., FunctionDefinition objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_getElementName", _wrap_ListOfFunctionDefinitions_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_getElementName(ListOfFunctionDefinitions self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfFunctionDefinitions, the XML element name is @c\n"
		"'listOfFunctionDefinitions'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfFunctionDefinitions'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_get", _wrap_ListOfFunctionDefinitions_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> FunctionDefinition\n"
		"get(unsigned int n) -> FunctionDefinition\n"
		"get(string sid) -> FunctionDefinition\n"
		"ListOfFunctionDefinitions_get(ListOfFunctionDefinitions self, string sid) -> FunctionDefinition\n"
		"\n"
		"Get a FunctionDefinition from the ListOfFunctionDefinitions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the FunctionDefinition to get.\n"
		"\n"
		"@return FunctionDefinition in this ListOfFunctionDefinitions\n"
		"with the given id or @c NULL if no such\n"
		"FunctionDefinition exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_remove", _wrap_ListOfFunctionDefinitions_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> FunctionDefinition\n"
		"ListOfFunctionDefinitions_remove(ListOfFunctionDefinitions self, string sid) -> FunctionDefinition\n"
		"\n"
		"Removes item in this ListOfFunctionDefinitions items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfFunctionDefinitions", _wrap_new_ListOfFunctionDefinitions, METH_VARARGS, (char *)"new_ListOfFunctionDefinitions() -> ListOfFunctionDefinitions"},
	 { (char *)"delete_ListOfFunctionDefinitions", _wrap_delete_ListOfFunctionDefinitions, METH_VARARGS, (char *)"delete_ListOfFunctionDefinitions(ListOfFunctionDefinitions self)"},
	 { (char *)"ListOfFunctionDefinitions_swigregister", ListOfFunctionDefinitions_swigregister, METH_VARARGS, NULL},
	 { (char *)"UnitKind_equals", _wrap_UnitKind_equals, METH_VARARGS, (char *)"\n"
		"UnitKind_equals(UnitKind_t uk1, UnitKind_t uk2) -> int\n"
		"\n"
		"Tests for logical equality between two given UnitKind_t values.\n"
		"\n"
		"This function behaves exactly like C's <tt>==</tt> operator, except for\n"
		"the following two cases:\n"
		"\n"
		"@li UNIT_KIND_LITER <code>==</code> UNIT_KIND_LITRE\n"
		"@li UNIT_KIND_METER <code>==</code> UNIT_KIND_METRE\n"
		"\n"
		"C equality comparison would yield false (because each of the above is a\n"
		"distinct enumeration value), but UnitKind_equals() returns true.\n"
		"\n"
		"@param uk1 a UnitKind_t enumeration value \n"
		"@param uk2 the UnitKind_t enumeration value to compare to @p uk1\n"
		"\n"
		"@return nonzero (for true) if uk1 is logically equivalent to uk2,\n"
		"zero (0) otherwise.\n"
		"\n"
		"@note For more information about the UnitKind_t enumeration, please\n"
		"refer to the class documentation for Unit.\n"
		"\n"
		"\n"
		""},
	 { (char *)"UnitKind_forName", _wrap_UnitKind_forName, METH_VARARGS, (char *)"\n"
		"UnitKind_forName(char name) -> UnitKind_t\n"
		"\n"
		"Converts a string to its corresponding UnitKind_t enumeration value.\n"
		"\n"
		"@param name a string, the name of a predefined base unit in SBML\n"
		"\n"
		"@return a value from UnitKind_t corresponding to the given name\n"
		"(determined in a case-insensitive manner).\n"
		"\n"
		"@note For more information about the UnitKind_t enumeration, please\n"
		"refer to the class documentation for Unit.\n"
		"\n"
		"\n"
		""},
	 { (char *)"UnitKind_toString", _wrap_UnitKind_toString, METH_VARARGS, (char *)"\n"
		"UnitKind_toString(UnitKind_t uk) -> char\n"
		"\n"
		"Converts a UnitKind_t enumeration value to a text string equivalent.\n"
		"\n"
		"@param uk the UnitKind_t value to convert\n"
		"\n"
		"@return the name of the given UnitKind.\n"
		"\n"
		"@note The string returned is a static data value.  The caller does not\n"
		"own the returned string and is therefore not allowed to modify it.\n"
		"\n"
		"@note For more information about the UnitKind_t enumeration, please\n"
		"refer to the class documentation for Unit.\n"
		"\n"
		"\n"
		""},
	 { (char *)"UnitKind_isValidUnitKindString", _wrap_UnitKind_isValidUnitKindString, METH_VARARGS, (char *)"\n"
		"UnitKind_isValidUnitKindString(char string, unsigned int level, unsigned int version) -> int\n"
		"\n"
		"Predicate for testing whether a given string corresponds to a\n"
		"predefined UnitKind_t enumeration value.\n"
		"\n"
		"@return nonzero (for true) if string is the name of a valid\n"
		"UnitKind_t enumeration value, zero (0) otherwise.\n"
		"\n"
		"@note For more information about the UnitKind_t enumeration, please\n"
		"refer to the class documentation for Unit.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Unit", _wrap_delete_Unit, METH_VARARGS, (char *)"delete_Unit(Unit self)"},
	 { (char *)"new_Unit", _wrap_new_Unit, METH_VARARGS, (char *)"\n"
		"Unit(unsigned int level, unsigned int version)\n"
		"Unit(SBMLNamespaces sbmlns)\n"
		"new_Unit(Unit orig) -> Unit\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Unit object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Unit object are:\n"
		"@li 'kind'\n"
		"@li 'exponent' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"@li 'multiplier' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"@li 'scale' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Unit_clone", _wrap_Unit_clone, METH_VARARGS, (char *)"\n"
		"Unit_clone(Unit self) -> Unit\n"
		"\n"
		"Creates and returns a deep copy of this Unit.\n"
		"\n"
		"@return a (deep) copy of this Unit.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_initDefaults", _wrap_Unit_initDefaults, METH_VARARGS, (char *)"\n"
		"Unit_initDefaults(Unit self)\n"
		"\n"
		"Initializes the fields of this Unit object to 'typical' default\n"
		"values.\n"
		"\n"
		"The SBML Unit component has slightly different aspects and default\n"
		"attribute values in different SBML Levels and Versions.  This method\n"
		"sets the values to certain common defaults, based mostly on what they\n"
		"are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets attribute 'exponent' to @c 1\n"
		"<li> Sets attribute 'scale' to @c 0\n"
		"<li> Sets attribute 'multiplier' to @c 1.0\n"
		"</ul>\n"
		"\n"
		"The 'kind' attribute is left unchanged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getKind", _wrap_Unit_getKind, METH_VARARGS, (char *)"\n"
		"Unit_getKind(Unit self) -> UnitKind_t\n"
		"\n"
		"Returns the 'kind' of Unit this is.\n"
		"\n"
		"@return the value of the 'kind' attribute of this Unit as a value from\n"
		"the <a class='el' href='#UnitKind_t'>UnitKind_t</a> enumeration.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getExponent", _wrap_Unit_getExponent, METH_VARARGS, (char *)"\n"
		"Unit_getExponent(Unit self) -> int\n"
		"\n"
		"Returns the value of the 'exponent' attribute of this unit.\n"
		"\n"
		"@return the 'exponent' value of this Unit, as an integer.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getExponentAsDouble", _wrap_Unit_getExponentAsDouble, METH_VARARGS, (char *)"\n"
		"Unit_getExponentAsDouble(Unit self) -> double\n"
		"\n"
		"Returns the value of the 'exponent' attribute of this unit.\n"
		"\n"
		"@return the 'exponent' value of this Unit, as a double.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getScale", _wrap_Unit_getScale, METH_VARARGS, (char *)"\n"
		"Unit_getScale(Unit self) -> int\n"
		"\n"
		"Returns the value of the 'scale' attribute of this unit.\n"
		"\n"
		"@return the 'scale' value of this Unit, as an integer.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getMultiplier", _wrap_Unit_getMultiplier, METH_VARARGS, (char *)"\n"
		"Unit_getMultiplier(Unit self) -> double\n"
		"\n"
		"Returns the value of the 'multiplier' attribute of this Unit.\n"
		"\n"
		"@return the 'multiplier' value of this Unit, as a double.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getOffset", _wrap_Unit_getOffset, METH_VARARGS, (char *)"\n"
		"Unit_getOffset(Unit self) -> double\n"
		"\n"
		"Returns the value of the 'offset' attribute of this Unit.\n"
		"\n"
		"@warning The 'offset' attribute is only available in SBML Level&nbsp;2\n"
		"Version&nbsp;1.  This attribute is not present in SBML Level&nbsp;2\n"
		"Version&nbsp;2 or above.  When producing SBML models using these later\n"
		"specifications, modelers and software tools need to account for units\n"
		"with offsets explicitly.  The %SBML specification document offers a\n"
		"number of suggestions for how to achieve this.  LibSBML methods such\n"
		"as this one related to 'offset' are retained for compatibility with\n"
		"earlier versions of SBML Level&nbsp;2, but their use is strongly\n"
		"discouraged.\n"
		"\n"
		"@return the 'offset' value of this Unit, as a double.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isAmpere", _wrap_Unit_isAmpere, METH_VARARGS, (char *)"\n"
		"Unit_isAmpere(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c ampere.\n"
		"\n"
		"@return @c true if the kind of this Unit is @c ampere, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isAvogadro", _wrap_Unit_isAvogadro, METH_VARARGS, (char *)"\n"
		"Unit_isAvogadro(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c avogadro.\n"
		"\n"
		"@return @c true if the kind of this Unit is @c avogadro, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isBecquerel", _wrap_Unit_isBecquerel, METH_VARARGS, (char *)"\n"
		"Unit_isBecquerel(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c becquerel\n"
		"\n"
		"@return @c true if the kind of this Unit is @c becquerel, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isCandela", _wrap_Unit_isCandela, METH_VARARGS, (char *)"\n"
		"Unit_isCandela(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c candela\n"
		"\n"
		"@return @c true if the kind of this Unit is @c candela, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isCelsius", _wrap_Unit_isCelsius, METH_VARARGS, (char *)"\n"
		"Unit_isCelsius(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c Celsius\n"
		"\n"
		"@return @c true if the kind of this Unit is @c Celsius, @c false\n"
		"otherwise. \n"
		"\n"
		"@warning The predefined unit @c Celsius was removed from the list of\n"
		"predefined units in SBML Level&nbsp;2 Version&nbsp;2 at the same time\n"
		"that the 'offset' attribute was removed from Unit definitions.\n"
		"LibSBML methods such as this one related to @c Celsius are retained in\n"
		"order to support SBML Level&nbsp;2 Version&nbsp;1, but their use is\n"
		"strongly discouraged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isCoulomb", _wrap_Unit_isCoulomb, METH_VARARGS, (char *)"\n"
		"Unit_isCoulomb(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c coulomb\n"
		"\n"
		"@return @c true if the kind of this Unit is @c coulomb, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isDimensionless", _wrap_Unit_isDimensionless, METH_VARARGS, (char *)"\n"
		"Unit_isDimensionless(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c\n"
		"dimensionless.\n"
		"\n"
		"@return @c true if the kind of this Unit is @c dimensionless, @c false\n"
		"\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isFarad", _wrap_Unit_isFarad, METH_VARARGS, (char *)"\n"
		"Unit_isFarad(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c farad\n"
		"\n"
		"@return @c true if the kind of this Unit is @c farad, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isGram", _wrap_Unit_isGram, METH_VARARGS, (char *)"\n"
		"Unit_isGram(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c gram\n"
		"\n"
		"@return @c true if the kind of this Unit is @c gram, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isGray", _wrap_Unit_isGray, METH_VARARGS, (char *)"\n"
		"Unit_isGray(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c gray\n"
		"\n"
		"@return @c true if the kind of this Unit is @c gray, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isHenry", _wrap_Unit_isHenry, METH_VARARGS, (char *)"\n"
		"Unit_isHenry(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c henry\n"
		"\n"
		"@return @c true if the kind of this Unit is @c henry, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isHertz", _wrap_Unit_isHertz, METH_VARARGS, (char *)"\n"
		"Unit_isHertz(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c hertz\n"
		"\n"
		"@return @c true if the kind of this Unit is @c hertz, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isItem", _wrap_Unit_isItem, METH_VARARGS, (char *)"\n"
		"Unit_isItem(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c item\n"
		"\n"
		"@return @c true if the kind of this Unit is @c item, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isJoule", _wrap_Unit_isJoule, METH_VARARGS, (char *)"\n"
		"Unit_isJoule(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c joule\n"
		"\n"
		"@return @c true if the kind of this Unit is @c joule, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isKatal", _wrap_Unit_isKatal, METH_VARARGS, (char *)"\n"
		"Unit_isKatal(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c katal\n"
		"\n"
		"@return @c true if the kind of this Unit is @c katal, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isKelvin", _wrap_Unit_isKelvin, METH_VARARGS, (char *)"\n"
		"Unit_isKelvin(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c kelvin\n"
		"\n"
		"@return @c true if the kind of this Unit is @c kelvin, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isKilogram", _wrap_Unit_isKilogram, METH_VARARGS, (char *)"\n"
		"Unit_isKilogram(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c kilogram\n"
		"\n"
		"@return @c true if the kind of this Unit is @c kilogram, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isLitre", _wrap_Unit_isLitre, METH_VARARGS, (char *)"\n"
		"Unit_isLitre(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c litre\n"
		"\n"
		"@return @c true if the kind of this Unit is @c litre or 'liter', @c\n"
		"false \n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isLumen", _wrap_Unit_isLumen, METH_VARARGS, (char *)"\n"
		"Unit_isLumen(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c lumen\n"
		"\n"
		"@return @c true if the kind of this Unit is @c lumen, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isLux", _wrap_Unit_isLux, METH_VARARGS, (char *)"\n"
		"Unit_isLux(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c lux\n"
		"\n"
		"@return @c true if the kind of this Unit is @c lux, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isMetre", _wrap_Unit_isMetre, METH_VARARGS, (char *)"\n"
		"Unit_isMetre(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c metre\n"
		"\n"
		"@return @c true if the kind of this Unit is @c metre or 'meter', @c\n"
		"false \n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isMole", _wrap_Unit_isMole, METH_VARARGS, (char *)"\n"
		"Unit_isMole(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c mole\n"
		"\n"
		"@return @c true if the kind of this Unit is @c mole, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isNewton", _wrap_Unit_isNewton, METH_VARARGS, (char *)"\n"
		"Unit_isNewton(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c newton\n"
		"\n"
		"@return @c true if the kind of this Unit is @c newton, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isOhm", _wrap_Unit_isOhm, METH_VARARGS, (char *)"\n"
		"Unit_isOhm(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c ohm\n"
		"\n"
		"@return @c true if the kind of this Unit is @c ohm, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isPascal", _wrap_Unit_isPascal, METH_VARARGS, (char *)"\n"
		"Unit_isPascal(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c pascal\n"
		"\n"
		"@return @c true if the kind of this Unit is @c pascal, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isRadian", _wrap_Unit_isRadian, METH_VARARGS, (char *)"\n"
		"Unit_isRadian(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c radian\n"
		"\n"
		"@return @c true if the kind of this Unit is @c radian, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSecond", _wrap_Unit_isSecond, METH_VARARGS, (char *)"\n"
		"Unit_isSecond(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c second\n"
		"\n"
		"@return @c true if the kind of this Unit is @c second, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSiemens", _wrap_Unit_isSiemens, METH_VARARGS, (char *)"\n"
		"Unit_isSiemens(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c siemens\n"
		"\n"
		"@return @c true if the kind of this Unit is @c siemens, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSievert", _wrap_Unit_isSievert, METH_VARARGS, (char *)"\n"
		"Unit_isSievert(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c sievert\n"
		"\n"
		"@return @c true if the kind of this Unit is @c sievert, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSteradian", _wrap_Unit_isSteradian, METH_VARARGS, (char *)"\n"
		"Unit_isSteradian(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c steradian\n"
		"\n"
		"@return @c true if the kind of this Unit is @c steradian, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isTesla", _wrap_Unit_isTesla, METH_VARARGS, (char *)"\n"
		"Unit_isTesla(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c tesla\n"
		"\n"
		"@return @c true if the kind of this Unit is @c tesla, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isVolt", _wrap_Unit_isVolt, METH_VARARGS, (char *)"\n"
		"Unit_isVolt(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c volt\n"
		"\n"
		"@return @c true if the kind of this Unit is @c volt, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isWatt", _wrap_Unit_isWatt, METH_VARARGS, (char *)"\n"
		"Unit_isWatt(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c watt\n"
		"\n"
		"@return @c true if the kind of this Unit is @c watt, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isWeber", _wrap_Unit_isWeber, METH_VARARGS, (char *)"\n"
		"Unit_isWeber(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c weber\n"
		"\n"
		"@return @c true if the kind of this Unit is @c weber, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetKind", _wrap_Unit_isSetKind, METH_VARARGS, (char *)"\n"
		"Unit_isSetKind(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'kind' attribute of this Unit has been set.\n"
		"\n"
		"@return @c true if the 'kind' attribute of this Unit has been set, @c\n"
		"false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetExponent", _wrap_Unit_isSetExponent, METH_VARARGS, (char *)"\n"
		"Unit_isSetExponent(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'exponent' attribute of this Unit \n"
		"has been set.\n"
		"\n"
		"@return @c true if the 'exponent' attribute of this Unit has been set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetScale", _wrap_Unit_isSetScale, METH_VARARGS, (char *)"\n"
		"Unit_isSetScale(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'scale' attribute of this Unit \n"
		"has been set.\n"
		"\n"
		"@return @c true if the 'scale' attribute of this Unit has been set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetMultiplier", _wrap_Unit_isSetMultiplier, METH_VARARGS, (char *)"\n"
		"Unit_isSetMultiplier(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'multiplier' attribute of this Unit \n"
		"has been set.\n"
		"\n"
		"@return @c true if the 'multiplier' attribute of this Unit has been set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setKind", _wrap_Unit_setKind, METH_VARARGS, (char *)"\n"
		"Unit_setKind(Unit self, UnitKind_t kind) -> int\n"
		"\n"
		"Sets the 'kind' attribute value of this Unit.\n"
		"\n"
		"@param kind a value from the <a class='el'\n"
		"href='#UnitKind_t'>UnitKind_t</a> enumeration\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setExponent", _wrap_Unit_setExponent, METH_VARARGS, (char *)"\n"
		"setExponent(int value) -> int\n"
		"Unit_setExponent(Unit self, double value) -> int\n"
		"\n"
		"Sets the 'exponent' attribute value of this Unit.\n"
		"\n"
		"@param value the double to which the attribute 'exponent' should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setScale", _wrap_Unit_setScale, METH_VARARGS, (char *)"\n"
		"Unit_setScale(Unit self, int value) -> int\n"
		"\n"
		"Sets the 'scale' attribute value of this Unit.\n"
		"\n"
		"@param value the integer to which the attribute 'scale' should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setMultiplier", _wrap_Unit_setMultiplier, METH_VARARGS, (char *)"\n"
		"Unit_setMultiplier(Unit self, double value) -> int\n"
		"\n"
		"Sets the 'multipler' attribute value of this Unit.\n"
		"\n"
		"@param value the floating-point value to which the attribute\n"
		"'multiplier' should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setOffset", _wrap_Unit_setOffset, METH_VARARGS, (char *)"\n"
		"Unit_setOffset(Unit self, double value) -> int\n"
		"\n"
		"Sets the 'offset' attribute value of this Unit.\n"
		"\n"
		"@param value the float-point value to which the attribute 'offset'\n"
		"should set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@warning The 'offset' attribute is only available in SBML Level&nbsp;2\n"
		"Version&nbsp;1.  This attribute is not present in SBML Level&nbsp;2\n"
		"Version&nbsp;2 or above.  When producing SBML models using these later\n"
		"specifications, modelers and software tools need to account for units\n"
		"with offsets explicitly.  The %SBML specification document offers a\n"
		"number of suggestions for how to achieve this.  LibSBML methods such\n"
		"as this one related to 'offset' are retained for compatibility with\n"
		"earlier versions of SBML Level&nbsp;2, but their use is strongly\n"
		"discouraged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getTypeCode", _wrap_Unit_getTypeCode, METH_VARARGS, (char *)"\n"
		"Unit_getTypeCode(Unit self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getElementName", _wrap_Unit_getElementName, METH_VARARGS, (char *)"\n"
		"Unit_getElementName(Unit self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Unit, is\n"
		"always @c 'unit'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'unit'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isBuiltIn", _wrap_Unit_isBuiltIn, METH_VARARGS, (char *)"\n"
		"Unit_isBuiltIn(string name, unsigned int level) -> bool\n"
		"\n"
		"Predicate to test whether a given string is the name of a\n"
		"predefined SBML unit.\n"
		"\n"
		"@param name a string to be tested against the predefined unit names\n"
		"\n"
		"@param level the Level of SBML for which the determination should be\n"
		"made.  This is necessary because there are a few small differences\n"
		"in allowed units between SBML Level&nbsp;1 and Level&nbsp;2.\n"
		"\n"
		"@return @c true if @p name is one of the five SBML predefined unit\n"
		"identifiers (@c 'substance', @c 'volume', @c 'area', @c 'length' or @c\n"
		"'time'), @c false otherwise.\n"
		"\n"
		"@note The predefined unit identifiers @c 'length' and @c 'area' were\n"
		"added in Level&nbsp;2 Version&nbsp;1\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isUnitKind", _wrap_Unit_isUnitKind, METH_VARARGS, (char *)"\n"
		"Unit_isUnitKind(string name, unsigned int level, unsigned int version) -> bool\n"
		"\n"
		"Predicate to test whether a given string is the name of a valid\n"
		"base unit in SBML (such as @c 'gram' or @c 'mole').\n"
		"\n"
		"This method exists because prior to SBML Level&nbsp;2 Version&nbsp;3,\n"
		"an enumeration called @c UnitKind was defined by SBML.  This enumeration\n"
		"was removed in SBML Level&nbsp;2 Version&nbsp;3 and its values were\n"
		"folded into the space of values of a type called @c UnitSId.  This method\n"
		"therefore has less significance in SBML Level&nbsp;2 Version&nbsp;3\n"
		"and Level&nbsp;2 Version&nbsp;4, but remains for backward\n"
		"compatibility and support for reading models in older Versions of\n"
		"Level&nbsp;2.\n"
		"\n"
		"@param name a string to be tested\n"
		"\n"
		"@param level an unsigned int representing the SBML specification\n"
		"Level \n"
		"\n"
		"@param version an unsigned int representing the SBML specification\n"
		"Version\n"
		"\n"
		"@return @c true if name is a valid UnitKind, @c false otherwise\n"
		"\n"
		"@note The allowed unit names differ between SBML Levels&nbsp;1\n"
		"and&nbsp;2 and again slightly between Level&nbsp;2 Versions&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_areIdentical", _wrap_Unit_areIdentical, METH_VARARGS, (char *)"\n"
		"Unit_areIdentical(Unit unit1, Unit unit2) -> bool\n"
		"\n"
		"Predicate returning @c true if two\n"
		"Unit objects are identical.\n"
		"\n"
		"Two Unit objects are considered to be @em identical if they match in\n"
		"all attributes.  (Contrast this to the method areEquivalent(), which\n"
		"compares Unit objects only with respect to certain attributes.)\n"
		"\n"
		"@param unit1 the first Unit object to compare\n"
		"@param unit2 the second Unit object to compare\n"
		"\n"
		"@return @c true if all the attributes of unit1 are identical\n"
		"to the attributes of unit2, @c false otherwise.\n"
		"\n"
		"@see areEquivalent()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_areEquivalent", _wrap_Unit_areEquivalent, METH_VARARGS, (char *)"\n"
		"Unit_areEquivalent(Unit unit1, Unit unit2) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"Unit objects are equivalent.\n"
		"\n"
		"Two Unit objects are considered to be @em equivalent either if (1) both\n"
		"have a 'kind' attribute value of @c dimensionless, or (2) their 'kind',\n"
		"'exponent' and (for SBML Level&nbsp;2 Version&nbsp;1) 'offset'\n"
		"attribute values are equal. (Contrast this to the method\n"
		"areIdentical(), which compares Unit objects with respect to all\n"
		"attributes, not just the 'kind' and 'exponent'.)\n"
		"\n"
		"@param unit1 the first Unit object to compare\n"
		"@param unit2 the second Unit object to compare\n"
		"\n"
		"@return @c true if the 'kind' and 'exponent' attributes of unit1 are\n"
		"identical to the kind and exponent attributes of unit2, @c false\n"
		"otherwise.\n"
		"\n"
		"@see areIdentical()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_removeScale", _wrap_Unit_removeScale, METH_VARARGS, (char *)"\n"
		"Unit_removeScale(Unit unit) -> int\n"
		"\n"
		"Manipulates the attributes of the Unit to express the unit with the \n"
		"value of the scale attribute reduced to zero.\n"
		"\n"
		"For example, 1 millimetre can be expressed as a Unit with kind=@c\n"
		"'metre' multiplier=@c '1' scale=@c '-3' exponent=@c '1'. It can also be\n"
		"expressed as a Unit with kind=@c 'metre'\n"
		"multiplier=<code>'0.001'</code> scale=@c '0' exponent=@c '1'.\n"
		"\n"
		"@param unit the Unit object to manipulate.\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see convertToSI()\n"
		"@see merge()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_merge", _wrap_Unit_merge, METH_VARARGS, (char *)"\n"
		"Unit_merge(Unit unit1, Unit unit2)\n"
		"\n"
		"Merges two Unit objects with the same 'kind' attribute value into a\n"
		"single Unit.\n"
		"\n"
		"For example, the following,\n"
		"@code\n"
		"<unit kind='metre' exponent='2'/>\n"
		"<unit kind='metre' exponent='1'/>\n"
		"@endcode\n"
		"would be merged to become\n"
		"@code\n"
		"<unit kind='metre' exponent='3'/>\n"
		"@endcode\n"
		"\n"
		"@param unit1 the first Unit object; the result of the operation is\n"
		"left as a new version of this unit, modified in-place.\n"
		"\n"
		"@param unit2 the second Unit object to merge with the first\n"
		"\n"
		"@see convertToSI()\n"
		"@see removeScale()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_convertToSI", _wrap_Unit_convertToSI, METH_VARARGS, (char *)"\n"
		"Unit_convertToSI(Unit unit) -> UnitDefinition\n"
		"\n"
		"Returns a UnitDefinition object containing the given @p unit converted\n"
		"to the appropriate SI unit.\n"
		"\n"
		"This method exists because some units can be expressed in terms of\n"
		"others when the same physical dimension is involved.  For example, one\n"
		"hertz is identical to 1&nbsp;sec<sup>-1</sup>, one litre is equivalent\n"
		"to 1 cubic decametre, and so on.\n"
		"\n"
		"@param unit the Unit object to convert to SI\n"
		"\n"
		"@return a UnitDefinition object containing the SI unit.\n"
		"\n"
		"@see merge()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_hasRequiredAttributes", _wrap_Unit_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Unit_hasRequiredAttributes(Unit self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Unit object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Unit object are:\n"
		"@li 'kind'\n"
		"@li 'exponent' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"@li 'multiplier' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"@li 'scale' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_swigregister", Unit_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfUnits_clone", _wrap_ListOfUnits_clone, METH_VARARGS, (char *)"\n"
		"ListOfUnits_clone(ListOfUnits self) -> ListOfUnits\n"
		"\n"
		"Creates and returns a deep copy of this ListOfUnits.\n"
		"\n"
		"@return a (deep) copy of this ListOfUnits.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_getTypeCode", _wrap_ListOfUnits_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnits_getTypeCode(ListOfUnits self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_getItemTypeCode", _wrap_ListOfUnits_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnits_getItemTypeCode(ListOfUnits self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Unit objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_getElementName", _wrap_ListOfUnits_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfUnits_getElementName(ListOfUnits self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfUnits, the XML element name is @c 'listOfUnits'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfUnits'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_get", _wrap_ListOfUnits_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Unit\n"
		"ListOfUnits_get(ListOfUnits self, unsigned int n) -> Unit\n"
		"\n"
		"Get a Unit from the ListOfUnits.\n"
		"\n"
		"@param n the index number of the Unit to get.\n"
		"\n"
		"@return the nth Unit in this ListOfUnits.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_remove", _wrap_ListOfUnits_remove, METH_VARARGS, (char *)"\n"
		"ListOfUnits_remove(ListOfUnits self, unsigned int n) -> Unit\n"
		"\n"
		"Removes the nth item from this ListOfUnits items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfUnits", _wrap_new_ListOfUnits, METH_VARARGS, (char *)"new_ListOfUnits() -> ListOfUnits"},
	 { (char *)"delete_ListOfUnits", _wrap_delete_ListOfUnits, METH_VARARGS, (char *)"delete_ListOfUnits(ListOfUnits self)"},
	 { (char *)"ListOfUnits_swigregister", ListOfUnits_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_UnitDefinition", _wrap_delete_UnitDefinition, METH_VARARGS, (char *)"delete_UnitDefinition(UnitDefinition self)"},
	 { (char *)"new_UnitDefinition", _wrap_new_UnitDefinition, METH_VARARGS, (char *)"\n"
		"UnitDefinition(unsigned int level, unsigned int version)\n"
		"UnitDefinition(SBMLNamespaces sbmlns)\n"
		"new_UnitDefinition(UnitDefinition orig) -> UnitDefinition\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this UnitDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Constraint object are:\n"
		"@li 'listOfUnits' (required in SBML Level&nbsp;2 only, optional in Level&nbsp;3)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"UnitDefinition_clone", _wrap_UnitDefinition_clone, METH_VARARGS, (char *)"\n"
		"UnitDefinition_clone(UnitDefinition self) -> UnitDefinition\n"
		"\n"
		"Creates and returns a deep copy of this UnitDefinition.\n"
		"\n"
		"@return a (deep) copy of this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getId", _wrap_UnitDefinition_getId, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getId(UnitDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this UnitDefinition.\n"
		"\n"
		"@return the id of this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getName", _wrap_UnitDefinition_getName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getName(UnitDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this UnitDefinition.\n"
		"\n"
		"@return the name of this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isSetId", _wrap_UnitDefinition_isSetId, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isSetId(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"UnitDefinition's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this UnitDefinition has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isSetName", _wrap_UnitDefinition_isSetName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isSetName(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"UnitDefinition's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this UnitDefinition has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_setId", _wrap_UnitDefinition_setId, METH_VARARGS, (char *)"\n"
		"UnitDefinition_setId(UnitDefinition self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this UnitDefinition.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this UnitDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_setName", _wrap_UnitDefinition_setName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_setName(UnitDefinition self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this UnitDefinition.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the UnitDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_unsetName", _wrap_UnitDefinition_unsetName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_unsetName(UnitDefinition self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this UnitDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfArea", _wrap_UnitDefinition_isVariantOfArea, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfArea(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'area'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c area, meaning square metres with only abritrary variations\n"
		"in scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfLength", _wrap_UnitDefinition_isVariantOfLength, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfLength(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'length'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c length, meaning metres with only abritrary variations in scale\n"
		"or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfSubstance", _wrap_UnitDefinition_isVariantOfSubstance, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfSubstance(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'substance'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c substance, meaning moles or items (and grams or kilograms from\n"
		"SBML Level&nbsp;2 Version&nbsp;2 onwards) with only abritrary variations\n"
		"in scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfTime", _wrap_UnitDefinition_isVariantOfTime, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfTime(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'time'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c time, meaning seconds with only abritrary variations in scale or\n"
		"multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfVolume", _wrap_UnitDefinition_isVariantOfVolume, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfVolume(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'volume'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c volume, meaning litre or cubic metre with only abritrary\n"
		"variations in scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfDimensionless", _wrap_UnitDefinition_isVariantOfDimensionless, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfDimensionless(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the unit @c 'dimensionless'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of @c\n"
		"dimensionless, meaning dimensionless with only abritrary variations in\n"
		"scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfMass", _wrap_UnitDefinition_isVariantOfMass, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfMass(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'mass'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of mass units,\n"
		"meaning gram or kilogram with only abritrary variations in scale or\n"
		"multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfSubstancePerTime", _wrap_UnitDefinition_isVariantOfSubstancePerTime, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfSubstancePerTime(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit @c 'substance' divided by the predefined\n"
		"unit @c 'time'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c substance per predefined unit @c time, meaning it contains two\n"
		"units one of which is a variant of substance and the other is a\n"
		"variant of time which an exponent of -1; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_addUnit", _wrap_UnitDefinition_addUnit, METH_VARARGS, (char *)"\n"
		"UnitDefinition_addUnit(UnitDefinition self, Unit u) -> int\n"
		"\n"
		"Adds a copy of the given Unit to this UnitDefinition.\n"
		"\n"
		"@param u the Unit instance to add to this UnitDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this UnitDefinition.  Changes made to the original\n"
		"object instance (such as resetting attribute values) will <em>not\n"
		"affect the instance in the UnitDefinition</em>.  In addition, the\n"
		"caller should make sure to free the original object if it is no longer\n"
		"being used, or else a memory leak will result.  Please see\n"
		"UnitDefinition::createUnit() for a method that does not lead to these\n"
		"issues.\n"
		"\n"
		"@see createUnit()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_createUnit", _wrap_UnitDefinition_createUnit, METH_VARARGS, (char *)"\n"
		"UnitDefinition_createUnit(UnitDefinition self) -> Unit\n"
		"\n"
		"Creates a new and empty Unit, adds it to this UnitDefinition's list of\n"
		"units, and returns it.\n"
		"\n"
		"@return a newly constructed (and empty) Unit instance.\n"
		"\n"
		"@note It is worth emphasizing that the attribute 'kind' value of a\n"
		"Unit is a required attribute for a valid Unit definition.  The\n"
		"createUnit() method does not assign a valid kind to the constructed\n"
		"unit (instead, it sets the 'kind' to @c UNIT_KIND_INVALID).  Callers\n"
		"are cautioned to set the newly-constructed Unit's kind using\n"
		"Unit::setKind() soon after calling this method.\n"
		"\n"
		"@see addUnit(const Unit* u)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getListOfUnits", _wrap_UnitDefinition_getListOfUnits, METH_VARARGS, (char *)"\n"
		"getListOfUnits() -> ListOfUnits\n"
		"UnitDefinition_getListOfUnits(UnitDefinition self) -> ListOfUnits\n"
		"\n"
		"Returns the list of Units for this UnitDefinition instance.\n"
		"@return the ListOfUnits value for this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getUnit", _wrap_UnitDefinition_getUnit, METH_VARARGS, (char *)"\n"
		"getUnit(unsigned int n) -> Unit\n"
		"UnitDefinition_getUnit(UnitDefinition self, unsigned int n) -> Unit\n"
		"\n"
		"Returns a specific Unit instance belonging to this UnitDefinition.\n"
		"\n"
		"@param n an integer, the index of the Unit to be returned.\n"
		"\n"
		"@return the nth Unit of this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getNumUnits", _wrap_UnitDefinition_getNumUnits, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getNumUnits(UnitDefinition self) -> unsigned int\n"
		"\n"
		"Returns the number of Unit objects contained within this\n"
		"UnitDefinition.\n"
		"\n"
		"@return an integer representing the number of Units in this\n"
		"UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_removeUnit", _wrap_UnitDefinition_removeUnit, METH_VARARGS, (char *)"\n"
		"UnitDefinition_removeUnit(UnitDefinition self, unsigned int n) -> Unit\n"
		"\n"
		"Removes the nth Unit object from this UnitDefinition object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Unit object to remove\n"
		"\n"
		"@return the Unit object removed, or @c NULL if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getTypeCode", _wrap_UnitDefinition_getTypeCode, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getTypeCode(UnitDefinition self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getElementName", _wrap_UnitDefinition_getElementName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getElementName(UnitDefinition self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for UnitDefinition,\n"
		"is always @c 'unitDefinition'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'unitDefinition'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_simplify", _wrap_UnitDefinition_simplify, METH_VARARGS, (char *)"\n"
		"UnitDefinition_simplify(UnitDefinition ud)\n"
		"\n"
		"Simplifies the UnitDefinition such that any given kind of Unit object\n"
		"occurs only once in the ListOfUnits.\n"
		"\n"
		"For example, the following definition,\n"
		"@code\n"
		"<unitDefinition>\n"
		" <listOfUnits>\n"
		"   <unit kind='metre' exponent='1'/>\n"
		"   <unit kind='metre' exponent='2'/>\n"
		" </listOfUnits>\n"
		"<unitDefinition>\n"
		"@endcode\n"
		"will be simplified to \n"
		"@code\n"
		"<unitDefinition>\n"
		"  <listOfUnits>\n"
		"    <unit kind='metre' exponent='3'/>\n"
		"  </listOfUnits>\n"
		"<unitDefinition>\n"
		"@endcode\n"
		"\n"
		"@param ud the UnitDefinition object to be simplified.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_reorder", _wrap_UnitDefinition_reorder, METH_VARARGS, (char *)"\n"
		"UnitDefinition_reorder(UnitDefinition ud)\n"
		"\n"
		"Alphabetically orders the Unit objects within the ListOfUnits of a\n"
		"UnitDefinition.\n"
		"\n"
		"@param ud the UnitDefinition object whose units are to be reordered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_convertToSI", _wrap_UnitDefinition_convertToSI, METH_VARARGS, (char *)"\n"
		"UnitDefinition_convertToSI(UnitDefinition arg0) -> UnitDefinition\n"
		"\n"
		"Convert a given UnitDefinition into a new UnitDefinition object\n"
		"that uses SI units.\n"
		"\n"
		"@param ud the UnitDefinition object to convert to SI\n"
		"\n"
		"@return a new UnitDefinition object representing the results of the\n"
		"conversion.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_areIdentical", _wrap_UnitDefinition_areIdentical, METH_VARARGS, (char *)"\n"
		"UnitDefinition_areIdentical(UnitDefinition ud1, UnitDefinition ud2) -> bool\n"
		"\n"
		"Predicate returning @c true if two\n"
		"UnitDefinition objects are identical.\n"
		"\n"
		"For the purposes of performing this comparison, two UnitDefinition\n"
		"objects are considered identical when they contain identical lists of\n"
		"Unit objects.  Pairs of Unit objects in the lists are in turn\n"
		"considered identical if they satisfy the predicate\n"
		"Unit::areIdentical().  The predicate compares every attribute of the\n"
		"Unit objects.\n"
		"\n"
		"@param ud1 the first UnitDefinition object to compare\n"
		"@param ud2 the second UnitDefinition object to compare\n"
		"\n"
		"@return @c true if all the Unit objects in ud1 are identical to the\n"
		"Unit objects of ud2, @c false otherwise.\n"
		"\n"
		"@see areEquivalent(const UnitDefinition * ud1, const %UnitDefinition * ud2)\n"
		"@see Unit::areIdentical(Unit * unit1, %Unit * unit2)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_areEquivalent", _wrap_UnitDefinition_areEquivalent, METH_VARARGS, (char *)"\n"
		"UnitDefinition_areEquivalent(UnitDefinition ud1, UnitDefinition ud2) -> bool\n"
		"\n"
		"Predicate returning @c true if two\n"
		"UnitDefinition objects are equivalent.\n"
		"\n"
		"For the purposes of performing this comparison, two UnitDefinition\n"
		"objects are considered equivalent when they contain @em equivalent\n"
		"list of Unit objects.  Unit objects are in turn considered equivalent\n"
		"if they satisfy the predicate Unit::areEquivalent().  The predicate\n"
		"tests a subset of the objects's attributes.\n"
		"\n"
		"@param ud1 the first UnitDefinition object to compare\n"
		"\n"
		"@param ud2 the second UnitDefinition object to compare\n"
		"\n"
		"@return @c true if all the Unit objects in ud1 are equivalent\n"
		"to the Unit objects in ud2, @c false otherwise.\n"
		"\n"
		"@see areIdentical(const UnitDefinition * ud1, const %UnitDefinition * ud2)\n"
		"@see Unit::areEquivalent(Unit * unit1, %Unit * unit2)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_combine", _wrap_UnitDefinition_combine, METH_VARARGS, (char *)"\n"
		"UnitDefinition_combine(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition\n"
		"\n"
		"Combines two UnitDefinition objects into a single UnitDefinition.\n"
		"\n"
		"This takes UnitDefinition objects @p ud1 and @p ud2, and creates a\n"
		"UnitDefinition object that expresses the product of the units of @p\n"
		"ud1 and @p ud2.\n"
		"\n"
		"@param ud1 the first UnitDefinition object \n"
		"@param ud2 the second UnitDefinition object\n"
		"\n"
		"@return a UnitDefinition which represents the product of the \n"
		"units of the two argument UnitDefinitions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_printUnits", _wrap_UnitDefinition_printUnits, METH_VARARGS, (char *)"\n"
		"printUnits(UnitDefinition ud, bool compact = False) -> string\n"
		"UnitDefinition_printUnits(UnitDefinition ud) -> string\n"
		"\n"
		"Expresses the given definition in a plain-text form.\n"
		"\n"
		"For example, printUnits() applied to\n"
		"@code\n"
		"<unitDefinition>\n"
		" <listOfUnits>\n"
		"   <unit kind='metre' exponent='1'/>\n"
		"   <unit kind='second' exponent='-2'/>\n"
		" </listOfUnits>\n"
		"<unitDefinition>\n"
		"@endcode\n"
		"will return the string <code>'metre (exponent = 1, multiplier = 1,\n"
		"scale = 0) second (exponent = -2, multiplier = 1, scale = 0)'</code>\n"
		"or, if the optional parameter @p compact is given the value @c true,\n"
		"the string <code>'(1 metre)^1 (1 second)^-2'</code>.  This method may\n"
		"be useful for printing unit information to human users, or in\n"
		"debugging software, or other situations.\n"
		"\n"
		"@param ud the UnitDefinition object\n"
		"@param compact boolean indicating whether the compact form\n"
		"should be used (defaults to false)\n"
		"\n"
		"@return a string expressing the unit definition defined by the given\n"
		"UnitDefinition object @p ud.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_hasRequiredAttributes", _wrap_UnitDefinition_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"UnitDefinition_hasRequiredAttributes(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this UnitDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a UnitDefinition object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_hasRequiredElements", _wrap_UnitDefinition_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"UnitDefinition_hasRequiredElements(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this UnitDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Constraint object are:\n"
		"@li 'listOfUnits' (required in SBML Level&nbsp;2 only, optional in Level&nbsp;3)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_swigregister", UnitDefinition_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfUnitDefinitions_clone", _wrap_ListOfUnitDefinitions_clone, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_clone(ListOfUnitDefinitions self) -> ListOfUnitDefinitions\n"
		"\n"
		"Creates and returns a deep copy of this ListOfUnitDefinitions instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfUnitDefinitions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_getTypeCode", _wrap_ListOfUnitDefinitions_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_getTypeCode(ListOfUnitDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_getItemTypeCode", _wrap_ListOfUnitDefinitions_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_getItemTypeCode(ListOfUnitDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., UnitDefinition objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_getElementName", _wrap_ListOfUnitDefinitions_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_getElementName(ListOfUnitDefinitions self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfUnitDefinitions, the XML element name is @c\n"
		"'listOfUnitDefinitions'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfUnitDefinitions'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_get", _wrap_ListOfUnitDefinitions_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> UnitDefinition\n"
		"get(unsigned int n) -> UnitDefinition\n"
		"get(string sid) -> UnitDefinition\n"
		"ListOfUnitDefinitions_get(ListOfUnitDefinitions self, string sid) -> UnitDefinition\n"
		"\n"
		"Get a UnitDefinition from the ListOfUnitDefinitions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the UnitDefinition to get.\n"
		"\n"
		"@return UnitDefinition in this ListOfUnitDefinitions\n"
		"with the given id or @c NULL if no such\n"
		"UnitDefinition exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_remove", _wrap_ListOfUnitDefinitions_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> UnitDefinition\n"
		"ListOfUnitDefinitions_remove(ListOfUnitDefinitions self, string sid) -> UnitDefinition\n"
		"\n"
		"Removes item in this ListOfUnitDefinitions items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfUnitDefinitions", _wrap_new_ListOfUnitDefinitions, METH_VARARGS, (char *)"new_ListOfUnitDefinitions() -> ListOfUnitDefinitions"},
	 { (char *)"delete_ListOfUnitDefinitions", _wrap_delete_ListOfUnitDefinitions, METH_VARARGS, (char *)"delete_ListOfUnitDefinitions(ListOfUnitDefinitions self)"},
	 { (char *)"ListOfUnitDefinitions_swigregister", ListOfUnitDefinitions_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_CompartmentType", _wrap_delete_CompartmentType, METH_VARARGS, (char *)"delete_CompartmentType(CompartmentType self)"},
	 { (char *)"new_CompartmentType", _wrap_new_CompartmentType, METH_VARARGS, (char *)"\n"
		"CompartmentType(unsigned int level, unsigned int version)\n"
		"CompartmentType(SBMLNamespaces sbmlns)\n"
		"new_CompartmentType(CompartmentType orig) -> CompartmentType\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this CompartmentType object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a CompartmentType object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"CompartmentType_clone", _wrap_CompartmentType_clone, METH_VARARGS, (char *)"\n"
		"CompartmentType_clone(CompartmentType self) -> CompartmentType\n"
		"\n"
		"Creates and returns a deep copy of this CompartmentType.\n"
		"\n"
		"@return a (deep) copy of this CompartmentType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getId", _wrap_CompartmentType_getId, METH_VARARGS, (char *)"\n"
		"CompartmentType_getId(CompartmentType self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this CompartmentType.\n"
		"\n"
		"@return the id of this CompartmentType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getName", _wrap_CompartmentType_getName, METH_VARARGS, (char *)"\n"
		"CompartmentType_getName(CompartmentType self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this CompartmentType.\n"
		"\n"
		"@return the name of this CompartmentType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_isSetId", _wrap_CompartmentType_isSetId, METH_VARARGS, (char *)"\n"
		"CompartmentType_isSetId(CompartmentType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"CompartmentType's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this CompartmentType has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_isSetName", _wrap_CompartmentType_isSetName, METH_VARARGS, (char *)"\n"
		"CompartmentType_isSetName(CompartmentType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"CompartmentType's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this CompartmentTypeType has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_setId", _wrap_CompartmentType_setId, METH_VARARGS, (char *)"\n"
		"CompartmentType_setId(CompartmentType self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this CompartmentType.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this CompartmentType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_setName", _wrap_CompartmentType_setName, METH_VARARGS, (char *)"\n"
		"CompartmentType_setName(CompartmentType self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this CompartmentType.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the CompartmentType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_unsetName", _wrap_CompartmentType_unsetName, METH_VARARGS, (char *)"\n"
		"CompartmentType_unsetName(CompartmentType self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this CompartmentType.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getTypeCode", _wrap_CompartmentType_getTypeCode, METH_VARARGS, (char *)"\n"
		"CompartmentType_getTypeCode(CompartmentType self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getElementName", _wrap_CompartmentType_getElementName, METH_VARARGS, (char *)"\n"
		"CompartmentType_getElementName(CompartmentType self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"CompartmentType, is always @c 'compartmentType'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'compartmentType'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_hasRequiredAttributes", _wrap_CompartmentType_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"CompartmentType_hasRequiredAttributes(CompartmentType self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this CompartmentType object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a CompartmentType object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_swigregister", CompartmentType_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfCompartmentTypes_clone", _wrap_ListOfCompartmentTypes_clone, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_clone(ListOfCompartmentTypes self) -> ListOfCompartmentTypes\n"
		"\n"
		"Creates and returns a deep copy of this ListOfCompartmentTypes instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfCompartmentTypes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_getTypeCode", _wrap_ListOfCompartmentTypes_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_getTypeCode(ListOfCompartmentTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_getItemTypeCode", _wrap_ListOfCompartmentTypes_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_getItemTypeCode(ListOfCompartmentTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., CompartmentType objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_getElementName", _wrap_ListOfCompartmentTypes_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_getElementName(ListOfCompartmentTypes self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfCompartmentTypes, the XML element name is @c\n"
		"'listOfCompartmentTypes'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfCompartmentTypes'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_get", _wrap_ListOfCompartmentTypes_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> CompartmentType\n"
		"get(unsigned int n) -> CompartmentType\n"
		"get(string sid) -> CompartmentType\n"
		"ListOfCompartmentTypes_get(ListOfCompartmentTypes self, string sid) -> CompartmentType\n"
		"\n"
		"Get a CompartmentType from the ListOfCompartmentTypes\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the CompartmentType to get.\n"
		"\n"
		"@return CompartmentType in this ListOfCompartmentTypes\n"
		"with the given id or @c NULL if no such\n"
		"CompartmentType exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_remove", _wrap_ListOfCompartmentTypes_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> CompartmentType\n"
		"ListOfCompartmentTypes_remove(ListOfCompartmentTypes self, string sid) -> CompartmentType\n"
		"\n"
		"Removes item in this ListOfCompartmentTypes items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfCompartmentTypes", _wrap_new_ListOfCompartmentTypes, METH_VARARGS, (char *)"new_ListOfCompartmentTypes() -> ListOfCompartmentTypes"},
	 { (char *)"delete_ListOfCompartmentTypes", _wrap_delete_ListOfCompartmentTypes, METH_VARARGS, (char *)"delete_ListOfCompartmentTypes(ListOfCompartmentTypes self)"},
	 { (char *)"ListOfCompartmentTypes_swigregister", ListOfCompartmentTypes_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SpeciesType", _wrap_delete_SpeciesType, METH_VARARGS, (char *)"delete_SpeciesType(SpeciesType self)"},
	 { (char *)"new_SpeciesType", _wrap_new_SpeciesType, METH_VARARGS, (char *)"\n"
		"SpeciesType(unsigned int level, unsigned int version)\n"
		"SpeciesType(SBMLNamespaces sbmlns)\n"
		"new_SpeciesType(SpeciesType orig) -> SpeciesType\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this SpeciesType object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a SpeciesType object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SpeciesType_clone", _wrap_SpeciesType_clone, METH_VARARGS, (char *)"\n"
		"SpeciesType_clone(SpeciesType self) -> SpeciesType\n"
		"\n"
		"Creates and returns a deep copy of this SpeciesType.\n"
		"\n"
		"@return a (deep) copy of this SpeciesType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getId", _wrap_SpeciesType_getId, METH_VARARGS, (char *)"\n"
		"SpeciesType_getId(SpeciesType self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this SpeciesType.\n"
		"\n"
		"@return the id of this SpeciesType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getName", _wrap_SpeciesType_getName, METH_VARARGS, (char *)"\n"
		"SpeciesType_getName(SpeciesType self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this SpeciesType.\n"
		"\n"
		"@return the name of this SpeciesType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_isSetId", _wrap_SpeciesType_isSetId, METH_VARARGS, (char *)"\n"
		"SpeciesType_isSetId(SpeciesType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesType's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this SpeciesType has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_isSetName", _wrap_SpeciesType_isSetName, METH_VARARGS, (char *)"\n"
		"SpeciesType_isSetName(SpeciesType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesType's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this SpeciesType has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_setId", _wrap_SpeciesType_setId, METH_VARARGS, (char *)"\n"
		"SpeciesType_setId(SpeciesType self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this SpeciesType.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this SpeciesType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_setName", _wrap_SpeciesType_setName, METH_VARARGS, (char *)"\n"
		"SpeciesType_setName(SpeciesType self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this SpeciesType.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the SpeciesType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_unsetName", _wrap_SpeciesType_unsetName, METH_VARARGS, (char *)"\n"
		"SpeciesType_unsetName(SpeciesType self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this SpeciesType.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getTypeCode", _wrap_SpeciesType_getTypeCode, METH_VARARGS, (char *)"\n"
		"SpeciesType_getTypeCode(SpeciesType self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getElementName", _wrap_SpeciesType_getElementName, METH_VARARGS, (char *)"\n"
		"SpeciesType_getElementName(SpeciesType self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"SpeciesType, is always @c 'compartmentType'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'compartmentType'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_hasRequiredAttributes", _wrap_SpeciesType_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"SpeciesType_hasRequiredAttributes(SpeciesType self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this SpeciesType object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a SpeciesType object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_swigregister", SpeciesType_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfSpeciesTypes_clone", _wrap_ListOfSpeciesTypes_clone, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_clone(ListOfSpeciesTypes self) -> ListOfSpeciesTypes\n"
		"\n"
		"Creates and returns a deep copy of this ListOfSpeciesTypes instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfSpeciesTypes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_getTypeCode", _wrap_ListOfSpeciesTypes_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_getTypeCode(ListOfSpeciesTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_getItemTypeCode", _wrap_ListOfSpeciesTypes_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_getItemTypeCode(ListOfSpeciesTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., SpeciesType objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_getElementName", _wrap_ListOfSpeciesTypes_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_getElementName(ListOfSpeciesTypes self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfSpeciesTypes, the XML element name is @c\n"
		"'listOfSpeciesTypes'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfSpeciesTypes'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_get", _wrap_ListOfSpeciesTypes_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> SpeciesType\n"
		"get(unsigned int n) -> SpeciesType\n"
		"get(string sid) -> SpeciesType\n"
		"ListOfSpeciesTypes_get(ListOfSpeciesTypes self, string sid) -> SpeciesType\n"
		"\n"
		"Get a SpeciesType from the ListOfSpeciesTypes\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the SpeciesType to get.\n"
		"\n"
		"@return SpeciesType in this ListOfSpeciesTypes\n"
		"with the given id or @c NULL if no such\n"
		"SpeciesType exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_remove", _wrap_ListOfSpeciesTypes_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> SpeciesType\n"
		"ListOfSpeciesTypes_remove(ListOfSpeciesTypes self, string sid) -> SpeciesType\n"
		"\n"
		"Removes item in this ListOfSpeciesTypes items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfSpeciesTypes", _wrap_new_ListOfSpeciesTypes, METH_VARARGS, (char *)"new_ListOfSpeciesTypes() -> ListOfSpeciesTypes"},
	 { (char *)"delete_ListOfSpeciesTypes", _wrap_delete_ListOfSpeciesTypes, METH_VARARGS, (char *)"delete_ListOfSpeciesTypes(ListOfSpeciesTypes self)"},
	 { (char *)"ListOfSpeciesTypes_swigregister", ListOfSpeciesTypes_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Compartment", _wrap_delete_Compartment, METH_VARARGS, (char *)"delete_Compartment(Compartment self)"},
	 { (char *)"new_Compartment", _wrap_new_Compartment, METH_VARARGS, (char *)"\n"
		"Compartment(unsigned int level, unsigned int version)\n"
		"Compartment(SBMLNamespaces sbmlns)\n"
		"new_Compartment(Compartment orig) -> Compartment\n"
		"\n"
		"This is a constructor that takes no arguments and \n"
		"only exists because the validator code needs it.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Compartment_clone", _wrap_Compartment_clone, METH_VARARGS, (char *)"\n"
		"Compartment_clone(Compartment self) -> Compartment\n"
		"\n"
		"Creates and returns a deep copy of this Compartment object.\n"
		"\n"
		"@return a (deep) copy of this Compartment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_initDefaults", _wrap_Compartment_initDefaults, METH_VARARGS, (char *)"\n"
		"Compartment_initDefaults(Compartment self)\n"
		"\n"
		"Initializes the fields of this Compartment object to 'typical' default\n"
		"values.\n"
		"\n"
		"The SBML Compartment component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets attribute 'spatialDimensions' to @c 3\n"
		"<li> Sets attribute 'constant' to @c true\n"
		"<li> (Applies to Level&nbsp;1 models only) Sets attribute 'volume' to @c 1.0\n"
		"</ul>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getId", _wrap_Compartment_getId, METH_VARARGS, (char *)"\n"
		"Compartment_getId(Compartment self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Compartment object.\n"
		"\n"
		"@return the id of this Compartment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getName", _wrap_Compartment_getName, METH_VARARGS, (char *)"\n"
		"Compartment_getName(Compartment self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Compartment object.\n"
		"\n"
		"@return the name of this Compartment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getCompartmentType", _wrap_Compartment_getCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_getCompartmentType(Compartment self) -> string\n"
		"\n"
		"Get the value of the 'compartmentType' attribute of this Compartment\n"
		"object.\n"
		"\n"
		"@return the value of the 'compartmentType' attribute of this\n"
		"Compartment as a string.\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getSpatialDimensions", _wrap_Compartment_getSpatialDimensions, METH_VARARGS, (char *)"\n"
		"Compartment_getSpatialDimensions(Compartment self) -> unsigned int\n"
		"\n"
		"Get the number of spatial dimensions of this Compartment object.\n"
		"\n"
		"@note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'\n"
		"attribute is @c double, whereas in Level&nbsp;2, it is @c integer.\n"
		"LibSBML provides a separate method for obtaining the value as a double,\n"
		"for models where it is relevant.\n"
		"\n"
		"@return the value of the 'spatialDimensions' attribute of this\n"
		"Compartment as an unsigned integer\n"
		"\n"
		"@see getSpatialDimensionsAsDouble()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getSpatialDimensionsAsDouble", _wrap_Compartment_getSpatialDimensionsAsDouble, METH_VARARGS, (char *)"\n"
		"Compartment_getSpatialDimensionsAsDouble(Compartment self) -> double\n"
		"\n"
		"Get the number of spatial dimensions of this Compartment object\n"
		"as a double.\n"
		"\n"
		"@note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'\n"
		"attribute is @c double, whereas in Level&nbsp;2, it is @c integer.  To\n"
		"avoid backward compatibility issues, libSBML provides a separate\n"
		"method for obtaining the value as a double, for models where it is\n"
		"relevant.\n"
		"\n"
		"@return the value of the 'spatialDimensions' attribute of this\n"
		"Compartment as a double, or @c NaN if this model is not in SBML\n"
		"Level&nbsp;3 format.\n"
		"\n"
		"@see getSpatialDimensions()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getSize", _wrap_Compartment_getSize, METH_VARARGS, (char *)"\n"
		"Compartment_getSize(Compartment self) -> double\n"
		"\n"
		"Get the size of this Compartment.\n"
		"\n"
		"This method is identical to getVolume().  In SBML Level&nbsp;1,\n"
		"compartments are always three-dimensional constructs and only have\n"
		"volumes, whereas in SBML Level&nbsp;2, compartments may be other than\n"
		"three-dimensional and therefore the 'volume' attribute is named 'size'\n"
		"in Level&nbsp;2.  LibSBML provides both getSize() and getVolume() for\n"
		"easier compatibility between SBML Levels.\n"
		"\n"
		"@return the value of the 'size' attribute ('volume' in Level&nbsp;1) of\n"
		"this Compartment as a float-point number.\n"
		"\n"
		"@see isSetSize()\n"
		"@see getVolume()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getVolume", _wrap_Compartment_getVolume, METH_VARARGS, (char *)"\n"
		"Compartment_getVolume(Compartment self) -> double\n"
		"\n"
		"Get the volume of this Compartment.\n"
		"\n"
		"This method is identical to getSize().  In SBML Level&nbsp;1, compartments\n"
		"are always three-dimensional constructs and only have volumes, whereas\n"
		"in SBML Level&nbsp;2, compartments may be other than three-dimensional and\n"
		"therefore the 'volume' attribute is named 'size' in Level&nbsp;2.  LibSBML\n"
		"provides both getSize() and getVolume() for easier compatibility\n"
		"between SBML Levels.\n"
		"\n"
		"@return the value of the 'volume' attribute ('size' in Level&nbsp;2) of\n"
		"this Compartment, as a floating-point number.\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"\n"
		"@see isSetVolume()\n"
		"@see getSize()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getUnits", _wrap_Compartment_getUnits, METH_VARARGS, (char *)"\n"
		"Compartment_getUnits(Compartment self) -> string\n"
		"\n"
		"Get the units of this compartment's size.\n"
		"\n"
		"The value of an SBML compartment's 'units' attribute establishes the\n"
		"unit of measurement associated with the compartment's size.\n"
		"\n"
		"@return the value of the 'units' attribute of this Compartment, as a\n"
		"string.  An empty string indicates that no units have been assigned to\n"
		"the value of the size.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"\n"
		"@see isSetUnits()\n"
		"@see setUnits()\n"
		"@see getSize()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getOutside", _wrap_Compartment_getOutside, METH_VARARGS, (char *)"\n"
		"Compartment_getOutside(Compartment self) -> string\n"
		"\n"
		"Get the identifier, if any, of the compartment that is designated\n"
		"as being outside of this one.\n"
		"\n"
		"@return the value of the 'outside' attribute of this Compartment.\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getConstant", _wrap_Compartment_getConstant, METH_VARARGS, (char *)"\n"
		"Compartment_getConstant(Compartment self) -> bool\n"
		"\n"
		"Get the value of the 'constant' attribute of this Compartment.\n"
		"\n"
		"@return @c true if this Compartment's size is flagged as being\n"
		"constant, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetId", _wrap_Compartment_isSetId, METH_VARARGS, (char *)"\n"
		"Compartment_isSetId(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Compartment has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetName", _wrap_Compartment_isSetName, METH_VARARGS, (char *)"\n"
		"Compartment_isSetName(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Compartment has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetCompartmentType", _wrap_Compartment_isSetCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_isSetCompartmentType(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'compartmentType' attribute has been set.\n"
		"\n"
		"@return @c true if the 'compartmentType' attribute of this Compartment\n"
		"has been set, @c false otherwise.\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetSize", _wrap_Compartment_isSetSize, METH_VARARGS, (char *)"\n"
		"Compartment_isSetSize(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'size' attribute has been set.\n"
		"\n"
		"This method is similar but not identical to isSetVolume().  The latter\n"
		"should be used in the context of SBML Level&nbsp;1 models instead of\n"
		"isSetSize() because isSetVolume() performs extra processing to take\n"
		"into account the difference in default values between SBML Levels 1\n"
		"and 2.\n"
		"\n"
		"@return @c true if the 'size' attribute ('volume' in Level&nbsp;2) of\n"
		"this Compartment has been set, @c false otherwise.\n"
		"\n"
		"@see isSetVolume()\n"
		"@see setSize(double value)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetVolume", _wrap_Compartment_isSetVolume, METH_VARARGS, (char *)"\n"
		"Compartment_isSetVolume(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Compartment's\n"
		"'volume' attribute has been set.\n"
		"\n"
		"This method is similar but not identical to isSetSize().  The latter\n"
		"should not be used in the context of SBML Level&nbsp;1 models because this\n"
		"method (isSetVolume()) performs extra processing to take into account\n"
		"the difference in default values between SBML Levels 1 and 2.\n"
		"\n"
		"@return @c true if the 'volume' attribute ('size' in Level&nbsp;2 and\n"
		"above) of this Compartment has been set, @c false otherwise.\n"
		"\n"
		"@see isSetSize()\n"
		"@see setVolume(double value)\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.  In SBML Level&nbsp;1, a compartment's volume has a\n"
		"default value (@c 1.0) and therefore this method will always return @c\n"
		"true.  In Level 2, a compartment's size (the equivalent of SBML\n"
		"Level&nbsp;1's 'volume') is optional and has no default value, and\n"
		"therefore may or may not be set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetUnits", _wrap_Compartment_isSetUnits, METH_VARARGS, (char *)"\n"
		"Compartment_isSetUnits(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'units' attribute has been set.\n"
		"\n"
		"@return @c true if the 'units' attribute of this Compartment has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetOutside", _wrap_Compartment_isSetOutside, METH_VARARGS, (char *)"\n"
		"Compartment_isSetOutside(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'outside' attribute has been set.\n"
		"\n"
		"@return @c true if the 'outside' attribute of this Compartment has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetSpatialDimensions", _wrap_Compartment_isSetSpatialDimensions, METH_VARARGS, (char *)"\n"
		"Compartment_isSetSpatialDimensions(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'spatialDimensions' attribute has been set.\n"
		"\n"
		"@return @c true if the 'spatialDimensions' attribute of this\n"
		"Compartment has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetConstant", _wrap_Compartment_isSetConstant, METH_VARARGS, (char *)"\n"
		"Compartment_isSetConstant(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'constant' attribute has been set.\n"
		"\n"
		"@return @c true if the 'constant' attribute of this Compartment has\n"
		"been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setId", _wrap_Compartment_setId, METH_VARARGS, (char *)"\n"
		"Compartment_setId(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Compartment.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Compartment\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setName", _wrap_Compartment_setName, METH_VARARGS, (char *)"\n"
		"Compartment_setName(Compartment self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Compartment.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Compartment\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setCompartmentType", _wrap_Compartment_setCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_setCompartmentType(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the 'compartmentType' attribute of this Compartment.\n"
		"\n"
		"@param sid the identifier of a CompartmentType object defined\n"
		"elsewhere in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setSpatialDimensions", _wrap_Compartment_setSpatialDimensions, METH_VARARGS, (char *)"\n"
		"setSpatialDimensions(unsigned int value) -> int\n"
		"Compartment_setSpatialDimensions(Compartment self, double value) -> int\n"
		"\n"
		"Sets the 'spatialDimensions' attribute of this Compartment as a double.\n"
		"\n"
		"@param value a double indicating the number of dimensions\n"
		"of this compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setSize", _wrap_Compartment_setSize, METH_VARARGS, (char *)"\n"
		"Compartment_setSize(Compartment self, double value) -> int\n"
		"\n"
		"Sets the 'size' attribute (or 'volume' in SBML Level&nbsp;1) of this\n"
		"Compartment.\n"
		"\n"
		"This method is identical to setVolume() and is provided for\n"
		"compatibility between SBML Level&nbsp;1 and Level&nbsp;2.\n"
		"\n"
		"@param value a @c double representing the size of this compartment\n"
		"instance in whatever units are in effect for the compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setVolume", _wrap_Compartment_setVolume, METH_VARARGS, (char *)"\n"
		"Compartment_setVolume(Compartment self, double value) -> int\n"
		"\n"
		"Sets the 'volume' attribute (or 'size' in SBML Level&nbsp;2) of this\n"
		"Compartment.\n"
		"\n"
		"This method is identical to setVolume() and is provided for\n"
		"compatibility between SBML Level&nbsp;1 and Level&nbsp;2.\n"
		"\n"
		"@param value a @c double representing the volume of this compartment\n"
		"instance in whatever units are in effect for the compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setUnits", _wrap_Compartment_setUnits, METH_VARARGS, (char *)"\n"
		"Compartment_setUnits(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the 'units' attribute of this Compartment.\n"
		"\n"
		"@param sid the identifier of the defined units to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setOutside", _wrap_Compartment_setOutside, METH_VARARGS, (char *)"\n"
		"Compartment_setOutside(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the 'outside' attribute of this Compartment.\n"
		"\n"
		"@param sid the identifier of a compartment that encloses this one.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setConstant", _wrap_Compartment_setConstant, METH_VARARGS, (char *)"\n"
		"Compartment_setConstant(Compartment self, bool value) -> int\n"
		"\n"
		"Sets the value of the 'constant' attribute of this Compartment.\n"
		"\n"
		"@param value a boolean indicating whether the size/volume of this\n"
		"compartment should be considered constant (@c true) or variable (@c\n"
		"false)\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetName", _wrap_Compartment_unsetName, METH_VARARGS, (char *)"\n"
		"Compartment_unsetName(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetCompartmentType", _wrap_Compartment_unsetCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_unsetCompartmentType(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'compartmentType'\n"
		"attribute of this Compartment.\n"
		"\n"
		"@see setCompartmentType(const std::string& sid)\n"
		"@see isSetCompartmentType()\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetSize", _wrap_Compartment_unsetSize, METH_VARARGS, (char *)"\n"
		"Compartment_unsetSize(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'size' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetVolume", _wrap_Compartment_unsetVolume, METH_VARARGS, (char *)"\n"
		"Compartment_unsetVolume(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'volume' attribute of this\n"
		"Compartment.\n"
		"\n"
		"In SBML Level&nbsp;1, a Compartment volume has a default value (1.0) and\n"
		"therefore <em>should always be set</em>.  In Level&nbsp;2, 'size' is\n"
		"optional with no default value and as such may or may not be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetUnits", _wrap_Compartment_unsetUnits, METH_VARARGS, (char *)"\n"
		"Compartment_unsetUnits(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'units' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetOutside", _wrap_Compartment_unsetOutside, METH_VARARGS, (char *)"\n"
		"Compartment_unsetOutside(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'outside' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetSpatialDimensions", _wrap_Compartment_unsetSpatialDimensions, METH_VARARGS, (char *)"\n"
		"Compartment_unsetSpatialDimensions(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'spatialDimensions' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This function is only valid for SBML Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getDerivedUnitDefinition", _wrap_Compartment_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Compartment_getDerivedUnitDefinition(Compartment self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this Compartment's designated size.\n"
		"\n"
		"Compartments in SBML have an attribute ('units') for declaring the\n"
		"units of measurement intended for the value of the compartment's size.\n"
		"In the absence of a value given for this attribute, the units are\n"
		"inherited from values either defined on the enclosing Model (in SBML\n"
		"Level&nbsp;3) or in defaults (in SBML Level&nbsp;2).  This method\n"
		"returns a UnitDefinition object based on how this compartment's units\n"
		"are interpreted according to the relevant SBML guidelines, or it\n"
		"returns @c NULL if no units have been declared and no defaults are\n"
		"defined by the relevant SBML specification.\n"
		"\n"
		"Note that unit declarations for Compartment objects are specified in\n"
		"terms of the @em identifier of a unit (e.g., using setUnits()), but\n"
		"@em this method returns a UnitDefinition object, not a unit\n"
		"identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even\n"
		"when the value of the 'units' attribute is one of the special SBML\n"
		"Level&nbsp;2 unit identifiers @c 'substance', @c 'volume', @c 'area',\n"
		"@c 'length' or @c 'time'.  Callers may find this useful in conjunction\n"
		"with the helper methods provided by the UnitDefinition class for\n"
		"comparing different UnitDefinition objects.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"Compartment, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@note The libSBML system for unit analysis depends on the model as a\n"
		"whole.  In cases where the Compartment object has not yet been added\n"
		"to a model, or the model itself is incomplete, unit analysis is not\n"
		"possible, and consequently this method will return @c NULL.\n"
		"\n"
		"@see isSetUnits()\n"
		"@see getUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getTypeCode", _wrap_Compartment_getTypeCode, METH_VARARGS, (char *)"\n"
		"Compartment_getTypeCode(Compartment self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getElementName", _wrap_Compartment_getElementName, METH_VARARGS, (char *)"\n"
		"Compartment_getElementName(Compartment self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Compartment, is\n"
		"always @c 'compartment'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'compartment'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_hasRequiredAttributes", _wrap_Compartment_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Compartment_hasRequiredAttributes(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Compartment object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Compartment object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'constant' (in SBML Level&nbsp;3 only)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_swigregister", Compartment_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfCompartments_clone", _wrap_ListOfCompartments_clone, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_clone(ListOfCompartments self) -> ListOfCompartments\n"
		"\n"
		"Creates and returns a deep copy of this ListOfCompartments instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfCompartments.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_getTypeCode", _wrap_ListOfCompartments_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_getTypeCode(ListOfCompartments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_getItemTypeCode", _wrap_ListOfCompartments_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_getItemTypeCode(ListOfCompartments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Compartment objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_getElementName", _wrap_ListOfCompartments_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_getElementName(ListOfCompartments self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfCompartments, the XML element name is @c 'listOfCompartments'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfCompartments'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_get", _wrap_ListOfCompartments_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Compartment\n"
		"get(unsigned int n) -> Compartment\n"
		"get(string sid) -> Compartment\n"
		"ListOfCompartments_get(ListOfCompartments self, string sid) -> Compartment\n"
		"\n"
		"Get a Compartment from the ListOfCompartments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Compartment to get.\n"
		"\n"
		"@return Compartment in this ListOfCompartments\n"
		"with the given id or @c NULL if no such\n"
		"Compartment exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_remove", _wrap_ListOfCompartments_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Compartment\n"
		"ListOfCompartments_remove(ListOfCompartments self, string sid) -> Compartment\n"
		"\n"
		"Removes item in this ListOfCompartments items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"@c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfCompartments", _wrap_new_ListOfCompartments, METH_VARARGS, (char *)"new_ListOfCompartments() -> ListOfCompartments"},
	 { (char *)"delete_ListOfCompartments", _wrap_delete_ListOfCompartments, METH_VARARGS, (char *)"delete_ListOfCompartments(ListOfCompartments self)"},
	 { (char *)"ListOfCompartments_swigregister", ListOfCompartments_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Species", _wrap_delete_Species, METH_VARARGS, (char *)"delete_Species(Species self)"},
	 { (char *)"new_Species", _wrap_new_Species, METH_VARARGS, (char *)"\n"
		"Species(unsigned int level, unsigned int version)\n"
		"Species(SBMLNamespaces sbmlns)\n"
		"new_Species(Species orig) -> Species\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Species object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Species object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'compartment'\n"
		"@li 'initialAmount' (required in SBML Level&nbsp;1 only; optional otherwise)\n"
		"@li 'hasOnlySubstanceUnits' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)\n"
		"@li 'boundaryCondition' (required in SBML Level&nbsp;3; optional in Levels&nbsp;1 and&nbsp;2)\n"
		"@li 'constant' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Species_clone", _wrap_Species_clone, METH_VARARGS, (char *)"\n"
		"Species_clone(Species self) -> Species\n"
		"\n"
		"Creates and returns a deep copy of this Species object.\n"
		"\n"
		"@return a (deep) copy of this Species.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_initDefaults", _wrap_Species_initDefaults, METH_VARARGS, (char *)"\n"
		"Species_initDefaults(Species self)\n"
		"\n"
		"Initializes the fields of this Species object to 'typical' defaults\n"
		"values.\n"
		"\n"
		"The SBML Species component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets 'boundaryCondition' to @c false\n"
		"<li> Sets 'constant' to @c false\n"
		"<li> sets 'hasOnlySubstanceUnits' to @c false\n"
		"</ul>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getId", _wrap_Species_getId, METH_VARARGS, (char *)"\n"
		"Species_getId(Species self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Species object.\n"
		"\n"
		"@return the id of this Species.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getName", _wrap_Species_getName, METH_VARARGS, (char *)"\n"
		"Species_getName(Species self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Species object.\n"
		"\n"
		"@return the name of this Species.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getSpeciesType", _wrap_Species_getSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_getSpeciesType(Species self) -> string\n"
		"\n"
		"Get the type of this Species object object.\n"
		"\n"
		"@return the value of the 'speciesType' attribute of this\n"
		"Species as a string.\n"
		"\n"
		"@note The 'speciesType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getCompartment", _wrap_Species_getCompartment, METH_VARARGS, (char *)"\n"
		"Species_getCompartment(Species self) -> string\n"
		"\n"
		"Get the compartment in which this species is located.\n"
		"\n"
		"The compartment is designated by its identifier.\n"
		"\n"
		"@return the value of the 'compartment' attribute of this Species\n"
		"object, as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getInitialAmount", _wrap_Species_getInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_getInitialAmount(Species self) -> double\n"
		"\n"
		"Get the value of the 'initialAmount' attribute.\n"
		"\n"
		"@return the initialAmount of this Species, as a float-point number.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getInitialConcentration", _wrap_Species_getInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_getInitialConcentration(Species self) -> double\n"
		"\n"
		"Get the value of the 'initialConcentration' attribute.\n"
		"\n"
		"@return the initialConcentration of this Species,, as a float-point\n"
		"number.\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getSubstanceUnits", _wrap_Species_getSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_getSubstanceUnits(Species self) -> string\n"
		"\n"
		"Get the value of the 'substanceUnits' attribute.\n"
		"\n"
		"@return the value of the 'substanceUnits' attribute of this Species,\n"
		"as a string.  An empty string indicates that no units have been\n"
		"assigned.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"\n"
		"@see isSetSubstanceUnits()\n"
		"@see setSubstanceUnits(const std::string& sid)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getSpatialSizeUnits", _wrap_Species_getSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_getSpatialSizeUnits(Species self) -> string\n"
		"\n"
		"Get the value of the 'spatialSizeUnits' attribute.\n"
		"\n"
		"@return the value of the 'spatialSizeUnits' attribute of this Species\n"
		"object, as a string.\n"
		"\n"
		"@warning In versions of SBML Level&nbsp;2 before Version&nbsp;3, the\n"
		"class Species included an attribute called 'spatialSizeUnits', which\n"
		"allowed explicitly setting the units of size for initial\n"
		"concentration.  This attribute was removed in SBML Level&nbsp;2\n"
		"Version&nbsp;3.  LibSBML retains this attribute for compatibility with\n"
		"older definitions of Level&nbsp;2, but its use is strongly discouraged\n"
		"because it is incompatible with Level&nbsp;2 Version&nbsp;3 and\n"
		"Level&nbsp;2 Version&nbsp;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getUnits", _wrap_Species_getUnits, METH_VARARGS, (char *)"\n"
		"Species_getUnits(Species self) -> string\n"
		"\n"
		"Get the value of the 'units' attribute.\n"
		"\n"
		"@return the units of this Species (L1 only).\n"
		"\n"
		"@note The 'units' attribute is defined only in SBML Level&nbsp;1.  In\n"
		"SBML Level&nbsp;2 and Level&nbsp;3, it has been replaced by a\n"
		"combination of 'substanceUnits' and the units of the Compartment\n"
		"object in which a species is located.  In SBML Level&nbsp;2\n"
		"Versions&nbsp;1&ndash;2, an additional attribute 'spatialSizeUnits'\n"
		"helps determine the units of the species quantity, but this attribute\n"
		"was removed in later versions of SBML Level&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getHasOnlySubstanceUnits", _wrap_Species_getHasOnlySubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_getHasOnlySubstanceUnits(Species self) -> bool\n"
		"\n"
		"Get the value of the 'hasOnlySubstanceUnits' attribute.\n"
		"\n"
		"@return @c true if this Species' 'hasOnlySubstanceUnits' attribute\n"
		"value is nonzero, @c false otherwise.\n"
		"\n"
		"@note The 'hasOnlySubstanceUnits' attribute does not exist in SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getBoundaryCondition", _wrap_Species_getBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Species_getBoundaryCondition(Species self) -> bool\n"
		"\n"
		"Get the value of the 'boundaryCondition' attribute.\n"
		"\n"
		"@return @c true if this Species' 'boundaryCondition' attribute value\n"
		"is nonzero, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getCharge", _wrap_Species_getCharge, METH_VARARGS, (char *)"\n"
		"Species_getCharge(Species self) -> int\n"
		"\n"
		"Get the value of the 'charge' attribute.\n"
		"\n"
		"@return the charge of this Species.\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species is deprecated and in SBML Level&nbsp;3 it does\n"
		"not exist at all.  Its use strongly discouraged.  Its presence is\n"
		"considered a misfeature in earlier definitions of SBML because its\n"
		"implications for the mathematics of a model were never defined, and in\n"
		"any case, no known modeling system ever used it.  Instead, models take\n"
		"account of charge values directly in their definitions of species by\n"
		"(for example) having separate species identities for the charged and\n"
		"uncharged versions of the same species.  This allows the condition to\n"
		"affect model mathematics directly.  LibSBML retains this method for\n"
		"easier compatibility with SBML Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getConstant", _wrap_Species_getConstant, METH_VARARGS, (char *)"\n"
		"Species_getConstant(Species self) -> bool\n"
		"\n"
		"Get the value of the 'constant' attribute.\n"
		"\n"
		"@return @c true if this Species's 'constant' attribute value is\n"
		"nonzero, @c false otherwise.\n"
		"\n"
		"@note The attribute 'constant' is only available in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getConversionFactor", _wrap_Species_getConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_getConversionFactor(Species self) -> string\n"
		"\n"
		"Get the value of the 'conversionFactor' attribute.\n"
		"\n"
		"@return the conversionFactor of this Species, as a string.\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetId", _wrap_Species_isSetId, METH_VARARGS, (char *)"\n"
		"Species_isSetId(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Species has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetName", _wrap_Species_isSetName, METH_VARARGS, (char *)"\n"
		"Species_isSetName(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Species has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetSpeciesType", _wrap_Species_isSetSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_isSetSpeciesType(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Species's\n"
		"'speciesType' attribute has been set.\n"
		"\n"
		"@return @c true if the 'speciesType' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note The 'speciesType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetCompartment", _wrap_Species_isSetCompartment, METH_VARARGS, (char *)"\n"
		"Species_isSetCompartment(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'compartment' attribute has been set.\n"
		"\n"
		"@return @c true if the 'compartment' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetInitialAmount", _wrap_Species_isSetInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_isSetInitialAmount(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'initialAmount' attribute has been set.\n"
		"\n"
		"@return @c true if the 'initialAmount' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note In SBML Level&nbsp;1, Species' 'initialAmount' is required and\n"
		"therefore <em>should always be set</em>.  (However, in Level&nbsp;1, the\n"
		"attribute has no default value either, so this method will not return\n"
		"@c true until a value has been assigned.)  In SBML Level&nbsp;2,\n"
		"'initialAmount' is optional and as such may or may not be set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetInitialConcentration", _wrap_Species_isSetInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_isSetInitialConcentration(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'initialConcentration' attribute has been set.\n"
		"\n"
		"@return @c true if the 'initialConcentration' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetSubstanceUnits", _wrap_Species_isSetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetSubstanceUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'substanceUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'substanceUnits' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetSpatialSizeUnits", _wrap_Species_isSetSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetSpatialSizeUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'spatialSizeUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'spatialSizeUnits' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@warning In versions of SBML Level~2 before Version&nbsp;3, the class\n"
		"Species included an attribute called 'spatialSizeUnits', which allowed\n"
		"explicitly setting the units of size for initial concentration.  This\n"
		"attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML\n"
		"retains this attribute for compatibility with older definitions of\n"
		"Level&nbsp;2, but its use is strongly discouraged because it is\n"
		"incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetUnits", _wrap_Species_isSetUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this Species's 'units' attribute has been set.\n"
		"\n"
		"@return @c true if the 'units' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetCharge", _wrap_Species_isSetCharge, METH_VARARGS, (char *)"\n"
		"Species_isSetCharge(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'charge' attribute has been set.\n"
		"\n"
		"@return @c true if the 'charge' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species in SBML is deprecated and in SBML Level&nbsp;3 it\n"
		"does not exist at all.  Its use strongly discouraged.  Its presence is\n"
		"considered a misfeature in earlier definitions of SBML because its\n"
		"implications for the mathematics of a model were never defined, and in\n"
		"any case, no known modeling system ever used it.  Instead, models take\n"
		"account of charge values directly in their definitions of species by\n"
		"(for example) having separate species identities for the charged and\n"
		"uncharged versions of the same species.  This allows the condition to\n"
		"affect model mathematics directly.  LibSBML retains this method for\n"
		"easier compatibility with SBML Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetConversionFactor", _wrap_Species_isSetConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_isSetConversionFactor(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'conversionFactor' attribute has been set.\n"
		"\n"
		"@return @c true if the 'conversionFactor' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetBoundaryCondition", _wrap_Species_isSetBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Species_isSetBoundaryCondition(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'boundaryCondition' attribute has been set.\n"
		"\n"
		"@return @c true if the 'boundaryCondition' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetHasOnlySubstanceUnits", _wrap_Species_isSetHasOnlySubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetHasOnlySubstanceUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'hasOnlySubstanceUnits' attribute has been set.\n"
		"\n"
		"@return @c true if the 'hasOnlySubstanceUnits' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note The 'hasOnlySubstanceUnits' attribute does not exist in SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetConstant", _wrap_Species_isSetConstant, METH_VARARGS, (char *)"\n"
		"Species_isSetConstant(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species's 'constant' attribute has been set.\n"
		"\n"
		"@return @c true if the 'constant' attribute of this Species has\n"
		"been set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'constant' is only available in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setId", _wrap_Species_setId, METH_VARARGS, (char *)"\n"
		"Species_setId(Species self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Species.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Species\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setName", _wrap_Species_setName, METH_VARARGS, (char *)"\n"
		"Species_setName(Species self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Species.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Species\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setSpeciesType", _wrap_Species_setSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_setSpeciesType(Species self, string sid) -> int\n"
		"\n"
		"Sets the 'speciesType' attribute of this Species.\n"
		"\n"
		"@param sid the identifier of a SpeciesType object defined elsewhere\n"
		"in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The 'speciesType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setCompartment", _wrap_Species_setCompartment, METH_VARARGS, (char *)"\n"
		"Species_setCompartment(Species self, string sid) -> int\n"
		"\n"
		"Sets the 'compartment' attribute of this Species.\n"
		"\n"
		"@param sid the identifier of a Compartment object defined elsewhere\n"
		"in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setInitialAmount", _wrap_Species_setInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_setInitialAmount(Species self, double value) -> int\n"
		"\n"
		"Sets the 'initialAmount' attribute of this Species and marks the field\n"
		"as set.\n"
		"\n"
		"This method also unsets the 'initialConcentration' attribute.\n"
		"\n"
		"@param value the value to which the 'initialAmount' attribute should\n"
		"be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setInitialConcentration", _wrap_Species_setInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_setInitialConcentration(Species self, double value) -> int\n"
		"\n"
		"Sets the 'initialConcentration' attribute of this Species and marks\n"
		"the field as set.\n"
		"\n"
		"This method also unsets the 'initialAmount' attribute.\n"
		"\n"
		"@param value the value to which the 'initialConcentration' attribute\n"
		"should be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setSubstanceUnits", _wrap_Species_setSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_setSubstanceUnits(Species self, string sid) -> int\n"
		"\n"
		"Sets the 'substanceUnits' attribute of this Species.\n"
		"\n"
		"@param sid the identifier of the unit to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setSpatialSizeUnits", _wrap_Species_setSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_setSpatialSizeUnits(Species self, string sid) -> int\n"
		"\n"
		"(SBML Level&nbsp;2 Versions&nbsp;1&ndash;2) Sets the 'spatialSizeUnits' attribute of this Species.\n"
		"\n"
		"@param sid the identifier of the unit to use.\n"
		"\n"
		"@warning In versions of SBML Level~2 before Version&nbsp;3, the class\n"
		"Species included an attribute called 'spatialSizeUnits', which allowed\n"
		"explicitly setting the units of size for initial concentration.  This\n"
		"attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML\n"
		"retains this attribute for compatibility with older definitions of\n"
		"Level&nbsp;2, but its use is strongly discouraged because it is\n"
		"incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setUnits", _wrap_Species_setUnits, METH_VARARGS, (char *)"\n"
		"Species_setUnits(Species self, string sname) -> int\n"
		"\n"
		"(SBML Level&nbsp;1 only) Sets the units of this Species.\n"
		"\n"
		"@param sname the identifier of the unit to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		" \n"
		"\n"
		""},
	 { (char *)"Species_setHasOnlySubstanceUnits", _wrap_Species_setHasOnlySubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_setHasOnlySubstanceUnits(Species self, bool value) -> int\n"
		"\n"
		"Sets the 'hasOnlySubstanceUnits' attribute of this Species.\n"
		"\n"
		"@param value boolean value for the 'hasOnlySubstanceUnits' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The 'hasOnlySubstanceUnits' attribute does not exist in SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setBoundaryCondition", _wrap_Species_setBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Species_setBoundaryCondition(Species self, bool value) -> int\n"
		"\n"
		"Sets the 'boundaryCondition' attribute of this Species.\n"
		"\n"
		"@param value boolean value for the 'boundaryCondition' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setCharge", _wrap_Species_setCharge, METH_VARARGS, (char *)"\n"
		"Species_setCharge(Species self, int value) -> int\n"
		"\n"
		"Sets the 'charge' attribute of this Species.\n"
		"\n"
		"@param value an integer to which to set the 'charge' to.\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species in SBML is deprecated and its use strongly\n"
		"discouraged, and it does not exist in SBML Level&nbsp;3 at all.  Its\n"
		"presence is considered a misfeature in earlier definitions of SBML\n"
		"because its implications for the mathematics of a model were never\n"
		"defined, and in any case, no known modeling system ever used it.\n"
		"Instead, models take account of charge values directly in their\n"
		"definitions of species by (for example) having separate species\n"
		"identities for the charged and uncharged versions of the same species.\n"
		"This allows the condition to affect model mathematics directly.\n"
		"LibSBML retains this method for easier compatibility with SBML\n"
		"Level&nbsp;1.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setConstant", _wrap_Species_setConstant, METH_VARARGS, (char *)"\n"
		"Species_setConstant(Species self, bool value) -> int\n"
		"\n"
		"Sets the 'constant' attribute of this Species.\n"
		"\n"
		"@param value a boolean value for the 'constant' attribute\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'constant' is only available in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setConversionFactor", _wrap_Species_setConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_setConversionFactor(Species self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'conversionFactor' attribute of this Species.\n"
		"\n"
		"The string in @p sid is copied.\n"
		"\n"
		"@param sid the new conversionFactor for the Species\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetName", _wrap_Species_unsetName, METH_VARARGS, (char *)"\n"
		"Species_unsetName(Species self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetSpeciesType", _wrap_Species_unsetSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_unsetSpeciesType(Species self) -> int\n"
		"\n"
		"Unsets the 'speciesType' attribute value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attribute 'speciesType' is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetInitialAmount", _wrap_Species_unsetInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_unsetInitialAmount(Species self) -> int\n"
		"\n"
		"Unsets the 'initialAmount' attribute value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetInitialConcentration", _wrap_Species_unsetInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_unsetInitialConcentration(Species self) -> int\n"
		"\n"
		"Unsets the 'initialConcentration' attribute value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetSubstanceUnits", _wrap_Species_unsetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_unsetSubstanceUnits(Species self) -> int\n"
		"\n"
		"Unsets the 'substanceUnits' attribute value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetSpatialSizeUnits", _wrap_Species_unsetSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_unsetSpatialSizeUnits(Species self) -> int\n"
		"\n"
		"Unsets the 'spatialSizeUnits' attribute value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@warning In versions of SBML Level~2 before Version&nbsp;3, the class\n"
		"Species included an attribute called 'spatialSizeUnits', which allowed\n"
		"explicitly setting the units of size for initial concentration.  This\n"
		"attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML\n"
		"retains this attribute for compatibility with older definitions of\n"
		"Level&nbsp;2, but its use is strongly discouraged because it is\n"
		"incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetUnits", _wrap_Species_unsetUnits, METH_VARARGS, (char *)"\n"
		"Species_unsetUnits(Species self) -> int\n"
		"\n"
		"Unsets the 'units' attribute value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetCharge", _wrap_Species_unsetCharge, METH_VARARGS, (char *)"\n"
		"Species_unsetCharge(Species self) -> int\n"
		"\n"
		"Unsets the 'charge' attribute\n"
		"value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species in SBML is deprecated and its use strongly\n"
		"discouraged, and it does not exist in SBML Level&nbsp;3 at all.  Its\n"
		"presence is considered a misfeature in earlier definitions of SBML\n"
		"because its implications for the mathematics of a model were never\n"
		"defined, and in any case, no known modeling system ever used it.\n"
		"Instead, models take account of charge values directly in their\n"
		"definitions of species by (for example) having separate species\n"
		"identities for the charged and uncharged versions of the same species.\n"
		"This allows the condition to affect model mathematics directly.\n"
		"LibSBML retains this method for easier compatibility with SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetConversionFactor", _wrap_Species_unsetConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_unsetConversionFactor(Species self) -> int\n"
		"\n"
		"Unsets the 'conversionFactor' attribute value of this Species.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getDerivedUnitDefinition", _wrap_Species_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Species_getDerivedUnitDefinition(Species self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this Species' amount or concentration.\n"
		"\n"
		"Species in SBML have an attribute ('substanceUnits') for declaring the\n"
		"units of measurement intended for the species' amount or concentration\n"
		"(depending on which one applies).  In the absence of a value given for\n"
		"'substanceUnits', the units are taken from the enclosing Model's\n"
		"definition of @c 'substance' or @c 'substance'/<em>(size of the\n"
		"compartment)</em> in which the species is located, or finally, if\n"
		"these are not redefined by the Model, the relevant SBML default units\n"
		"for those quantities.  Following that procedure, the method\n"
		"getDerivedUnitDefinition() returns a UnitDefinition based on the\n"
		"interpreted units of this species's amount or concentration.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c NULL.\n"
		"\n"
		"Note also that unit declarations for Species are in terms of the @em\n"
		"identifier of a unit, but this method returns a UnitDefinition object,\n"
		"not a unit identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.  Callers may find this particularly useful when used\n"
		"in conjunction with the helper methods on UnitDefinition for comparing\n"
		"different UnitDefinition objects.\n"
		"\n"
		"In SBML Level&nbsp;2 specifications prior to Version&nbsp;3, Species\n"
		"includes an additional attribute named 'spatialSizeUnits', which\n"
		"allows explicitly setting the units of size for initial concentration.\n"
		"The getDerivedUnitDefinition() takes this into account for models\n"
		"expressed in SBML Level&nbsp;2 Versions&nbsp;1 and&nbsp;2.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"Species, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@see getSubstanceUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getTypeCode", _wrap_Species_getTypeCode, METH_VARARGS, (char *)"\n"
		"Species_getTypeCode(Species self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getElementName", _wrap_Species_getElementName, METH_VARARGS, (char *)"\n"
		"Species_getElementName(Species self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Species, is\n"
		"always @c 'species'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'species'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_hasRequiredAttributes", _wrap_Species_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Species_hasRequiredAttributes(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Species object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Species object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'compartment'\n"
		"@li 'initialAmount' (required in SBML Level&nbsp;1 only; optional otherwise)\n"
		"@li 'hasOnlySubstanceUnits' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)\n"
		"@li 'boundaryCondition' (required in SBML Level&nbsp;3; optional in Levels&nbsp;1 and&nbsp;2)\n"
		"@li 'constant' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_swigregister", Species_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfSpecies_clone", _wrap_ListOfSpecies_clone, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_clone(ListOfSpecies self) -> ListOfSpecies\n"
		"\n"
		"Creates and returns a deep copy of this ListOfSpeciess instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfSpeciess.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_getTypeCode", _wrap_ListOfSpecies_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_getTypeCode(ListOfSpecies self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_getItemTypeCode", _wrap_ListOfSpecies_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_getItemTypeCode(ListOfSpecies self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Species objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_getElementName", _wrap_ListOfSpecies_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_getElementName(ListOfSpecies self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfSpeciess, the XML element name is @c 'listOfSpeciess'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfSpeciess'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_get", _wrap_ListOfSpecies_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Species\n"
		"get(unsigned int n) -> Species\n"
		"get(string sid) -> Species\n"
		"ListOfSpecies_get(ListOfSpecies self, string sid) -> Species\n"
		"\n"
		"Get a Species from the ListOfSpecies\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Species to get.\n"
		"\n"
		"@return Species in this ListOfSpecies\n"
		"with the given id or @c NULL if no such\n"
		"Species exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_remove", _wrap_ListOfSpecies_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Species\n"
		"ListOfSpecies_remove(ListOfSpecies self, string sid) -> Species\n"
		"\n"
		"Removes item in this ListOfSpeciess items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfSpecies", _wrap_new_ListOfSpecies, METH_VARARGS, (char *)"new_ListOfSpecies() -> ListOfSpecies"},
	 { (char *)"delete_ListOfSpecies", _wrap_delete_ListOfSpecies, METH_VARARGS, (char *)"delete_ListOfSpecies(ListOfSpecies self)"},
	 { (char *)"ListOfSpecies_swigregister", ListOfSpecies_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Parameter", _wrap_delete_Parameter, METH_VARARGS, (char *)"delete_Parameter(Parameter self)"},
	 { (char *)"new_Parameter", _wrap_new_Parameter, METH_VARARGS, (char *)"\n"
		"Parameter(unsigned int level, unsigned int version)\n"
		"Parameter(SBMLNamespaces sbmlns)\n"
		"new_Parameter(Parameter orig) -> Parameter\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Parameter object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Parameter object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'value' (required in Level&nbsp;1, optional otherwise)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Parameter_clone", _wrap_Parameter_clone, METH_VARARGS, (char *)"\n"
		"Parameter_clone(Parameter self) -> Parameter\n"
		"\n"
		"Creates and returns a deep copy of this Parameter.\n"
		"\n"
		"@return a (deep) copy of this Parameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_initDefaults", _wrap_Parameter_initDefaults, METH_VARARGS, (char *)"\n"
		"Parameter_initDefaults(Parameter self)\n"
		"\n"
		"Initializes the fields of this Parameter object to 'typical' defaults\n"
		"values.\n"
		"\n"
		"The SBML Parameter component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.  Many\n"
		"SBML object classes defined by libSBML have an initDefaults() method\n"
		"to set the values to certain common defaults, based mostly on what\n"
		"they are in SBML Level&nbsp;2.  In the case of Parameter, this method\n"
		"only sets the value of the 'constant' attribute to @c true.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getId", _wrap_Parameter_getId, METH_VARARGS, (char *)"\n"
		"Parameter_getId(Parameter self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Parameter.\n"
		"\n"
		"@return the id of this Parameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getName", _wrap_Parameter_getName, METH_VARARGS, (char *)"\n"
		"Parameter_getName(Parameter self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Parameter.\n"
		"\n"
		"@return the name of this Parameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getValue", _wrap_Parameter_getValue, METH_VARARGS, (char *)"\n"
		"Parameter_getValue(Parameter self) -> double\n"
		"\n"
		"Gets the numerical value of this Parameter.\n"
		"\n"
		"@return the value of the 'value' attribute of this Parameter, as a\n"
		"number of type @c double.\n"
		"\n"
		"@note <b>It is crucial</b> that callers not blindly call\n"
		"Parameter::getValue() without first using Parameter::isSetValue() to\n"
		"determine whether a value has ever been set.  Otherwise, the value\n"
		"return by Parameter::getValue() may not actually represent a value\n"
		"assigned to the parameter.  The reason is simply that the data type\n"
		"@c double in a program always has @em some value.  A separate test is\n"
		"needed to determine whether the value is a true model value, or\n"
		"uninitialized data in a computer's memory location.\n"
		"\n"
		"@see isSetValue()\n"
		"@see setValue(double value)\n"
		"@see getUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getUnits", _wrap_Parameter_getUnits, METH_VARARGS, (char *)"\n"
		"Parameter_getUnits(Parameter self) -> string\n"
		"\n"
		"Gets the units defined for this Parameter.\n"
		"\n"
		"The value of an SBML parameter's 'units' attribute establishes the\n"
		"unit of measurement associated with the parameter's value.\n"
		"\n"
		"@return the value of the 'units' attribute of this Parameter, as a\n"
		"string.  An empty string indicates that no units have been assigned.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"\n"
		"@see isSetUnits()\n"
		"@see setUnits()\n"
		"@see getValue()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getConstant", _wrap_Parameter_getConstant, METH_VARARGS, (char *)"\n"
		"Parameter_getConstant(Parameter self) -> bool\n"
		"\n"
		"Gets the value of the 'constant' attribute of this Parameter instance.\n"
		"\n"
		"@return @c true if this Parameter has been declared as being constant,\n"
		"@c false otherwise.\n"
		"\n"
		"@see isSetConstant()\n"
		"@see setConstant(bool flag)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetId", _wrap_Parameter_isSetId, METH_VARARGS, (char *)"\n"
		"Parameter_isSetId(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Parameter's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Parameter has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetName", _wrap_Parameter_isSetName, METH_VARARGS, (char *)"\n"
		"Parameter_isSetName(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Parameter's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Parameter has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetValue", _wrap_Parameter_isSetValue, METH_VARARGS, (char *)"\n"
		"Parameter_isSetValue(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if the\n"
		"'value' attribute of this Parameter has been set.\n"
		"\n"
		"In SBML definitions after SBML Level&nbsp;1 Version&nbsp;1,\n"
		"parameter values are optional and have no defaults.  If a model read\n"
		"from a file does not contain a setting for the 'value' attribute of a\n"
		"parameter, its value is considered unset; it does not default to any\n"
		"particular value.  Similarly, when a Parameter object is created in\n"
		"libSBML, it has no value until given a value.  The\n"
		"Parameter::isSetValue() method allows calling applications to\n"
		"determine whether a given parameter's value has ever been set.\n"
		"\n"
		"In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have\n"
		"values and therefore, the value of a Parameter <b>should always be\n"
		"set</b>.  In Level&nbsp;1 Version&nbsp;2 and beyond, the value is\n"
		"optional and as such, the 'value' attribute may or may not be set.\n"
		"\n"
		"@return @c true if the value of this Parameter has been set,\n"
		"@c false otherwise.\n"
		"\n"
		"@see getValue()\n"
		"@see setValue(double value)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetUnits", _wrap_Parameter_isSetUnits, METH_VARARGS, (char *)"\n"
		"Parameter_isSetUnits(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if the\n"
		"'units' attribute of this Parameter has been set.\n"
		"\n"
		"@return @c true if the 'units' attribute of this Parameter has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetConstant", _wrap_Parameter_isSetConstant, METH_VARARGS, (char *)"\n"
		"Parameter_isSetConstant(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if the\n"
		"'constant' attribute of this Parameter has been set.\n"
		"\n"
		"@return @c true if the 'constant' attribute of this Parameter has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setId", _wrap_Parameter_setId, METH_VARARGS, (char *)"\n"
		"Parameter_setId(Parameter self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Parameter.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Parameter\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setName", _wrap_Parameter_setName, METH_VARARGS, (char *)"\n"
		"Parameter_setName(Parameter self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Parameter.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Parameter\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setValue", _wrap_Parameter_setValue, METH_VARARGS, (char *)"\n"
		"Parameter_setValue(Parameter self, double value) -> int\n"
		"\n"
		"Sets the 'value' attribute of this Parameter to the given @c double\n"
		"value and marks the attribute as set.\n"
		"\n"
		"@param value a @c double, the value to assign\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setUnits", _wrap_Parameter_setUnits, METH_VARARGS, (char *)"\n"
		"Parameter_setUnits(Parameter self, string units) -> int\n"
		"\n"
		"Sets the 'units' attribute of this Parameter to a copy of the given\n"
		"units identifier @p units.\n"
		"\n"
		"@param units a string, the identifier of the units to assign to this\n"
		"Parameter instance\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setConstant", _wrap_Parameter_setConstant, METH_VARARGS, (char *)"\n"
		"Parameter_setConstant(Parameter self, bool flag) -> int\n"
		"\n"
		"Sets the 'constant' attribute of this Parameter to the given boolean\n"
		"@p flag.\n"
		"\n"
		"@param flag a boolean, the value for the 'constant' attribute of this\n"
		"Parameter instance\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_unsetName", _wrap_Parameter_unsetName, METH_VARARGS, (char *)"\n"
		"Parameter_unsetName(Parameter self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Parameter.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_unsetValue", _wrap_Parameter_unsetValue, METH_VARARGS, (char *)"\n"
		"Parameter_unsetValue(Parameter self) -> int\n"
		"\n"
		"Unsets the 'value' attribute of this Parameter instance.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have\n"
		"values and therefore, the value of a Parameter <b>should always be\n"
		"set</b>.  In SBML Level&nbsp;1 Version&nbsp;2 and beyond, the value\n"
		"is optional and as such, the 'value' attribute may or may not be set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_unsetUnits", _wrap_Parameter_unsetUnits, METH_VARARGS, (char *)"\n"
		"Parameter_unsetUnits(Parameter self) -> int\n"
		"\n"
		"Unsets the 'units' attribute of this Parameter instance.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getDerivedUnitDefinition", _wrap_Parameter_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Parameter_getDerivedUnitDefinition(Parameter self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this Parameter's value.\n"
		"\n"
		"Parameters in SBML have an attribute ('units') for declaring the units\n"
		"of measurement intended for the parameter's value.  <b>No defaults are\n"
		"defined</b> by SBML in the absence of a definition for 'units'.  This\n"
		"method returns a UnitDefinition object based on the units declared for\n"
		"this Parameter using its 'units' attribute, or it returns @c NULL if\n"
		"no units have been declared.\n"
		"\n"
		"Note that unit declarations for Parameter objects are specified in\n"
		"terms of the @em identifier of a unit (e.g., using setUnits()), but\n"
		"@em this method returns a UnitDefinition object, not a unit\n"
		"identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even\n"
		"when the value of the 'units' attribute is one of the predefined SBML\n"
		"units @c 'substance', @c 'volume', @c 'area', @c 'length' or @c\n"
		"'time'.  Callers may find this useful in conjunction with the helper\n"
		"methods provided by the UnitDefinition class for comparing different\n"
		"UnitDefinition objects.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"Parameter, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@note The libSBML system for unit analysis depends on the model as a\n"
		"whole.  In cases where the Parameter object has not yet been added to\n"
		"a model, or the model itself is incomplete, unit analysis is not\n"
		"possible, and consequently this method will return @c NULL.\n"
		"\n"
		"@see isSetUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getTypeCode", _wrap_Parameter_getTypeCode, METH_VARARGS, (char *)"\n"
		"Parameter_getTypeCode(Parameter self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or\n"
		"@link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getElementName", _wrap_Parameter_getElementName, METH_VARARGS, (char *)"\n"
		"Parameter_getElementName(Parameter self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Parameter, is\n"
		"always @c 'parameter'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'parameter'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_hasRequiredAttributes", _wrap_Parameter_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Parameter_hasRequiredAttributes(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Parameter object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Parameter object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'value' (required in Level&nbsp;1, optional otherwise)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_swigregister", Parameter_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfParameters_clone", _wrap_ListOfParameters_clone, METH_VARARGS, (char *)"\n"
		"ListOfParameters_clone(ListOfParameters self) -> ListOfParameters\n"
		"\n"
		"Creates and returns a deep copy of this ListOfParameters instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfParameters.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_getTypeCode", _wrap_ListOfParameters_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfParameters_getTypeCode(ListOfParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_getItemTypeCode", _wrap_ListOfParameters_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfParameters_getItemTypeCode(ListOfParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Parameter objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink\n"
		"(default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_getElementName", _wrap_ListOfParameters_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfParameters_getElementName(ListOfParameters self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfParameters, the XML element name is @c 'listOfParameters'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfParameters'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_get", _wrap_ListOfParameters_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Parameter\n"
		"get(unsigned int n) -> Parameter\n"
		"get(string sid) -> Parameter\n"
		"ListOfParameters_get(ListOfParameters self, string sid) -> Parameter\n"
		"\n"
		"Returns the first Parameter object matching the given identifier.\n"
		"\n"
		"@param sid a string representing the identifier of the Parameter to\n"
		"get.\n"
		"\n"
		"@return the Parameter object found.  The caller owns the returned\n"
		"object and is responsible for deleting it.  If none of the items have\n"
		"an identifier matching @p sid, then @c NULL is returned.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_remove", _wrap_ListOfParameters_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Parameter\n"
		"ListOfParameters_remove(ListOfParameters self, string sid) -> Parameter\n"
		"\n"
		"Removes the first Parameter object in this ListOfParameters\n"
		"matching the given identifier, and returns a pointer to it.\n"
		"\n"
		"@param sid the identifier of the item to remove.\n"
		"\n"
		"@return the item removed.  The caller owns the returned object and is\n"
		"responsible for deleting it.  If none of the items have an identifier\n"
		"matching @p sid, then @c NULL is returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfParameters", _wrap_new_ListOfParameters, METH_VARARGS, (char *)"new_ListOfParameters() -> ListOfParameters"},
	 { (char *)"delete_ListOfParameters", _wrap_delete_ListOfParameters, METH_VARARGS, (char *)"delete_ListOfParameters(ListOfParameters self)"},
	 { (char *)"ListOfParameters_swigregister", ListOfParameters_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_LocalParameter", _wrap_delete_LocalParameter, METH_VARARGS, (char *)"delete_LocalParameter(LocalParameter self)"},
	 { (char *)"new_LocalParameter", _wrap_new_LocalParameter, METH_VARARGS, (char *)"\n"
		"LocalParameter(unsigned int level, unsigned int version)\n"
		"LocalParameter(SBMLNamespaces sbmlns)\n"
		"LocalParameter(LocalParameter orig)\n"
		"new_LocalParameter(Parameter orig) -> LocalParameter\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this LocalParameter object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a LocalParameter object are:\n"
		"@li 'id'\n"
		"@li 'value'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"LocalParameter_clone", _wrap_LocalParameter_clone, METH_VARARGS, (char *)"\n"
		"LocalParameter_clone(LocalParameter self) -> LocalParameter\n"
		"\n"
		"Creates and returns a deep copy of this LocalParameter.\n"
		"\n"
		"@return a (deep) copy of this LocalParameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_getDerivedUnitDefinition", _wrap_LocalParameter_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"LocalParameter_getDerivedUnitDefinition(LocalParameter self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this LocalParameter's value.\n"
		"\n"
		"LocalParameters in SBML have an attribute ('units') for declaring the\n"
		"units of measurement intended for the parameter's value.  <b>No\n"
		"defaults are defined</b> by SBML in the absence of a definition for\n"
		"'units'.  This method returns a UnitDefinition object based on the\n"
		"units declared for this LocalParameter using its 'units' attribute, or\n"
		"it returns @c NULL if no units have been declared.\n"
		"\n"
		"Note that unit declarations for LocalParameter objects are specified\n"
		"in terms of the @em identifier of a unit (e.g., using setUnits()), but\n"
		"@em this method returns a UnitDefinition object, not a unit\n"
		"identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even\n"
		"when the value of the 'units' attribute is one of the predefined SBML\n"
		"units @c 'substance', @c 'volume', @c 'area', @c 'length' or @c\n"
		"'time'.  Callers may find this useful in conjunction with the helper\n"
		"methods provided by the UnitDefinition class for comparing different\n"
		"UnitDefinition objects.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"LocalParameter, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@note The libSBML system for unit analysis depends on the model as a\n"
		"whole.  In cases where the LocalParameter object has not yet been\n"
		"added to a model, or the model itself is incomplete, unit analysis is\n"
		"not possible, and consequently this method will return @c NULL.\n"
		"\n"
		"@see isSetUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_getTypeCode", _wrap_LocalParameter_getTypeCode, METH_VARARGS, (char *)"\n"
		"LocalParameter_getTypeCode(LocalParameter self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_getElementName", _wrap_LocalParameter_getElementName, METH_VARARGS, (char *)"\n"
		"LocalParameter_getElementName(LocalParameter self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for LocalParameter,\n"
		"is always @c 'localParameter'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'localParameter'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_hasRequiredAttributes", _wrap_LocalParameter_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"LocalParameter_hasRequiredAttributes(LocalParameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this LocalParameter object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a LocalParameter object are:\n"
		"@li 'id'\n"
		"@li 'value'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_swigregister", LocalParameter_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfLocalParameters_clone", _wrap_ListOfLocalParameters_clone, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_clone(ListOfLocalParameters self) -> ListOfLocalParameters\n"
		"\n"
		"Creates and returns a deep copy of this ListOfLocalParameters object.\n"
		"\n"
		"@return a (deep) copy of this ListOfLocalParameters.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_getTypeCode", _wrap_ListOfLocalParameters_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_getTypeCode(ListOfLocalParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_getItemTypeCode", _wrap_ListOfLocalParameters_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_getItemTypeCode(ListOfLocalParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., LocalParameter objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink\n"
		"(default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_getElementName", _wrap_ListOfLocalParameters_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_getElementName(ListOfLocalParameters self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfLocalParameters, the XML element name is @c 'listOfLocalParameters'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfLocalParameters'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_get", _wrap_ListOfLocalParameters_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> LocalParameter\n"
		"get(unsigned int n) -> LocalParameter\n"
		"get(string sid) -> LocalParameter\n"
		"ListOfLocalParameters_get(ListOfLocalParameters self, string sid) -> LocalParameter\n"
		"\n"
		"Returns the first LocalParameter object matching the given identifier.\n"
		"\n"
		"@param sid a string representing the identifier of the LocalParameter\n"
		"to get.\n"
		"\n"
		"@return the LocalParameter object found.  The caller owns the returned\n"
		"object and is responsible for deleting it.  If none of the items have\n"
		"an identifier matching @p sid, then @c NULL is returned.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_remove", _wrap_ListOfLocalParameters_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> LocalParameter\n"
		"ListOfLocalParameters_remove(ListOfLocalParameters self, string sid) -> LocalParameter\n"
		"\n"
		"Removes the first LocalParameter object in this ListOfLocalParameters\n"
		"matching the given identifier, and returns a pointer to it.\n"
		"\n"
		"@param sid the identifier of the item to remove.\n"
		"\n"
		"@return the item removed.  The caller owns the returned object and is\n"
		"responsible for deleting it.  If none of the items have an identifier\n"
		"matching @p sid, then @c NULL is returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfLocalParameters", _wrap_new_ListOfLocalParameters, METH_VARARGS, (char *)"new_ListOfLocalParameters() -> ListOfLocalParameters"},
	 { (char *)"delete_ListOfLocalParameters", _wrap_delete_ListOfLocalParameters, METH_VARARGS, (char *)"delete_ListOfLocalParameters(ListOfLocalParameters self)"},
	 { (char *)"ListOfLocalParameters_swigregister", ListOfLocalParameters_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_InitialAssignment", _wrap_delete_InitialAssignment, METH_VARARGS, (char *)"delete_InitialAssignment(InitialAssignment self)"},
	 { (char *)"new_InitialAssignment", _wrap_new_InitialAssignment, METH_VARARGS, (char *)"\n"
		"InitialAssignment(unsigned int level, unsigned int version)\n"
		"InitialAssignment(SBMLNamespaces sbmlns)\n"
		"new_InitialAssignment(InitialAssignment orig) -> InitialAssignment\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this InitialAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a InitialAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"InitialAssignment_clone", _wrap_InitialAssignment_clone, METH_VARARGS, (char *)"\n"
		"InitialAssignment_clone(InitialAssignment self) -> InitialAssignment\n"
		"\n"
		"Creates and returns a deep copy of this InitialAssignment.\n"
		"\n"
		"@return a (deep) copy of this InitialAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getSymbol", _wrap_InitialAssignment_getSymbol, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getSymbol(InitialAssignment self) -> string\n"
		"\n"
		"Get the value of the 'symbol' attribute of this InitialAssignment.\n"
		"\n"
		"@return the identifier string stored as the 'symbol' attribute value\n"
		"in this InitialAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getMath", _wrap_InitialAssignment_getMath, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getMath(InitialAssignment self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula of this InitialAssignment.\n"
		"\n"
		"@return an ASTNode, the value of the 'math' subelement of this\n"
		"InitialAssignment\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_isSetSymbol", _wrap_InitialAssignment_isSetSymbol, METH_VARARGS, (char *)"\n"
		"InitialAssignment_isSetSymbol(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"InitialAssignment's 'symbol' attribute has been set.\n"
		"\n"
		"@return @c true if the 'symbol' attribute of this InitialAssignment\n"
		"has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_isSetMath", _wrap_InitialAssignment_isSetMath, METH_VARARGS, (char *)"\n"
		"InitialAssignment_isSetMath(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"InitialAssignment's 'math' subelement contains a value.\n"
		"\n"
		"@return @c true if the 'math' for this InitialAssignment has been set,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_setSymbol", _wrap_InitialAssignment_setSymbol, METH_VARARGS, (char *)"\n"
		"InitialAssignment_setSymbol(InitialAssignment self, string sid) -> int\n"
		"\n"
		"Sets the 'symbol' attribute value of this InitialAssignment.\n"
		"\n"
		"@param sid the identifier of a Species, Compartment or Parameter\n"
		"object defined elsewhere in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_setMath", _wrap_InitialAssignment_setMath, METH_VARARGS, (char *)"\n"
		"InitialAssignment_setMath(InitialAssignment self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this InitialAssignment.\n"
		"\n"
		"The AST passed in @p math is copied.\n"
		"\n"
		"@param math an AST containing the mathematical expression to\n"
		"be used as the formula for this InitialAssignment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getDerivedUnitDefinition", _wrap_InitialAssignment_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"InitialAssignment_getDerivedUnitDefinition(InitialAssignment self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this\n"
		"InitialAssignment.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"InitialAssignment and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"getDerivedUnitDefinition() method returns the calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c NULL.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"InitialAssignment contains pure numbers or parameters with undeclared\n"
		"units.  In those cases, it is not possible to calculate the units of\n"
		"the overall expression without making assumptions.  LibSBML does not\n"
		"make assumptions about the units, and getDerivedUnitDefinition() only\n"
		"returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  <strong>It is important that callers also\n"
		"invoke the method</strong> containsUndeclaredUnits() <strong>to\n"
		"determine whether this situation holds</strong>.  Callers may wish to\n"
		"take suitable actions in those scenarios.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this InitialAssignment, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_containsUndeclaredUnits", _wrap_InitialAssignment_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"InitialAssignment_containsUndeclaredUnits(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the math expression of this InitialAssignment contains\n"
		"parameters/numbers with undeclared units.\n"
		"\n"
		"@return @c true if the math expression of this InitialAssignment\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by getDerivedUnitDefinition() may not accurately represent\n"
		"the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getTypeCode", _wrap_InitialAssignment_getTypeCode, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getTypeCode(InitialAssignment self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getElementName", _wrap_InitialAssignment_getElementName, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getElementName(InitialAssignment self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"InitialAssignment, is always @c 'initialAssignment'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'initialAssignment'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_hasRequiredAttributes", _wrap_InitialAssignment_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"InitialAssignment_hasRequiredAttributes(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this InitialAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for an InitialAssignment object are:\n"
		"@li 'symbol'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_hasRequiredElements", _wrap_InitialAssignment_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"InitialAssignment_hasRequiredElements(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this InitialAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a InitialAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getId", _wrap_InitialAssignment_getId, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getId(InitialAssignment self) -> string\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this InitialAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a InitialAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"InitialAssignment_swigregister", InitialAssignment_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfInitialAssignments_clone", _wrap_ListOfInitialAssignments_clone, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_clone(ListOfInitialAssignments self) -> ListOfInitialAssignments\n"
		"\n"
		"Creates and returns a deep copy of this ListOfInitialAssignments instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfInitialAssignments.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_getTypeCode", _wrap_ListOfInitialAssignments_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_getTypeCode(ListOfInitialAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_getItemTypeCode", _wrap_ListOfInitialAssignments_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_getItemTypeCode(ListOfInitialAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., InitialAssignment objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_getElementName", _wrap_ListOfInitialAssignments_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_getElementName(ListOfInitialAssignments self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfInitialAssignments, the XML element name is @c\n"
		"'listOfInitialAssignments'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfInitialAssignments'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_get", _wrap_ListOfInitialAssignments_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> InitialAssignment\n"
		"get(unsigned int n) -> InitialAssignment\n"
		"get(string sid) -> InitialAssignment\n"
		"ListOfInitialAssignments_get(ListOfInitialAssignments self, string sid) -> InitialAssignment\n"
		"\n"
		"Get a InitialAssignment from the ListOfInitialAssignments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the InitialAssignment to get.\n"
		"\n"
		"@return InitialAssignment in this ListOfInitialAssignments\n"
		"with the given id or @c NULL if no such\n"
		"InitialAssignment exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_remove", _wrap_ListOfInitialAssignments_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> InitialAssignment\n"
		"ListOfInitialAssignments_remove(ListOfInitialAssignments self, string sid) -> InitialAssignment\n"
		"\n"
		"Removes item in this ListOfInitialAssignments items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfInitialAssignments", _wrap_new_ListOfInitialAssignments, METH_VARARGS, (char *)"new_ListOfInitialAssignments() -> ListOfInitialAssignments"},
	 { (char *)"delete_ListOfInitialAssignments", _wrap_delete_ListOfInitialAssignments, METH_VARARGS, (char *)"delete_ListOfInitialAssignments(ListOfInitialAssignments self)"},
	 { (char *)"ListOfInitialAssignments_swigregister", ListOfInitialAssignments_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Rule", _wrap_delete_Rule, METH_VARARGS, (char *)"delete_Rule(Rule self)"},
	 { (char *)"new_Rule", _wrap_new_Rule, METH_VARARGS, (char *)"\n"
		"new_Rule(Rule orig) -> Rule\n"
		"\n"
		"Only subclasses may create Rules.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Rule_clone", _wrap_Rule_clone, METH_VARARGS, (char *)"\n"
		"Rule_clone(Rule self) -> Rule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getFormula", _wrap_Rule_getFormula, METH_VARARGS, (char *)"\n"
		"Rule_getFormula(Rule self) -> string\n"
		"\n"
		"Returns the mathematical expression of this Rule in text-string form.\n"
		"\n"
		"The text string is produced by SBML_formulaToString(); please consult\n"
		"the documentation for that function to find out more about the format\n"
		"of the text-string formula.\n"
		"\n"
		"@return the formula text string for this Rule.\n"
		"\n"
		"@see getMath()\n"
		"\n"
		"@note The attribute 'formula' is specific to SBML Level&nbsp;1; in\n"
		"higher Levels of SBML, it has been replaced with a subelement named\n"
		"'math'.  However, libSBML provides a unified interface to the\n"
		"underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getMath", _wrap_Rule_getMath, METH_VARARGS, (char *)"\n"
		"Rule_getMath(Rule self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula of this Rule as an ASTNode tree.\n"
		"\n"
		"@return an ASTNode, the value of the 'math' subelement of this Rule.\n"
		"\n"
		"@see getFormula()\n"
		"\n"
		"@note The subelement 'math' is present in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the\n"
		"attribute named 'formula'.  LibSBML provides a unified interface to\n"
		"the underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getVariable", _wrap_Rule_getVariable, METH_VARARGS, (char *)"\n"
		"Rule_getVariable(Rule self) -> string\n"
		"\n"
		"Get the value of the 'variable' attribute of this Rule object.\n"
		"\n"
		"In SBML Level&nbsp;1, the different rule types each have a different\n"
		"name for the attribute holding the reference to the object\n"
		"constituting the left-hand side of the rule.  (E.g., for\n"
		"SpeciesConcentrationRule the attribute is 'species', for\n"
		"CompartmentVolumeRule it is 'compartment', etc.)  In SBML\n"
		"Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a\n"
		"left-hand side object reference are AssignmentRule and RateRule, and\n"
		"both of them use the same name for attribute: 'variable'.  In order to\n"
		"make it easier for application developers to work with all Levels of\n"
		"SBML, libSBML uses a uniform name for all of such attributes, and it\n"
		"is 'variable', regardless of whether Level&nbsp;1 rules or\n"
		"Level&nbsp;2&ndash;3 rules are being used.\n"
		"\n"
		"@return the identifier string stored as the 'variable' attribute value\n"
		"in this Rule, or @c NULL if this object is an AlgebraicRule object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getUnits", _wrap_Rule_getUnits, METH_VARARGS, (char *)"\n"
		"Rule_getUnits(Rule self) -> string\n"
		"\n"
		"Returns the units for the\n"
		"mathematical formula of this Rule.\n"
		"\n"
		"@return the identifier of the units for the expression of this Rule.\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetFormula", _wrap_Rule_isSetFormula, METH_VARARGS, (char *)"\n"
		"Rule_isSetFormula(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule's mathematical expression has been set.\n"
		"\n"
		"This method is equivalent to isSetMath().  This version is present for\n"
		"easier compatibility with SBML Level&nbsp;1, in which mathematical\n"
		"formulas were written in text-string form.\n"
		"\n"
		"@return @c true if the mathematical formula for this Rule has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@see isSetMath()\n"
		"\n"
		"@note The attribute 'formula' is specific to SBML Level&nbsp;1; in\n"
		"higher Levels of SBML, it has been replaced with a subelement named\n"
		"'math'.  However, libSBML provides a unified interface to the\n"
		"underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetMath", _wrap_Rule_isSetMath, METH_VARARGS, (char *)"\n"
		"Rule_isSetMath(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule's mathematical expression has been set.\n"
		"\n"
		"This method is equivalent to isSetFormula().\n"
		"\n"
		"@return @c true if the formula (or equivalently the math) for this\n"
		"Rule has been set, @c false otherwise.\n"
		"\n"
		"@note The subelement 'math' is present in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the\n"
		"attribute named 'formula'.  LibSBML provides a unified interface to\n"
		"the underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetVariable", _wrap_Rule_isSetVariable, METH_VARARGS, (char *)"\n"
		"Rule_isSetVariable(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule's 'variable' attribute has been set.\n"
		"\n"
		"In SBML Level&nbsp;1, the different rule types each have a different\n"
		"name for the attribute holding the reference to the object\n"
		"constituting the left-hand side of the rule.  (E.g., for\n"
		"SpeciesConcentrationRule the attribute is 'species', for\n"
		"CompartmentVolumeRule it is 'compartment', etc.)  In SBML\n"
		"Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a\n"
		"left-hand side object reference are AssignmentRule and RateRule, and\n"
		"both of them use the same name for attribute: 'variable'.  In order to\n"
		"make it easier for application developers to work with all Levels of\n"
		"SBML, libSBML uses a uniform name for all such attributes, and it is\n"
		"'variable', regardless of whether Level&nbsp;1 rules or\n"
		"Level&nbsp;2&ndash;3 rules are being used.\n"
		"\n"
		"@return @c true if the 'variable' attribute value of this Rule has\n"
		"been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetUnits", _wrap_Rule_isSetUnits, METH_VARARGS, (char *)"\n"
		"Rule_isSetUnits(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true\n"
		"if this Rule's 'units' attribute has been set.\n"
		"\n"
		"@return @c true if the units for this Rule has been set, @c false\n"
		"otherwise\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setFormula", _wrap_Rule_setFormula, METH_VARARGS, (char *)"\n"
		"Rule_setFormula(Rule self, string formula) -> int\n"
		"\n"
		"Sets the 'math' subelement of this Rule to an expression in\n"
		"text-string form.\n"
		"\n"
		"This is equivalent to setMath().  The provision of using text-string\n"
		"formulas is retained for easier SBML Level&nbsp;1 compatibility.  The\n"
		"formula is converted to an ASTNode internally.\n"
		"\n"
		"@param formula a mathematical formula in text-string form.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note The attribute 'formula' is specific to SBML Level&nbsp;1; in\n"
		"higher Levels of SBML, it has been replaced with a subelement named\n"
		"'math'.  However, libSBML provides a unified interface to the\n"
		"underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setMath", _wrap_Rule_setMath, METH_VARARGS, (char *)"\n"
		"Rule_setMath(Rule self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this Rule to a copy of the given\n"
		"ASTNode.\n"
		"\n"
		"@param math the ASTNode structure of the mathematical formula.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note The subelement 'math' is present in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the\n"
		"attribute named 'formula'.  LibSBML provides a unified interface to\n"
		"the underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setVariable", _wrap_Rule_setVariable, METH_VARARGS, (char *)"\n"
		"Rule_setVariable(Rule self, string sid) -> int\n"
		"\n"
		"Sets the 'variable' attribute value of this Rule object.\n"
		"\n"
		"In SBML Level&nbsp;1, the different rule types each have a different\n"
		"name for the attribute holding the reference to the object\n"
		"constituting the left-hand side of the rule.  (E.g., for\n"
		"SpeciesConcentrationRule the attribute is 'species', for\n"
		"CompartmentVolumeRule it is 'compartment', etc.)  In SBML\n"
		"Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a\n"
		"left-hand side object reference are AssignmentRule and RateRule, and\n"
		"both of them use the same name for attribute: 'variable'.  In order to\n"
		"make it easier for application developers to work with all Levels of\n"
		"SBML, libSBML uses a uniform name for all such attributes, and it is\n"
		"'variable', regardless of whether Level&nbsp;1 rules or\n"
		"Level&nbsp;2&ndash;3 rules are being used.\n"
		"\n"
		"@param sid the identifier of a Compartment, Species or Parameter\n"
		"elsewhere in the enclosing Model object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setUnits", _wrap_Rule_setUnits, METH_VARARGS, (char *)"\n"
		"Rule_setUnits(Rule self, string sname) -> int\n"
		"\n"
		"Sets the units for this Rule.\n"
		"\n"
		"@param sname the identifier of the units\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_unsetUnits", _wrap_Rule_unsetUnits, METH_VARARGS, (char *)"\n"
		"Rule_unsetUnits(Rule self) -> int\n"
		"\n"
		"Unsets the 'units' for this Rule.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getDerivedUnitDefinition", _wrap_Rule_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Rule_getDerivedUnitDefinition(Rule self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units of\n"
		"measurement assumed for the 'math' expression of this Rule.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"Rule and the model quantities referenced by <code>&lt;ci&gt;</code>\n"
		"elements used within that expression.  The getDerivedUnitDefinition()\n"
		"method returns the calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c NULL.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the Rule\n"
		"contains pure numbers or parameters with undeclared units.  In those\n"
		"cases, it is not possible to calculate the units of the overall\n"
		"expression without making assumptions.  LibSBML does not make\n"
		"assumptions about the units, and getDerivedUnitDefinition() only\n"
		"returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  <strong>It is important that callers also\n"
		"invoke the method</strong> containsUndeclaredUnits() <strong>to\n"
		"determine whether this situation holds</strong>.  Callers may wish to\n"
		"take suitable actions in those scenarios.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this Rule, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_containsUndeclaredUnits", _wrap_Rule_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"Rule_containsUndeclaredUnits(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the math expression of this Rule contains\n"
		"parameters/numbers with undeclared units.\n"
		"\n"
		"@return @c true if the math expression of this Rule\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by getDerivedUnitDefinition() may not accurately represent\n"
		"the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getType", _wrap_Rule_getType, METH_VARARGS, (char *)"\n"
		"Rule_getType(Rule self) -> RuleType_t\n"
		"\n"
		"Get the type of rule this is.\n"
		"\n"
		"@return the rule type (a value drawn from the enumeration <a\n"
		"class='el' href='#RuleType_t'>RuleType_t</a>) of this Rule.  The value\n"
		"will be either @link RuleType_t#RULE_TYPE_RATE RULE_TYPE_RATE@endlink\n"
		"or @link RateRule_t#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink.\n"
		"\n"
		"@note The attribute 'type' on Rule objects was present only in SBML\n"
		"Level&nbsp;1.  In SBML Level&nbsp;2 and later, the type has been\n"
		"replaced by subclassing the Rule object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isAlgebraic", _wrap_Rule_isAlgebraic, METH_VARARGS, (char *)"\n"
		"Rule_isAlgebraic(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule is an AlgebraicRule.\n"
		"\n"
		"@return @c true if this Rule is an AlgebraicRule, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isAssignment", _wrap_Rule_isAssignment, METH_VARARGS, (char *)"\n"
		"Rule_isAssignment(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule is an AssignmentRule.\n"
		"\n"
		"@return @c true if this Rule is an AssignmentRule, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isCompartmentVolume", _wrap_Rule_isCompartmentVolume, METH_VARARGS, (char *)"\n"
		"Rule_isCompartmentVolume(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this Rule is an CompartmentVolumeRule.\n"
		"\n"
		"@return @c true if this Rule is a CompartmentVolumeRule, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isParameter", _wrap_Rule_isParameter, METH_VARARGS, (char *)"\n"
		"Rule_isParameter(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this Rule is an ParameterRule.\n"
		"\n"
		"@return @c true if this Rule is a ParameterRule, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isRate", _wrap_Rule_isRate, METH_VARARGS, (char *)"\n"
		"Rule_isRate(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Rule\n"
		"is a RateRule (SBML Levels&nbsp;2&ndash;3) or has a 'type' attribute\n"
		"value of @c 'rate' (SBML Level&nbsp;1).\n"
		"\n"
		"@return @c true if this Rule is a RateRule (Level&nbsp;2) or has\n"
		"type 'rate' (Level&nbsp;1), @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isScalar", _wrap_Rule_isScalar, METH_VARARGS, (char *)"\n"
		"Rule_isScalar(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Rule\n"
		"is an AssignmentRule (SBML Levels&nbsp;2&ndash;3) or has a 'type'\n"
		"attribute value of @c 'scalar' (SBML Level&nbsp;1).\n"
		"\n"
		"@return @c true if this Rule is an AssignmentRule (Level&nbsp;2) or has\n"
		"type 'scalar' (Level&nbsp;1), @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSpeciesConcentration", _wrap_Rule_isSpeciesConcentration, METH_VARARGS, (char *)"\n"
		"Rule_isSpeciesConcentration(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this Rule is an SpeciesConcentrationRule.\n"
		"\n"
		"@return @c true if this Rule is a SpeciesConcentrationRule, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getTypeCode", _wrap_Rule_getTypeCode, METH_VARARGS, (char *)"\n"
		"Rule_getTypeCode(Rule self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getL1TypeCode", _wrap_Rule_getL1TypeCode, METH_VARARGS, (char *)"\n"
		"Rule_getL1TypeCode(Rule self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the SBML Level&nbsp;1 type code for this Rule object.\n"
		"\n"
		"This only applies to SBML Level&nbsp;1 model objects.  If this is not\n"
		"an SBML Level&nbsp;1 rule object, this method will return @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink.\n"
		"\n"
		"@return the SBML Level&nbsp;1 type code for this Rule (namely, @link\n"
		"SBMLTypeCode_t#SBML_COMPARTMENT_VOLUME_RULE\n"
		"SBML_COMPARTMENT_VOLUME_RULE@endlink, @link\n"
		"SBMLTypeCode_t#SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink, @link\n"
		"SBMLTypeCode_t#SBML_SPECIES_CONCENTRATION_RULE\n"
		"SBML_SPECIES_CONCENTRATION_RULE@endlink, or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getElementName", _wrap_Rule_getElementName, METH_VARARGS, (char *)"\n"
		"Rule_getElementName(Rule self) -> string\n"
		"\n"
		"Returns the XML element name of this object\n"
		"\n"
		"The returned value can be any of a number of different strings,\n"
		"depending on the SBML Level in use and the kind of Rule object this\n"
		"is.  The rules as of libSBML 4.1.0 are the following:\n"
		"<ul>\n"
		"<li> (Level&nbsp;2 and&nbsp;3) RateRule: returns @c 'rateRule'\n"
		"<li> (Level&nbsp;2 and&nbsp;3) AssignmentRule: returns @c 'assignmentRule' \n"
		"<li> (Level&nbsp;2 and&nbsp;3) AlgebraicRule: returns @c 'algebraicRule'\n"
		"<li> (Level&nbsp;1 Version&nbsp;1) SpecieConcentrationRule: returns @c 'specieConcentrationRule'\n"
		"<li> (Level&nbsp;1 Version&nbsp;2) SpeciesConcentrationRule: returns @c 'speciesConcentrationRule'\n"
		"<li> (Level&nbsp;1) CompartmentVolumeRule: returns @c 'compartmentVolumeRule'\n"
		"<li> (Level&nbsp;1) ParameterRule: returns @c 'parameterRule'\n"
		"<li> Unknown rule type: returns @c 'unknownRule'\n"
		"</ul>\n"
		"\n"
		"Beware that the last (@c 'unknownRule') is not a valid SBML element\n"
		"name.\n"
		"\n"
		"@return the name of this element\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setL1TypeCode", _wrap_Rule_setL1TypeCode, METH_VARARGS, (char *)"\n"
		"Rule_setL1TypeCode(Rule self, SBMLTypeCode_t type) -> int\n"
		"\n"
		"Sets the SBML Level&nbsp;1 type code for this Rule.\n"
		"\n"
		"@param type the SBML Level&nbsp;1 type code for this Rule, drawn from\n"
		"the enumeration #SBMLTypeCode_t.  The allowable values are @link\n"
		"SBMLTypeCode_t#SBML_COMPARTMENT_VOLUME_RULE\n"
		"SBML_COMPARTMENT_VOLUME_RULE@endlink, @link\n"
		"SBMLTypeCode_t#SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink, and\n"
		"@link SBMLTypeCode_t#SBML_SPECIES_CONCENTRATION_RULE\n"
		"SBML_SPECIES_CONCENTRATION_RULE@endlink.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink\n"
		"if given @p type value is not one of the above.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_hasRequiredElements", _wrap_Rule_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Rule_hasRequiredElements(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the\n"
		"required elements for this Rule object have been set.\n"
		"\n"
		"The only required element for a Rule object is the 'math' subelement.\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_hasRequiredAttributes", _wrap_Rule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Rule_hasRequiredAttributes(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the\n"
		"required attributes for this Rule object have been set.\n"
		"\n"
		"The required attributes for a Rule object depend on the type of Rule\n"
		"it is.  For AssignmentRule and RateRule objects (and SBML\n"
		"Level&nbsp1's SpeciesConcentrationRule, CompartmentVolumeRule, and\n"
		"ParameterRule objects), the required attribute is 'variable'; for\n"
		"AlgebraicRule objects, there is no required attribute.\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getId", _wrap_Rule_getId, METH_VARARGS, (char *)"\n"
		"Rule_getId(Rule self) -> string\n"
		"\n"
		"Predicate returning @c true if all the\n"
		"required attributes for this Rule object have been set.\n"
		"\n"
		"The required attributes for a Rule object depend on the type of Rule\n"
		"it is.  For AssignmentRule and RateRule objects (and SBML\n"
		"Level&nbsp1's SpeciesConcentrationRule, CompartmentVolumeRule, and\n"
		"ParameterRule objects), the required attribute is 'variable'; for\n"
		"AlgebraicRule objects, there is no required attribute.\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Rule_swigregister", Rule_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_AlgebraicRule", _wrap_new_AlgebraicRule, METH_VARARGS, (char *)"\n"
		"AlgebraicRule(unsigned int level, unsigned int version)\n"
		"new_AlgebraicRule(SBMLNamespaces sbmlns) -> AlgebraicRule\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this AlgebraicRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, there is no required attribute\n"
		"for an AlgebraicRule object.  For Level&nbsp;1, the only required\n"
		"attribute is 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_AlgebraicRule", _wrap_delete_AlgebraicRule, METH_VARARGS, (char *)"delete_AlgebraicRule(AlgebraicRule self)"},
	 { (char *)"AlgebraicRule_clone", _wrap_AlgebraicRule_clone, METH_VARARGS, (char *)"\n"
		"AlgebraicRule_clone(AlgebraicRule self) -> AlgebraicRule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AlgebraicRule_hasRequiredAttributes", _wrap_AlgebraicRule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"AlgebraicRule_hasRequiredAttributes(AlgebraicRule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this AlgebraicRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, there is no required attribute\n"
		"for an AlgebraicRule object.  For Level&nbsp;1, the only required\n"
		"attribute is 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AlgebraicRule_swigregister", AlgebraicRule_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_AssignmentRule", _wrap_new_AssignmentRule, METH_VARARGS, (char *)"\n"
		"AssignmentRule(unsigned int level, unsigned int version)\n"
		"new_AssignmentRule(SBMLNamespaces sbmlns) -> AssignmentRule\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this AssignmentRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, the only required attribute for\n"
		"an AssignmentRule object is 'variable'.  For Level&nbsp;1, where the\n"
		"equivalent attribute is known by different names ('compartment',\n"
		"'species', or 'name', depending on the type of object), there is an\n"
		"additional required attribute called 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_AssignmentRule", _wrap_delete_AssignmentRule, METH_VARARGS, (char *)"delete_AssignmentRule(AssignmentRule self)"},
	 { (char *)"AssignmentRule_clone", _wrap_AssignmentRule_clone, METH_VARARGS, (char *)"\n"
		"AssignmentRule_clone(AssignmentRule self) -> AssignmentRule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AssignmentRule_hasRequiredAttributes", _wrap_AssignmentRule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"AssignmentRule_hasRequiredAttributes(AssignmentRule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this AssignmentRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, the only required attribute for\n"
		"an AssignmentRule object is 'variable'.  For Level&nbsp;1, where the\n"
		"equivalent attribute is known by different names ('compartment',\n"
		"'species', or 'name', depending on the type of object), there is an\n"
		"additional required attribute called 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AssignmentRule_swigregister", AssignmentRule_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_RateRule", _wrap_new_RateRule, METH_VARARGS, (char *)"\n"
		"RateRule(unsigned int level, unsigned int version)\n"
		"new_RateRule(SBMLNamespaces sbmlns) -> RateRule\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this RateRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, the only required attribute for a\n"
		"RateRule object is 'variable'.  For Level&nbsp;1, where the equivalent\n"
		"attribute is known by different names ('compartment', 'species', or\n"
		"'name', depending on the type of object), there is an additional\n"
		"required attribute called 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_RateRule", _wrap_delete_RateRule, METH_VARARGS, (char *)"delete_RateRule(RateRule self)"},
	 { (char *)"RateRule_clone", _wrap_RateRule_clone, METH_VARARGS, (char *)"\n"
		"RateRule_clone(RateRule self) -> RateRule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RateRule_hasRequiredAttributes", _wrap_RateRule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"RateRule_hasRequiredAttributes(RateRule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this RateRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, the only required attribute for a\n"
		"RateRule object is 'variable'.  For Level&nbsp;1, where the equivalent\n"
		"attribute is known by different names ('compartment', 'species', or\n"
		"'name', depending on the type of object), there is an additional\n"
		"required attribute called 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RateRule_swigregister", RateRule_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfRules_clone", _wrap_ListOfRules_clone, METH_VARARGS, (char *)"\n"
		"ListOfRules_clone(ListOfRules self) -> ListOfRules\n"
		"\n"
		"Creates and returns a deep copy of this ListOfRules instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfRules.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_getTypeCode", _wrap_ListOfRules_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfRules_getTypeCode(ListOfRules self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_getItemTypeCode", _wrap_ListOfRules_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfRules_getItemTypeCode(ListOfRules self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Rule objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_getElementName", _wrap_ListOfRules_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfRules_getElementName(ListOfRules self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfRules, the XML element name is @c 'listOfRules'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfRules'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_get", _wrap_ListOfRules_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Rule\n"
		"get(unsigned int n) -> Rule\n"
		"get(string sid) -> Rule\n"
		"ListOfRules_get(ListOfRules self, string sid) -> Rule\n"
		"\n"
		"Get a Rule from the ListOfRules\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Rule to get.\n"
		"\n"
		"@return Rule in this ListOfRules\n"
		"with the given id or @c NULL if no such\n"
		"Rule exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_remove", _wrap_ListOfRules_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Rule\n"
		"ListOfRules_remove(ListOfRules self, string sid) -> Rule\n"
		"\n"
		"Removes item in this ListOfRules items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfRules", _wrap_new_ListOfRules, METH_VARARGS, (char *)"new_ListOfRules() -> ListOfRules"},
	 { (char *)"delete_ListOfRules", _wrap_delete_ListOfRules, METH_VARARGS, (char *)"delete_ListOfRules(ListOfRules self)"},
	 { (char *)"ListOfRules_swigregister", ListOfRules_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Constraint", _wrap_delete_Constraint, METH_VARARGS, (char *)"delete_Constraint(Constraint self)"},
	 { (char *)"new_Constraint", _wrap_new_Constraint, METH_VARARGS, (char *)"\n"
		"Constraint(unsigned int level, unsigned int version)\n"
		"Constraint(SBMLNamespaces sbmlns)\n"
		"new_Constraint(Constraint orig) -> Constraint\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Constraint object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Constraint object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Constraint_clone", _wrap_Constraint_clone, METH_VARARGS, (char *)"\n"
		"Constraint_clone(Constraint self) -> Constraint\n"
		"\n"
		"Creates and returns a deep copy of this Constraint.\n"
		"\n"
		"@return a (deep) copy of this Constraint.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getMessage", _wrap_Constraint_getMessage, METH_VARARGS, (char *)"\n"
		"Constraint_getMessage(Constraint self) -> XMLNode\n"
		"\n"
		"Get the message, if any, associated with this Constraint\n"
		"\n"
		"@return the message for this Constraint, as an XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getMessageString", _wrap_Constraint_getMessageString, METH_VARARGS, (char *)"\n"
		"Constraint_getMessageString(Constraint self) -> string\n"
		"\n"
		"Get the message string, if any, associated with this Constraint\n"
		"\n"
		"@return the message for this Constraint, as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getMath", _wrap_Constraint_getMath, METH_VARARGS, (char *)"\n"
		"Constraint_getMath(Constraint self) -> ASTNode\n"
		"\n"
		"Get the mathematical expression of this Constraint\n"
		"\n"
		"@return the math for this Constraint, as an ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_isSetMessage", _wrap_Constraint_isSetMessage, METH_VARARGS, (char *)"\n"
		"Constraint_isSetMessage(Constraint self) -> bool\n"
		"\n"
		"Predicate returning @c true if a\n"
		"message has been defined for this Constraint.\n"
		"\n"
		"@return @c true if the message of this Constraint has been set,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_isSetMath", _wrap_Constraint_isSetMath, METH_VARARGS, (char *)"\n"
		"Constraint_isSetMath(Constraint self) -> bool\n"
		"\n"
		"Predicate returning @c true if a\n"
		"mathematical formula has been defined for this Constraint.\n"
		"\n"
		"@return @c true if the 'math' subelement for this Constraint has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_setMessage", _wrap_Constraint_setMessage, METH_VARARGS, (char *)"\n"
		"Constraint_setMessage(Constraint self, XMLNode xhtml) -> int\n"
		"\n"
		"Sets the message of this Constraint.\n"
		"\n"
		"The XMLNode tree passed in @p xhtml is copied.\n"
		"\n"
		"@param xhtml an XML tree containing XHTML content.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_setMath", _wrap_Constraint_setMath, METH_VARARGS, (char *)"\n"
		"Constraint_setMath(Constraint self, ASTNode math) -> int\n"
		"\n"
		"Sets the mathematical expression of this Constraint to a copy of the\n"
		"AST given as @p math.\n"
		"\n"
		"@param math an ASTNode expression to be assigned as the 'math'\n"
		"subelement of this Constraint\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_unsetMessage", _wrap_Constraint_unsetMessage, METH_VARARGS, (char *)"\n"
		"Constraint_unsetMessage(Constraint self) -> int\n"
		"\n"
		"Unsets the 'message' subelement of this Constraint.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getTypeCode", _wrap_Constraint_getTypeCode, METH_VARARGS, (char *)"\n"
		"Constraint_getTypeCode(Constraint self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getElementName", _wrap_Constraint_getElementName, METH_VARARGS, (char *)"\n"
		"Constraint_getElementName(Constraint self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Constraint, is\n"
		"always @c 'constraint'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'constraint'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_hasRequiredElements", _wrap_Constraint_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Constraint_hasRequiredElements(Constraint self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Constraint object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Constraint object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_swigregister", Constraint_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfConstraints_clone", _wrap_ListOfConstraints_clone, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_clone(ListOfConstraints self) -> ListOfConstraints\n"
		"\n"
		"Creates and returns a deep copy of this ListOfConstraints instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfConstraints.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_getTypeCode", _wrap_ListOfConstraints_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_getTypeCode(ListOfConstraints self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_getItemTypeCode", _wrap_ListOfConstraints_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_getItemTypeCode(ListOfConstraints self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Constraint objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_getElementName", _wrap_ListOfConstraints_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_getElementName(ListOfConstraints self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfConstraints, the XML element name is @c 'listOfConstraints'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfConstraints'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_get", _wrap_ListOfConstraints_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Constraint\n"
		"ListOfConstraints_get(ListOfConstraints self, unsigned int n) -> Constraint\n"
		"\n"
		"Get a Constraint from the ListOfConstraints.\n"
		"\n"
		"@param n the index number of the Constraint to get.\n"
		"\n"
		"@return the nth Constraint in this ListOfConstraints.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_remove", _wrap_ListOfConstraints_remove, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_remove(ListOfConstraints self, unsigned int n) -> Constraint\n"
		"\n"
		"Removes the nth item from this ListOfConstraints items and returns a\n"
		"pointer to it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfConstraints", _wrap_new_ListOfConstraints, METH_VARARGS, (char *)"new_ListOfConstraints() -> ListOfConstraints"},
	 { (char *)"delete_ListOfConstraints", _wrap_delete_ListOfConstraints, METH_VARARGS, (char *)"delete_ListOfConstraints(ListOfConstraints self)"},
	 { (char *)"ListOfConstraints_swigregister", ListOfConstraints_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Reaction", _wrap_delete_Reaction, METH_VARARGS, (char *)"delete_Reaction(Reaction self)"},
	 { (char *)"new_Reaction", _wrap_new_Reaction, METH_VARARGS, (char *)"\n"
		"Reaction(unsigned int level, unsigned int version)\n"
		"Reaction(SBMLNamespaces sbmlns)\n"
		"new_Reaction(Reaction orig) -> Reaction\n"
		"\n"
		"Predicate returning @c true if all the required attributes for this\n"
		"Reaction object have been set.\n"
		"\n"
		"@note The required attributes for a Reaction object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'fast' (in Level&nbsp;3 only, where it is defined as a required attribute)\n"
		"@li 'reversible' (in Level&nbsp;3 only, where it is defined as a required attribute)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Reaction_clone", _wrap_Reaction_clone, METH_VARARGS, (char *)"\n"
		"Reaction_clone(Reaction self) -> Reaction\n"
		"\n"
		"Creates and returns a deep copy of this Reaction.\n"
		"\n"
		"@return a (deep) copy of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_initDefaults", _wrap_Reaction_initDefaults, METH_VARARGS, (char *)"\n"
		"Reaction_initDefaults(Reaction self)\n"
		"\n"
		"Initializes the fields of this Reaction object to 'typical' default\n"
		"values.\n"
		"\n"
		"The SBML Reaction component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets the 'reversible' attribute to @c true\n"
		"<li> Sets the 'fast' attribute to @c false\n"
		"<li> Marks the 'fast' attribute as @em not having been set\n"
		"</ul>\n"
		"\n"
		"@warning The 'fast' attribute must be used with care.  SBML\n"
		"definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  Beginning with\n"
		"SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications therefore\n"
		"stipulate that if a model has any reactions with 'fast' set to @c\n"
		"true, a software tool must be able to respect the attribute or else\n"
		"indicate to the user that it does not have the capacity to do so.\n"
		"Readers are directed to the SBML specifications, which provides more\n"
		"detail about the conditions under which a reaction can be considered\n"
		"to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getId", _wrap_Reaction_getId, METH_VARARGS, (char *)"\n"
		"Reaction_getId(Reaction self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Reaction.\n"
		"\n"
		"@return the id of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getName", _wrap_Reaction_getName, METH_VARARGS, (char *)"\n"
		"Reaction_getName(Reaction self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Reaction.\n"
		"\n"
		"@return the name of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getKineticLaw", _wrap_Reaction_getKineticLaw, METH_VARARGS, (char *)"\n"
		"getKineticLaw() -> KineticLaw\n"
		"Reaction_getKineticLaw(Reaction self) -> KineticLaw\n"
		"\n"
		"Returns the KineticLaw object contained in this Reaction.\n"
		"\n"
		"@return the KineticLaw instance.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getReversible", _wrap_Reaction_getReversible, METH_VARARGS, (char *)"\n"
		"Reaction_getReversible(Reaction self) -> bool\n"
		"\n"
		"Returns the value of the 'reversible' attribute on the Reaction as a\n"
		"boolean value.\n"
		"\n"
		"@return the reversibility status of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getFast", _wrap_Reaction_getFast, METH_VARARGS, (char *)"\n"
		"Reaction_getFast(Reaction self) -> bool\n"
		"\n"
		"Returns the value of the 'fast' attribute of this Reaction.\n"
		"\n"
		"@return the 'fast' status of this Reaction.\n"
		"\n"
		"@warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2\n"
		"Versions 2, 3 and 4 therefore stipulate that if a model has any reactions\n"
		"with 'fast' set to @c true, a software tool must be able to respect\n"
		"the attribute or else indicate to the user that it does not have the\n"
		"capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version\n"
		"4 specification, which provides more detail about the conditions under\n"
		"which a reaction can be considered to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getCompartment", _wrap_Reaction_getCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_getCompartment(Reaction self) -> string\n"
		"\n"
		"(SBML Level&nbsp;3 only) Returns the value of the 'compartment'\n"
		"attribute on the Reaction.\n"
		"\n"
		"@return the compartment of this Reaction.\n"
		"\n"
		"@note The 'compartment' attribute has been introduced in SBML\n"
		"Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in\n"
		"lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetId", _wrap_Reaction_isSetId, METH_VARARGS, (char *)"\n"
		"Reaction_isSetId(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Reaction has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetName", _wrap_Reaction_isSetName, METH_VARARGS, (char *)"\n"
		"Reaction_isSetName(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Reaction has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetKineticLaw", _wrap_Reaction_isSetKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_isSetKineticLaw(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction contains a kinetic law object.\n"
		"\n"
		"@return @c true if a KineticLaw is present in this Reaction,, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetFast", _wrap_Reaction_isSetFast, METH_VARARGS, (char *)"\n"
		"Reaction_isSetFast(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if the value of\n"
		"the 'fast' attribute on this Reaction.\n"
		"\n"
		"@return @c true if the 'fast' attribute is true, @c false otherwise.\n"
		"\n"
		"@warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2\n"
		"Versions 2, 3 and 4 therefore stipulate that if a model has any reactions\n"
		"with 'fast' set to @c true, a software tool must be able to respect\n"
		"the attribute or else indicate to the user that it does not have the\n"
		"capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version\n"
		"4 specification, which provides more detail about the conditions under\n"
		"which a reaction can be considered to be fast in this sense.  Note\n"
		"also that in SBML Level&nbsp;1, 'fast' is defined as optional with a\n"
		"default of @c false, which means it is effectively always set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetCompartment", _wrap_Reaction_isSetCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_isSetCompartment(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'compartment' attribute has been set.\n"
		"\n"
		"@return @c true if the 'compartment' attribute of this Reaction has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'compartment' attribute has been introduced in SBML\n"
		"Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in\n"
		"lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetReversible", _wrap_Reaction_isSetReversible, METH_VARARGS, (char *)"\n"
		"Reaction_isSetReversible(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'reversible' attribute has been set.\n"
		"\n"
		"@return @c true if the 'reversible' attribute of this Reaction has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setId", _wrap_Reaction_setId, METH_VARARGS, (char *)"\n"
		"Reaction_setId(Reaction self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Reaction.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Reaction\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setName", _wrap_Reaction_setName, METH_VARARGS, (char *)"\n"
		"Reaction_setName(Reaction self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Reaction.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Reaction\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setKineticLaw", _wrap_Reaction_setKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_setKineticLaw(Reaction self, KineticLaw kl) -> int\n"
		"\n"
		"Sets the 'kineticLaw' subelement of this Reaction to a copy of the\n"
		"given KineticLaw object.\n"
		"\n"
		"@param kl the KineticLaw object to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		" \n"
		"\n"
		""},
	 { (char *)"Reaction_setReversible", _wrap_Reaction_setReversible, METH_VARARGS, (char *)"\n"
		"Reaction_setReversible(Reaction self, bool value) -> int\n"
		"\n"
		"Sets the value of the 'reversible' attribute of this Reaction.\n"
		"\n"
		"@param value the value of the 'reversible' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setFast", _wrap_Reaction_setFast, METH_VARARGS, (char *)"\n"
		"Reaction_setFast(Reaction self, bool value) -> int\n"
		"\n"
		"Sets the value of the 'fast' attribute of this Reaction.\n"
		"\n"
		"@param value the value of the 'fast' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2\n"
		"Versions 2, 3 and 4 therefore stipulate that if a model has any reactions\n"
		"with 'fast' set to @c true, a software tool must be able to respect\n"
		"the attribute or else indicate to the user that it does not have the\n"
		"capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version\n"
		"4 specification, which provides more detail about the conditions under\n"
		"which a reaction can be considered to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setCompartment", _wrap_Reaction_setCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_setCompartment(Reaction self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'compartment' attribute of this Reaction.\n"
		"\n"
		"The string @p sid is copied.  \n"
		"\n"
		"@param sid the string to use as the compartment of this Reaction\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'compartment' attribute has been introduced in SBML\n"
		"Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in\n"
		"lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetName", _wrap_Reaction_unsetName, METH_VARARGS, (char *)"\n"
		"Reaction_unsetName(Reaction self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetKineticLaw", _wrap_Reaction_unsetKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_unsetKineticLaw(Reaction self) -> int\n"
		"\n"
		"Unsets the 'kineticLaw' subelement of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetFast", _wrap_Reaction_unsetFast, METH_VARARGS, (char *)"\n"
		"Reaction_unsetFast(Reaction self) -> int\n"
		"\n"
		"Unsets the value of the 'fast' attribute of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@warning In SBML Level&nbsp;1, 'fast' is optional with a default of @c\n"
		"false, which means it is effectively always set (and reset to @c false\n"
		"if this method is called).  Further, SBML definitions before SBML\n"
		"Level&nbsp;2 Version&nbsp;2 incorrectly indicated that software tools could\n"
		"ignore this attribute if they did not implement support for the\n"
		"corresponding concept; however, further research in SBML has revealed\n"
		"that this is not true, and 'fast' <em>cannot be ignored</em> if it is\n"
		"set to @c true.  SBML Level&nbsp;2 Versions 2, 3 and 4 therefore stipulate\n"
		"that if a model has any reactions with 'fast' set to @c true, a\n"
		"software tool must be able to respect the attribute or else indicate\n"
		"to the user that it does not have the capacity to do so.  Readers are\n"
		"directed to the SBML Level&nbsp;2 Version&nbsp;4 specification, which provides\n"
		"more detail about the conditions under which a reaction can be\n"
		"considered to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetCompartment", _wrap_Reaction_unsetCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_unsetCompartment(Reaction self) -> int\n"
		"\n"
		"Unsets the value of the 'compartment' attribute of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'compartment' attribute has been introduced in SBML\n"
		"Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in\n"
		"lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_addReactant", _wrap_Reaction_addReactant, METH_VARARGS, (char *)"\n"
		"Reaction_addReactant(Reaction self, SpeciesReference sr) -> int\n"
		"\n"
		"Adds a given SpeciesReference object as a reactant in this Reaction.\n"
		"\n"
		"The SpeciesReference instance in @p sr is copied.\n"
		"\n"
		"@param sr a SpeciesReference object referring to a Species in the\n"
		"enclosing Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Reaction.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Reaction</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see Reaction::createReactant()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createReactant()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_addProduct", _wrap_Reaction_addProduct, METH_VARARGS, (char *)"\n"
		"Reaction_addProduct(Reaction self, SpeciesReference sr) -> int\n"
		"\n"
		"Adds a given SpeciesReference object as a product in this Reaction.\n"
		"\n"
		"The SpeciesReference instance in @p sr is copied.\n"
		"\n"
		"@param sr a SpeciesReference object referring to a Species in the\n"
		"enclosing Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Reaction.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Reaction</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see Reaction::createProduct()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createProduct()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_addModifier", _wrap_Reaction_addModifier, METH_VARARGS, (char *)"\n"
		"Reaction_addModifier(Reaction self, ModifierSpeciesReference msr) -> int\n"
		"\n"
		"Adds a given ModifierSpeciesReference object as a product in this\n"
		"Reaction.\n"
		"\n"
		"The ModifierSpeciesReference instance in @p msr is copied.\n"
		"\n"
		"@param msr a ModifierSpeciesReference object referring to a Species in\n"
		"the enclosing Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Reaction.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Reaction</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see Reaction::createModifier()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createModifier()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createReactant", _wrap_Reaction_createReactant, METH_VARARGS, (char *)"\n"
		"Reaction_createReactant(Reaction self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference, adds it to this Reaction's list of\n"
		"reactants, and returns it.\n"
		"\n"
		"@return a new SpeciesReference object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createProduct", _wrap_Reaction_createProduct, METH_VARARGS, (char *)"\n"
		"Reaction_createProduct(Reaction self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference, adds it to this Reaction's list of\n"
		"products, and returns it.\n"
		"\n"
		"@return a new SpeciesReference object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createModifier", _wrap_Reaction_createModifier, METH_VARARGS, (char *)"\n"
		"Reaction_createModifier(Reaction self) -> ModifierSpeciesReference\n"
		"\n"
		"Creates a new ModifierSpeciesReference, adds it to this Reaction's\n"
		"list of modifiers and returns it.\n"
		"\n"
		"@return a new ModifierSpeciesReference object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createKineticLaw", _wrap_Reaction_createKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_createKineticLaw(Reaction self) -> KineticLaw\n"
		"\n"
		"Creates a new KineticLaw object, installs it as this Reaction's\n"
		"'kineticLaw' subelement, and returns it.\n"
		"\n"
		"If this Reaction had a previous KineticLaw, it will be destroyed.\n"
		"\n"
		"@return the new KineticLaw object\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getListOfReactants", _wrap_Reaction_getListOfReactants, METH_VARARGS, (char *)"\n"
		"getListOfReactants() -> ListOfSpeciesReferences\n"
		"Reaction_getListOfReactants(Reaction self) -> ListOfSpeciesReferences\n"
		"\n"
		"Returns the list of reactants in this Reaction object.\n"
		"\n"
		"@return the ListOfSpeciesReferences containing the references to the\n"
		"species acting as reactants in this reaction\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getListOfProducts", _wrap_Reaction_getListOfProducts, METH_VARARGS, (char *)"\n"
		"getListOfProducts() -> ListOfSpeciesReferences\n"
		"Reaction_getListOfProducts(Reaction self) -> ListOfSpeciesReferences\n"
		"\n"
		"Returns the list of products in this Reaction object.\n"
		"\n"
		"@return the ListOfSpeciesReferences containing the references to the\n"
		"species acting as products in this reaction\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getListOfModifiers", _wrap_Reaction_getListOfModifiers, METH_VARARGS, (char *)"\n"
		"getListOfModifiers() -> ListOfSpeciesReferences\n"
		"Reaction_getListOfModifiers(Reaction self) -> ListOfSpeciesReferences\n"
		"\n"
		"Returns the list of modifiers in this Reaction object.\n"
		"\n"
		"@return the ListOfSpeciesReferences containing the references to the\n"
		"species acting as modifiers in this reaction\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getReactant", _wrap_Reaction_getReactant, METH_VARARGS, (char *)"\n"
		"getReactant(unsigned int n) -> SpeciesReference\n"
		"getReactant(unsigned int n) -> SpeciesReference\n"
		"getReactant(string species) -> SpeciesReference\n"
		"Reaction_getReactant(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"Returns the reactant species (as a SpeciesReference object) having \n"
		"a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the reactant Species ('species' \n"
		"attribute of the reactant SpeciesReference object)\n"
		"\n"
		"@return a SpeciesReference object, or @c NULL if no species with the\n"
		"given identifier @p species appears as a reactant in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getProduct", _wrap_Reaction_getProduct, METH_VARARGS, (char *)"\n"
		"getProduct(unsigned int n) -> SpeciesReference\n"
		"getProduct(unsigned int n) -> SpeciesReference\n"
		"getProduct(string species) -> SpeciesReference\n"
		"Reaction_getProduct(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"Returns the product species (as a SpeciesReference object) having \n"
		"a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the product Species ('species'\n"
		"attribute of the product SpeciesReference object)\n"
		"\n"
		"@return a SpeciesReference object, or @c NULL if no species with the\n"
		"given identifier @p species appears as a product in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getModifier", _wrap_Reaction_getModifier, METH_VARARGS, (char *)"\n"
		"getModifier(unsigned int n) -> ModifierSpeciesReference\n"
		"getModifier(unsigned int n) -> ModifierSpeciesReference\n"
		"getModifier(string species) -> ModifierSpeciesReference\n"
		"Reaction_getModifier(Reaction self, string species) -> ModifierSpeciesReference\n"
		"\n"
		"Returns the modifier species (as a ModifierSpeciesReference object) \n"
		"having a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the modifier Species ('species' \n"
		"attribute of the ModifierSpeciesReference object)\n"
		"\n"
		"@return a ModifierSpeciesReference object, or @c NULL if no species with\n"
		"the given identifier @p species appears as a modifier in this\n"
		"Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getNumReactants", _wrap_Reaction_getNumReactants, METH_VARARGS, (char *)"\n"
		"Reaction_getNumReactants(Reaction self) -> unsigned int\n"
		"\n"
		"Returns the number of reactant species in this Reaction.\n"
		"\n"
		"@return the number of reactants in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getNumProducts", _wrap_Reaction_getNumProducts, METH_VARARGS, (char *)"\n"
		"Reaction_getNumProducts(Reaction self) -> unsigned int\n"
		"\n"
		"Returns the number of product species in this Reaction.\n"
		"\n"
		"@return the number of products in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getNumModifiers", _wrap_Reaction_getNumModifiers, METH_VARARGS, (char *)"\n"
		"Reaction_getNumModifiers(Reaction self) -> unsigned int\n"
		"\n"
		"Returns the number of modifier species in this Reaction.\n"
		"\n"
		"@return the number of modifiers in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_removeReactant", _wrap_Reaction_removeReactant, METH_VARARGS, (char *)"\n"
		"removeReactant(unsigned int n) -> SpeciesReference\n"
		"Reaction_removeReactant(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"Removes the reactant species (SpeciesReference object) having the given  \n"
		"'species' attribute in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param species the 'species' attribute of the reactant SpeciesReference \n"
		"object\n"
		"\n"
		"@return the removed reactant SpeciesReference object, or @c NULL if no \n"
		"reactant SpeciesReference object with the given 'species' attribute \n"
		"@p species exists in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_removeProduct", _wrap_Reaction_removeProduct, METH_VARARGS, (char *)"\n"
		"removeProduct(unsigned int n) -> SpeciesReference\n"
		"Reaction_removeProduct(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"Removes the product species (SpeciesReference object) having the given  \n"
		"'species' attribute in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param species the 'species' attribute of the product SpeciesReference \n"
		"object\n"
		"\n"
		"@return the removed product SpeciesReference object, or @c NULL if no \n"
		"product SpeciesReference object with the given 'species' attribute \n"
		"@p species exists in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_removeModifier", _wrap_Reaction_removeModifier, METH_VARARGS, (char *)"\n"
		"removeModifier(unsigned int n) -> ModifierSpeciesReference\n"
		"Reaction_removeModifier(Reaction self, string species) -> ModifierSpeciesReference\n"
		"\n"
		"Removes the modifier species (ModifierSpeciesReference object) having \n"
		"the given 'species' attribute in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param species the 'species' attribute of the ModifierSpeciesReference \n"
		"object\n"
		"\n"
		"@return the removed ModifierSpeciesReference object, or @c NULL if no \n"
		"ModifierSpeciesReference object with the given 'species' attribute @p \n"
		"species exists in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getTypeCode", _wrap_Reaction_getTypeCode, METH_VARARGS, (char *)"\n"
		"Reaction_getTypeCode(Reaction self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getElementName", _wrap_Reaction_getElementName, METH_VARARGS, (char *)"\n"
		"Reaction_getElementName(Reaction self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Reaction, is\n"
		"always @c 'reaction'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'reaction'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_hasRequiredAttributes", _wrap_Reaction_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Reaction_hasRequiredAttributes(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the required attributes for this\n"
		"Reaction object have been set.\n"
		"\n"
		"@note The required attributes for a Reaction object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'fast' (in Level&nbsp;3 only, where it is defined as a required attribute)\n"
		"@li 'reversible' (in Level&nbsp;3 only, where it is defined as a required attribute)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_swigregister", Reaction_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfReactions_clone", _wrap_ListOfReactions_clone, METH_VARARGS, (char *)"\n"
		"ListOfReactions_clone(ListOfReactions self) -> ListOfReactions\n"
		"\n"
		"Creates and returns a deep copy of this ListOfReactions instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfReactions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_getTypeCode", _wrap_ListOfReactions_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfReactions_getTypeCode(ListOfReactions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_getItemTypeCode", _wrap_ListOfReactions_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfReactions_getItemTypeCode(ListOfReactions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Reaction objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_getElementName", _wrap_ListOfReactions_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfReactions_getElementName(ListOfReactions self) -> string\n"
		"\n"
		"Returns the XML element name of this object\n"
		"\n"
		"For ListOfReactions, the XML element name is @c 'listOfReactions'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfReactions'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_get", _wrap_ListOfReactions_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Reaction\n"
		"get(unsigned int n) -> Reaction\n"
		"get(string sid) -> Reaction\n"
		"ListOfReactions_get(ListOfReactions self, string sid) -> Reaction\n"
		"\n"
		"Get a Reaction from the ListOfReactions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Reaction to get.\n"
		"\n"
		"@return Reaction in this ListOfReactions\n"
		"with the given id or @c NULL if no such\n"
		"Reaction exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_remove", _wrap_ListOfReactions_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Reaction\n"
		"ListOfReactions_remove(ListOfReactions self, string sid) -> Reaction\n"
		"\n"
		"Removes item in this ListOfReactions items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"@c NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfReactions", _wrap_new_ListOfReactions, METH_VARARGS, (char *)"new_ListOfReactions() -> ListOfReactions"},
	 { (char *)"delete_ListOfReactions", _wrap_delete_ListOfReactions, METH_VARARGS, (char *)"delete_ListOfReactions(ListOfReactions self)"},
	 { (char *)"ListOfReactions_swigregister", ListOfReactions_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_KineticLaw", _wrap_delete_KineticLaw, METH_VARARGS, (char *)"delete_KineticLaw(KineticLaw self)"},
	 { (char *)"new_KineticLaw", _wrap_new_KineticLaw, METH_VARARGS, (char *)"\n"
		"KineticLaw(unsigned int level, unsigned int version)\n"
		"KineticLaw(SBMLNamespaces sbmlns)\n"
		"new_KineticLaw(KineticLaw orig) -> KineticLaw\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this KineticLaw object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a KineticLaw object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"KineticLaw_clone", _wrap_KineticLaw_clone, METH_VARARGS, (char *)"\n"
		"KineticLaw_clone(KineticLaw self) -> KineticLaw\n"
		"\n"
		"Creates and returns a deep copy of this KineticLaw object.\n"
		"\n"
		"@return a (deep) copy of this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getFormula", _wrap_KineticLaw_getFormula, METH_VARARGS, (char *)"\n"
		"KineticLaw_getFormula(KineticLaw self) -> string\n"
		"\n"
		"Returns the mathematical formula for this KineticLaw object and return\n"
		"it as as a text string.\n"
		"\n"
		"This is fundamentally equivalent to getMath().  This variant is\n"
		"provided principally for compatibility compatibility with SBML Level\n"
		"1.\n"
		"\n"
		"@return a string representing the formula of this KineticLaw.\n"
		"\n"
		"@see getMath()\n"
		"\n"
		"@note SBML Level&nbsp;1 uses a text-string format for mathematical\n"
		"formulas.  SBML Level&nbsp;2 uses MathML, an XML format for\n"
		"representing mathematical expressions.  LibSBML provides an Abstract\n"
		"Syntax Tree API for working with mathematical expressions; this API is\n"
		"more powerful than working with formulas directly in text form, and\n"
		"ASTs can be translated into either MathML or the text-string syntax.\n"
		"The libSBML methods that accept text-string formulas directly (such as\n"
		"this constructor) are provided for SBML Level&nbsp;1 compatibility,\n"
		"but developers are encouraged to use the AST mechanisms.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getMath", _wrap_KineticLaw_getMath, METH_VARARGS, (char *)"\n"
		"KineticLaw_getMath(KineticLaw self) -> ASTNode\n"
		"\n"
		"Returns the mathematical formula for this KineticLaw object and return\n"
		"it as as an AST.\n"
		"\n"
		"This is fundamentally equivalent to getFormula().  The latter is\n"
		"provided principally for compatibility compatibility with SBML Level\n"
		"1, which represented mathematical formulas in text-string form.\n"
		"\n"
		"@return the ASTNode representation of the mathematical formula.\n"
		"\n"
		"@see getFormula()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getTimeUnits", _wrap_KineticLaw_getTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_getTimeUnits(KineticLaw self) -> string\n"
		"\n"
		"Returns the value of the 'timeUnits' attribute of this KineticLaw\n"
		"object.\n"
		"\n"
		"@return the 'timeUnits' attribute value\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getSubstanceUnits", _wrap_KineticLaw_getSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_getSubstanceUnits(KineticLaw self) -> string\n"
		"\n"
		"Returns the value of the\n"
		"'substanceUnits' attribute of this KineticLaw object.\n"
		"\n"
		"@return the 'substanceUnits' attribute value\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetFormula", _wrap_KineticLaw_isSetFormula, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetFormula(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"KineticLaw's 'formula' attribute has been set\n"
		"\n"
		"This is functionally identical to the method isSetMath().  It is\n"
		"provided in order to mirror the parallel between getFormula() and\n"
		"getMath().\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this KineticLaw has been set, @c false otherwise.\n"
		"\n"
		"@note SBML Level&nbsp;1 uses a text-string format for mathematical\n"
		"formulas.  SBML Level&nbsp;2 uses MathML, an XML format for\n"
		"representing mathematical expressions.  LibSBML provides an Abstract\n"
		"Syntax Tree API for working with mathematical expressions; this API is\n"
		"more powerful than working with formulas directly in text form, and\n"
		"ASTs can be translated into either MathML or the text-string syntax.\n"
		"The libSBML methods that accept text-string formulas directly (such as\n"
		"this constructor) are provided for SBML Level&nbsp;1 compatibility,\n"
		"but developers are encouraged to use the AST mechanisms.\n"
		"    \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetMath", _wrap_KineticLaw_isSetMath, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetMath(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Kinetic's 'math' subelement has been set\n"
		"\n"
		"This is identical to the method isSetFormula().  It is provided\n"
		"in order to mirror the parallel between getFormula() and getMath().\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this KineticLaw has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetTimeUnits", _wrap_KineticLaw_isSetTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetTimeUnits(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this SpeciesReference's 'timeUnits' attribute has been set\n"
		"\n"
		"@return @c true if the 'timeUnits' attribute of this KineticLaw object\n"
		"has been set, @c false otherwise.\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetSubstanceUnits", _wrap_KineticLaw_isSetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetSubstanceUnits(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this SpeciesReference's 'substanceUnits' attribute has been set\n"
		"\n"
		"@return @c true if the 'substanceUnits' attribute of this KineticLaw\n"
		"object has been set, @c false otherwise.\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setFormula", _wrap_KineticLaw_setFormula, METH_VARARGS, (char *)"\n"
		"KineticLaw_setFormula(KineticLaw self, string formula) -> int\n"
		"\n"
		"Sets the mathematical expression of this KineticLaw instance to the\n"
		"given @p formula.\n"
		"\n"
		"The given @p formula string is copied.  Internally, libSBML stores the\n"
		"mathematical expression as an ASTNode.\n"
		"\n"
		"@param formula the mathematical expression to use, represented in\n"
		"text-string form.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note SBML Level&nbsp;1 uses a text-string format for mathematical\n"
		"formulas.  SBML Level&nbsp;2 uses MathML, an XML format for representing\n"
		"mathematical expressions.  LibSBML provides an Abstract Syntax Tree\n"
		"API for working with mathematical expressions; this API is more\n"
		"powerful than working with formulas directly in text form, and ASTs\n"
		"can be translated into either MathML or the text-string syntax.  The\n"
		"libSBML methods that accept text-string formulas directly (such as\n"
		"this constructor) are provided for SBML Level&nbsp;1 compatibility, but\n"
		"developers are encouraged to use the AST mechanisms.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setMath", _wrap_KineticLaw_setMath, METH_VARARGS, (char *)"\n"
		"KineticLaw_setMath(KineticLaw self, ASTNode math) -> int\n"
		"\n"
		"Sets the mathematical expression of this KineticLaw instance to a copy\n"
		"of the given ASTNode.\n"
		"\n"
		"This is fundamentally identical to setFormula().  The latter is\n"
		"provided principally for compatibility compatibility with SBML Level\n"
		"1, which represented mathematical formulas in text-string form.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		" \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setTimeUnits", _wrap_KineticLaw_setTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_setTimeUnits(KineticLaw self, string sid) -> int\n"
		"\n"
		"Sets the 'timeUnits' attribute\n"
		"of this KineticLaw object to a copy of the identifier in @p sid.\n"
		"\n"
		"@param sid the identifier of the units to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setSubstanceUnits", _wrap_KineticLaw_setSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_setSubstanceUnits(KineticLaw self, string sid) -> int\n"
		"\n"
		"Sets the 'substanceUnits'\n"
		"attribute of this KineticLaw object to a copy of the identifier given\n"
		"in @p sid.\n"
		"\n"
		"@param sid the identifier of the units to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_unsetTimeUnits", _wrap_KineticLaw_unsetTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_unsetTimeUnits(KineticLaw self) -> int\n"
		"\n"
		"Unsets the 'timeUnits'\n"
		"attribugte of this KineticLaw object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_unsetSubstanceUnits", _wrap_KineticLaw_unsetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_unsetSubstanceUnits(KineticLaw self) -> int\n"
		"\n"
		"Unsets the 'substanceUnits'\n"
		"attribute of this KineticLaw object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_addParameter", _wrap_KineticLaw_addParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_addParameter(KineticLaw self, Parameter p) -> int\n"
		"\n"
		"Adds a copy of the given Parameter object to the list of local\n"
		"parameters in this KineticLaw.\n"
		"\n"
		"@param p the Parameter to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this KineticLaw.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the KineticLaw</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see\n"
		"KineticLaw::createParameter() for ab method that does not lead to\n"
		"these issues.\n"
		"\n"
		"@see createParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_addLocalParameter", _wrap_KineticLaw_addLocalParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_addLocalParameter(KineticLaw self, LocalParameter p) -> int\n"
		"\n"
		"Adds a copy of the given LocalParameter object to the list of local\n"
		"parameters in this KineticLaw.\n"
		"\n"
		"@param p the LocalParameter to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this KineticLaw.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the KineticLaw</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see\n"
		"KineticLaw::createParameter() for ab method that does not lead to\n"
		"these issues.\n"
		"\n"
		"@see createLocalParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_createParameter", _wrap_KineticLaw_createParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_createParameter(KineticLaw self) -> Parameter\n"
		"\n"
		"Creates a new Parameter object, adds it to this KineticLaw's list of\n"
		"local parameters, and returns the Parameter object created.\n"
		"\n"
		"@return a new Parameter object instance\n"
		"\n"
		"@see addParameter(const Parameter* p)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_createLocalParameter", _wrap_KineticLaw_createLocalParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_createLocalParameter(KineticLaw self) -> LocalParameter\n"
		"\n"
		"Creates a new LocalParameter object, adds it to this KineticLaw's list of\n"
		"local parameters, and returns the LocalParameter object created.\n"
		"\n"
		"@return a new LocalParameter object instance\n"
		"\n"
		"@see addLocalParameter(const LocalParameter* p)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getListOfParameters", _wrap_KineticLaw_getListOfParameters, METH_VARARGS, (char *)"\n"
		"getListOfParameters() -> ListOfParameters\n"
		"KineticLaw_getListOfParameters(KineticLaw self) -> ListOfParameters\n"
		"\n"
		"Returns the list of local parameters in this KineticLaw object.\n"
		"\n"
		"@return the list of Parameters for this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getListOfLocalParameters", _wrap_KineticLaw_getListOfLocalParameters, METH_VARARGS, (char *)"\n"
		"getListOfLocalParameters() -> ListOfLocalParameters\n"
		"KineticLaw_getListOfLocalParameters(KineticLaw self) -> ListOfLocalParameters\n"
		"\n"
		"Returns the list of local parameters in this KineticLaw object.\n"
		"\n"
		"@return the list of LocalParameters for this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getParameter", _wrap_KineticLaw_getParameter, METH_VARARGS, (char *)"\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(string sid) -> Parameter\n"
		"KineticLaw_getParameter(KineticLaw self, string sid) -> Parameter\n"
		"\n"
		"Returns a local parameter based on its identifier.\n"
		"\n"
		"@param sid the identifier of the Parameter being sought.\n"
		"\n"
		"@return the Parameter object in this KineticLaw instace having the\n"
		"given 'id', or @c NULL if no such Parameter exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getLocalParameter", _wrap_KineticLaw_getLocalParameter, METH_VARARGS, (char *)"\n"
		"getLocalParameter(unsigned int n) -> LocalParameter\n"
		"getLocalParameter(unsigned int n) -> LocalParameter\n"
		"getLocalParameter(string sid) -> LocalParameter\n"
		"KineticLaw_getLocalParameter(KineticLaw self, string sid) -> LocalParameter\n"
		"\n"
		"Returns a local parameter based on its identifier.\n"
		"\n"
		"@param sid the identifier of the LocalParameter being sought.\n"
		"\n"
		"@return the LocalParameter object in this KineticLaw instace having the\n"
		"given 'id', or @c NULL if no such LocalParameter exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getNumParameters", _wrap_KineticLaw_getNumParameters, METH_VARARGS, (char *)"\n"
		"KineticLaw_getNumParameters(KineticLaw self) -> unsigned int\n"
		"\n"
		"Returns the number of local parameters in this KineticLaw instance.\n"
		"\n"
		"@return the number of Parameters in this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getNumLocalParameters", _wrap_KineticLaw_getNumLocalParameters, METH_VARARGS, (char *)"\n"
		"KineticLaw_getNumLocalParameters(KineticLaw self) -> unsigned int\n"
		"\n"
		"Returns the number of local parameters in this KineticLaw instance.\n"
		"\n"
		"@return the number of LocalParameters in this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getDerivedUnitDefinition", _wrap_KineticLaw_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"KineticLaw_getDerivedUnitDefinition(KineticLaw self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this\n"
		"KineticLaw.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"KineticLaw and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"getDerivedUnitDefinition() method returns the calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c NULL.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"KineticLaw contains pure numbers or parameters with undeclared\n"
		"units.  In those cases, it is not possible to calculate the units of\n"
		"the overall expression without making assumptions.  LibSBML does not\n"
		"make assumptions about the units, and getDerivedUnitDefinition() only\n"
		"returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  <strong>It is important that callers also\n"
		"invoke the method</strong> containsUndeclaredUnits() <strong>to\n"
		"determine whether this situation holds</strong>.  Callers may wish to\n"
		"take suitable actions in those scenarios.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this KineticLaw, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_containsUndeclaredUnits", _wrap_KineticLaw_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"KineticLaw_containsUndeclaredUnits(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the math expression of this KineticLaw contains\n"
		"parameters/numbers with undeclared units.\n"
		"\n"
		"@return @c true if the math expression of this KineticLaw\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by getDerivedUnitDefinition() may not accurately represent\n"
		"the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_removeParameter", _wrap_KineticLaw_removeParameter, METH_VARARGS, (char *)"\n"
		"removeParameter(unsigned int n) -> Parameter\n"
		"KineticLaw_removeParameter(KineticLaw self, string sid) -> Parameter\n"
		"\n"
		"Removes a Parameter object with the given identifier in the list of\n"
		"local parameters in this KineticLaw instance and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param sid the identifier of the Parameter to remove\n"
		"\n"
		"@return the Parameter object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no Parameter\n"
		"object with the identifier exists in this KineticLaw instance.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_removeLocalParameter", _wrap_KineticLaw_removeLocalParameter, METH_VARARGS, (char *)"\n"
		"removeLocalParameter(unsigned int n) -> LocalParameter\n"
		"KineticLaw_removeLocalParameter(KineticLaw self, string sid) -> LocalParameter\n"
		"\n"
		"Removes a LocalParameter object with the given identifier in the list of\n"
		"local parameters in this KineticLaw instance and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param sid the identifier of the LocalParameter to remove\n"
		"\n"
		"@return the LocalParameter object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no LocalParameter\n"
		"object with the identifier exists in this KineticLaw instance.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getTypeCode", _wrap_KineticLaw_getTypeCode, METH_VARARGS, (char *)"\n"
		"KineticLaw_getTypeCode(KineticLaw self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getElementName", _wrap_KineticLaw_getElementName, METH_VARARGS, (char *)"\n"
		"KineticLaw_getElementName(KineticLaw self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Species, is\n"
		"always @c 'kineticLaw'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'kineticLaw'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_hasRequiredAttributes", _wrap_KineticLaw_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"KineticLaw_hasRequiredAttributes(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this KineticLaw object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a KineticLaw object are:\n"
		"@li 'formula' (SBML Level&nbsp;1 only)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_hasRequiredElements", _wrap_KineticLaw_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"KineticLaw_hasRequiredElements(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this KineticLaw object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a KineticLaw object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_swigregister", KineticLaw_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SimpleSpeciesReference", _wrap_delete_SimpleSpeciesReference, METH_VARARGS, (char *)"delete_SimpleSpeciesReference(SimpleSpeciesReference self)"},
	 { (char *)"SimpleSpeciesReference_getId", _wrap_SimpleSpeciesReference_getId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_getId(SimpleSpeciesReference self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return the id of this SimpleSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_getName", _wrap_SimpleSpeciesReference_getName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_getName(SimpleSpeciesReference self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return the name of this SimpleSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_getSpecies", _wrap_SimpleSpeciesReference_getSpecies, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_getSpecies(SimpleSpeciesReference self) -> string\n"
		"\n"
		"Get the value of the 'species' attribute.\n"
		"\n"
		"@return the value of the attribute 'species' for this\n"
		"SimpleSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isSetId", _wrap_SimpleSpeciesReference_isSetId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isSetId(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SimpleSpeciesReference's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this SimpleSpeciesReference has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isSetName", _wrap_SimpleSpeciesReference_isSetName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isSetName(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SimpleSpeciesReference's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this SimpleSpeciesReference has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isSetSpecies", _wrap_SimpleSpeciesReference_isSetSpecies, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isSetSpecies(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SimpleSpeciesReference's 'species' attribute has been set.\n"
		"\n"
		"@return @c true if the 'species' attribute of this\n"
		"SimpleSpeciesReference has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_setSpecies", _wrap_SimpleSpeciesReference_setSpecies, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_setSpecies(SimpleSpeciesReference self, string sid) -> int\n"
		"\n"
		"Sets the 'species' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"The identifier string passed in @p sid is copied.\n"
		"\n"
		"@param sid the identifier of a species defined in the enclosing\n"
		"Model's ListOfSpecies.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_setId", _wrap_SimpleSpeciesReference_setId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_setId(SimpleSpeciesReference self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this SimpleSpeciesReference\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_setName", _wrap_SimpleSpeciesReference_setName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_setName(SimpleSpeciesReference self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the SimpleSpeciesReference\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_unsetId", _wrap_SimpleSpeciesReference_unsetId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_unsetId(SimpleSpeciesReference self) -> int\n"
		"\n"
		"Unsets the value of the 'id' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_unsetName", _wrap_SimpleSpeciesReference_unsetName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_unsetName(SimpleSpeciesReference self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isModifier", _wrap_SimpleSpeciesReference_isModifier, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isModifier(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"is a ModifierSpeciesReference.\n"
		"\n"
		"@return @c true if this SimpleSpeciesReference's subclass is\n"
		"ModiferSpeciesReference, @c false if it is a plain SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_swigregister", SimpleSpeciesReference_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SpeciesReference", _wrap_delete_SpeciesReference, METH_VARARGS, (char *)"delete_SpeciesReference(SpeciesReference self)"},
	 { (char *)"new_SpeciesReference", _wrap_new_SpeciesReference, METH_VARARGS, (char *)"\n"
		"SpeciesReference(unsigned int level, unsigned int version)\n"
		"SpeciesReference(SBMLNamespaces sbmlns)\n"
		"new_SpeciesReference(SpeciesReference orig) -> SpeciesReference\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this SpeciesReference object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a SpeciesReference object are:\n"
		"@li 'species'\n"
		"@li 'constant' (only available SBML Level&nbsp;3)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SpeciesReference_clone", _wrap_SpeciesReference_clone, METH_VARARGS, (char *)"\n"
		"SpeciesReference_clone(SpeciesReference self) -> SpeciesReference\n"
		"\n"
		"Creates and returns a deep copy of this SpeciesReference instance.\n"
		"\n"
		"@return a (deep) copy of this SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_initDefaults", _wrap_SpeciesReference_initDefaults, METH_VARARGS, (char *)"\n"
		"SpeciesReference_initDefaults(SpeciesReference self)\n"
		"\n"
		"Initializes the fields of this SpeciesReference object to 'typical'\n"
		"default values.\n"
		"\n"
		"The SBML SpeciesReference component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets attribute 'stoichiometry' to @c 1.0\n"
		"<li> (Applies to Level&nbsp;1 models only) Sets attribute 'denominator' to @c 1\n"
		"</ul>\n"
		"\n"
		"@see getDenominator()\n"
		"@see setDenominator(int value)\n"
		"@see getStoichiometry()\n"
		"@see setStoichiometry(double value)\n"
		"@see getStoichiometryMath()\n"
		"@see setStoichiometryMath(const StoichiometryMath* math)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getStoichiometry", _wrap_SpeciesReference_getStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getStoichiometry(SpeciesReference self) -> double\n"
		"\n"
		"Get the value of the 'stoichiometry' attribute.\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@return the value of the (scalar) 'stoichiometry' attribute of this\n"
		"SpeciesReference.\n"
		"\n"
		"@see getStoichiometryMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getStoichiometryMath", _wrap_SpeciesReference_getStoichiometryMath, METH_VARARGS, (char *)"\n"
		"getStoichiometryMath() -> StoichiometryMath\n"
		"SpeciesReference_getStoichiometryMath(SpeciesReference self) -> StoichiometryMath\n"
		"\n"
		"Get the content of the 'stoichiometryMath' subelement as an ASTNode\n"
		"tree.\n"
		"\n"
		"The 'stoichiometryMath' element exists only in SBML Level 2.  There,\n"
		"product and reactant stoichiometries can be specified using\n"
		"<em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or decimal).\n"
		"\n"
		"@return the content of the 'stoichiometryMath' subelement of this\n"
		"SpeciesReference.\n"
		"\n"
		"@see getStoichiometry()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getDenominator", _wrap_SpeciesReference_getDenominator, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getDenominator(SpeciesReference self) -> int\n"
		"\n"
		"Get the value of the 'denominator' attribute, for the case of a\n"
		"rational-numbered stoichiometry or a model in SBML Level&nbsp;1.\n"
		"\n"
		"The 'denominator' attribute is only actually written out in the case\n"
		"of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number\n"
		"stoichiometries are written as MathML elements in the\n"
		"'stoichiometryMath' subelement.  However, as a convenience to users,\n"
		"libSBML allows the creation and manipulation of rational-number\n"
		"stoichiometries by supplying the numerator and denominator directly\n"
		"rather than having to manually create an ASTNode structure.  LibSBML\n"
		"will write out the appropriate constructs (either a combination of\n"
		"'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or a\n"
		"'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).\n"
		"\n"
		"@return the value of the 'denominator' attribute of this\n"
		"SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getConstant", _wrap_SpeciesReference_getConstant, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getConstant(SpeciesReference self) -> bool\n"
		"\n"
		"Get the value of the 'constant' attribute.\n"
		"\n"
		"@return the value of the 'constant' attribute of this\n"
		"SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_isSetStoichiometryMath", _wrap_SpeciesReference_isSetStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_isSetStoichiometryMath(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesReference's 'stoichiometryMath' subelement has been set\n"
		"\n"
		"@return @c true if the 'stoichiometryMath' subelement of this\n"
		"SpeciesReference has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_isSetConstant", _wrap_SpeciesReference_isSetConstant, METH_VARARGS, (char *)"\n"
		"SpeciesReference_isSetConstant(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesReference's 'constant' attribute has been set\n"
		"\n"
		"@return @c true if the 'constant' attribute of this\n"
		"SpeciesReference has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_isSetStoichiometry", _wrap_SpeciesReference_isSetStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_isSetStoichiometry(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesReference's 'stoichiometry' attribute has been set.\n"
		"\n"
		"@return @c true if the 'stoichiometry' attribute of this\n"
		"SpeciesReference has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setStoichiometry", _wrap_SpeciesReference_setStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setStoichiometry(SpeciesReference self, double value) -> int\n"
		"\n"
		"Sets the value of the 'stoichiometry' attribute of this\n"
		"SpeciesReference.\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@param value the new value of the 'stoichiometry' attribute\n"
		"\n"
		"@note In SBML Level&nbsp;2, the 'stoichiometryMath' subelement of this\n"
		"SpeciesReference object will be unset because the 'stoichiometry'\n"
		"attribute and the stoichiometryMath' subelement are mutually\n"
		"exclusive.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setStoichiometryMath", _wrap_SpeciesReference_setStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setStoichiometryMath(SpeciesReference self, StoichiometryMath math) -> int\n"
		"\n"
		"Sets the 'stoichiometryMath' subelement of this SpeciesReference.\n"
		"\n"
		"The Abstract Syntax Tree in @p math is copied.\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@param math the StoichiometryMath expression that is to be copied as the\n"
		"content of the 'stoichiometryMath' subelement.\n"
		"\n"
		"@note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this\n"
		"SpeciesReference object will be unset (isSetStoichiometry() will\n"
		"return @c false although getStoichiometry() will return @c 1.0) if the\n"
		"given math is not null because the 'stoichiometry' attribute and the\n"
		"stoichiometryMath' subelement are mutually exclusive.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setDenominator", _wrap_SpeciesReference_setDenominator, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setDenominator(SpeciesReference self, int value) -> int\n"
		"\n"
		"Set the value of the 'denominator' attribute, for the case of a\n"
		"rational-numbered stoichiometry or a model in SBML Level&nbsp;1.\n"
		"\n"
		"The 'denominator' attribute is only actually written out in the case\n"
		"of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number\n"
		"stoichiometries are written as MathML elements in the\n"
		"'stoichiometryMath' subelement.  However, as a convenience to users,\n"
		"libSBML allows the creation and manipulation of rational-number\n"
		"stoichiometries by supplying the numerator and denominator directly\n"
		"rather than having to manually create an ASTNode structure.  LibSBML\n"
		"will write out the appropriate constructs (either a combination of\n"
		"'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or\n"
		"a 'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).\n"
		"\n"
		"@param value the scalar value \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setConstant", _wrap_SpeciesReference_setConstant, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setConstant(SpeciesReference self, bool flag) -> int\n"
		"\n"
		"Sets the 'constant' attribute of this SpeciesReference to the given boolean\n"
		"@p flag.\n"
		"\n"
		"@param flag a boolean, the value for the 'constant' attribute of this\n"
		"SpeciesReference instance\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_unsetStoichiometryMath", _wrap_SpeciesReference_unsetStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_unsetStoichiometryMath(SpeciesReference self) -> int\n"
		"\n"
		"Unsets the 'stoichiometryMath' subelement of this SpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this\n"
		"SpeciesReference object will be reset to a default value (@c 1.0) if\n"
		"the 'stoichiometry' attribute has not been set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_unsetStoichiometry", _wrap_SpeciesReference_unsetStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_unsetStoichiometry(SpeciesReference self) -> int\n"
		"\n"
		"Unsets the 'stoichiometry' attribute of this SpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note In SBML Level&nbsp;1, the 'stoichiometry' attribute of this\n"
		"SpeciesReference object will be just reset to a default value (@c 1.0)\n"
		"and isSetStoichiometry() will still return @c true.  In SBML\n"
		"Level&nbsp;2, the 'stoichiometry' attribute of this object will be\n"
		"unset (which will result in isSetStoichiometry() returning @c false,\n"
		"although getStoichiometry() will return @c 1.0) if the\n"
		"'stoichiometryMath' subelement has been set, otherwise the attribute\n"
		"will be just reset to the default value (@c 1.0) (and\n"
		"isSetStoichiometry() will still return @c true).  In SBML\n"
		"Level&nbsp;3, the 'stoichiometry' attribute of this object will be set\n"
		"to @c NaN and isSetStoichiometry() will return @c false.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_createStoichiometryMath", _wrap_SpeciesReference_createStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_createStoichiometryMath(SpeciesReference self) -> StoichiometryMath\n"
		"\n"
		"Creates a new, empty StoichiometryMath object, adds it to this\n"
		"SpeciesReference, and returns it.\n"
		"\n"
		"@return the newly created StoichiometryMath object instance\n"
		"\n"
		"@see Reaction::addReactant(const SpeciesReference* sr)\n"
		"@see Reaction::addProduct(const SpeciesReference* sr)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setAnnotation", _wrap_SpeciesReference_setAnnotation, METH_VARARGS, (char *)"\n"
		"setAnnotation(XMLNode annotation) -> int\n"
		"SpeciesReference_setAnnotation(SpeciesReference self, string annotation) -> int\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object to a\n"
		"copy of @p annotation.\n"
		"\n"
		"Any existing content of the 'annotation' subelement is discarded.\n"
		"Unless you have taken steps to first copy and reconstitute any\n"
		"existing annotations into the @p annotation that is about to be\n"
		"assigned, it is likely that performing such wholesale replacement is\n"
		"unfriendly towards other software applications whose annotations are\n"
		"discarded.  An alternative may be to use appendAnnotation().\n"
		"\n"
		"@param annotation an XML string that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see appendAnnotation(const XMLNode* annotation)\n"
		"@see appendAnnotation(const std::string& annotation)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_appendAnnotation", _wrap_SpeciesReference_appendAnnotation, METH_VARARGS, (char *)"\n"
		"appendAnnotation(XMLNode annotation) -> int\n"
		"SpeciesReference_appendAnnotation(SpeciesReference self, string annotation) -> int\n"
		"\n"
		"Appends annotation content to any existing content in the 'annotation'\n"
		"subelement of this object.\n"
		"\n"
		"The content in @p annotation is copied.  Unlike setAnnotation(), this\n"
		"method allows other annotations to be preserved when an application\n"
		"adds its own data.\n"
		"\n"
		"@param annotation an XML string that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see setAnnotation(const std::string& annotation)\n"
		"@see setAnnotation(const XMLNode* annotation)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getTypeCode", _wrap_SpeciesReference_getTypeCode, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getTypeCode(SpeciesReference self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getElementName", _wrap_SpeciesReference_getElementName, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getElementName(SpeciesReference self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"SpeciesReference, is always @c 'speciesReference'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'speciesReference'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_initL2Stoichiometry", _wrap_SpeciesReference_initL2Stoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_initL2Stoichiometry(SpeciesReference self)\n"
		"\n"
		"Subclasses should override this method to write out their contained\n"
		"SBML objects as XML elements.  Be sure to call your parents\n"
		"implementation of this method as well.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"SpeciesReference_hasRequiredAttributes", _wrap_SpeciesReference_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"SpeciesReference_hasRequiredAttributes(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this SpeciesReference object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a SpeciesReference object are:\n"
		"@li 'species'\n"
		"@li 'constant' (only available SBML Level&nbsp;3)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_swigregister", SpeciesReference_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ModifierSpeciesReference", _wrap_new_ModifierSpeciesReference, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference(unsigned int level, unsigned int version)\n"
		"new_ModifierSpeciesReference(SBMLNamespaces sbmlns) -> ModifierSpeciesReference\n"
		"\n"
		"Creates a new ModifierSpeciesReference using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a ModifierSpeciesReference object to an\n"
		"SBMLDocument (e.g., using Model::addModifierSpeciesReference()), the\n"
		"SBML XML namespace of the document @em overrides the value used when\n"
		"creating the ModifierSpeciesReference object via this constructor.\n"
		"This is necessary to ensure that an SBML document is a consistent\n"
		"structure.  Nevertheless, the ability to supply the values at the time\n"
		"of creation of a ModifierSpeciesReference is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_ModifierSpeciesReference", _wrap_delete_ModifierSpeciesReference, METH_VARARGS, (char *)"delete_ModifierSpeciesReference(ModifierSpeciesReference self)"},
	 { (char *)"ModifierSpeciesReference_clone", _wrap_ModifierSpeciesReference_clone, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_clone(ModifierSpeciesReference self) -> ModifierSpeciesReference\n"
		"\n"
		"Creates and returns a deep copy of this ModifierSpeciesReference\n"
		"instance.\n"
		"\n"
		"@return a (deep) copy of this ModifierSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_getTypeCode", _wrap_ModifierSpeciesReference_getTypeCode, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_getTypeCode(ModifierSpeciesReference self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_getElementName", _wrap_ModifierSpeciesReference_getElementName, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_getElementName(ModifierSpeciesReference self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Species, is\n"
		"always @c 'modifierSpeciesReference'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'modifierSpeciesReference'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_hasRequiredAttributes", _wrap_ModifierSpeciesReference_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_hasRequiredAttributes(ModifierSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this ModifierSpeciesReference object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a ModifierSpeciesReference object are:\n"
		"species\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_swigregister", ModifierSpeciesReference_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ListOfSpeciesReferences", _wrap_new_ListOfSpeciesReferences, METH_VARARGS, (char *)"\n"
		"new_ListOfSpeciesReferences() -> ListOfSpeciesReferences\n"
		"\n"
		"Creates a new, empty ListOfSpeciesReferences.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_clone", _wrap_ListOfSpeciesReferences_clone, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_clone(ListOfSpeciesReferences self) -> ListOfSpeciesReferences\n"
		"\n"
		"Creates and returns a deep copy of this ListOfSpeciesReferences\n"
		"instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfSpeciesReferences.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_getTypeCode", _wrap_ListOfSpeciesReferences_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_getTypeCode(ListOfSpeciesReferences self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_getItemTypeCode", _wrap_ListOfSpeciesReferences_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_getItemTypeCode(ListOfSpeciesReferences self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., SpeciesReference objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_getElementName", _wrap_ListOfSpeciesReferences_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_getElementName(ListOfSpeciesReferences self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfSpeciesReferences, the XML element name is @c\n"
		"'listOfSpeciesReferences'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfSpeciesReferences'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_get", _wrap_ListOfSpeciesReferences_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> SimpleSpeciesReference\n"
		"get(unsigned int n) -> SimpleSpeciesReference\n"
		"get(string sid) -> SimpleSpeciesReference\n"
		"ListOfSpeciesReferences_get(ListOfSpeciesReferences self, string sid) -> SimpleSpeciesReference\n"
		"\n"
		"Get a SpeciesReference from the ListOfSpeciesReferences\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the SpeciesReference to get.\n"
		"\n"
		"@return SpeciesReference in this ListOfSpeciesReferences\n"
		"with the given id or @c NULL if no such\n"
		"SpeciesReference exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_remove", _wrap_ListOfSpeciesReferences_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> SimpleSpeciesReference\n"
		"ListOfSpeciesReferences_remove(ListOfSpeciesReferences self, string sid) -> SimpleSpeciesReference\n"
		"\n"
		"Removes item in this ListOfSpeciesReferences items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_ListOfSpeciesReferences", _wrap_delete_ListOfSpeciesReferences, METH_VARARGS, (char *)"delete_ListOfSpeciesReferences(ListOfSpeciesReferences self)"},
	 { (char *)"ListOfSpeciesReferences_swigregister", ListOfSpeciesReferences_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Event", _wrap_delete_Event, METH_VARARGS, (char *)"delete_Event(Event self)"},
	 { (char *)"new_Event", _wrap_new_Event, METH_VARARGS, (char *)"\n"
		"Event(unsigned int level, unsigned int version)\n"
		"Event(SBMLNamespaces sbmlns)\n"
		"new_Event(Event orig) -> Event\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Event object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Event object are:\n"
		"@li 'trigger'\n"
		"@li 'listOfEventAssignments' (required in SBML Level&nbsp;2, optional in Level&nbsp;3)\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Event_clone", _wrap_Event_clone, METH_VARARGS, (char *)"\n"
		"Event_clone(Event self) -> Event\n"
		"\n"
		"Creates and returns a deep copy of this Event.\n"
		"\n"
		"@return a (deep) copy of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getId", _wrap_Event_getId, METH_VARARGS, (char *)"\n"
		"Event_getId(Event self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Event.\n"
		"\n"
		"@return the id of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getName", _wrap_Event_getName, METH_VARARGS, (char *)"\n"
		"Event_getName(Event self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Event.\n"
		"\n"
		"@return the name of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getTrigger", _wrap_Event_getTrigger, METH_VARARGS, (char *)"\n"
		"getTrigger() -> Trigger\n"
		"Event_getTrigger(Event self) -> Trigger\n"
		"\n"
		"Get the event trigger portion of this Event.\n"
		"\n"
		"@return the Trigger object of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getDelay", _wrap_Event_getDelay, METH_VARARGS, (char *)"\n"
		"getDelay() -> Delay\n"
		"Event_getDelay(Event self) -> Delay\n"
		"\n"
		"Get the assignment delay portion of this Event, if there is one.\n"
		"\n"
		"@return the delay of this Event if one is defined, or @c NULL if none\n"
		"is defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getTimeUnits", _wrap_Event_getTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_getTimeUnits(Event self) -> string\n"
		"\n"
		"Get the value of the 'timeUnits' attribute of this Event, if it has one.\n"
		"\n"
		"@return the value of the attribute 'timeUnits' as a string.\n"
		"\n"
		"@warning Definitions of Event in SBML Level 2 Versions&nbsp;1\n"
		"and&nbsp;2 included the additional attribute called 'timeUnits', but\n"
		"it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports\n"
		"this attribute for compatibility with previous versions of SBML\n"
		"Level&nbsp;2, but its use is discouraged since models in Level 2\n"
		"Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3\n"
		"or&nbsp;4 model sets the attribute, the consistency-checking method\n"
		"SBMLDocument::checkConsistency() will report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getUseValuesFromTriggerTime", _wrap_Event_getUseValuesFromTriggerTime, METH_VARARGS, (char *)"\n"
		"Event_getUseValuesFromTriggerTime(Event self) -> bool\n"
		"\n"
		"Get the value of the 'useValuesFromTriggerTime' attribute of this Event.\n"
		"\n"
		"The optional Delay on Event means there are two times to consider when\n"
		"computing the results of an event: the time at which the event\n"
		"<em>fires</em>, and the time at which assignments are <em>executed</em>.\n"
		"It is also possible to distinguish between the time at which the\n"
		"EventAssignment's expression is calculated, and the time at which the\n"
		"assignment is made: the expression could be evaluated at the same time\n"
		"the assignments are performed, i.e., when the event is\n"
		"<em>executed</em>, but it could also be defined to be evaluated at the\n"
		"time the event <em>fired</em>.\n"
		"\n"
		"In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics of\n"
		"Event time delays were defined such that the expressions in the event's\n"
		"assignments were always evaluated at the time the event was\n"
		"<em>fired</em>.  This definition made it difficult to define an event\n"
		"whose assignment formulas were meant to be evaluated at the time the\n"
		"event was <em>executed</em> (i.e., after the time period defined by the\n"
		"value of the Delay element).  In SBML Level&nbsp;2 Version&nbsp;4, the\n"
		"attribute 'useValuesFromTriggerTime' on Event allows a model to indicate\n"
		"the time at which the event's assignments are intended to be evaluated.\n"
		"The default value is @c true, which corresponds to the interpretation of\n"
		"event assignments prior to Version&nbsp;4: the values of the assignment\n"
		"formulas are computed at the moment the event fired, not after the\n"
		"delay.  If 'useValuesFromTriggerTime'=@c false, it means that the\n"
		"formulas in the event's assignments are to be computed after the delay,\n"
		"at the time the event is executed.\n"
		"\n"
		"@return the value of the attribute 'useValuesFromTriggerTime' as a boolean.\n"
		"\n"
		"@warning The attribute 'useValuesFromTriggerTime' was introduced in\n"
		"SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in models defined\n"
		"using SBML Level&nbsp;2 versions prior to Version&nbsp;4.  If a\n"
		"Version&nbsp;1&ndash;&nbsp;3 model sets the attribute, the\n"
		"consistency-checking method SBMLDocument::checkConsistency() will\n"
		"report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetId", _wrap_Event_isSetId, METH_VARARGS, (char *)"\n"
		"Event_isSetId(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Event's 'id' attribute has been set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Event has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetName", _wrap_Event_isSetName, METH_VARARGS, (char *)"\n"
		"Event_isSetName(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Event's 'name' attribute has been set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Event has been\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetTrigger", _wrap_Event_isSetTrigger, METH_VARARGS, (char *)"\n"
		"Event_isSetTrigger(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the trigger for this Event has been set.\n"
		"\n"
		"@return @c true if the trigger of this Event has been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetDelay", _wrap_Event_isSetDelay, METH_VARARGS, (char *)"\n"
		"Event_isSetDelay(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the delay for this Event has been set.\n"
		"\n"
		"@return @c true if the delay of this Event has been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetTimeUnits", _wrap_Event_isSetTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_isSetTimeUnits(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the 'timeUnits' attribute of this Event\n"
		"has been set.\n"
		"\n"
		"@return @c true if the 'timeUnits' attribute of this Event has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@warning Definitions of Event in SBML Level 2 Versions&nbsp;1\n"
		"and&nbsp;2 included the additional attribute called 'timeUnits', but\n"
		"it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports\n"
		"this attribute for compatibility with previous versions of SBML\n"
		"Level&nbsp;2, but its use is discouraged since models in Level 2\n"
		"Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3\n"
		"or&nbsp;4 model sets the attribute, the consistency-checking method\n"
		"SBMLDocument::checkConsistency() will report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetUseValuesFromTriggerTime", _wrap_Event_isSetUseValuesFromTriggerTime, METH_VARARGS, (char *)"\n"
		"Event_isSetUseValuesFromTriggerTime(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the 'useValuesFromTriggerTime' attribute of this Event\n"
		"has been set.\n"
		"\n"
		"@return @c true if the 'useValuesFromTriggerTime' attribute of this Event has been\n"
		"set, @c false otherwise.\n"
		"\n"
		"@warning Definitions of Event in SBML Level 2 Versions&nbsp;1\n"
		"and&nbsp;2 included the additional attribute called 'timeUnits', but\n"
		"it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports\n"
		"this attribute for compatibility with previous versions of SBML\n"
		"Level&nbsp;2, but its use is discouraged since models in Level 2\n"
		"Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3\n"
		"or&nbsp;4 model sets the attribute, the consistency-checking method\n"
		"SBMLDocument::checkConsistency() will report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setId", _wrap_Event_setId, METH_VARARGS, (char *)"\n"
		"Event_setId(Event self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Event.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Event\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setName", _wrap_Event_setName, METH_VARARGS, (char *)"\n"
		"Event_setName(Event self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Event.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Event\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setTrigger", _wrap_Event_setTrigger, METH_VARARGS, (char *)"\n"
		"Event_setTrigger(Event self, Trigger trigger) -> int\n"
		"\n"
		"Sets the trigger definition of this Event to a copy of the given\n"
		"Trigger object instance.\n"
		"\n"
		"@param trigger the Trigger object instance to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setDelay", _wrap_Event_setDelay, METH_VARARGS, (char *)"\n"
		"Event_setDelay(Event self, Delay delay) -> int\n"
		"\n"
		"Sets the delay definition of this Event to a copy of the given Delay\n"
		"object instance.\n"
		"\n"
		"@param delay the Delay object instance to use\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setTimeUnits", _wrap_Event_setTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_setTimeUnits(Event self, string sid) -> int\n"
		"\n"
		"Sets the 'timeUnits' attribute of this Event to a copy of @p sid.\n"
		"\n"
		"@param sid the identifier of the time units to use.\n"
		"\n"
		"@warning Definitions of Event in SBML Level 2 Versions&nbsp;1\n"
		"and&nbsp;2 included the additional attribute called 'timeUnits', but\n"
		"it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports\n"
		"this attribute for compatibility with previous versions of SBML\n"
		"Level&nbsp;2, but its use is discouraged since models in Level 2\n"
		"Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3\n"
		"or&nbsp;4 model sets the attribute, the consistency-checking method\n"
		"SBMLDocument::checkConsistency() will report an error.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setUseValuesFromTriggerTime", _wrap_Event_setUseValuesFromTriggerTime, METH_VARARGS, (char *)"\n"
		"Event_setUseValuesFromTriggerTime(Event self, bool value) -> int\n"
		"\n"
		"Sets the 'useValuesFromTriggerTime' attribute of this Event to a @p value.\n"
		"\n"
		"The optional Delay on Event means there are two times to consider when\n"
		"computing the results of an event: the time at which the event\n"
		"<em>fires</em>, and the time at which assignments are <em>executed</em>.\n"
		"It is also possible to distinguish between the time at which the\n"
		"EventAssignment's expression is calculated, and the time at which the\n"
		"assignment is made: the expression could be evaluated at the same time\n"
		"the assignments are performed, i.e., when the event is\n"
		"<em>executed</em>, but it could also be defined to be evaluated at the\n"
		"time the event <em>fired</em>.\n"
		"\n"
		"In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics of\n"
		"Event time delays were defined such that the expressions in the event's\n"
		"assignments were always evaluated at the time the event was\n"
		"<em>fired</em>.  This definition made it difficult to define an event\n"
		"whose assignment formulas were meant to be evaluated at the time the\n"
		"event was <em>executed</em> (i.e., after the time period defined by the\n"
		"value of the Delay element).  In SBML Level&nbsp;2 Version&nbsp;4, the\n"
		"attribute 'useValuesFromTriggerTime' on Event allows a model to indicate\n"
		"the time at which the event's assignments are intended to be evaluated.\n"
		"The default value is @c true, which corresponds to the interpretation of\n"
		"event assignments prior to Version&nbsp;4: the values of the assignment\n"
		"formulas are computed at the moment the event fired, not after the\n"
		"delay.  If 'useValuesFromTriggerTime'=@c false, it means that the\n"
		"formulas in the event's assignments are to be computed after the delay,\n"
		"at the time the event is executed.\n"
		"\n"
		"@param value the value of useValuesFromTriggerTime to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@warning The attribute 'useValuesFromTriggerTime' was introduced in\n"
		"SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in models defined\n"
		"using SBML Level&nbsp;2 versions prior to Version&nbsp;4.  If a\n"
		"Version&nbsp;1&ndash;&nbsp;3 model sets the attribute, the\n"
		"consistency-checking method SBMLDocument::checkConsistency() will\n"
		"report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetId", _wrap_Event_unsetId, METH_VARARGS, (char *)"\n"
		"Event_unsetId(Event self) -> int\n"
		"\n"
		"Unsets the value of the 'id' attribute of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetName", _wrap_Event_unsetName, METH_VARARGS, (char *)"\n"
		"Event_unsetName(Event self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetDelay", _wrap_Event_unsetDelay, METH_VARARGS, (char *)"\n"
		"Event_unsetDelay(Event self) -> int\n"
		"\n"
		"Unsets the Delay of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetTimeUnits", _wrap_Event_unsetTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_unsetTimeUnits(Event self) -> int\n"
		"\n"
		"Unsets the 'timeUnits' attribute of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@warning Definitions of Event in SBML Level&nbsp;2 Versions 1 and 2\n"
		"included the attribute called 'timeUnits', but it was removed in SBML\n"
		"Level&nbsp;2 Version&nbsp;3.  LibSBML supports this attribute for\n"
		"compatibility with previous versions of SBML Level&nbsp;2, but its use\n"
		"is discouraged since models in Level&nbsp;2 Version&nbsp;3 and\n"
		"Version&nbsp;4 cannot contain it.  If a Version&nbsp;3 or&nbsp;4 model\n"
		"sets this attribute, the consistency-checking method\n"
		"SBMLDocument::checkConsistency() will report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_addEventAssignment", _wrap_Event_addEventAssignment, METH_VARARGS, (char *)"\n"
		"Event_addEventAssignment(Event self, EventAssignment ea) -> int\n"
		"\n"
		"Appends a copy of the given EventAssignment to this Event.\n"
		"\n"
		"@param ea the EventAssignment object to add.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Event.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Event</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Event::createEventAssignment()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createEventAssignment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_createEventAssignment", _wrap_Event_createEventAssignment, METH_VARARGS, (char *)"\n"
		"Event_createEventAssignment(Event self) -> EventAssignment\n"
		"\n"
		"Creates a new, empty EventAssignment, adds it to this Event's list of\n"
		"event assignments and returns the EventAssignment.\n"
		"\n"
		"@return the newly created EventAssignment object instance\n"
		"\n"
		"@see addEventAssignment(const EventAssignment* ea)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_createTrigger", _wrap_Event_createTrigger, METH_VARARGS, (char *)"\n"
		"Event_createTrigger(Event self) -> Trigger\n"
		"\n"
		"Creates a new, empty Trigger, adds it to this Event and \n"
		"returns the Trigger.\n"
		"\n"
		"@return the newly created Trigger object instance\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_createDelay", _wrap_Event_createDelay, METH_VARARGS, (char *)"\n"
		"Event_createDelay(Event self) -> Delay\n"
		"\n"
		"Creates a new, empty Delay, adds it to this Event and \n"
		"returns the Delay.\n"
		"\n"
		"@return the newly created Delay object instance\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getListOfEventAssignments", _wrap_Event_getListOfEventAssignments, METH_VARARGS, (char *)"\n"
		"getListOfEventAssignments() -> ListOfEventAssignments\n"
		"Event_getListOfEventAssignments(Event self) -> ListOfEventAssignments\n"
		"\n"
		"Returns the list of event assignments for this Event.\n"
		"\n"
		"@return the list of EventAssignments for this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getEventAssignment", _wrap_Event_getEventAssignment, METH_VARARGS, (char *)"\n"
		"getEventAssignment(unsigned int n) -> EventAssignment\n"
		"getEventAssignment(unsigned int n) -> EventAssignment\n"
		"getEventAssignment(string variable) -> EventAssignment\n"
		"Event_getEventAssignment(Event self, string variable) -> EventAssignment\n"
		"\n"
		"Return the event assignment indicated by the given @p variable.\n"
		"\n"
		"@param variable a string, the identifier of the variable whose\n"
		"EventAssignment is being sought.\n"
		"\n"
		"@return the EventAssignment for the given @p variable, or @c NULL if\n"
		"no such EventAssignment exits.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getNumEventAssignments", _wrap_Event_getNumEventAssignments, METH_VARARGS, (char *)"\n"
		"Event_getNumEventAssignments(Event self) -> unsigned int\n"
		"\n"
		"Returns the number of EventAssignment objects attached to this\n"
		"Event.\n"
		"\n"
		"@return the number of EventAssignments in this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_removeEventAssignment", _wrap_Event_removeEventAssignment, METH_VARARGS, (char *)"\n"
		"removeEventAssignment(unsigned int n) -> EventAssignment\n"
		"Event_removeEventAssignment(Event self, string variable) -> EventAssignment\n"
		"\n"
		"Removes the EventAssignment object with the given 'variable' attribute \n"
		"from this Event object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the EventAssignment objects in this Event object have the \n"
		"'variable' attribute @p variable, then @c NULL is returned.\n"
		"\n"
		"@param variable the 'variable' attribute of the EventAssignment object \n"
		"to remove\n"
		"\n"
		"@return the EventAssignment object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c NULL is returned if no EventAssignment\n"
		"object with the 'variable' attribute exists in this Event object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getTypeCode", _wrap_Event_getTypeCode, METH_VARARGS, (char *)"\n"
		"Event_getTypeCode(Event self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getElementName", _wrap_Event_getElementName, METH_VARARGS, (char *)"\n"
		"Event_getElementName(Event self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Event, is\n"
		"always @c 'event'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'event'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_hasRequiredAttributes", _wrap_Event_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Event_hasRequiredAttributes(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Event object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Event object are:\n"
		"@li 'useValuesfromTriggerTime' (required in SBML Level&nbsp;3)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_hasRequiredElements", _wrap_Event_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Event_hasRequiredElements(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Event object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Event object are:\n"
		"@li 'trigger'\n"
		"@li 'listOfEventAssignments' (required in SBML Level&nbsp;2, optional in Level&nbsp;3)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_swigregister", Event_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfEvents_clone", _wrap_ListOfEvents_clone, METH_VARARGS, (char *)"\n"
		"ListOfEvents_clone(ListOfEvents self) -> ListOfEvents\n"
		"\n"
		"Creates and returns a deep copy of this ListOfEvents.\n"
		"\n"
		"@return a (deep) copy of this ListOfEvents.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_getTypeCode", _wrap_ListOfEvents_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEvents_getTypeCode(ListOfEvents self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_getItemTypeCode", _wrap_ListOfEvents_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEvents_getItemTypeCode(ListOfEvents self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Event objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_getElementName", _wrap_ListOfEvents_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfEvents_getElementName(ListOfEvents self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfEvents, the XML element name is @c 'listOfEvents'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfEvents'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_get", _wrap_ListOfEvents_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Event\n"
		"get(unsigned int n) -> Event\n"
		"get(string sid) -> Event\n"
		"ListOfEvents_get(ListOfEvents self, string sid) -> Event\n"
		"\n"
		"Get a Event from the ListOfEvents\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Event to get.\n"
		"\n"
		"@return Event in this ListOfEvents\n"
		"with the given id or @c NULL if no such\n"
		"Event exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_remove", _wrap_ListOfEvents_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Event\n"
		"ListOfEvents_remove(ListOfEvents self, string sid) -> Event\n"
		"\n"
		"Removes item in this ListOfEvents items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfEvents", _wrap_new_ListOfEvents, METH_VARARGS, (char *)"new_ListOfEvents() -> ListOfEvents"},
	 { (char *)"delete_ListOfEvents", _wrap_delete_ListOfEvents, METH_VARARGS, (char *)"delete_ListOfEvents(ListOfEvents self)"},
	 { (char *)"ListOfEvents_swigregister", ListOfEvents_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_EventAssignment", _wrap_delete_EventAssignment, METH_VARARGS, (char *)"delete_EventAssignment(EventAssignment self)"},
	 { (char *)"new_EventAssignment", _wrap_new_EventAssignment, METH_VARARGS, (char *)"\n"
		"EventAssignment(unsigned int level, unsigned int version)\n"
		"EventAssignment(SBMLNamespaces sbmlns)\n"
		"new_EventAssignment(EventAssignment orig) -> EventAssignment\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this EventAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a EventAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"EventAssignment_clone", _wrap_EventAssignment_clone, METH_VARARGS, (char *)"\n"
		"EventAssignment_clone(EventAssignment self) -> EventAssignment\n"
		"\n"
		"Creates and returns a deep copy of this EventAssignment.\n"
		"\n"
		"@return a (deep) copy of this EventAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getVariable", _wrap_EventAssignment_getVariable, METH_VARARGS, (char *)"\n"
		"EventAssignment_getVariable(EventAssignment self) -> string\n"
		"\n"
		"Get the value of this EventAssignment's 'variable' attribute.\n"
		"\n"
		"@return the identifier stored in the 'variable' attribute of this\n"
		"EventAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getMath", _wrap_EventAssignment_getMath, METH_VARARGS, (char *)"\n"
		"EventAssignment_getMath(EventAssignment self) -> ASTNode\n"
		"\n"
		"Get the mathematical expression in this EventAssignment's 'math'\n"
		"subelement.\n"
		"\n"
		"@return the top ASTNode of an abstract syntax tree representing the\n"
		"mathematical formula in this EventAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_isSetVariable", _wrap_EventAssignment_isSetVariable, METH_VARARGS, (char *)"\n"
		"EventAssignment_isSetVariable(EventAssignment self) -> bool\n"
		"\n"
		"Predicate for testing whether the attribute 'variable' of this\n"
		"EventAssignment has been set.\n"
		"\n"
		"@return @c true if the 'variable' attribute of this EventAssignment\n"
		"has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_isSetMath", _wrap_EventAssignment_isSetMath, METH_VARARGS, (char *)"\n"
		"EventAssignment_isSetMath(EventAssignment self) -> bool\n"
		"\n"
		"Predicate for testing whether the 'math' subelement of this\n"
		"EventAssignment has been set.\n"
		"\n"
		"@return @c true if this EventAssignment has a 'math' subelement,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_setVariable", _wrap_EventAssignment_setVariable, METH_VARARGS, (char *)"\n"
		"EventAssignment_setVariable(EventAssignment self, string sid) -> int\n"
		"\n"
		"Sets the attribute 'variable' of this EventAssignment to a copy of\n"
		"the given identifier string.\n"
		"\n"
		"@param sid the identifier of a Compartment, Species or (global)\n"
		"Parameter defined in this model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_setMath", _wrap_EventAssignment_setMath, METH_VARARGS, (char *)"\n"
		"EventAssignment_setMath(EventAssignment self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this EventAssignment to a copy of the\n"
		"given ASTNode.\n"
		"\n"
		"@param math an ASTNode that will be copied and stored as the\n"
		"mathematical formula for this EventAssignment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getDerivedUnitDefinition", _wrap_EventAssignment_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"EventAssignment_getDerivedUnitDefinition(EventAssignment self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this\n"
		"EventAssignment.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"EventAssignment and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"EventAssignment::getDerivedUnitDefinition() method returns the\n"
		"calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c NULL.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"EventAssignment contains literal numbers or parameters with undeclared\n"
		"units.  In those cases, it is not possible to calculate the units of\n"
		"the overall expression without making assumptions.  LibSBML does not\n"
		"make assumptions about the units, and\n"
		"EventAssignment::getDerivedUnitDefinition() only returns the units as\n"
		"far as it is able to determine them.  For example, in an expression\n"
		"<em>X + Y</em>, if <em>X</em> has unambiguously-defined units and\n"
		"<em>Y</em> does not, it will return the units of <em>X</em>.  When\n"
		"using this method, <strong>it is critical that callers also invoke the\n"
		"method</strong> EventAssignment::containsUndeclaredUnits() <strong>to\n"
		"determine whether this situation holds</strong>.  Callers should take\n"
		"suitable action in those situations.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this EventAssignment, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_containsUndeclaredUnits", _wrap_EventAssignment_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"EventAssignment_containsUndeclaredUnits(EventAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if the math\n"
		"expression of this EventAssignment contains literal numbers or\n"
		"parameters with undeclared units.\n"
		"\n"
		"The EventAssignment::getDerivedUnitDefinition() method returns what\n"
		"libSBML computes to be the units of the 'math', to the extent that\n"
		"libSBML can compute them.  However, if the expression contains literal\n"
		"numbers or parameters with undeclared units, libSBML may not be able\n"
		"to compute the full units of the expression and will only return what\n"
		"it can compute.  Callers should always use\n"
		"EventAssignment::containsUndeclaredUnits() when using\n"
		"EventAssignment::getDerivedUnitDefinition() to decide whether the\n"
		"returned units may be incomplete.\n"
		"\n"
		"@return @c true if the math expression of this EventAssignment\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by EventAssignment::getDerivedUnitDefinition() may not\n"
		"accurately represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getTypeCode", _wrap_EventAssignment_getTypeCode, METH_VARARGS, (char *)"\n"
		"EventAssignment_getTypeCode(EventAssignment self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getElementName", _wrap_EventAssignment_getElementName, METH_VARARGS, (char *)"\n"
		"EventAssignment_getElementName(EventAssignment self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"EventAssignment, is always @c 'eventAssignment'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'eventAssignment'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_hasRequiredAttributes", _wrap_EventAssignment_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"EventAssignment_hasRequiredAttributes(EventAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this EventAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a EventAssignment object are:\n"
		"@li 'variable'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_hasRequiredElements", _wrap_EventAssignment_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"EventAssignment_hasRequiredElements(EventAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this EventAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a EventAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getId", _wrap_EventAssignment_getId, METH_VARARGS, (char *)"\n"
		"EventAssignment_getId(EventAssignment self) -> string\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this EventAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a EventAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"EventAssignment_swigregister", EventAssignment_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfEventAssignments_clone", _wrap_ListOfEventAssignments_clone, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_clone(ListOfEventAssignments self) -> ListOfEventAssignments\n"
		"\n"
		"Creates and returns a deep copy of this ListOfEventAssignments.\n"
		"\n"
		"@return a (deep) copy of this ListOfEventAssignments.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_getTypeCode", _wrap_ListOfEventAssignments_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_getTypeCode(ListOfEventAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_getItemTypeCode", _wrap_ListOfEventAssignments_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_getItemTypeCode(ListOfEventAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., EventAssignment objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_getElementName", _wrap_ListOfEventAssignments_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_getElementName(ListOfEventAssignments self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfEventAssignments, the XML element name is @c\n"
		"'listOfEventAssignments'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfEventAssignments'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_get", _wrap_ListOfEventAssignments_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> EventAssignment\n"
		"get(unsigned int n) -> EventAssignment\n"
		"get(string sid) -> EventAssignment\n"
		"ListOfEventAssignments_get(ListOfEventAssignments self, string sid) -> EventAssignment\n"
		"\n"
		"Get a EventAssignment from the ListOfEventAssignments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the EventAssignment to get.\n"
		"\n"
		"@return EventAssignment in this ListOfEventAssignments\n"
		"with the given id or @c NULL if no such\n"
		"EventAssignment exists.\n"
		"\n"
		"@see get(unsigned int n)\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_remove", _wrap_ListOfEventAssignments_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> EventAssignment\n"
		"ListOfEventAssignments_remove(ListOfEventAssignments self, string sid) -> EventAssignment\n"
		"\n"
		"Removes item in this ListOfEventAssignments items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"NULL is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfEventAssignments", _wrap_new_ListOfEventAssignments, METH_VARARGS, (char *)"new_ListOfEventAssignments() -> ListOfEventAssignments"},
	 { (char *)"delete_ListOfEventAssignments", _wrap_delete_ListOfEventAssignments, METH_VARARGS, (char *)"delete_ListOfEventAssignments(ListOfEventAssignments self)"},
	 { (char *)"ListOfEventAssignments_swigregister", ListOfEventAssignments_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Trigger", _wrap_delete_Trigger, METH_VARARGS, (char *)"delete_Trigger(Trigger self)"},
	 { (char *)"new_Trigger", _wrap_new_Trigger, METH_VARARGS, (char *)"\n"
		"Trigger(unsigned int level, unsigned int version)\n"
		"Trigger(SBMLNamespaces sbmlns)\n"
		"new_Trigger(Trigger orig) -> Trigger\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Trigger object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Trigger object are:\n"
		"math\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Trigger_clone", _wrap_Trigger_clone, METH_VARARGS, (char *)"\n"
		"Trigger_clone(Trigger self) -> Trigger\n"
		"\n"
		"Creates and returns a deep copy of this Trigger.\n"
		"\n"
		"@return a (deep) copy of this Trigger.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getMath", _wrap_Trigger_getMath, METH_VARARGS, (char *)"\n"
		"Trigger_getMath(Trigger self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula for the trigger and return it\n"
		"as an AST.\n"
		"\n"
		"@return the math of this Trigger.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_isSetMath", _wrap_Trigger_isSetMath, METH_VARARGS, (char *)"\n"
		"Trigger_isSetMath(Trigger self) -> bool\n"
		"\n"
		"Predicate to test whether the math for this trigger has been set.\n"
		"\n"
		"@return @c true if the formula (meaning the 'math' subelement) of\n"
		"this Trigger has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_setMath", _wrap_Trigger_setMath, METH_VARARGS, (char *)"\n"
		"Trigger_setMath(Trigger self, ASTNode math) -> int\n"
		"\n"
		"Sets the trigger expression of this Trigger instance to a copy of the given\n"
		"ASTNode.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink!\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getTypeCode", _wrap_Trigger_getTypeCode, METH_VARARGS, (char *)"\n"
		"Trigger_getTypeCode(Trigger self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getElementName", _wrap_Trigger_getElementName, METH_VARARGS, (char *)"\n"
		"Trigger_getElementName(Trigger self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Trigger, is\n"
		"always @c 'trigger'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'trigger'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_hasRequiredElements", _wrap_Trigger_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Trigger_hasRequiredElements(Trigger self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Trigger object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Trigger object are:\n"
		"math\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_swigregister", Trigger_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Delay", _wrap_delete_Delay, METH_VARARGS, (char *)"delete_Delay(Delay self)"},
	 { (char *)"new_Delay", _wrap_new_Delay, METH_VARARGS, (char *)"\n"
		"Delay(unsigned int level, unsigned int version)\n"
		"Delay(SBMLNamespaces sbmlns)\n"
		"new_Delay(Delay orig) -> Delay\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Delay object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Delay object are:\n"
		"math\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"Delay_clone", _wrap_Delay_clone, METH_VARARGS, (char *)"\n"
		"Delay_clone(Delay self) -> Delay\n"
		"\n"
		"Creates and returns a deep copy of this Delay.\n"
		"\n"
		"@return a (deep) copy of this Delay.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getMath", _wrap_Delay_getMath, METH_VARARGS, (char *)"\n"
		"Delay_getMath(Delay self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula for the delay and return it\n"
		"as an AST.\n"
		"\n"
		"@return the math of this Delay.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_isSetMath", _wrap_Delay_isSetMath, METH_VARARGS, (char *)"\n"
		"Delay_isSetMath(Delay self) -> bool\n"
		"\n"
		"Predicate to test whether the formula for this delay has been set.\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this Delay has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_setMath", _wrap_Delay_setMath, METH_VARARGS, (char *)"\n"
		"Delay_setMath(Delay self, ASTNode math) -> int\n"
		"\n"
		"Sets the delay expression of this Delay instance to a copy of the given\n"
		"ASTNode.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t.  @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getDerivedUnitDefinition", _wrap_Delay_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Delay_getDerivedUnitDefinition(Delay self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this Delay.\n"
		"\n"
		"Delay elements in SBML express a time delay for an Event.  Beginning\n"
		"with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are\n"
		"calculated based on the mathematical expression and the model\n"
		"quantities referenced by <code>&lt;ci&gt;</code> elements used within\n"
		"that expression.  The Delay::getDerivedUnitDefinition() method returns\n"
		"what libSBML computes the units to be, to the extent that libSBML can\n"
		"compute them.\n"
		"\n"
		"(Prior to SBML Level&nbsp;2 Version&nbsp;2, there existed an attribute\n"
		"on Event called 'timeUnits'.  This attribute could be used to set the\n"
		"intended units of the delay expression.  For such models, this will\n"
		"return a UnitDefinition object that corresponds to the declared\n"
		"'timeUnits' units.)\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c NULL.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the Delay\n"
		"contains literal numbers or parameters with undeclared units.  In\n"
		"those cases, it is not possible to calculate the units of the overall\n"
		"expression without making assumptions.  LibSBML does not make\n"
		"assumptions about the units, and Delay::getDerivedUnitDefinition()\n"
		"only returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  When using this method, <strong>it is\n"
		"critical that callers also invoke the method</strong>\n"
		"Delay::containsUndeclaredUnits() <strong>to determine whether this\n"
		"situation holds</strong>.  Callers should take suitable action in\n"
		"those situations.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this Delay, or @c NULL if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_containsUndeclaredUnits", _wrap_Delay_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"Delay_containsUndeclaredUnits(Delay self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the 'math' expression in this Delay instance contains\n"
		"parameters with undeclared units or literal numbers.\n"
		"\n"
		"Delay elements in SBML express a time delay for an Event.  Beginning\n"
		"with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are\n"
		"calculated based on the mathematical expression and the model\n"
		"quantities referenced by <code>&lt;ci&gt;</code> elements used within\n"
		"that expression.  The Delay::getDerivedUnitDefinition() method returns\n"
		"what libSBML computes the units to be, to the extent that libSBML can\n"
		"compute them.  However, if the expression contains literal numbers or\n"
		"parameters with undeclared units, libSBML may not be able to compute\n"
		"the full units of the expression and will only return what it can\n"
		"compute.  Callers should always use Delay::containsUndeclaredUnits()\n"
		"when using Delay::getDerivedUnitDefinition() to decide whether the\n"
		"returned units may be incomplete.\n"
		"\n"
		"@return @c true if the math expression of this Delay includes\n"
		"numbers/parameters with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by Delay::getDerivedUnitDefinition() may not accurately\n"
		"represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getTypeCode", _wrap_Delay_getTypeCode, METH_VARARGS, (char *)"\n"
		"Delay_getTypeCode(Delay self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getElementName", _wrap_Delay_getElementName, METH_VARARGS, (char *)"\n"
		"Delay_getElementName(Delay self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Delay, is\n"
		"always @c 'delay'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'delay'.\n"
		"\n"
		"@see getTypeCode()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_hasRequiredElements", _wrap_Delay_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Delay_hasRequiredElements(Delay self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Delay object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Delay object are:\n"
		"math\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_swigregister", Delay_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBO_isQuantitativeParameter", _wrap_SBO_isQuantitativeParameter, METH_VARARGS, (char *)"\n"
		"SBO_isQuantitativeParameter(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a QuantitativeParameter, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isParticipantRole", _wrap_SBO_isParticipantRole, METH_VARARGS, (char *)"\n"
		"SBO_isParticipantRole(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a ParticipantRole, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isModellingFramework", _wrap_SBO_isModellingFramework, METH_VARARGS, (char *)"\n"
		"SBO_isModellingFramework(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a ModellingFramework, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isMathematicalExpression", _wrap_SBO_isMathematicalExpression, METH_VARARGS, (char *)"\n"
		"SBO_isMathematicalExpression(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a MathematicalExpression, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isKineticConstant", _wrap_SBO_isKineticConstant, METH_VARARGS, (char *)"\n"
		"SBO_isKineticConstant(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a KineticConstant, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isReactant", _wrap_SBO_isReactant, METH_VARARGS, (char *)"\n"
		"SBO_isReactant(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a Reactant, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isProduct", _wrap_SBO_isProduct, METH_VARARGS, (char *)"\n"
		"SBO_isProduct(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a Product, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isModifier", _wrap_SBO_isModifier, METH_VARARGS, (char *)"\n"
		"SBO_isModifier(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a Modifier, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isRateLaw", _wrap_SBO_isRateLaw, METH_VARARGS, (char *)"\n"
		"SBO_isRateLaw(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a RateLaw, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isEvent", _wrap_SBO_isEvent, METH_VARARGS, (char *)"\n"
		"SBO_isEvent(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a Event, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isPhysicalParticipant", _wrap_SBO_isPhysicalParticipant, METH_VARARGS, (char *)"\n"
		"SBO_isPhysicalParticipant(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a PhysicalParticipant, false otherwise\n"
		"   \n"
		"\n"
		""},
	 { (char *)"SBO_isParticipant", _wrap_SBO_isParticipant, METH_VARARGS, (char *)"\n"
		"SBO_isParticipant(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a Participant, false otherwise\n"
		"   \n"
		"\n"
		""},
	 { (char *)"SBO_isInteraction", _wrap_SBO_isInteraction, METH_VARARGS, (char *)"\n"
		"SBO_isInteraction(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a Interaction, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isEntity", _wrap_SBO_isEntity, METH_VARARGS, (char *)"\n"
		"SBO_isEntity(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a Entity, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isFunctionalEntity", _wrap_SBO_isFunctionalEntity, METH_VARARGS, (char *)"\n"
		"SBO_isFunctionalEntity(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a FunctionalEntity, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isMaterialEntity", _wrap_SBO_isMaterialEntity, METH_VARARGS, (char *)"\n"
		"SBO_isMaterialEntity(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a MaterialEntity, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isConservationLaw", _wrap_SBO_isConservationLaw, METH_VARARGS, (char *)"\n"
		"SBO_isConservationLaw(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a ConservationLaw, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isSteadyStateExpression", _wrap_SBO_isSteadyStateExpression, METH_VARARGS, (char *)"\n"
		"SBO_isSteadyStateExpression(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a SteadyStateExpression, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isFunctionalCompartment", _wrap_SBO_isFunctionalCompartment, METH_VARARGS, (char *)"\n"
		"SBO_isFunctionalCompartment(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a FunctionalCompartment, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isContinuousFramework", _wrap_SBO_isContinuousFramework, METH_VARARGS, (char *)"\n"
		"SBO_isContinuousFramework(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a ContinuousFramework, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isDiscreteFramework", _wrap_SBO_isDiscreteFramework, METH_VARARGS, (char *)"\n"
		"SBO_isDiscreteFramework(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a DiscreteFramework, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isLogicalFramework", _wrap_SBO_isLogicalFramework, METH_VARARGS, (char *)"\n"
		"SBO_isLogicalFramework(unsigned int term) -> bool\n"
		"\n"
		"Function for checking the SBO term is from correct part of SBO.\n"
		"\n"
		"@return true if the term is-a LogicalFramework, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isObselete", _wrap_SBO_isObselete, METH_VARARGS, (char *)"\n"
		"SBO_isObselete(unsigned int term) -> bool\n"
		"\n"
		"Function for checking whether the SBO term is obselete.\n"
		"\n"
		"@return true if the term is-a Obsolete, false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_intToString", _wrap_SBO_intToString, METH_VARARGS, (char *)"\n"
		"SBO_intToString(int sboTerm) -> string\n"
		"\n"
		"Returns the integer as a correctly formatted SBO string.\n"
		"\n"
		"@return the given integer sboTerm as a zero-padded seven digit string.\n"
		"\n"
		"@note If the sboTerm is not in the correct range ([0 -- 9999999]), an empty\n"
		"string is returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_stringToInt", _wrap_SBO_stringToInt, METH_VARARGS, (char *)"\n"
		"SBO_stringToInt(string sboTerm) -> int\n"
		"\n"
		"Returns the string as a correctly formatted SBO integer portion.\n"
		"\n"
		"@return the given string sboTerm as an integer.  If the sboTerm is not\n"
		"in the correct format (a zero-padded, seven digit string), -1 is\n"
		"returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_checkTerm", _wrap_SBO_checkTerm, METH_VARARGS, (char *)"\n"
		"checkTerm(string sboTerm) -> bool\n"
		"SBO_checkTerm(int sboTerm) -> bool\n"
		"\n"
		"Checks the format of the given SBO integer portion.\n"
		"\n"
		"@return true if sboTerm is in the range [0 -- 9999999], false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_SBO", _wrap_new_SBO, METH_VARARGS, (char *)"new_SBO() -> SBO"},
	 { (char *)"delete_SBO", _wrap_delete_SBO, METH_VARARGS, (char *)"delete_SBO(SBO self)"},
	 { (char *)"SBO_swigregister", SBO_swigregister, METH_VARARGS, NULL},
	 { (char *)"SyntaxChecker_isValidSBMLSId", _wrap_SyntaxChecker_isValidSBMLSId, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidSBMLSId(string sid) -> bool\n"
		"\n"
		"Returns true @c true or @c false depending on whether the argument\n"
		"string conforms to the syntax of SBML identifiers.\n"
		"\n"
		"In SBML, identifiers that are the values of <code>id</code> attributes\n"
		"on objects must conform to a data type called <code>SId</code> in the\n"
		"SBML specifications.  LibSBML does not provide an explicit\n"
		"<code>SId</code> data type; instead, it tests for identifier validity\n"
		"at various times, such as when reading in models from files and data\n"
		"streams.  To enable calling programs to test that the identifiers they\n"
		"generate also conform to the SBML identifier syntax, libSBML provides\n"
		"this method.\n"
		"\n"
		"@param sid string to be checked for conformance to SBML identifier\n"
		"syntax.\n"
		"\n"
		"@return @c true if the string conforms to type SBML data type\n"
		"<code>SId</code>, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude id-syntax.html\n"
		"\n"
		"@see isValidUnitSId(std::string sid)\n"
		"@see isValidXMLID(std::string sid)\n"
		"    \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_isValidXMLID", _wrap_SyntaxChecker_isValidXMLID, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidXMLID(string id) -> bool\n"
		"\n"
		"Returns @c true or @c false depending on whether the argument string\n"
		"conforms to the XML data type <code>ID</code>.\n"
		"\n"
		"In SBML, identifiers that are the values of <code>metaid</code>\n"
		"attributes on objects must conform to the <a target='_blank' \n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a> data type.  LibSBML\n"
		"does not provide an explicit XML <code>ID</code> data type; instead,\n"
		"it tests for identifier validity at various times, such as when\n"
		"reading in models from files and data streams.  To enable calling\n"
		"programs to test that the identifiers they generate also conform to\n"
		"the SBML identifier syntax, libSBML provides this method.\n"
		"\n"
		"@param id string to be checked for conformance to the syntax of\n"
		"<a target='_blank' href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.\n"
		"\n"
		"@return @c true if the string is a syntactically-valid value for the\n"
		"XML type <a target='_blank'\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>ID</a>, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude xmlid-syntax.html\n"
		"\n"
		"@see isValidSBMLSId(std::string sid)\n"
		"@see isValidUnitSId(std::string sid)\n"
		"    \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_isValidUnitSId", _wrap_SyntaxChecker_isValidUnitSId, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidUnitSId(string units) -> bool\n"
		"\n"
		"Returns @c true or @c false depending on whether the argument string\n"
		"conforms to the syntax of SBML unit identifiers.\n"
		"\n"
		"In SBML, the identifiers of units (of both the predefined units and\n"
		"user-defined units) must conform to a data type called\n"
		"<code>UnitSId</code> in the SBML specifications.  LibSBML does not\n"
		"provide an explicit <code>UnitSId</code> data type; instead, it tests\n"
		"for identifier validity at various times, such as when reading in\n"
		"models from files and data streams.  To enable calling programs to\n"
		"test that the unit identifiers they generate also conform to the SBML\n"
		"identifier syntax, libSBML provides this method.\n"
		"\n"
		"@param units string to be checked for conformance to SBML unit\n"
		"identifier syntax.\n"
		"\n"
		"@return @c true if the string conforms to type SBML data type\n"
		"<code>UnitSId</code>, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude unitid-syntax.html\n"
		"\n"
		"@see isValidSBMLSId(std::string sid)\n"
		"@see isValidXMLID(std::string sid)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_hasExpectedXHTMLSyntax", _wrap_SyntaxChecker_hasExpectedXHTMLSyntax, METH_VARARGS, (char *)"\n"
		"hasExpectedXHTMLSyntax(XMLNode xhtml, SBMLNamespaces sbmlns = None) -> bool\n"
		"SyntaxChecker_hasExpectedXHTMLSyntax(XMLNode xhtml) -> bool\n"
		"\n"
		"Returns @c true or @c false depending on whether the given XMLNode\n"
		"object contains valid XHTML content.\n"
		"\n"
		"In SBML, the content of the 'notes' subelement available on SBase, as\n"
		"well as the 'message' subelement available on Constraint, must conform\n"
		"to <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a> (which is\n"
		"simply an XML-ized version of HTML).  However, the content cannot be\n"
		"@em entirely free-form; it must satisfy certain requirements defined in\n"
		"the <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML\n"
		"specifications</a> for specific SBML Levels.  This method implements a\n"
		"verification process that lets callers check whether the content of a\n"
		"given XMLNode object conforms to the SBML requirements for 'notes' and\n"
		"'message' structure.\n"
		"\n"
		"An aspect of XHTML validity is that the content is declared to be in\n"
		"the XML namespace for XHTML&nbsp;1.0.  There is more than one way in\n"
		"which this can be done in XML.  In particular, a model might not\n"
		"contain the declaration within the 'notes' or 'message' subelement\n"
		"itself, but might instead place the declaration on an enclosing\n"
		"element and use an XML namespace prefix within the 'notes' element to\n"
		"refer to it.  In other words, the following is valid:\n"
		"  @verbatim\n"
		" <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'\n"
		"       xmlns:xhtml='http://www.w3.org/1999/xhtml'>\n"
		"   <model>\n"
		"     <notes>\n"
		"       <xhtml:body>\n"
		"         <xhtml:center><xhtml:h2>A Simple Mitotic Oscillator</xhtml:h2></xhtml:center>\n"
		"         <xhtml:p>A minimal cascade model for the mitotic oscillator.</xhtml:p>\n"
		"       </xhtml:body>\n"
		"     </notes>\n"
		"   ... rest of model ...\n"
		" </sbml>\n"
		" @endverbatim\n"
		"Contrast the above with the following, self-contained version, which\n"
		"places the XML namespace declaration within the <code>&lt;notes&gt;</code>\n"
		"element itself:\n"
		"  @verbatim\n"
		" <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'>\n"
		"   <model>\n"
		"     <notes>\n"
		"       <html xmlns='http://www.w3.org/1999/xhtml'>\n"
		"         <head>\n"
		"           <title/>\n"
		"         </head>\n"
		"         <body>\n"
		"           <center><h2>A Simple Mitotic Oscillator</h2></center>\n"
		"           <p>A minimal cascade model for the mitotic oscillator.</p>\n"
		"         </body>\n"
		"       </html>\n"
		"     </notes>\n"
		"   ... rest of model ...\n"
		" </sbml>\n"
		" @endverbatim\n"
		"\n"
		"Both of the above are valid XML.  The purpose of the @p sbmlns\n"
		"argument to this method is to allow callers to check the validity of\n"
		"'notes' and 'message' subelements whose XML namespace declarations\n"
		"have been put elsewhere in the manner illustrated above.  Callers can\n"
		"can pass in the SBMLNamespaces object of a higher-level model\n"
		"component if the XMLNode object does not itself have the XML namespace\n"
		"declaration for XHTML&nbsp;1.0.\n"
		"\n"
		"@param xhtml the XMLNode to be checked for conformance.\n"
		"@param sbmlns the SBMLNamespaces associated with the object.\n"
		"\n"
		"@return @c true if the XMLNode content conforms, @c false otherwise.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_SyntaxChecker", _wrap_new_SyntaxChecker, METH_VARARGS, (char *)"new_SyntaxChecker() -> SyntaxChecker"},
	 { (char *)"delete_SyntaxChecker", _wrap_delete_SyntaxChecker, METH_VARARGS, (char *)"delete_SyntaxChecker(SyntaxChecker self)"},
	 { (char *)"SyntaxChecker_swigregister", SyntaxChecker_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_StoichiometryMath", _wrap_delete_StoichiometryMath, METH_VARARGS, (char *)"delete_StoichiometryMath(StoichiometryMath self)"},
	 { (char *)"new_StoichiometryMath", _wrap_new_StoichiometryMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath(unsigned int level, unsigned int version)\n"
		"StoichiometryMath(SBMLNamespaces sbmlns)\n"
		"new_StoichiometryMath(StoichiometryMath orig) -> StoichiometryMath\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this StoichiometryMath object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a StoichiometryMath object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_clone", _wrap_StoichiometryMath_clone, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_clone(StoichiometryMath self) -> StoichiometryMath\n"
		"\n"
		"Creates and returns a deep copy of this StoichiometryMath object.\n"
		"\n"
		"@return a (deep) copy of this StoichiometryMath.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getMath", _wrap_StoichiometryMath_getMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_getMath(StoichiometryMath self) -> ASTNode\n"
		"\n"
		"Retrieves the mathematical formula within this StoichiometryMath and\n"
		"return it as an AST.\n"
		"\n"
		"@return the math of this StoichiometryMath.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_isSetMath", _wrap_StoichiometryMath_isSetMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_isSetMath(StoichiometryMath self) -> bool\n"
		"\n"
		"Predicate to test whether the math for this StoichiometryMath object\n"
		"has been set.\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this StoichiometryMath has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_setMath", _wrap_StoichiometryMath_setMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_setMath(StoichiometryMath self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' expression of this StoichiometryMath instance to a\n"
		"copy of the given ASTNode.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getDerivedUnitDefinition", _wrap_StoichiometryMath_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"StoichiometryMath_getDerivedUnitDefinition(StoichiometryMath self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition object that expresses the\n"
		"units returned by the math expression in this StoichiometryMath\n"
		"object.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"StoichiometryMath and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"StoichiometryMath::getDerivedUnitDefinition() method returns the\n"
		"calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c NULL.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"StoichiometryMath instance contains literal numbers or parameters with\n"
		"undeclared units.  In those cases, it is not possible to calculate the\n"
		"units of the overall expression without making assumptions.  LibSBML\n"
		"does not make assumptions about the units, and\n"
		"StoichiometryMath::getDerivedUnitDefinition() only returns the units\n"
		"as far as it is able to determine them.  For example, in an expression\n"
		"<em>X + Y</em>, if <em>X</em> has unambiguously-defined units and\n"
		"<em>Y</em> does not, it will return the units of <em>X</em>.  When\n"
		"using this method, <strong>it is critical that callers also invoke the\n"
		"method</strong> StoichiometryMath::containsUndeclaredUnits()\n"
		"<strong>to determine whether this situation holds</strong>.  Callers\n"
		"should take suitable action in those situations.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math,\n"
		"or @c NULL if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_containsUndeclaredUnits", _wrap_StoichiometryMath_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"StoichiometryMath_containsUndeclaredUnits(StoichiometryMath self) -> bool\n"
		"\n"
		"Predicate returning @c true if the math\n"
		"expression of this StoichiometryMath object contains literal numbers\n"
		"or parameters with undeclared units.\n"
		"\n"
		"The StoichiometryMath::getDerivedUnitDefinition() method returns what\n"
		"libSBML computes the units of the Stoichiometry to be, to the extent\n"
		"that libSBML can compute them.  However, if the expression contains\n"
		"literal numbers or parameters with undeclared units, libSBML may not\n"
		"be able to compute the full units of the expression and will only\n"
		"return what it can compute.  Callers should always use\n"
		"StoichiometryMath::containsUndeclaredUnits() when using\n"
		"StoichiometryMath::getDerivedUnitDefinition() to decide whether the\n"
		"returned units may be incomplete.\n"
		"\n"
		"@return @c true if the math expression of this StoichiometryMath\n"
		"includes numbers/parameters with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by StoichiometryMath::getDerivedUnitDefinition() may not\n"
		"accurately represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getTypeCode", _wrap_StoichiometryMath_getTypeCode, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_getTypeCode(StoichiometryMath self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.\n"
		"The set of possible type codes is defined in the enumeration\n"
		"#SBMLTypeCode_t.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if java LibSBML attaches an\n"
		"identifying code to every kind of SBML object.  These are known as\n"
		"<em>SBML type codes</em>.  In other languages, the set of type codes\n"
		"is stored in an enumeration; in the Java language interface for\n"
		"libSBML, the type codes are defined as static integer constants in\n"
		"interface class {@link libsbmlConstants}.  The names of the type codes\n"
		"all begin with the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getElementName", _wrap_StoichiometryMath_getElementName, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_getElementName(StoichiometryMath self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for StoichiometryMath, is\n"
		"always @c 'stoichiometryMath'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'stoichiometryMath'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_hasRequiredElements", _wrap_StoichiometryMath_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_hasRequiredElements(StoichiometryMath self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this StoichiometryMath object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a StoichiometryMath object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_swigregister", StoichiometryMath_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SBMLNamespaces", _wrap_delete_SBMLNamespaces, METH_VARARGS, (char *)"delete_SBMLNamespaces(SBMLNamespaces self)"},
	 { (char *)"new_SBMLNamespaces", _wrap_new_SBMLNamespaces, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces(unsigned int level = 3, unsigned int version = 1)\n"
		"SBMLNamespaces(unsigned int level = 3)\n"
		"SBMLNamespaces()\n"
		"new_SBMLNamespaces(SBMLNamespaces orig) -> SBMLNamespaces\n"
		"\n"
		"Copy constructor; creates a copy of a SBMLNamespaces.\n"
		"\n"
		"@param orig the SBMLNamespaces instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_clone", _wrap_SBMLNamespaces_clone, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_clone(SBMLNamespaces self) -> SBMLNamespaces\n"
		"\n"
		"Creates and returns a deep copy of this SBMLNamespaces.\n"
		"\n"
		"@return a (deep) copy of this SBMLNamespaces.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getSBMLNamespaceURI", _wrap_SBMLNamespaces_getSBMLNamespaceURI, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_getSBMLNamespaceURI(unsigned int level, unsigned int version) -> string\n"
		"\n"
		"Returns a string representing the SBML XML namespace for the \n"
		"given @p level and @p version of SBML.\n"
		"\n"
		"@param level the SBML level\n"
		"@param version the SBML version\n"
		"\n"
		"@return a string representing the SBML namespace that reflects the\n"
		"SBML Level and Version specified.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getLevel", _wrap_SBMLNamespaces_getLevel, METH_VARARGS, (char *)"\n"
		"getLevel() -> unsigned int\n"
		"SBMLNamespaces_getLevel(SBMLNamespaces self) -> unsigned int\n"
		"\n"
		"Get the SBML Level of this SBMLNamespaces object.\n"
		"\n"
		"@return the SBML Level of this SBMLNamespaces object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getVersion", _wrap_SBMLNamespaces_getVersion, METH_VARARGS, (char *)"\n"
		"getVersion() -> unsigned int\n"
		"SBMLNamespaces_getVersion(SBMLNamespaces self) -> unsigned int\n"
		"\n"
		"Get the SBML Version of this SBMLNamespaces object.\n"
		"\n"
		"@return the SBML Version of this SBMLNamespaces object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getNamespaces", _wrap_SBMLNamespaces_getNamespaces, METH_VARARGS, (char *)"\n"
		"getNamespaces() -> XMLNamespaces\n"
		"SBMLNamespaces_getNamespaces(SBMLNamespaces self) -> XMLNamespaces\n"
		"\n"
		"Get the XML namespaces list for this SBMLNamespaces object.\n"
		"\n"
		"The plural is not a mistake, because in SBML Level&nbsp;3, objects may\n"
		"have extensions added by Level&nbsp;3 packages used by a given model,\n"
		"and therefore there may be multiple XML namespaces involved too.\n"
		"However, until the introduction of SBML Level&nbsp;3, the\n"
		"SBMLNamespaces object only records one SBML Level/Version/namespace\n"
		"combination at a time, and so this method will also only return\n"
		"a list of one item.\n"
		"\n"
		"@return the XML namespaces of this SBMLNamespaces object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_addNamespaces", _wrap_SBMLNamespaces_addNamespaces, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_addNamespaces(SBMLNamespaces self, XMLNamespaces xmlns)\n"
		"\n"
		"Add the XML namespaces list to the set of namespaces\n"
		"within this SBMLNamespaces object.\n"
		"\n"
		"@param xmlns the XML namespaces to be added.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_swigregister", SBMLNamespaces_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_SBMLTransforms", _wrap_new_SBMLTransforms, METH_VARARGS, (char *)"new_SBMLTransforms() -> SBMLTransforms"},
	 { (char *)"delete_SBMLTransforms", _wrap_delete_SBMLTransforms, METH_VARARGS, (char *)"delete_SBMLTransforms(SBMLTransforms self)"},
	 { (char *)"SBMLTransforms_swigregister", SBMLTransforms_swigregister, METH_VARARGS, NULL},
	 { (char *)"readMathMLFromString", _wrap_readMathMLFromString, METH_VARARGS, (char *)"\n"
		"readMathMLFromString(char xml) -> ASTNode_t\n"
		"\n"
		"Reads the MathML from the given XML string, constructs a corresponding\n"
		"abstract syntax tree, and returns a pointer to the root of the tree.\n"
		"\n"
		"@param xml a string containing a full MathML expression\n"
		"\n"
		"@return the root of an AST corresponding to the given mathematical\n"
		"expression, otherwise @c NULL is returned if the given string is @c NULL\n"
		"or invalid.\n"
		"\n"
		"\n"
		""},
	 { (char *)"writeMathMLToString", _wrap_writeMathMLToString, METH_VARARGS, (char *)"\n"
		"writeMathMLToString(ASTNode_t node) -> char\n"
		"\n"
		"Writes the given ASTNode (and its children) to a string as MathML, and\n"
		"returns the string.\n"
		"\n"
		"@param node the root of an AST to write out to the stream.\n"
		"\n"
		"@return a string containing the written-out MathML representation\n"
		"of the given AST.\n"
		"\n"
		"@note The string is owned by the caller and should be freed (with\n"
		"free()) when no longer needed.  @c NULL is returned if the given\n"
		"argument is @c NULL.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_ASTNode", _wrap_new_ASTNode, METH_VARARGS, (char *)"\n"
		"ASTNode(ASTNodeType_t type = AST_UNKNOWN)\n"
		"ASTNode()\n"
		"new_ASTNode(ASTNode orig) -> ASTNode\n"
		"\n"
		"Copy constructor; creates a deep copy of the given ASTNode.\n"
		"\n"
		"@param orig the ASTNode to be copied.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_ASTNode", _wrap_delete_ASTNode, METH_VARARGS, (char *)"delete_ASTNode(ASTNode self)"},
	 { (char *)"ASTNode_freeName", _wrap_ASTNode_freeName, METH_VARARGS, (char *)"\n"
		"ASTNode_freeName(ASTNode self) -> int\n"
		"\n"
		"Frees the name of this ASTNode and sets it to @c NULL.\n"
		"\n"
		"This operation is only applicable to ASTNodes corresponding to\n"
		"operators, numbers, or @link ASTNodeType_t#AST_UNKNOWN\n"
		"AST_UNKNOWN@endlink.  This method has no effect on other types of\n"
		"nodes.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_canonicalize", _wrap_ASTNode_canonicalize, METH_VARARGS, (char *)"\n"
		"ASTNode_canonicalize(ASTNode self) -> bool\n"
		"\n"
		"Converts this ASTNode to a canonical form and returns @c true if\n"
		"successful, @c false otherwise.\n"
		"\n"
		"The rules determining the canonical form conversion are as follows:\n"
		"<ul>\n"
		"\n"
		"<li> If the node type is @link ASTNodeType_t#AST_NAME AST_NAME@endlink\n"
		"and the node name matches @c 'ExponentialE', @c 'Pi', @c 'True' or @c\n"
		"'False' the node type is converted to the corresponding @c\n"
		"AST_CONSTANT_<em><span class='placeholder'>X</span></em> type.\n"
		"\n"
		"<li> If the node type is an @link ASTNodeType_t#AST_FUNCTION\n"
		"AST_FUNCTION@endlink and the node name matches an SBML Level&nbsp;1 or\n"
		"Level&nbsp;2 (MathML) function name, logical operator name, or\n"
		"relational operator name, the node is converted to the corresponding\n"
		"<code>AST_FUNCTION_</code><em><span class='placeholder'>X</span></em> or\n"
		"<code>AST_LOGICAL_</code><em><span class='placeholder'>X</span></em> type.\n"
		"\n"
		"</ul>\n"
		"\n"
		"SBML Level&nbsp;1 function names are searched first; thus, for\n"
		"example, canonicalizing @c log will result in a node type of @link\n"
		"ASTNodeType_t#AST_FUNCTION_LN AST_FUNCTION_LN@endlink.  (See the SBML\n"
		"Level&nbsp;1 Version&nbsp;2 Specification, Appendix C.)\n"
		"\n"
		"Sometimes, canonicalization of a node results in a structural\n"
		"conversion of the node as a result of adding a child.  For example, a\n"
		"node with the SBML Level&nbsp;1 function name @c sqr and a single\n"
		"child node (the argument) will be transformed to a node of type\n"
		"@link ASTNodeType_t#AST_FUNCTION_POWER AST_FUNCTION_POWER@endlink with\n"
		"two children.  The first child will remain unchanged, but the second\n"
		"child will be an ASTNode of type @link ASTNodeType_t#AST_INTEGER\n"
		"AST_INTEGER@endlink and a value of 2.  The function names that result\n"
		"in structural changes are: @c log10, @c sqr, and @c sqrt.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_addChild", _wrap_ASTNode_addChild, METH_VARARGS, (char *)"\n"
		"ASTNode_addChild(ASTNode self, ASTNode child) -> int\n"
		"\n"
		"Adds the given node as a child of this ASTNode.  Child nodes are added\n"
		"in-order, from left to right.\n"
		"\n"
		"@param child the ASTNode instance to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note Adding a child to an ASTNode may change the structure of\n"
		"the mathematical formula being represented by the tree structure,\n"
		"and may render the representation invalid.\n"
		"\n"
		"@see prependChild(ASTNode* child)\n"
		"@see replaceChild(unsigned int n, ASTNode* child)\n"
		"@see insertChild(unsigned int n, ASTNode* child)\n"
		"@see removeChild(unsigned int n)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_prependChild", _wrap_ASTNode_prependChild, METH_VARARGS, (char *)"\n"
		"ASTNode_prependChild(ASTNode self, ASTNode child) -> int\n"
		"\n"
		"Adds the given node as a child of this ASTNode.  This method adds\n"
		"child nodes from right to left.\n"
		"\n"
		"@param child the ASTNode instance to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note Prepending a child to an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild(ASTNode* child)\n"
		"@see replaceChild(unsigned int n, ASTNode* child)\n"
		"@see insertChild(unsigned int n, ASTNode* child)\n"
		"@see removeChild(unsigned int n)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_removeChild", _wrap_ASTNode_removeChild, METH_VARARGS, (char *)"\n"
		"ASTNode_removeChild(ASTNode self, unsigned int n) -> int\n"
		"\n"
		"Removes the nth child of this ASTNode object.\n"
		"\n"
		"@param n unsigned int the index of the child to remove\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"\n"
		"@note Removing a child from an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild(ASTNode* child)\n"
		"@see prependChild(ASTNode* child)\n"
		"@see replaceChild(unsigned int n, ASTNode* child)\n"
		"@see insertChild(unsigned int n, ASTNode* child)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_replaceChild", _wrap_ASTNode_replaceChild, METH_VARARGS, (char *)"\n"
		"ASTNode_replaceChild(ASTNode self, unsigned int n, ASTNode newChild) -> int\n"
		"\n"
		"Replaces the nth child of this ASTNode with the given ASTNode.\n"
		"\n"
		"@param n unsigned int the index of the child to replace\n"
		"@param newChild ASTNode to replace the nth child\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"\n"
		"@note Replacing a child from an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild(ASTNode* child)\n"
		"@see prependChild(ASTNode* child)\n"
		"@see insertChild(unsigned int n, ASTNode* child)\n"
		"@see removeChild(unsigned int n)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_insertChild", _wrap_ASTNode_insertChild, METH_VARARGS, (char *)"\n"
		"ASTNode_insertChild(ASTNode self, unsigned int n, ASTNode newChild) -> int\n"
		"\n"
		"Insert the given ASTNode at point n in the list of children\n"
		"of this ASTNode.\n"
		"\n"
		"@param n unsigned int the index of the ASTNode being added\n"
		"@param newChild ASTNode to insert as the nth child\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"\n"
		"@note Inserting a child into an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild(ASTNode* child)\n"
		"@see prependChild(ASTNode* child)\n"
		"@see replaceChild(unsigned int n, ASTNode* child)\n"
		"@see removeChild(unsigned int n)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_deepCopy", _wrap_ASTNode_deepCopy, METH_VARARGS, (char *)"\n"
		"ASTNode_deepCopy(ASTNode self) -> ASTNode\n"
		"\n"
		"Creates a recursive copy of this node and all its children.\n"
		"\n"
		"@return a copy of this ASTNode and all its children.  The caller owns\n"
		"the returned ASTNode and is reponsible for deleting it.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getChild", _wrap_ASTNode_getChild, METH_VARARGS, (char *)"\n"
		"ASTNode_getChild(ASTNode self, unsigned int n) -> ASTNode\n"
		"\n"
		"Get a child of this node according to an index number.\n"
		"\n"
		"@param n the index of the child to get\n"
		"\n"
		"@return the nth child of this ASTNode or @c NULL if this node has no nth\n"
		"child (<code>n &gt; getNumChildren() - 1</code>).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getLeftChild", _wrap_ASTNode_getLeftChild, METH_VARARGS, (char *)"\n"
		"ASTNode_getLeftChild(ASTNode self) -> ASTNode\n"
		"\n"
		"Get the left child of this node.\n"
		"\n"
		"@return the left child of this ASTNode.  This is equivalent to\n"
		"<code>getChild(0)</code>;\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getRightChild", _wrap_ASTNode_getRightChild, METH_VARARGS, (char *)"\n"
		"ASTNode_getRightChild(ASTNode self) -> ASTNode\n"
		"\n"
		"Get the right child of this node.\n"
		"\n"
		"@return the right child of this ASTNode, or @c NULL if this node has no\n"
		"right child.  If <code>getNumChildren() &gt; 1</code>, then\n"
		"this is equivalent to:\n"
		"@code\n"
		"getChild( getNumChildren() - 1 );\n"
		"@endcode\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getNumChildren", _wrap_ASTNode_getNumChildren, METH_VARARGS, (char *)"\n"
		"ASTNode_getNumChildren(ASTNode self) -> unsigned int\n"
		"\n"
		"Get the number of children that this node has.\n"
		"\n"
		"@return the number of children of this ASTNode, or 0 is this node has\n"
		"no children.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_addSemanticsAnnotation", _wrap_ASTNode_addSemanticsAnnotation, METH_VARARGS, (char *)"\n"
		"ASTNode_addSemanticsAnnotation(ASTNode self, XMLNode sAnnotation) -> int\n"
		"\n"
		"Adds the given XMLNode as a semantic annotation of this ASTNode.\n"
		"\n"
		"@param sAnnotation the annotation to add.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getNumSemanticsAnnotations", _wrap_ASTNode_getNumSemanticsAnnotations, METH_VARARGS, (char *)"\n"
		"ASTNode_getNumSemanticsAnnotations(ASTNode self) -> unsigned int\n"
		"\n"
		"Get the number of semantic annotation elements inside this node.\n"
		"\n"
		"@return the number of annotations of this ASTNode.  \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getSemanticsAnnotation", _wrap_ASTNode_getSemanticsAnnotation, METH_VARARGS, (char *)"\n"
		"ASTNode_getSemanticsAnnotation(ASTNode self, unsigned int n) -> XMLNode\n"
		"\n"
		"Get the nth semantic annotation of this node.\n"
		"\n"
		"@return the nth annotation of this ASTNode, or @c NULL if this node has\n"
		"no nth annotation (<code>n &gt; getNumChildren() - 1</code>).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getCharacter", _wrap_ASTNode_getCharacter, METH_VARARGS, (char *)"\n"
		"ASTNode_getCharacter(ASTNode self) -> char\n"
		"\n"
		"Get the value of this node as a single character.  This function\n"
		"should be called only when getType() is one of @link\n"
		"ASTNodeType_t#AST_PLUS AST_PLUS@endlink, @link ASTNodeType_t#AST_MINUS\n"
		"AST_MINUS@endlink, @link ASTNodeType_t#AST_TIMES AST_TIMES@endlink,\n"
		"@link ASTNodeType_t#AST_DIVIDE AST_DIVIDE@endlink or @link\n"
		"ASTNodeType_t#AST_POWER AST_POWER@endlink.\n"
		"\n"
		"@return the value of this ASTNode as a single character\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getInteger", _wrap_ASTNode_getInteger, METH_VARARGS, (char *)"\n"
		"ASTNode_getInteger(ASTNode self) -> long\n"
		"\n"
		"Get the value of this node as an integer. This function should be\n"
		"called only when <code>getType() == @link ASTNodeType_t#AST_INTEGER\n"
		"AST_INTEGER@endlink</code>.\n"
		"\n"
		"@return the value of this ASTNode as a (<code>long</code>) integer. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getName", _wrap_ASTNode_getName, METH_VARARGS, (char *)"\n"
		"ASTNode_getName(ASTNode self) -> char\n"
		"\n"
		"Get the value of this node as a string.  This function may be called\n"
		"on nodes that are not operators (<code>isOperator() == false</code>)\n"
		"or numbers (<code>isNumber() == false</code>).\n"
		"\n"
		"@return the value of this ASTNode as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getNumerator", _wrap_ASTNode_getNumerator, METH_VARARGS, (char *)"\n"
		"ASTNode_getNumerator(ASTNode self) -> long\n"
		"\n"
		"Get the value of the numerator of this node.  This function should be\n"
		"called only when <code>getType() == @link ASTNodeType_t#AST_RATIONAL\n"
		"AST_RATIONAL@endlink</code>.\n"
		"\n"
		"@return the value of the numerator of this ASTNode.  \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getDenominator", _wrap_ASTNode_getDenominator, METH_VARARGS, (char *)"\n"
		"ASTNode_getDenominator(ASTNode self) -> long\n"
		"\n"
		"Get the value of the denominator of this node.  This function should\n"
		"be called only when <code>getType() == @link\n"
		"ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink</code>.\n"
		"\n"
		"@return the value of the denominator of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getReal", _wrap_ASTNode_getReal, METH_VARARGS, (char *)"\n"
		"ASTNode_getReal(ASTNode self) -> double\n"
		"\n"
		"Get the real-numbered value of this node.  This function\n"
		"should be called only when <code>isReal() == true</code>.\n"
		"\n"
		"This function performs the necessary arithmetic if the node type is\n"
		"@link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink (<em>mantissa *\n"
		"10<sup> exponent</sup></em>) or @link ASTNodeType_t#AST_RATIONAL\n"
		"AST_RATIONAL@endlink (<em>numerator / denominator</em>).\n"
		"\n"
		"@return the value of this ASTNode as a real (double).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getMantissa", _wrap_ASTNode_getMantissa, METH_VARARGS, (char *)"\n"
		"ASTNode_getMantissa(ASTNode self) -> double\n"
		"\n"
		"Get the mantissa value of this node.  This function should be called\n"
		"only when getType() returns @link ASTNodeType_t#AST_REAL_E\n"
		"AST_REAL_E@endlink or @link ASTNodeType_t#AST_REAL AST_REAL@endlink.\n"
		"If getType() returns @link ASTNodeType_t#AST_REAL AST_REAL@endlink,\n"
		"this method is identical to getReal().\n"
		"\n"
		"@return the value of the mantissa of this ASTNode. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getExponent", _wrap_ASTNode_getExponent, METH_VARARGS, (char *)"\n"
		"ASTNode_getExponent(ASTNode self) -> long\n"
		"\n"
		"Get the exponent value of this ASTNode.  This function should be\n"
		"called only when getType() returns @link ASTNodeType_t#AST_REAL_E\n"
		"AST_REAL_E@endlink or @link ASTNodeType_t#AST_REAL AST_REAL@endlink.\n"
		"\n"
		"@return the value of the exponent of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getPrecedence", _wrap_ASTNode_getPrecedence, METH_VARARGS, (char *)"\n"
		"ASTNode_getPrecedence(ASTNode self) -> int\n"
		"\n"
		"Get the precedence of this node in the infix math syntax of SBML\n"
		"Level&nbsp;1.  For more information about the infix syntax, see the\n"
		"discussion about <a href='#math-convert'>text string formulas</a> at\n"
		"the top of the documentation for ASTNode.\n"
		"\n"
		"@return an integer indicating the precedence of this ASTNode\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getType", _wrap_ASTNode_getType, METH_VARARGS, (char *)"\n"
		"ASTNode_getType(ASTNode self) -> ASTNodeType_t\n"
		"\n"
		"Get the type of this ASTNode.  The value returned is one of the\n"
		"enumeration values such as @link ASTNodeType_t#AST_LAMBDA\n"
		"AST_LAMBDA@endlink, @link ASTNodeType_t#AST_PLUS AST_PLUS@endlink,\n"
		"etc.\n"
		"\n"
		"@return the type of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getUnits", _wrap_ASTNode_getUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_getUnits(ASTNode self) -> string\n"
		"\n"
		"Get the units of this ASTNode.  \n"
		"\n"
		"This operation only applies to MathML <code>&lt;cn&gt;</code> elements.\n"
		"\n"
		"@return the units of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isBoolean", _wrap_ASTNode_isBoolean, METH_VARARGS, (char *)"\n"
		"ASTNode_isBoolean(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node has a boolean type\n"
		"(a logical operator, a relational operator, or the constants @c true\n"
		"or @c false).\n"
		"\n"
		"@return true if this ASTNode is a boolean, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isConstant", _wrap_ASTNode_isConstant, METH_VARARGS, (char *)"\n"
		"ASTNode_isConstant(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a MathML\n"
		"constant (e.g., @c true, @c Pi).\n"
		"\n"
		"@return true if this ASTNode is a MathML constant, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isFunction", _wrap_ASTNode_isFunction, METH_VARARGS, (char *)"\n"
		"ASTNode_isFunction(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a\n"
		"MathML function (e.g., <code>abs()</code>), or an SBML Level&nbsp;1\n"
		"function, or a user-defined function.\n"
		"\n"
		"@return true if this ASTNode is a function, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isInfinity", _wrap_ASTNode_isInfinity, METH_VARARGS, (char *)"\n"
		"ASTNode_isInfinity(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents\n"
		"the special IEEE 754 value infinity, @c false (zero) otherwise.\n"
		"\n"
		"@return true if this ASTNode is the special IEEE 754 value infinity,\n"
		"false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isInteger", _wrap_ASTNode_isInteger, METH_VARARGS, (char *)"\n"
		"ASTNode_isInteger(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node contains an\n"
		"integer value, @c false (zero) otherwise.\n"
		"\n"
		"@return true if this ASTNode is of type @link\n"
		"ASTNodeType_t#AST_INTEGER AST_INTEGER@endlink, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isLambda", _wrap_ASTNode_isLambda, METH_VARARGS, (char *)"\n"
		"ASTNode_isLambda(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a MathML\n"
		"<code>&lt;lambda&gt;</code>, @c false (zero) otherwise.\n"
		"\n"
		"@return true if this ASTNode is of type @link ASTNodeType_t#AST_LAMBDA\n"
		"AST_LAMBDA@endlink, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isLog10", _wrap_ASTNode_isLog10, METH_VARARGS, (char *)"\n"
		"ASTNode_isLog10(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a @c\n"
		"log10() function, @c false (zero) otherwise.  More precisely, this\n"
		"predicate returns @c true if the node type is @link\n"
		"ASTNodeType_t#AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink with two\n"
		"children, the first of which is an @link ASTNodeType_t#AST_INTEGER\n"
		"AST_INTEGER@endlink equal to 10.\n"
		"\n"
		"@return true if the given ASTNode represents a log10() function, false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isLogical", _wrap_ASTNode_isLogical, METH_VARARGS, (char *)"\n"
		"ASTNode_isLogical(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a MathML\n"
		"logical operator (i.e., @c and, @c or, @c not, @c xor).\n"
		"\n"
		"@return true if this ASTNode is a MathML logical operator\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isName", _wrap_ASTNode_isName, METH_VARARGS, (char *)"\n"
		"ASTNode_isName(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a user-defined\n"
		"variable name in SBML L1, L2 (MathML), or the special symbols @c delay\n"
		"or @c time.  The predicate returns @c false (zero) otherwise.\n"
		"\n"
		"@return true if this ASTNode is a user-defined variable name in SBML\n"
		"L1, L2 (MathML) or the special symbols delay or time.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isNaN", _wrap_ASTNode_isNaN, METH_VARARGS, (char *)"\n"
		"ASTNode_isNaN(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents the\n"
		"special IEEE 754 value 'not a number' (NaN), @c false (zero)\n"
		"otherwise.\n"
		"\n"
		"@return true if this ASTNode is the special IEEE 754 NaN\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isNegInfinity", _wrap_ASTNode_isNegInfinity, METH_VARARGS, (char *)"\n"
		"ASTNode_isNegInfinity(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents the\n"
		"special IEEE 754 value 'negative infinity', @c false (zero) otherwise.\n"
		"\n"
		"@return true if this ASTNode is the special IEEE 754 value negative\n"
		"infinity, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isNumber", _wrap_ASTNode_isNumber, METH_VARARGS, (char *)"\n"
		"ASTNode_isNumber(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node contains a number,\n"
		"@c false (zero) otherwise.  This is functionally equivalent to the\n"
		"following code:\n"
		"@code\n"
		"  isInteger() || isReal()\n"
		"@endcode\n"
		"\n"
		"@return true if this ASTNode is a number, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isOperator", _wrap_ASTNode_isOperator, METH_VARARGS, (char *)"\n"
		"ASTNode_isOperator(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a mathematical\n"
		"operator, meaning, <code>+</code>, <code>-</code>, <code>*</code>, \n"
		"<code>/</code> or <code>^</code> (power).\n"
		"\n"
		"@return true if this ASTNode is an operator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isPiecewise", _wrap_ASTNode_isPiecewise, METH_VARARGS, (char *)"\n"
		"ASTNode_isPiecewise(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is the MathML\n"
		"<code>&lt;piecewise&gt;</code> construct, @c false (zero) otherwise.\n"
		"\n"
		"@return true if this ASTNode is a MathML @c piecewise function\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isRational", _wrap_ASTNode_isRational, METH_VARARGS, (char *)"\n"
		"ASTNode_isRational(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a rational\n"
		"number, @c false (zero) otherwise.\n"
		"\n"
		"@return true if this ASTNode is of type @link\n"
		"ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isReal", _wrap_ASTNode_isReal, METH_VARARGS, (char *)"\n"
		"ASTNode_isReal(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node can represent a\n"
		"real number, @c false (zero) otherwise.  More precisely, this node\n"
		"must be of one of the following types: @link ASTNodeType_t#AST_REAL\n"
		"AST_REAL@endlink, @link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink or\n"
		"@link ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink.\n"
		"\n"
		"@return true if the value of this ASTNode can represented as a real\n"
		"number, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isRelational", _wrap_ASTNode_isRelational, METH_VARARGS, (char *)"\n"
		"ASTNode_isRelational(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a MathML\n"
		"relational operator, meaning <code>==</code>, <code>&gt;=</code>, \n"
		"<code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>.\n"
		"\n"
		"@return true if this ASTNode is a MathML relational operator, false\n"
		"otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isSqrt", _wrap_ASTNode_isSqrt, METH_VARARGS, (char *)"\n"
		"ASTNode_isSqrt(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a\n"
		"square root function, @c false (zero) otherwise.  More precisely, the\n"
		"node type must be @link ASTNodeType_t#AST_FUNCTION_ROOT\n"
		"AST_FUNCTION_ROOT@endlink with two children, the first of which is an\n"
		"@link ASTNodeType_t#AST_INTEGER AST_INTEGER@endlink node having value\n"
		"equal to 2.\n"
		"\n"
		"@return true if the given ASTNode represents a sqrt() function, false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isUMinus", _wrap_ASTNode_isUMinus, METH_VARARGS, (char *)"\n"
		"ASTNode_isUMinus(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a unary minus\n"
		"operator, @c false (zero) otherwise.  A node is defined as a unary\n"
		"minus node if it is of type @link ASTNodeType_t#AST_MINUS\n"
		"AST_MINUS@endlink and has exactly one child.\n"
		"\n"
		"For numbers, unary minus nodes can be 'collapsed' by negating the\n"
		"number.  In fact, SBML_parseFormula() does this during its parse.\n"
		"However, unary minus nodes for symbols (@link ASTNodeType_t#AST_NAME\n"
		"AST_NAME@endlink) cannot be 'collapsed', so this predicate function\n"
		"is necessary.\n"
		"\n"
		"@return true if this ASTNode is a unary minus, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isUnknown", _wrap_ASTNode_isUnknown, METH_VARARGS, (char *)"\n"
		"ASTNode_isUnknown(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node has an unknown type.\n"
		"\n"
		"'Unknown' nodes have the type @link ASTNodeType_t#AST_UNKNOWN\n"
		"AST_UNKNOWN@endlink.  Nodes with unknown types will not appear in an\n"
		"ASTNode tree returned by libSBML based upon valid SBML input; the only\n"
		"situation in which a node with type @link ASTNodeType_t#AST_UNKNOWN\n"
		"AST_UNKNOWN@endlink may appear is immediately after having create a\n"
		"new, untyped node using the ASTNode constructor.  Callers creating\n"
		"nodes should endeavor to set the type to a valid node type as soon as\n"
		"possible after creating new nodes.\n"
		"\n"
		"@return true if this ASTNode is of type @link\n"
		"ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isSetUnits", _wrap_ASTNode_isSetUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_isSetUnits(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node has the attribute\n"
		"<code>sbml:units</code>.\n"
		"\n"
		"Only applies to MathML <code>&lt;cn&gt;</code> elements.\n"
		"\n"
		"@return true if this ASTNode has units, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_hasUnits", _wrap_ASTNode_hasUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_hasUnits(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node or any of its\n"
		"children nodes have the attribute <code>sbml:units</code>.\n"
		"\n"
		"@return true if this ASTNode or its children has units, \n"
		"false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setCharacter", _wrap_ASTNode_setCharacter, METH_VARARGS, (char *)"\n"
		"ASTNode_setCharacter(ASTNode self, char value) -> int\n"
		"\n"
		"Sets the value of this ASTNode to the given character.  If character\n"
		"is one of @c +, @c -, @c *, @c / or @c ^, the node type will be set\n"
		"accordingly.  For all other characters, the node type will be set to\n"
		"@link ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink.\n"
		"\n"
		"@param value the character value to which the node's value should be\n"
		"set.\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setName", _wrap_ASTNode_setName, METH_VARARGS, (char *)"\n"
		"ASTNode_setName(ASTNode self, char name) -> int\n"
		"\n"
		"Sets the value of this ASTNode to the given name.\n"
		"\n"
		"As a side-effect, this ASTNode object's type will be reset to\n"
		"@link ASTNodeType_t#AST_NAME AST_NAME@endlink if (and <em>only\n"
		"if</em>) the ASTNode was previously an operator (<code>isOperator() ==\n"
		"true</code>), number (<code>isNumber() == true</code>), or unknown.\n"
		"This allows names to be set for @link ASTNodeType_t#AST_FUNCTION\n"
		"AST_FUNCTION@endlink nodes and the like.\n"
		"\n"
		"@param name the string containing the name to which this node's value\n"
		"should be set\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setValue", _wrap_ASTNode_setValue, METH_VARARGS, (char *)"\n"
		"setValue(long value) -> int\n"
		"setValue(long numerator, long denominator) -> int\n"
		"setValue(double value) -> int\n"
		"ASTNode_setValue(ASTNode self, double mantissa, long exponent) -> int\n"
		"\n"
		"Sets the value of this ASTNode to the given real (@c double) in two\n"
		"parts: the mantissa and the exponent.  The node type is set to\n"
		"@link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink.\n"
		"\n"
		"@param mantissa the mantissa of this node's real-numbered value\n"
		"@param exponent the exponent of this node's real-numbered value\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setType", _wrap_ASTNode_setType, METH_VARARGS, (char *)"\n"
		"ASTNode_setType(ASTNode self, ASTNodeType_t type) -> int\n"
		"\n"
		"Sets the type of this ASTNode to the given <a class='el'\n"
		"href='#ASTNodeType_t'>ASTNodeType_t</a>.  A side-effect of doing this\n"
		"is that any numerical values previously stored in this node are reset\n"
		"to zero.\n"
		"\n"
		"@param type the type to which this node should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setUnits", _wrap_ASTNode_setUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_setUnits(ASTNode self, string units) -> int\n"
		"\n"
		"Sets the units of this ASTNode to units.\n"
		"\n"
		"The units will be set <em>only if</em> the ASTNode represents a MathML\n"
		"<code>&lt;cn&gt;</code> element, i.e., represents a number.  Callers\n"
		"may use isNumber() to inquire whether the node is of that type.\n"
		"\n"
		"@param units @c string representing the unit identifier.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_swapChildren", _wrap_ASTNode_swapChildren, METH_VARARGS, (char *)"\n"
		"ASTNode_swapChildren(ASTNode self, ASTNode that) -> int\n"
		"\n"
		"Swap the children of this ASTNode object with the children of the\n"
		"given ASTNode object.\n"
		"\n"
		"@param that the other node whose children should be used to replace\n"
		"<em>this</em> node's children\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_unsetUnits", _wrap_ASTNode_unsetUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_unsetUnits(ASTNode self) -> int\n"
		"\n"
		"Unsets the units of this ASTNode.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getDefinitionURL", _wrap_ASTNode_getDefinitionURL, METH_VARARGS, (char *)"\n"
		"ASTNode_getDefinitionURL(ASTNode self) -> XMLAttributes\n"
		"\n"
		"Gets the MathML @c definitionURL attribute value.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_replaceArgument", _wrap_ASTNode_replaceArgument, METH_VARARGS, (char *)"\n"
		"ASTNode_replaceArgument(ASTNode self, string bvar, ASTNode arg)\n"
		"\n"
		"Replaces occurences of a given name within this ASTNode with the\n"
		"name/value/formula represented by @p arg.\n"
		"\n"
		"For example, if the formula in this ASTNode is <code>x + y</code>,\n"
		"then the <code>&lt;bvar&gt;</code> is @c x and @c arg is an ASTNode\n"
		"representing the real value @c 3.  This method substitutes @c 3 for @c\n"
		"x within this ASTNode object.\n"
		"\n"
		"@param bvar a string representing the variable name to be substituted\n"
		"@param arg an ASTNode representing the name/value/formula to substitute\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getParentSBMLObject", _wrap_ASTNode_getParentSBMLObject, METH_VARARGS, (char *)"\n"
		"ASTNode_getParentSBMLObject(ASTNode self) -> SBase\n"
		"\n"
		"Returns the parent SBML object.\n"
		"\n"
		"@return the parent SBML object of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_reduceToBinary", _wrap_ASTNode_reduceToBinary, METH_VARARGS, (char *)"\n"
		"ASTNode_reduceToBinary(ASTNode self)\n"
		"\n"
		"Reduces this ASTNode to a binary tree.\n"
		"\n"
		"Example: if this ASTNode is <code>and(x, y, z)</code>, then the \n"
		"formula of the reduced node is <code>and(and(x, y), z)</code>.  The\n"
		"operation replaces the formula stored in the current ASTNode object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isWellFormedASTNode", _wrap_ASTNode_isWellFormedASTNode, METH_VARARGS, (char *)"\n"
		"ASTNode_isWellFormedASTNode(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ASTNode is well-formed.\n"
		"\n"
		"@note An ASTNode may be well-formed, with each node and its children\n"
		"having the appropriate number of children for the given type, but may\n"
		"still be invalid in the context of its use within an SBML model.\n"
		"\n"
		"@see hasCorrectNumberArguments()\n"
		"\n"
		"@return @c true if this ASTNode is well-formed, @c false otherwise.\n"
		" \n"
		"\n"
		""},
	 { (char *)"ASTNode_hasCorrectNumberArguments", _wrap_ASTNode_hasCorrectNumberArguments, METH_VARARGS, (char *)"\n"
		"ASTNode_hasCorrectNumberArguments(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ASTNode has the correct number of children for it's type.\n"
		"\n"
		"For example, an ASTNode with type @link ASTNodeType_t#AST_PLUS\n"
		"AST_PLUS@endlink expects 2 child nodes.\n"
		"\n"
		"@note This function performs a check on the toplevel node only.\n"
		"Child nodes are not checked.\n"
		"\n"
		"@see isWellFormedASTNode()\n"
		"\n"
		"@return @c true if this ASTNode is has appropriate number of children\n"
		"for it's type, @c false otherwise.\n"
		" \n"
		"\n"
		""},
	 { (char *)"ASTNode_getListOfNodes", _wrap_ASTNode_getListOfNodes, METH_VARARGS, (char *)"\n"
		"ASTNode_getListOfNodes(ASTNode self) -> ASTNodeList\n"
		"\n"
		"Performs a depth-first search of the tree rooted at this ASTNode\n"
		"object, and returns a List of nodes where the given function\n"
		"<code>predicate(node)</code> returns @c true (non-zero).\n"
		"\n"
		"For portability between different programming languages, the predicate\n"
		"is passed in as a pointer to a function.  The function definition must\n"
		"have the type @link ASTNode.h::ASTNodePredicate ASTNodePredicate\n"
		"@endlink, which is defined as\n"
		"@code\n"
		"int (*ASTNodePredicate) (const ASTNode_t *node);\n"
		"@endcode\n"
		"where a return value of non-zero represents @c true and zero\n"
		"represents @c false.\n"
		"\n"
		"@param predicate the predicate to use\n"
		"\n"
		"@return the list of nodes for which the predicate returned @c true\n"
		"(non-zero).  The List returned is owned by the caller and should be\n"
		"deleted after the caller is done using it.  The ASTNode objects in the\n"
		"list; however, are not owned by the caller (as they still belong to\n"
		"the tree itself), and therefore should not be deleted.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_swigregister", ASTNode_swigregister, METH_VARARGS, NULL},
	 { (char *)"parseFormula", _wrap_parseFormula, METH_VARARGS, (char *)"\n"
		"parseFormula(char formula) -> ASTNode_t\n"
		"\n"
		"Parses a text-string mathematical formula and returns a representation\n"
		"as an Abstract Syntax Tree.\n"
		"\n"
		"@if clike The text-string form of mathematical formulas produced by\n"
		"SBML_formulaToString() and read by SBML_parseFormula() are simple\n"
		"C-inspired infix notation taken from SBML Level&nbsp;1.  A formula in\n"
		"this text-string form therefore can be handed to a program that\n"
		"understands SBML Level&nbsp;1 mathematical expressions, or used as part\n"
		"of a formula translation system.  The syntax is described in detail in\n"
		"the documentation for ASTNode. @endif@if java The text-string form of\n"
		"mathematical formulas produced by <code><a\n"
		"href='libsbml.html'>libsbml.formulaToString()</a></code> and read by\n"
		"<code><a href='libsbml.html'>libsbml.parseFormula()</a></code> are\n"
		"simple C-inspired infix notation taken from SBML Level&nbsp;1.  A\n"
		"formula in this text-string form therefore can be handed to a program\n"
		"that understands SBML Level&nbsp;1 mathematical expressions, or used as\n"
		"part of a formula translation system.  The syntax is described in detail\n"
		"in the documentation for ASTNode.   @endif\n"
		"\n"
		"@param formula the string containing the mathematical formula.\n"
		"\n"
		"@return an ASTNode (the root of the expression tree).  If the formula\n"
		"contains a grammatical error, @c NULL is returned.\n"
		"\n"
		"\n"
		""},
	 { (char *)"formulaToString", _wrap_formulaToString, METH_VARARGS, (char *)"\n"
		"formulaToString(ASTNode_t tree) -> char\n"
		"\n"
		"Converts an ASTNode formula to a text string using a specific\n"
		"syntax for mathematical formulas.\n"
		"\n"
		"@if clike The text-string form of mathematical formulas produced by\n"
		"SBML_formulaToString() and read by SBML_parseFormula() are simple\n"
		"C-inspired infix notation taken from SBML Level&nbsp;1.  A formula in\n"
		"this text-string form therefore can be handed to a program that\n"
		"understands SBML Level&nbsp;1 mathematical expressions, or used as part\n"
		"of a formula translation system.  The syntax is described in detail in\n"
		"the documentation for ASTNode. @endif@if java The text-string form of\n"
		"mathematical formulas produced by <code><a\n"
		"href='libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)'>\n"
		"libsbml.formulaToString()</a></code> and read by\n"
		"<code><a href='libsbml.html#parseFormula(java.lang.String)'>\n"
		"libsbml.parseFormula()</a></code> are\n"
		"simple C-inspired infix notation taken from SBML Level&nbsp;1.  A\n"
		"formula in this text-string form therefore can be handed to a program\n"
		"that understands SBML Level&nbsp;1 mathematical expressions, or used as\n"
		"part of a formula translation system.  The syntax is described in detail\n"
		"in the documentation for ASTNode.   @endif\n"
		"\n"
		"@param tree the root of the ASTNode formula expression tree\n"
		"\n"
		"@return the formula from the given AST as an SBML Level 1 text-string\n"
		"mathematical formula.  The caller owns the returned string and is\n"
		"responsible for freeing it when it is no longer needed.\n"
		"@c NULL is returned if the given argument is @c NULL. \n"
		"\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_XMLAttributes", _wrap_delete_XMLAttributes, METH_VARARGS, (char *)"delete_XMLAttributes(XMLAttributes self)"},
	 { (char *)"new_XMLAttributes", _wrap_new_XMLAttributes, METH_VARARGS, (char *)"\n"
		"XMLAttributes()\n"
		"new_XMLAttributes(XMLAttributes orig) -> XMLAttributes\n"
		"\n"
		"Copy constructor; creates a copy of this XMLAttributes set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_clone", _wrap_XMLAttributes_clone, METH_VARARGS, (char *)"\n"
		"XMLAttributes_clone(XMLAttributes self) -> XMLAttributes\n"
		"\n"
		"Creates and returns a deep copy of this XMLAttributes set.\n"
		"\n"
		"@return a (deep) copy of this XMLAttributes set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_add", _wrap_XMLAttributes_add, METH_VARARGS, (char *)"\n"
		"add(string name, string value, string namespaceURI = \"\", \n"
		"    string prefix = \"\") -> int\n"
		"add(string name, string value, string namespaceURI = \"\") -> int\n"
		"add(string name, string value) -> int\n"
		"XMLAttributes_add(XMLAttributes self, XMLTriple triple, string value) -> int\n"
		"\n"
		"Adds an attribute with the given XMLTriple/value pair to this XMLAttributes set.\n"
		"\n"
		"@note if local name with the same namespace URI already exists in this attribute set, \n"
		"its value and prefix will be replaced.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"@param value a string, the value of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_removeResource", _wrap_XMLAttributes_removeResource, METH_VARARGS, (char *)"\n"
		"XMLAttributes_removeResource(XMLAttributes self, int n) -> int\n"
		"\n"
		"Removes an attribute with the given index from this XMLAttributes set.  \n"
		"\n"
		"@param n an integer the index of the resource to be deleted\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_remove", _wrap_XMLAttributes_remove, METH_VARARGS, (char *)"\n"
		"remove(int n) -> int\n"
		"remove(string name, string uri = \"\") -> int\n"
		"remove(string name) -> int\n"
		"XMLAttributes_remove(XMLAttributes self, XMLTriple triple) -> int\n"
		"\n"
		"Removes an attribute with the given XMLTriple from this XMLAttributes set.  \n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_clear", _wrap_XMLAttributes_clear, METH_VARARGS, (char *)"\n"
		"XMLAttributes_clear(XMLAttributes self) -> int\n"
		"\n"
		"Clears (deletes) all attributes in this XMLAttributes object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getIndex", _wrap_XMLAttributes_getIndex, METH_VARARGS, (char *)"\n"
		"getIndex(string name) -> int\n"
		"getIndex(string name, string uri) -> int\n"
		"XMLAttributes_getIndex(XMLAttributes self, XMLTriple triple) -> int\n"
		"\n"
		"Return the index of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute for which \n"
		"       the index is required.\n"
		"\n"
		"@return the index of an attribute with the given XMLTriple, or -1 if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getLength", _wrap_XMLAttributes_getLength, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getLength(XMLAttributes self) -> int\n"
		"\n"
		"Return the number of attributes in the set.\n"
		"\n"
		"@return the number of attributes in this XMLAttributes set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getName", _wrap_XMLAttributes_getName, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getName(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the local name of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose local name is \n"
		"required.\n"
		"\n"
		"@return the local name of an attribute in this list (by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLAttributes::hasAttribute(int index) to test for the attribute\n"
		"existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getPrefix", _wrap_XMLAttributes_getPrefix, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getPrefix(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the prefix of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefix is \n"
		"required.\n"
		"\n"
		"@return the namespace prefix of an attribute in this list (by\n"
		"position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned. Use\n"
		"XMLAttributes::hasAttribute(int index) to test for the attribute\n"
		"existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getPrefixedName", _wrap_XMLAttributes_getPrefixedName, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getPrefixedName(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the prefixed name of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefixed \n"
		"name is required.\n"
		"\n"
		"@return the prefixed name of an attribute in this list (by\n"
		"position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLAttributes::hasAttribute(int index) to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getURI", _wrap_XMLAttributes_getURI, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getURI(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the namespace URI of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose namespace URI is \n"
		"required.\n"
		"\n"
		"@return the namespace URI of an attribute in this list (by position).\n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLAttributes::hasAttribute(int index) to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getValue", _wrap_XMLAttributes_getValue, METH_VARARGS, (char *)"\n"
		"getValue(int index) -> string\n"
		"getValue(string name) -> string\n"
		"getValue(string name, string uri) -> string\n"
		"XMLAttributes_getValue(XMLAttributes self, XMLTriple triple) -> string\n"
		"\n"
		"Return a value of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute whose \n"
		"       value is required.\n"
		"\n"
		"@return The attribute value as a string.  \n"
		"\n"
		"@note If an attribute with the given XMLTriple does not exist, an\n"
		"empty string will be returned.  Use\n"
		"XMLAttributes::hasAttribute(const XMLTriple& triple) to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_hasAttribute", _wrap_XMLAttributes_hasAttribute, METH_VARARGS, (char *)"\n"
		"hasAttribute(int index) -> bool\n"
		"hasAttribute(string name, string uri = \"\") -> bool\n"
		"hasAttribute(string name) -> bool\n"
		"XMLAttributes_hasAttribute(XMLAttributes self, XMLTriple triple) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given XML triple exists in this XMLAttributes.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute \n"
		"\n"
		"@return @c true if an attribute with the given XML triple exists in this\n"
		"XMLAttributes, @c false otherwise.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_isEmpty", _wrap_XMLAttributes_isEmpty, METH_VARARGS, (char *)"\n"
		"XMLAttributes_isEmpty(XMLAttributes self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLAttributes set is empty.\n"
		"\n"
		"@return @c true if this XMLAttributes set is empty, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_swigregister", XMLAttributes_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_XMLNamespaces", _wrap_delete_XMLNamespaces, METH_VARARGS, (char *)"delete_XMLNamespaces(XMLNamespaces self)"},
	 { (char *)"new_XMLNamespaces", _wrap_new_XMLNamespaces, METH_VARARGS, (char *)"\n"
		"XMLNamespaces()\n"
		"new_XMLNamespaces(XMLNamespaces orig) -> XMLNamespaces\n"
		"\n"
		"Copy constructor; creates a copy of this XMLNamespaces list.\n"
		"\n"
		"@param orig the XMLNamespaces object to copy\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_clone", _wrap_XMLNamespaces_clone, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_clone(XMLNamespaces self) -> XMLNamespaces\n"
		"\n"
		"Creates and returns a deep copy of this XMLNamespaces list.\n"
		"\n"
		"@return a (deep) copy of this XMLNamespaces list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_add", _wrap_XMLNamespaces_add, METH_VARARGS, (char *)"\n"
		"add(string uri, string prefix = \"\") -> int\n"
		"XMLNamespaces_add(XMLNamespaces self, string uri) -> int\n"
		"\n"
		"Appends an XML namespace prefix and URI pair to this list of namespace\n"
		"declarations.\n"
		"\n"
		"An XMLNamespace object stores a list of pairs of namespaces and their\n"
		"prefixes.  If there is an XML namespace with the given @p uri prefix\n"
		"in this list, then its corresponding URI will be overwritten by the\n"
		"new @p uri.  Calling programs could use one of the other XMLNamespaces\n"
		"methods, such as\n"
		"@if clike XMLNamespaces::hasPrefix() @endif@if java XMLNamespaces::hasPrefix(String) @endif and \n"
		"@if clike XMLNamespaces::hasURI() @endif@if java XMLNamespaces::hasURI(String) @endif to\n"
		"inquire whether a given prefix and/or URI\n"
		"is already present in this XMLNamespaces object.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_remove", _wrap_XMLNamespaces_remove, METH_VARARGS, (char *)"\n"
		"remove(int index) -> int\n"
		"XMLNamespaces_remove(XMLNamespaces self, string prefix) -> int\n"
		"\n"
		"Removes an XML Namespace with the given prefix.\n"
		"\n"
		"@param prefix a string, prefix of the required namespace.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"\n"
		"@see remove(int index)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_clear", _wrap_XMLNamespaces_clear, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_clear(XMLNamespaces self) -> int\n"
		"\n"
		"Clears (deletes) all XML namespace declarations in this XMLNamespaces\n"
		"object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"\n"
		"@see remove(int index)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getIndex", _wrap_XMLNamespaces_getIndex, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_getIndex(XMLNamespaces self, string uri) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by URI.\n"
		"\n"
		"An XMLNamespace object stores a list of pairs of namespaces and their\n"
		"prefixes.  If this XMLNamespaces object contains a pair with the given\n"
		"URI @p uri, this method returns its index in the list.\n"
		"\n"
		"@param uri a string, the URI of the sought-after namespace.\n"
		"\n"
		"@return the index of the given declaration, or <code>-1</code> if not\n"
		"present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getIndexByPrefix", _wrap_XMLNamespaces_getIndexByPrefix, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_getIndexByPrefix(XMLNamespaces self, string prefix) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by prefix.\n"
		"\n"
		"An XMLNamespace object stores a list of pairs of namespaces and their\n"
		"prefixes.  If this XMLNamespaces object contains a pair with the given\n"
		"prefix @p prefix, this method returns its index in the list.\n"
		"\n"
		"@param prefix a string, the prefix string of the sought-after\n"
		"namespace\n"
		"\n"
		"@return the index of the given declaration, or <code>-1</code> if not\n"
		"present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getLength", _wrap_XMLNamespaces_getLength, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_getLength(XMLNamespaces self) -> int\n"
		"\n"
		"Returns the total number of URI-and-prefix pairs stored in this\n"
		"particular XMLNamespaces instance.\n"
		"\n"
		"@return the number of namespaces in this list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getPrefix", _wrap_XMLNamespaces_getPrefix, METH_VARARGS, (char *)"\n"
		"getPrefix(int index) -> string\n"
		"XMLNamespaces_getPrefix(XMLNamespaces self, string uri) -> string\n"
		"\n"
		"Look up the prefix of an XML namespace declaration by its URI.\n"
		"\n"
		"An XMLNamespace object stores a list of pairs of namespaces and their\n"
		"prefixes.  This method returns the prefix for a pair that has the\n"
		"given @p uri.\n"
		"\n"
		"@param uri a string, the URI of the prefix being sought\n"
		"\n"
		"@return the prefix of an XML namespace declaration given its URI, or\n"
		"an empty string if no such @p uri exists in this XMLNamespaces object\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getURI", _wrap_XMLNamespaces_getURI, METH_VARARGS, (char *)"\n"
		"getURI(int index) -> string\n"
		"getURI(string prefix = \"\") -> string\n"
		"XMLNamespaces_getURI(XMLNamespaces self) -> string\n"
		"\n"
		"Look up the URI of an XML namespace declaration by its prefix.\n"
		"\n"
		"An XMLNamespace object stores a list of pairs of namespaces and their\n"
		"prefixes.  This method returns the namespace URI for a pair that has\n"
		"the given @p prefix.\n"
		"\n"
		"@param prefix a string, the prefix of the required URI\n"
		"\n"
		"@return the URI of an XML namespace declaration having the given @p\n"
		"prefix, or an empty string if no such prefix-and-URI pair exists\n"
		"in this XMLNamespaces object\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"\n"
		"@see getURI()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_isEmpty", _wrap_XMLNamespaces_isEmpty, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_isEmpty(XMLNamespaces self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"XMLNamespaces list is empty.\n"
		"\n"
		"@return @c true if this XMLNamespaces list is empty, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_hasURI", _wrap_XMLNamespaces_hasURI, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_hasURI(XMLNamespaces self, string uri) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether an XML\n"
		"Namespace with the given URI is contained in this XMLNamespaces list.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in\n"
		"this XMLNamespaces list, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_hasPrefix", _wrap_XMLNamespaces_hasPrefix, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_hasPrefix(XMLNamespaces self, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether an XML\n"
		"Namespace with the given prefix is contained in this XMLNamespaces\n"
		"list.\n"
		"\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in\n"
		"this XMLNamespaces list, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_hasNS", _wrap_XMLNamespaces_hasNS, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_hasNS(XMLNamespaces self, string uri, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether an XML\n"
		"Namespace with the given URI and prefix pair is contained in this\n"
		"XMLNamespaces list.\n"
		"\n"
		"@param uri a string, the URI for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given uri/prefix pair is\n"
		"contained in this XMLNamespaces list, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_swigregister", XMLNamespaces_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_XMLToken", _wrap_delete_XMLToken, METH_VARARGS, (char *)"delete_XMLToken(XMLToken self)"},
	 { (char *)"new_XMLToken", _wrap_new_XMLToken, METH_VARARGS, (char *)"\n"
		"XMLToken()\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0, unsigned int column = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, \n"
		"    unsigned int column = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes)\n"
		"XMLToken(XMLTriple triple, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLToken(XMLTriple triple, unsigned int line = 0)\n"
		"XMLToken(XMLTriple triple)\n"
		"XMLToken(string chars, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLToken(string chars, unsigned int line = 0)\n"
		"XMLToken(string chars)\n"
		"new_XMLToken(XMLToken orig) -> XMLToken\n"
		"\n"
		"Copy constructor; creates a copy of this XMLToken.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_clone", _wrap_XMLToken_clone, METH_VARARGS, (char *)"\n"
		"XMLToken_clone(XMLToken self) -> XMLToken\n"
		"\n"
		"Creates and returns a deep copy of this XMLToken.\n"
		"\n"
		"@return a (deep) copy of this XMLToken set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttributes", _wrap_XMLToken_getAttributes, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttributes(XMLToken self) -> XMLAttributes\n"
		"\n"
		"Returns the attributes of this element.\n"
		"\n"
		"@return the XMLAttributes of this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setAttributes", _wrap_XMLToken_setAttributes, METH_VARARGS, (char *)"\n"
		"XMLToken_setAttributes(XMLToken self, XMLAttributes attributes) -> int\n"
		"\n"
		"Sets an XMLAttributes to this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param attributes XMLAttributes to be set to this XMLToken.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"\n"
		"@note This function replaces the existing XMLAttributes with the new one.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_addAttr", _wrap_XMLToken_addAttr, METH_VARARGS, (char *)"\n"
		"addAttr(string name, string value, string namespaceURI = \"\", \n"
		"    string prefix = \"\") -> int\n"
		"addAttr(string name, string value, string namespaceURI = \"\") -> int\n"
		"addAttr(string name, string value) -> int\n"
		"XMLToken_addAttr(XMLToken self, XMLTriple triple, string value) -> int\n"
		"\n"
		"Adds an attribute with the given XMLTriple/value pair to the attribute set\n"
		"in this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@note if local name with the same namespace URI already exists in the \n"
		"attribute set, its value and prefix will be replaced.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"@param value a string, the value of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_removeAttr", _wrap_XMLToken_removeAttr, METH_VARARGS, (char *)"\n"
		"removeAttr(int n) -> int\n"
		"removeAttr(string name, string uri = \"\") -> int\n"
		"removeAttr(string name) -> int\n"
		"XMLToken_removeAttr(XMLToken self, XMLTriple triple) -> int\n"
		"\n"
		"Removes an attribute with the given XMLTriple from the attribute set \n"
		"in this XMLToken.  \n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_clearAttributes", _wrap_XMLToken_clearAttributes, METH_VARARGS, (char *)"\n"
		"XMLToken_clearAttributes(XMLToken self) -> int\n"
		"\n"
		"Clears (deletes) all attributes in this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrIndex", _wrap_XMLToken_getAttrIndex, METH_VARARGS, (char *)"\n"
		"getAttrIndex(string name, string uri = \"\") -> int\n"
		"getAttrIndex(string name) -> int\n"
		"XMLToken_getAttrIndex(XMLToken self, XMLTriple triple) -> int\n"
		"\n"
		"Return the index of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute for which \n"
		"       the index is required.\n"
		"\n"
		"@return the index of an attribute with the given XMLTriple, or -1 if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttributesLength", _wrap_XMLToken_getAttributesLength, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttributesLength(XMLToken self) -> int\n"
		"\n"
		"Return the number of attributes in the attributes set.\n"
		"\n"
		"@return the number of attributes in the attributes set in this XMLToken.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrName", _wrap_XMLToken_getAttrName, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrName(XMLToken self, int index) -> string\n"
		"\n"
		"Return the local name of an attribute in the attributes set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose local name \n"
		"is required.\n"
		"\n"
		"@return the local name of an attribute in this list (by position).  \n"
		"\n"
		"@note If index\n"
		"is out of range, an empty string will be returned.  Use hasAttr(index) \n"
		"to test for the attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrPrefix", _wrap_XMLToken_getAttrPrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrPrefix(XMLToken self, int index) -> string\n"
		"\n"
		"Return the prefix of an attribute in the attribute set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefix is \n"
		"required.\n"
		"\n"
		"@return the namespace prefix of an attribute in the attribute set\n"
		"(by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be\n"
		"returned. Use hasAttr(index) to test for the attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrPrefixedName", _wrap_XMLToken_getAttrPrefixedName, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrPrefixedName(XMLToken self, int index) -> string\n"
		"\n"
		"Return the prefixed name of an attribute in the attribute set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefixed \n"
		"name is required.\n"
		"\n"
		"@return the prefixed name of an attribute in the attribute set \n"
		"(by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be\n"
		"returned.  Use hasAttr(index) to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrURI", _wrap_XMLToken_getAttrURI, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrURI(XMLToken self, int index) -> string\n"
		"\n"
		"Return the namespace URI of an attribute in the attribute set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose namespace \n"
		"URI is required.\n"
		"\n"
		"@return the namespace URI of an attribute in the attribute set (by position).\n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"hasAttr(index) to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrValue", _wrap_XMLToken_getAttrValue, METH_VARARGS, (char *)"\n"
		"getAttrValue(int index) -> string\n"
		"getAttrValue(string name, string uri = \"\") -> string\n"
		"getAttrValue(string name) -> string\n"
		"XMLToken_getAttrValue(XMLToken self, XMLTriple triple) -> string\n"
		"\n"
		"Return a value of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute whose \n"
		"       value is required.\n"
		"\n"
		"@return The attribute value as a string.  \n"
		"\n"
		"@note If an attribute with the\n"
		"given XMLTriple does not exist, an empty string will be returned.  \n"
		"Use hasAttr(triple) to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasAttr", _wrap_XMLToken_hasAttr, METH_VARARGS, (char *)"\n"
		"hasAttr(int index) -> bool\n"
		"hasAttr(string name, string uri = \"\") -> bool\n"
		"hasAttr(string name) -> bool\n"
		"XMLToken_hasAttr(XMLToken self, XMLTriple triple) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given XML triple exists in the attribute set in \n"
		"this XMLToken \n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute \n"
		"\n"
		"@return @c true if an attribute with the given XML triple exists\n"
		"in the attribute set in this XMLToken, @c false otherwise.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isAttributesEmpty", _wrap_XMLToken_isAttributesEmpty, METH_VARARGS, (char *)"\n"
		"XMLToken_isAttributesEmpty(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"the attribute set in this XMLToken set is empty.\n"
		"\n"
		"@return @c true if the attribute set in this XMLToken is empty, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaces", _wrap_XMLToken_getNamespaces, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespaces(XMLToken self) -> XMLNamespaces\n"
		"\n"
		"Returns the XML namespace declarations for this XML element.\n"
		"\n"
		"@return the XML namespace declarations for this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setNamespaces", _wrap_XMLToken_setNamespaces, METH_VARARGS, (char *)"\n"
		"XMLToken_setNamespaces(XMLToken self, XMLNamespaces namespaces) -> int\n"
		"\n"
		"Sets an XMLnamespaces to this XML element.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param namespaces XMLNamespaces to be set to this XMLToken.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"\n"
		"@note This function replaces the existing XMLNamespaces with the new one.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_addNamespace", _wrap_XMLToken_addNamespace, METH_VARARGS, (char *)"\n"
		"addNamespace(string uri, string prefix = \"\") -> int\n"
		"XMLToken_addNamespace(XMLToken self, string uri) -> int\n"
		"\n"
		"Appends an XML namespace prefix and URI pair to this XMLToken.\n"
		"If there is an XML namespace with the given prefix in this XMLToken, \n"
		"then the existing XML namespace will be overwritten by the new one.\n"
		"\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_removeNamespace", _wrap_XMLToken_removeNamespace, METH_VARARGS, (char *)"\n"
		"removeNamespace(int index) -> int\n"
		"XMLToken_removeNamespace(XMLToken self, string prefix) -> int\n"
		"\n"
		"Removes an XML Namespace with the given prefix.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param prefix a string, prefix of the required namespace.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_clearNamespaces", _wrap_XMLToken_clearNamespaces, METH_VARARGS, (char *)"\n"
		"XMLToken_clearNamespaces(XMLToken self) -> int\n"
		"\n"
		"Clears (deletes) all XML namespace declarations in the XMLNamespaces of\n"
		"this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaceIndex", _wrap_XMLToken_getNamespaceIndex, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespaceIndex(XMLToken self, string uri) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by URI.\n"
		"\n"
		"@param uri a string, uri of the required namespace.\n"
		"\n"
		"@return the index of the given declaration, or -1 if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaceIndexByPrefix", _wrap_XMLToken_getNamespaceIndexByPrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespaceIndexByPrefix(XMLToken self, string prefix) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by prefix.\n"
		"\n"
		"@param prefix a string, prefix of the required namespace.\n"
		"\n"
		"@return the index of the given declaration, or -1 if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespacesLength", _wrap_XMLToken_getNamespacesLength, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespacesLength(XMLToken self) -> int\n"
		"\n"
		"Returns the number of XML namespaces stored in the XMLNamespaces \n"
		"of this XMLToken.\n"
		"\n"
		"@return the number of namespaces in this list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespacePrefix", _wrap_XMLToken_getNamespacePrefix, METH_VARARGS, (char *)"\n"
		"getNamespacePrefix(int index) -> string\n"
		"XMLToken_getNamespacePrefix(XMLToken self, string uri) -> string\n"
		"\n"
		"Look up the prefix of an XML namespace declaration by its URI.\n"
		"\n"
		"@param uri a string, the URI of the prefix being sought\n"
		"\n"
		"@return the prefix of an XML namespace declaration given its URI.  \n"
		"\n"
		"@note If @p uri does not exist, an empty string will be returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaceURI", _wrap_XMLToken_getNamespaceURI, METH_VARARGS, (char *)"\n"
		"getNamespaceURI(int index) -> string\n"
		"getNamespaceURI(string prefix = \"\") -> string\n"
		"XMLToken_getNamespaceURI(XMLToken self) -> string\n"
		"\n"
		"Look up the URI of an XML namespace declaration by its prefix.\n"
		"\n"
		"@param prefix a string, the prefix of the required URI\n"
		"\n"
		"@return the URI of an XML namespace declaration given its prefix.  \n"
		"\n"
		"@note If @p prefix does not exist, an empty string will be returned.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isNamespacesEmpty", _wrap_XMLToken_isNamespacesEmpty, METH_VARARGS, (char *)"\n"
		"XMLToken_isNamespacesEmpty(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"the XMLNamespaces of this XMLToken is empty.\n"
		"\n"
		"@return @c true if the XMLNamespaces of this XMLToken is empty, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasNamespaceURI", _wrap_XMLToken_hasNamespaceURI, METH_VARARGS, (char *)"\n"
		"XMLToken_hasNamespaceURI(XMLToken self, string uri) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"an XML Namespace with the given URI is contained in the XMLNamespaces of\n"
		"this XMLToken.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in the\n"
		"XMLNamespaces of this XMLToken,  @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasNamespacePrefix", _wrap_XMLToken_hasNamespacePrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_hasNamespacePrefix(XMLToken self, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"an XML Namespace with the given prefix is contained in the XMLNamespaces of\n"
		"this XMLToken.\n"
		"\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in the\n"
		"XMLNamespaces of this XMLToken, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasNamespaceNS", _wrap_XMLToken_hasNamespaceNS, METH_VARARGS, (char *)"\n"
		"XMLToken_hasNamespaceNS(XMLToken self, string uri, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"an XML Namespace with the given uri/prefix pair is contained in the \n"
		"XMLNamespaces ofthis XMLToken.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given uri/prefix pair is \n"
		"contained in the XMLNamespaces of this XMLToken,  @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setTriple", _wrap_XMLToken_setTriple, METH_VARARGS, (char *)"\n"
		"XMLToken_setTriple(XMLToken self, XMLTriple triple) -> int\n"
		"\n"
		"Sets the XMLTripe (name, uri and prefix) of this XML element.\n"
		"Nothing will be done if this XML element is a text node.\n"
		"\n"
		"@param triple XMLTriple to be added to this XML element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getName", _wrap_XMLToken_getName, METH_VARARGS, (char *)"\n"
		"XMLToken_getName(XMLToken self) -> string\n"
		"\n"
		"Returns the (unqualified) name of this XML element.\n"
		"\n"
		"@return the (unqualified) name of this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getPrefix", _wrap_XMLToken_getPrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_getPrefix(XMLToken self) -> string\n"
		"\n"
		"Returns the namespace prefix of this XML element.\n"
		"\n"
		"@return the namespace prefix of this XML element.  \n"
		"\n"
		"@note If no prefix\n"
		"exists, an empty string will be return.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getURI", _wrap_XMLToken_getURI, METH_VARARGS, (char *)"\n"
		"XMLToken_getURI(XMLToken self) -> string\n"
		"\n"
		"Returns the namespace URI of this XML element.\n"
		"\n"
		"@return the namespace URI of this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getCharacters", _wrap_XMLToken_getCharacters, METH_VARARGS, (char *)"\n"
		"XMLToken_getCharacters(XMLToken self) -> string\n"
		"\n"
		"Returns the text of this element.\n"
		"\n"
		"@return the characters of this XML text.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_append", _wrap_XMLToken_append, METH_VARARGS, (char *)"\n"
		"XMLToken_append(XMLToken self, string chars) -> int\n"
		"\n"
		"Appends characters to this XML text content.\n"
		"\n"
		"@param chars string, characters to append\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getColumn", _wrap_XMLToken_getColumn, METH_VARARGS, (char *)"\n"
		"XMLToken_getColumn(XMLToken self) -> unsigned int\n"
		"\n"
		"Returns the column at which this XMLToken occurred in the input\n"
		"document or data stream.\n"
		"\n"
		"@return the column at which this XMLToken occurred.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getLine", _wrap_XMLToken_getLine, METH_VARARGS, (char *)"\n"
		"XMLToken_getLine(XMLToken self) -> unsigned int\n"
		"\n"
		"Returns the line at which this XMLToken occurred in the input document\n"
		"or data stream.\n"
		"\n"
		"@return the line at which this XMLToken occurred.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isElement", _wrap_XMLToken_isElement, METH_VARARGS, (char *)"\n"
		"XMLToken_isElement(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isEnd", _wrap_XMLToken_isEnd, METH_VARARGS, (char *)"\n"
		"XMLToken_isEnd(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML end element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML end element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isEndFor", _wrap_XMLToken_isEndFor, METH_VARARGS, (char *)"\n"
		"XMLToken_isEndFor(XMLToken self, XMLToken element) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML end element for the given start element.\n"
		"\n"
		"@param element XMLToken, element for which query is made.\n"
		"\n"
		"@return @c true if this XMLToken is an XML end element for the given\n"
		"XMLToken start element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isEOF", _wrap_XMLToken_isEOF, METH_VARARGS, (char *)"\n"
		"XMLToken_isEOF(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an end of file marker.\n"
		"\n"
		"@return @c true if this XMLToken is an end of file (input) marker, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isStart", _wrap_XMLToken_isStart, METH_VARARGS, (char *)"\n"
		"XMLToken_isStart(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML start element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML start element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isText", _wrap_XMLToken_isText, METH_VARARGS, (char *)"\n"
		"XMLToken_isText(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML text element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML text element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setEnd", _wrap_XMLToken_setEnd, METH_VARARGS, (char *)"\n"
		"XMLToken_setEnd(XMLToken self) -> int\n"
		"\n"
		"Declares this XML start element is also an end element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setEOF", _wrap_XMLToken_setEOF, METH_VARARGS, (char *)"\n"
		"XMLToken_setEOF(XMLToken self) -> int\n"
		"\n"
		"Declares this XMLToken is an end-of-file (input) marker.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_unsetEnd", _wrap_XMLToken_unsetEnd, METH_VARARGS, (char *)"\n"
		"XMLToken_unsetEnd(XMLToken self) -> int\n"
		"\n"
		"Declares this XML start/end element is no longer an end element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_toString", _wrap_XMLToken_toString, METH_VARARGS, (char *)"\n"
		"XMLToken_toString(XMLToken self) -> string\n"
		"\n"
		"Prints a string representation of the underlying token stream, for\n"
		"debugging purposes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_swigregister", XMLToken_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_XMLNode", _wrap_delete_XMLNode, METH_VARARGS, (char *)"delete_XMLNode(XMLNode self)"},
	 { (char *)"new_XMLNode", _wrap_new_XMLNode, METH_VARARGS, (char *)"\n"
		"XMLNode()\n"
		"XMLNode(XMLToken token)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0, unsigned int column = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, \n"
		"    unsigned int column = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes)\n"
		"XMLNode(XMLTriple triple, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLNode(XMLTriple triple, unsigned int line = 0)\n"
		"XMLNode(XMLTriple triple)\n"
		"XMLNode(string chars, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLNode(string chars, unsigned int line = 0)\n"
		"XMLNode(string chars)\n"
		"new_XMLNode(XMLNode orig) -> XMLNode\n"
		"\n"
		"Copy constructor; creates a copy of this XMLNode.\n"
		"\n"
		"@param orig the XMLNode instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_clone", _wrap_XMLNode_clone, METH_VARARGS, (char *)"\n"
		"XMLNode_clone(XMLNode self) -> XMLNode\n"
		"\n"
		"Creates and returns a deep copy of this XMLNode.\n"
		"\n"
		"@return a (deep) copy of this XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_addChild", _wrap_XMLNode_addChild, METH_VARARGS, (char *)"\n"
		"XMLNode_addChild(XMLNode self, XMLNode node) -> int\n"
		"\n"
		"Adds a copy of @p node as a child of this XMLNode.\n"
		"\n"
		"The given @p node is added at the end of the list of children.\n"
		"\n"
		"@param node the XMLNode to be added as child.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"\n"
		"@note The given node is added at the end of the children list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_insertChild", _wrap_XMLNode_insertChild, METH_VARARGS, (char *)"\n"
		"XMLNode_insertChild(XMLNode self, unsigned int n, XMLNode node) -> XMLNode\n"
		"\n"
		"Inserts a copy of the given node as the <code>n</code>th child of this\n"
		"XMLNode.\n"
		"\n"
		"If the given index @p n is out of range for this XMLNode instance,\n"
		"the @p node is added at the end of the list of children.  Even in\n"
		"that situation, this method does not throw an error.\n"
		"\n"
		"@param n an integer, the index at which the given node is inserted\n"
		"@param node an XMLNode to be inserted as <code>n</code>th child.\n"
		"\n"
		"@return a reference to the newly-inserted child @p node\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_removeChild", _wrap_XMLNode_removeChild, METH_VARARGS, (char *)"\n"
		"XMLNode_removeChild(XMLNode self, unsigned int n) -> XMLNode\n"
		"\n"
		"Removes the <code>n</code>th child of this XMLNode and returns the\n"
		"removed node.\n"
		"\n"
		"It is important to keep in mind that a given XMLNode may have more\n"
		"than one child.  Calling this method erases all existing references to\n"
		"child nodes @em after the given position @p n.  If the index @p n is\n"
		"greater than the number of child nodes in this XMLNode, this method\n"
		"takes no action (and returns @c NULL).\n"
		"\n"
		"@param n an integer, the index of the node to be removed\n"
		"\n"
		"@return the removed child, or @c NULL if @p n is greater than the number\n"
		"of children in this node\n"
		"\n"
		"@note The caller owns the returned node and is responsible for deleting it.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_removeChildren", _wrap_XMLNode_removeChildren, METH_VARARGS, (char *)"\n"
		"XMLNode_removeChildren(XMLNode self) -> int\n"
		"\n"
		"Removes all children from this node.\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_getChild", _wrap_XMLNode_getChild, METH_VARARGS, (char *)"\n"
		"getChild(unsigned int n) -> XMLNode\n"
		"XMLNode_getChild(XMLNode self, unsigned int n) -> XMLNode\n"
		"\n"
		"Returns the  <code>n</code>th child of this XMLNode.\n"
		"\n"
		"If the index @p n is greater than the number of child nodes, or it is\n"
		"0 or less, this method returns an empty node.\n"
		"\n"
		"@param n an integer, the index of the node to return\n"
		"\n"
		"@return the  <code>n</code>th child of this XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_getNumChildren", _wrap_XMLNode_getNumChildren, METH_VARARGS, (char *)"\n"
		"XMLNode_getNumChildren(XMLNode self) -> unsigned int\n"
		"\n"
		"Returns the number of children for this XMLNode.\n"
		"\n"
		"@return the number of children for this XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_toXMLString", _wrap_XMLNode_toXMLString, METH_VARARGS, (char *)"\n"
		"XMLNode_toXMLString(XMLNode self) -> string\n"
		"\n"
		"Returns a string representation of this XMLNode. \n"
		"\n"
		"@return a string derived from this XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_convertXMLNodeToString", _wrap_XMLNode_convertXMLNodeToString, METH_VARARGS, (char *)"\n"
		"XMLNode_convertXMLNodeToString(XMLNode node) -> string\n"
		"\n"
		"Returns a string representation of a given XMLNode. \n"
		"\n"
		"@param node the XMLNode to be represented as a string\n"
		"\n"
		"@return a string-form representation of @p node\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_convertStringToXMLNode", _wrap_XMLNode_convertStringToXMLNode, METH_VARARGS, (char *)"\n"
		"convertStringToXMLNode(string xmlstr, XMLNamespaces xmlns = None) -> XMLNode\n"
		"XMLNode_convertStringToXMLNode(string xmlstr) -> XMLNode\n"
		"\n"
		"Returns an XMLNode which is derived from a string containing XML\n"
		"content.\n"
		"\n"
		"The XML namespace must be defined using argument @p xmlns if the\n"
		"corresponding XML namespace attribute is not part of the string of the\n"
		"first argument.\n"
		"\n"
		"@param xmlstr string to be converted to a XML node.\n"
		"@param xmlns XMLNamespaces the namespaces to set (default value is @c NULL).\n"
		"\n"
		"@note The caller owns the returned XMLNode and is reponsible for deleting it.\n"
		"The returned XMLNode object is a dummy root (container) XMLNode if the top-level \n"
		"element in the given XML string is NOT @p html, @p body, @p annotation, @p notes.\n"
		"In the dummy root node, each top-level element in the given XML string is contained\n"
		"as a child XMLNode. XMLToken::isEOF() can be used to identify if the returned XMLNode \n"
		"object is a dummy node.\n"
		"\n"
		"@return a XMLNode which is converted from string @p xmlstr. @c NULL is returned\n"
		"if the conversion failed. \n"
		"\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_swigregister", XMLNode_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_XMLTriple", _wrap_new_XMLTriple, METH_VARARGS, (char *)"\n"
		"XMLTriple()\n"
		"XMLTriple(string name, string uri, string prefix)\n"
		"XMLTriple(string triplet, char sepchar = ' ')\n"
		"XMLTriple(string triplet)\n"
		"new_XMLTriple(XMLTriple orig) -> XMLTriple\n"
		"\n"
		"Copy constructor; creates a copy of this XMLTriple set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_clone", _wrap_XMLTriple_clone, METH_VARARGS, (char *)"\n"
		"XMLTriple_clone(XMLTriple self) -> XMLTriple\n"
		"\n"
		"Creates and returns a deep copy of this XMLTriple set.\n"
		"\n"
		"@return a (deep) copy of this XMLTriple set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getName", _wrap_XMLTriple_getName, METH_VARARGS, (char *)"\n"
		"XMLTriple_getName(XMLTriple self) -> string\n"
		"\n"
		"Returns the @em name portion of this XMLTriple.\n"
		"\n"
		"@return a string, the name from this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getPrefix", _wrap_XMLTriple_getPrefix, METH_VARARGS, (char *)"\n"
		"XMLTriple_getPrefix(XMLTriple self) -> string\n"
		"\n"
		"Returns the @em prefix portion of this XMLTriple.\n"
		"\n"
		"@return a string, the @em prefix portion of this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getURI", _wrap_XMLTriple_getURI, METH_VARARGS, (char *)"\n"
		"XMLTriple_getURI(XMLTriple self) -> string\n"
		"\n"
		"Returns the @em URI portion of this XMLTriple.\n"
		"\n"
		"@return URI a string, the @em prefix portion of this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getPrefixedName", _wrap_XMLTriple_getPrefixedName, METH_VARARGS, (char *)"\n"
		"XMLTriple_getPrefixedName(XMLTriple self) -> string\n"
		"\n"
		"Returns the prefixed name from this XMLTriple.\n"
		"\n"
		"@return a string, the prefixed name from this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_isEmpty", _wrap_XMLTriple_isEmpty, METH_VARARGS, (char *)"\n"
		"XMLTriple_isEmpty(XMLTriple self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLTriple is empty.\n"
		"\n"
		"@return @c true if this XMLTriple is empty, @c false otherwise.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_XMLTriple", _wrap_delete_XMLTriple, METH_VARARGS, (char *)"delete_XMLTriple(XMLTriple self)"},
	 { (char *)"XMLTriple_swigregister", XMLTriple_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_XMLOutputStream", _wrap_new_XMLOutputStream, METH_VARARGS, (char *)"\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\", bool writeXMLDecl = True, \n"
		"    string programName = \"\", string programVersion = \"\")\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\", bool writeXMLDecl = True, \n"
		"    string programName = \"\")\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\", bool writeXMLDecl = True)\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\")\n"
		"new_XMLOutputStream(ostream stream) -> XMLOutputStream\n"
		"\n"
		"Unitialized XMLOutputStreams may only be created by subclasses.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_endElement", _wrap_XMLOutputStream_endElement, METH_VARARGS, (char *)"\n"
		"endElement(string name)\n"
		"XMLOutputStream_endElement(XMLOutputStream self, XMLTriple triple)\n"
		"\n"
		"Writes the given XML end element 'prefix:name' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_setAutoIndent", _wrap_XMLOutputStream_setAutoIndent, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_setAutoIndent(XMLOutputStream self, bool indent)\n"
		"\n"
		"Turns automatic indentation on or off for this XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_startElement", _wrap_XMLOutputStream_startElement, METH_VARARGS, (char *)"\n"
		"startElement(string name)\n"
		"XMLOutputStream_startElement(XMLOutputStream self, XMLTriple triple)\n"
		"\n"
		"Writes the given XML start element 'prefix:name' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_startEndElement", _wrap_XMLOutputStream_startEndElement, METH_VARARGS, (char *)"\n"
		"startEndElement(string name)\n"
		"XMLOutputStream_startEndElement(XMLOutputStream self, XMLTriple triple)\n"
		"\n"
		"Writes the given XML start and end element 'prefix:name' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeAttribute", _wrap_XMLOutputStream_writeAttribute, METH_VARARGS, (char *)"\n"
		"writeAttribute(string name, string value)\n"
		"writeAttribute(XMLTriple triple, string value)\n"
		"writeAttribute(string name, bool value)\n"
		"writeAttribute(XMLTriple triple, bool value)\n"
		"writeAttribute(string name, double value)\n"
		"writeAttribute(XMLTriple triple, double value)\n"
		"writeAttribute(string name, long value)\n"
		"writeAttribute(XMLTriple triple, long value)\n"
		"writeAttribute(string name, int value)\n"
		"XMLOutputStream_writeAttribute(XMLOutputStream self, XMLTriple triple, int value)\n"
		"\n"
		"Writes the given attribute, prefix:name='value' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeXMLDecl", _wrap_XMLOutputStream_writeXMLDecl, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_writeXMLDecl(XMLOutputStream self)\n"
		"\n"
		"Writes the XML declaration:\n"
		"<?xml version='1.0' encoding='...'?>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeComment", _wrap_XMLOutputStream_writeComment, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_writeComment(XMLOutputStream self, string programName, string programVersion)\n"
		"\n"
		"Writes an XML comment:\n"
		"<?xml version='1.0' encoding='...'?>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_downIndent", _wrap_XMLOutputStream_downIndent, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_downIndent(XMLOutputStream self)\n"
		"\n"
		"Decreases the indentation level for this XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_upIndent", _wrap_XMLOutputStream_upIndent, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_upIndent(XMLOutputStream self)\n"
		"\n"
		"Increases the indentation level for this XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeAttributeBool", _wrap_XMLOutputStream_writeAttributeBool, METH_VARARGS, (char *)"\n"
		"writeAttributeBool(string name, bool value)\n"
		"XMLOutputStream_writeAttributeBool(XMLOutputStream self, XMLTriple name, bool value)\n"
		""},
	 { (char *)"delete_XMLOutputStream", _wrap_delete_XMLOutputStream, METH_VARARGS, (char *)"delete_XMLOutputStream(XMLOutputStream self)"},
	 { (char *)"XMLOutputStream_swigregister", XMLOutputStream_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_XMLError", _wrap_new_XMLError, METH_VARARGS, (char *)"\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0, \n"
		"    unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL, \n"
		"    unsigned int category = LIBSBML_CAT_INTERNAL)\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0, \n"
		"    unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL)\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0, \n"
		"    unsigned int column = 0)\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0)\n"
		"XMLError(int errorId = 0, string details = \"\")\n"
		"XMLError(int errorId = 0)\n"
		"XMLError()\n"
		"new_XMLError(XMLError orig) -> XMLError\n"
		"\n"
		"Copy constructor; creates a copy of this XMLError.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_XMLError", _wrap_delete_XMLError, METH_VARARGS, (char *)"delete_XMLError(XMLError self)"},
	 { (char *)"XMLError_getErrorId", _wrap_XMLError_getErrorId, METH_VARARGS, (char *)"\n"
		"XMLError_getErrorId(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the identifier of this error.\n"
		"\n"
		"@return the id of this XMLError.\n"
		"\n"
		"@see getMessage()\n"
		"@see getShortMessage()\n"
		"@see getCategory()\n"
		"@see getSeverity()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getMessage", _wrap_XMLError_getMessage, METH_VARARGS, (char *)"\n"
		"XMLError_getMessage(XMLError self) -> string\n"
		"\n"
		"Returns the message text of this error.\n"
		"\n"
		"The message associated with an error object describes the nature of\n"
		"the problem.  The message returned by this method is generally longer\n"
		"and clearer than the message returned by XMLError::getShortMessage(),\n"
		"but not in all cases.\n"
		"\n"
		"Callers may use XMLError::getCategory() and XMLError::getSeverity() to\n"
		"obtain additional information about the nature and severity of the\n"
		"problem.\n"
		"\n"
		"@return the message text\n"
		"\n"
		"@see getErrorId()\n"
		"@see getShortMessage()\n"
		"@see getCategory()\n"
		"@see getSeverity()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getShortMessage", _wrap_XMLError_getShortMessage, METH_VARARGS, (char *)"\n"
		"XMLError_getShortMessage(XMLError self) -> string\n"
		"\n"
		"Returns a brief message for this error.\n"
		"\n"
		"This is an alternative error message that, in general, is as short as\n"
		"the authors could make it.  However, brevity is often inversely\n"
		"proportional to clarity, so this short message may not be sufficiently\n"
		"informative to understand the nature of the error.  Calling\n"
		"applications may wish to check XMLError::getMessage() in addition or\n"
		"instead.\n"
		"\n"
		"@return the short error message text\n"
		"\n"
		"@see getErrorId()\n"
		"@see getMessage()\n"
		"@see getCategory()\n"
		"@see getSeverity()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getLine", _wrap_XMLError_getLine, METH_VARARGS, (char *)"\n"
		"XMLError_getLine(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the line number in the XML input near where the error, warning\n"
		"or other diagnostic occurred.\n"
		"\n"
		"We say 'near where the problem occurred', because many factors affect\n"
		"how accurate the line/column information ultimately is.  For example,\n"
		"different XML parsers have different conventions for which line and\n"
		"column number they report for a particular problem (which in turn\n"
		"makes a difference when a problem involves an opening XML tag on one\n"
		"line and a closing tag on another line).  In some situations, some\n"
		"parsers report invalid line and/or column numbers altogether.  If this\n"
		"occurs, the line and/or column number in the XMLError object will be\n"
		"set to the the value of the maximum unsigned long integer\n"
		"representable on the platform where libSBML is running.  (This is\n"
		"equal to the constant named <code>ULONG_MAX</code> in C and C++.)  The\n"
		"probability that a true line or column number in an SBML model would\n"
		"equal this value is vanishingly small; thus, if an application\n"
		"encounters these values in an XMLError object, it can assume no valid\n"
		"line/column number could be provided by libSBML in that situation.\n"
		"\n"
		"@return the line number\n"
		"\n"
		"@see getColumn()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getColumn", _wrap_XMLError_getColumn, METH_VARARGS, (char *)"\n"
		"XMLError_getColumn(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the column number in the XML input near where the error,\n"
		"warning or other diagnostic occurred.\n"
		"\n"
		"We say 'near where the problem occurred', because many factors affect\n"
		"how accurate the line/column information ultimately is.  For example,\n"
		"different XML parsers have different conventions for which line and\n"
		"column number they report for a particular problem (which in turn\n"
		"makes a difference when a problem involves an opening XML tag on one\n"
		"line and a closing tag on another line).  In some situations, some\n"
		"parsers report invalid line and/or column numbers altogether.  If this\n"
		"occurs, the line and/or column number in the XMLError object will be\n"
		"set to the the value of the maximum unsigned long integer\n"
		"representable on the platform where libSBML is running.  (This is\n"
		"equal to the constant named <code>ULONG_MAX</code> in C and C++.)  The\n"
		"probability that a true line or column number in an SBML model would\n"
		"equal this value is vanishingly small; thus, if an application\n"
		"encounters these values in an XMLError object, it can assume no valid\n"
		"line/column number could be provided by libSBML in that situation.\n"
		"\n"
		"@return the column number\n"
		"\n"
		"@see getLine()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getSeverity", _wrap_XMLError_getSeverity, METH_VARARGS, (char *)"\n"
		"XMLError_getSeverity(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the severity of this error.\n"
		"\n"
		"XMLError defines an enumeration of severity codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own severity codes with numbers higher than those in the predefined\n"
		"set of severity codes.\n"
		"\n"
		"@return the severity of this XMLError.\n"
		"\n"
		"@see getSeverityAsString()\n"
		"@see getCategory()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getSeverityAsString", _wrap_XMLError_getSeverityAsString, METH_VARARGS, (char *)"\n"
		"XMLError_getSeverityAsString(XMLError self) -> string\n"
		"\n"
		"Returns a string describing the severity level of this error.\n"
		"\n"
		"XMLError defines an enumeration of severity codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own severity codes with numbers higher than those in the predefined\n"
		"set of severity codes.\n"
		"\n"
		"@return string representing the severity of this XMLError.\n"
		"\n"
		"@see getSeverity()\n"
		"@see getCategoryAsString()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getCategory", _wrap_XMLError_getCategory, METH_VARARGS, (char *)"\n"
		"XMLError_getCategory(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the category of this error.\n"
		"\n"
		"XMLError defines an enumeration of category codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own categories with numbers higher than those in the predefined\n"
		"set of category codes.\n"
		"\n"
		"Categories can be used to partition errors into distinct groups.\n"
		"Among other things, this can be used to prevent id conflicts by\n"
		"uniquely identifying an XMLError by both id and category.\n"
		"\n"
		"@return the category of this XMLError.\n"
		"\n"
		"@see getSeverity()\n"
		"@see getCategoryAsString()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getCategoryAsString", _wrap_XMLError_getCategoryAsString, METH_VARARGS, (char *)"\n"
		"XMLError_getCategoryAsString(XMLError self) -> string\n"
		"\n"
		"Returns a string describing the category of this error.\n"
		"\n"
		"XMLError defines an enumeration of category codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own categories with numbers higher than those in the predefined\n"
		"set of category codes.\n"
		"\n"
		"Categories can be used to partition errors into distinct groups.\n"
		"Among other things, this can be used to prevent id conflicts by\n"
		"uniquely identifying an XMLError by both id and category.\n"
		"\n"
		"@return string representing the category of this XMLError.\n"
		"\n"
		"@see getCategory()\n"
		"@see getSeverityAsString()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isInfo", _wrap_XMLError_isInfo, METH_VARARGS, (char *)"\n"
		"XMLError_isInfo(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error object is for information purposes only.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError::getSeverity()) and then comparing it to the\n"
		"value <code>LIBSBML_SEV_INFO</code> from the\n"
		"@if clike enumeration\n"
		"#XMLErrorSeverity_t. @endif@if java set of predefined\n"
		"severity codes.@endif\n"
		"\n"
		"@return @c true if this XMLError is for informational purposes only,\n"
		"@c false otherwise.\n"
		"\n"
		"@see isWarning()\n"
		"@see isError()\n"
		"@see isFatal()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isWarning", _wrap_XMLError_isWarning, METH_VARARGS, (char *)"\n"
		"XMLError_isWarning(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this error object is a warning.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError::getSeverity()) and then comparing it to the\n"
		"value <code>LIBSBML_SEV_WARNING</code> from the\n"
		"@if clike enumeration\n"
		"#XMLErrorSeverity_t. @endif@if java set of predefined\n"
		"severity codes.@endif\n"
		"\n"
		"@return @c true if this error is a warning, @c false otherwise.\n"
		"\n"
		"@see isInfo()\n"
		"@see isError()\n"
		"@see isFatal()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isError", _wrap_XMLError_isError, METH_VARARGS, (char *)"\n"
		"XMLError_isError(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error is a significant error.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError::getSeverity()) and then comparing it to the\n"
		"value <code>LIBSBML_SEV_ERROR</code> from the\n"
		"@if clike enumeration\n"
		"#XMLErrorSeverity_t. @endif@if java set of predefined\n"
		"severity codes.@endif\n"
		"\n"
		"@return @c true if this error is an error, @c false otherwise.\n"
		"\n"
		"@see isInfo()\n"
		"@see isWarning()\n"
		"@see isFatal()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isFatal", _wrap_XMLError_isFatal, METH_VARARGS, (char *)"\n"
		"XMLError_isFatal(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error is a fatal run-time error.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError::getSeverity()) and then comparing it to the\n"
		"value <code>LIBSBML_SEV_FATAL</code> from the\n"
		"@if clike enumeration\n"
		"#XMLErrorSeverity_t. @endif@if java set of predefined\n"
		"severity codes.@endif\n"
		"\n"
		"@return @c true if this error is a fatal error, @c false otherwise.\n"
		"\n"
		"@see isInfo()\n"
		"@see isWarning()\n"
		"@see isError()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isInternal", _wrap_XMLError_isInternal, METH_VARARGS, (char *)"\n"
		"XMLError_isInternal(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error resulted from an internal program error.\n"
		"\n"
		"This is equivalent to obtaining the category identifier from an\n"
		"XMLError object (via XMLError::getCategory()) and then comparing it to\n"
		"the value <code>LIBSBML_CAT_INTERNAL</code> from the\n"
		"@if clike\n"
		"enumeration #XMLErrorCategory_t. @endif@if java set of\n"
		"predefined category codes.@endif\n"
		"\n"
		"@return @c true or @c false\n"
		"\n"
		"@see isSystem()\n"
		"@see isXML()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isSystem", _wrap_XMLError_isSystem, METH_VARARGS, (char *)"\n"
		"XMLError_isSystem(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error was generated by the operating system.\n"
		"\n"
		"This is equivalent to obtaining the category identifier from an\n"
		"XMLError object (via XMLError::getCategory()) and then comparing it to\n"
		"the value <code>LIBSBML_CAT_SYSTEM</code> from the\n"
		"@if clike\n"
		"enumeration #XMLErrorCategory_t. @endif@if java set of\n"
		"predefined category codes.@endif\n"
		"\n"
		"@return @c true or @c false\n"
		"\n"
		"@see isInternal()\n"
		"@see isXML()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isXML", _wrap_XMLError_isXML, METH_VARARGS, (char *)"\n"
		"XMLError_isXML(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error resulted from a problem in the XML input (e.g., an XML syntax\n"
		"error).\n"
		"\n"
		"This is equivalent to obtaining the category identifier from an\n"
		"XMLError object (via XMLError::getCategory()) and then comparing it to\n"
		"the value <code>LIBSBML_CAT_XML</code> from the\n"
		"@if clike\n"
		"enumeration #XMLErrorCategory_t. @endif@if java set of\n"
		"predefined category codes.@endif\n"
		"\n"
		"@return @c true or @c false\n"
		"\n"
		"@see isInternal()\n"
		"@see isSystem()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_setLine", _wrap_XMLError_setLine, METH_VARARGS, (char *)"\n"
		"XMLError_setLine(XMLError self, unsigned int line) -> int\n"
		"\n"
		"Sets the line number where this error occurred.\n"
		"\n"
		"@param line an unsigned int, the line number to set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setColumn(unsigned int column)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_setColumn", _wrap_XMLError_setColumn, METH_VARARGS, (char *)"\n"
		"XMLError_setColumn(XMLError self, unsigned int column) -> int\n"
		"\n"
		"Sets the column number where this error occurred.\n"
		"\n"
		"@param column an unsigned int, the column number to set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setLine(unsigned int line)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getStandardMessage", _wrap_XMLError_getStandardMessage, METH_VARARGS, (char *)"\n"
		"XMLError_getStandardMessage(int code) -> string\n"
		"\n"
		"Returns a copy of the message string associated with the given\n"
		"predefined XMLError code.\n"
		"\n"
		"@param code the error code whose message is sought; it must be a\n"
		"predefined value from @if clike <a class='el'\n"
		"href='#XMLErrorCode_t'>\n"
		"XMLErrorCode_t</a>. @endif@if java <a class='el'\n"
		"href='#XMLErrorCode_t'>the set of predefined error identifiers.@endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_swigregister", XMLError_swigregister, METH_VARARGS, NULL},
	 { (char *)"XMLErrorLog_getNumErrors", _wrap_XMLErrorLog_getNumErrors, METH_VARARGS, (char *)"\n"
		"XMLErrorLog_getNumErrors(XMLErrorLog self) -> unsigned int\n"
		"\n"
		"Returns the number of errors that have been logged.\n"
		"\n"
		"To retrieve individual errors from the log, callers may use\n"
		"getError(unsigned int n) const.\n"
		"\n"
		"@return the number of errors that have been logged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLErrorLog_getError", _wrap_XMLErrorLog_getError, METH_VARARGS, (char *)"\n"
		"XMLErrorLog_getError(XMLErrorLog self, unsigned int n) -> XMLError\n"
		"\n"
		"Returns the <i>n</i>th XMLError object in this log.\n"
		"\n"
		"Index @p n is counted from 0.  Callers should first inquire about the\n"
		"number of items in the log by using the method getNumErrors().\n"
		"Attempts to use an error index number that exceeds the actual number\n"
		"of errors in the log will result in a @c NULL being returned.\n"
		"\n"
		"@param n the index number of the error to retrieve (with 0 being the\n"
		"first error).\n"
		"\n"
		"@return the <i>n</i>th XMLError in this log, or @c NULL if @p n is\n"
		"greater than or equal to getNumErrors().\n"
		"\n"
		"@see getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLErrorLog_clearLog", _wrap_XMLErrorLog_clearLog, METH_VARARGS, (char *)"\n"
		"XMLErrorLog_clearLog(XMLErrorLog self)\n"
		"\n"
		"Deletes all errors from this log.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_XMLErrorLog", _wrap_delete_XMLErrorLog, METH_VARARGS, (char *)"delete_XMLErrorLog(XMLErrorLog self)"},
	 { (char *)"XMLErrorLog_swigregister", XMLErrorLog_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBMLErrorLog_getError", _wrap_SBMLErrorLog_getError, METH_VARARGS, (char *)"\n"
		"SBMLErrorLog_getError(SBMLErrorLog self, unsigned int n) -> SBMLError\n"
		"\n"
		"Returns the <i>n</i>th SBMLError object in this log.\n"
		"\n"
		"Index @p n is counted from 0.  Callers should first inquire about the\n"
		"number of items in the log by using the getNumErrors() method.  (This\n"
		"method is inherited from the parent class, XMLErrorLog).  Attempts to\n"
		"use an error index number that exceeds the actual number of errors in\n"
		"the log will result in a @c NULL being returned.\n"
		"\n"
		"@param n the index number of the error to retrieve (with 0 being the\n"
		"first error).\n"
		"\n"
		"@return the <i>n</i>th SBMLError in this log, or @c NULL if @p n is\n"
		"greater than or equal to getNumErrors().\n"
		"\n"
		"@see getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLErrorLog_getNumFailsWithSeverity", _wrap_SBMLErrorLog_getNumFailsWithSeverity, METH_VARARGS, (char *)"\n"
		"SBMLErrorLog_getNumFailsWithSeverity(SBMLErrorLog self, unsigned int severity) -> unsigned int\n"
		"\n"
		"Returns the number of errors that have been logged with the given\n"
		"severity code.\n"
		"\n"
		"LibSBML associates severity levels with every SBMLError object to\n"
		"provide an indication of how serious the problem is.  Severities range\n"
		"from informational diagnostics to fatal (irrecoverable) errors.  Given\n"
		"an SBMLError object instance, a caller can interrogate it for its\n"
		"severity level using methods such as SBMLError::getSeverity(),\n"
		"SBMLError::isFatal(), and so on.  The present method encapsulates\n"
		"iteration and interrogation of all objects in an SBMLErrorLog, making\n"
		"it easy to check for the presence of error objects with specific\n"
		"severity levels.\n"
		"\n"
		"@if clike @param severity a value from\n"
		"#SBMLErrorSeverity_t @endif@if java @param severity a\n"
		"value from the set of <code>LIBSBML_SEV_</code> constants defined by\n"
		"the interface class <code><a\n"
		"href='libsbmlConstants.html'>libsbmlConstants</a></code> @endif\n"
		"\n"
		"@return a count of the number of errors with the given severity code.\n"
		"\n"
		"@see getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLErrorLog", _wrap_delete_SBMLErrorLog, METH_VARARGS, (char *)"delete_SBMLErrorLog(SBMLErrorLog self)"},
	 { (char *)"SBMLErrorLog_swigregister", SBMLErrorLog_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_SBMLError", _wrap_new_SBMLError, METH_VARARGS, (char *)"\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0, unsigned int column = 0, \n"
		"    unsigned int severity = LIBSBML_SEV_ERROR, \n"
		"    unsigned int category = LIBSBML_CAT_SBML)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0, unsigned int column = 0, \n"
		"    unsigned int severity = LIBSBML_SEV_ERROR)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0, unsigned int column = 0)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\")\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3)\n"
		"SBMLError(unsigned int errorId = 0)\n"
		"SBMLError()\n"
		"new_SBMLError(SBMLError orig) -> SBMLError\n"
		"\n"
		"Copy constructor; creates a copy of this SBMLError.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLError", _wrap_delete_SBMLError, METH_VARARGS, (char *)"delete_SBMLError(SBMLError self)"},
	 { (char *)"SBMLError_swigregister", SBMLError_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_CVTerm", _wrap_delete_CVTerm, METH_VARARGS, (char *)"delete_CVTerm(CVTerm self)"},
	 { (char *)"new_CVTerm", _wrap_new_CVTerm, METH_VARARGS, (char *)"\n"
		"CVTerm(QualifierType_t type = UNKNOWN_QUALIFIER)\n"
		"CVTerm()\n"
		"CVTerm(XMLNode node)\n"
		"new_CVTerm(CVTerm orig) -> CVTerm\n"
		"\n"
		"Copy constructor; creates a copy of a CVTerm.\n"
		"\n"
		"@param orig the CVTerm instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_clone", _wrap_CVTerm_clone, METH_VARARGS, (char *)"\n"
		"CVTerm_clone(CVTerm self) -> CVTerm\n"
		"\n"
		"Creates and returns a deep copy of this CVTerm.\n"
		"\n"
		"@return a (deep) copy of this CVTerm.\n"
		"    \n"
		"\n"
		""},
	 { (char *)"CVTerm_getQualifierType", _wrap_CVTerm_getQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_getQualifierType(CVTerm self) -> QualifierType_t\n"
		"\n"
		"Returns the Qualifier Type code for this %CVTerm.\n"
		"\n"
		"@return the #QualifierType_t value of this object or UNKNOWN_QUALIFIER\n"
		"(default).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getModelQualifierType", _wrap_CVTerm_getModelQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_getModelQualifierType(CVTerm self) -> ModelQualifierType_t\n"
		"\n"
		"Returns the Model QualifierType code for this %CVTerm.\n"
		"\n"
		"@return the #ModelQualifierType_t value of this object or BQM_UNKNOWN\n"
		"(default).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getBiologicalQualifierType", _wrap_CVTerm_getBiologicalQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_getBiologicalQualifierType(CVTerm self) -> BiolQualifierType_t\n"
		"\n"
		"Returns the Biological QualifierType code for this %CVTerm.\n"
		"\n"
		"@return the #BiolQualifierType_t value of this object or BQB_UNKNOWN\n"
		"(default).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getResources", _wrap_CVTerm_getResources, METH_VARARGS, (char *)"\n"
		"getResources() -> XMLAttributes\n"
		"CVTerm_getResources(CVTerm self) -> XMLAttributes\n"
		"\n"
		"Returns the resources for this %CVTerm.\n"
		"\n"
		"@return the XMLAttributes that store the resources of this %CVTerm.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getNumResources", _wrap_CVTerm_getNumResources, METH_VARARGS, (char *)"\n"
		"CVTerm_getNumResources(CVTerm self) -> unsigned int\n"
		"\n"
		"Returns the number of resources for this %CVTerm.\n"
		"\n"
		"@return the number of resources in the set of XMLAttributes\n"
		"of this %CVTerm.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getResourceURI", _wrap_CVTerm_getResourceURI, METH_VARARGS, (char *)"\n"
		"CVTerm_getResourceURI(CVTerm self, unsigned int n) -> string\n"
		"\n"
		"Returns the value of the nth resource for this %CVTerm.\n"
		"\n"
		"@param n the index of the resource to query\n"
		"\n"
		"@return string representing the value of the nth resource\n"
		"in the set of XMLAttributes of this %CVTerm.\n"
		"\n"
		"@note Since the values of the resource attributes in a CVTerm\n"
		"are URIs this is a convenience function to facilitate\n"
		"interaction with the CVTerm class.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_setQualifierType", _wrap_CVTerm_setQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_setQualifierType(CVTerm self, QualifierType_t type) -> int\n"
		"\n"
		"Sets the #QualifierType_t value of this %CVTerm.\n"
		"\n"
		"@param type the #QualifierType_t type value \n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_setModelQualifierType", _wrap_CVTerm_setModelQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_setModelQualifierType(CVTerm self, ModelQualifierType_t type) -> int\n"
		"\n"
		"Sets the #ModelQualifierType_t value of this %CVTerm.\n"
		"\n"
		"@param type the #ModelQualifierType_t value\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note If the Qualifier Type of this object is not MODEL_QUALIFIER,\n"
		"then the ModelQualifierType_t will default to BQM_UNKNOWN.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_setBiologicalQualifierType", _wrap_CVTerm_setBiologicalQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_setBiologicalQualifierType(CVTerm self, BiolQualifierType_t type) -> int\n"
		"\n"
		"Sets the #BiolQualifierType_t of this %CVTerm.\n"
		"\n"
		"@param type the #BiolQualifierType_t value\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note if the Qualifier Type of this object is not\n"
		"BIOLOGICAL_QUALIFIER, then the #BiolQualifierType_t value will default\n"
		"to BQB_UNKNOWN.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_addResource", _wrap_CVTerm_addResource, METH_VARARGS, (char *)"\n"
		"CVTerm_addResource(CVTerm self, string resource) -> int\n"
		"\n"
		"Adds a resource to the CVTerm.\n"
		"\n"
		"@param resource string representing the resource; e.g.,\n"
		"'http://www.geneontology.org/#GO:0005892'\n"
		"\n"
		"@note this method adds the name 'rdf:resource' to the attribute prior\n"
		"to adding it to the resources in this CVTerm.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_removeResource", _wrap_CVTerm_removeResource, METH_VARARGS, (char *)"\n"
		"CVTerm_removeResource(CVTerm self, string resource) -> int\n"
		"\n"
		"Removes a resource from the CVTerm.\n"
		"\n"
		"@param resource string representing the resource; e.g.,\n"
		"'http://www.geneontology.org/#GO:0005892'\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_hasRequiredAttributes", _wrap_CVTerm_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"CVTerm_hasRequiredAttributes(CVTerm self) -> bool\n"
		"\n"
		"Removes a resource from the CVTerm.\n"
		"\n"
		"@param resource string representing the resource; e.g.,\n"
		"'http://www.geneontology.org/#GO:0005892'\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"CVTerm_swigregister", CVTerm_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Date", _wrap_delete_Date, METH_VARARGS, (char *)"delete_Date(Date self)"},
	 { (char *)"new_Date", _wrap_new_Date, METH_VARARGS, (char *)"\n"
		"Date(unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0, \n"
		"    unsigned int sign = 0, unsigned int hoursOffset = 0, \n"
		"    unsigned int minutesOffset = 0)\n"
		"Date(unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0, \n"
		"    unsigned int sign = 0, unsigned int hoursOffset = 0)\n"
		"Date(unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0, \n"
		"    unsigned int sign = 0)\n"
		"Date(unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0)\n"
		"Date(unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0)\n"
		"Date(unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0)\n"
		"Date(unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1)\n"
		"Date(unsigned int year = 2007, unsigned int month = 1)\n"
		"Date(unsigned int year = 2007)\n"
		"Date()\n"
		"Date(string date)\n"
		"new_Date(Date orig) -> Date\n"
		"\n"
		"Copy constructor; creates a copy of this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_clone", _wrap_Date_clone, METH_VARARGS, (char *)"\n"
		"Date_clone(Date self) -> Date\n"
		"\n"
		"Returns a copy of this Date.\n"
		"\n"
		"@return a (deep) copy of this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getYear", _wrap_Date_getYear, METH_VARARGS, (char *)"\n"
		"Date_getYear(Date self) -> unsigned int\n"
		"\n"
		"Returns the year from this Date.\n"
		"\n"
		"@return the year from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getMonth", _wrap_Date_getMonth, METH_VARARGS, (char *)"\n"
		"Date_getMonth(Date self) -> unsigned int\n"
		"\n"
		"Returns the month from this Date.\n"
		"\n"
		"@return the month from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getDay", _wrap_Date_getDay, METH_VARARGS, (char *)"\n"
		"Date_getDay(Date self) -> unsigned int\n"
		"\n"
		"Returns the day from this Date.\n"
		"\n"
		"@return the day from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getHour", _wrap_Date_getHour, METH_VARARGS, (char *)"\n"
		"Date_getHour(Date self) -> unsigned int\n"
		"\n"
		"Returns the hour from this Date.\n"
		"\n"
		"@return the hour from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getMinute", _wrap_Date_getMinute, METH_VARARGS, (char *)"\n"
		"Date_getMinute(Date self) -> unsigned int\n"
		"\n"
		"Returns the minute from this Date.\n"
		"\n"
		"@return the minute from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getSecond", _wrap_Date_getSecond, METH_VARARGS, (char *)"\n"
		"Date_getSecond(Date self) -> unsigned int\n"
		"\n"
		"Returns the seconds from this Date.\n"
		"\n"
		"@return the seconds from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getSignOffset", _wrap_Date_getSignOffset, METH_VARARGS, (char *)"\n"
		"Date_getSignOffset(Date self) -> unsigned int\n"
		"\n"
		"Returns the sign of the offset from this Date.\n"
		"\n"
		"@return the sign of the offset from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getHoursOffset", _wrap_Date_getHoursOffset, METH_VARARGS, (char *)"\n"
		"Date_getHoursOffset(Date self) -> unsigned int\n"
		"\n"
		"Returns the hours of the offset from this Date.\n"
		"\n"
		"@return the hours of the offset from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getMinutesOffset", _wrap_Date_getMinutesOffset, METH_VARARGS, (char *)"\n"
		"Date_getMinutesOffset(Date self) -> unsigned int\n"
		"\n"
		"Returns the minutes of the offset from this Date.\n"
		"\n"
		"@return the minutes of the offset from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getDateAsString", _wrap_Date_getDateAsString, METH_VARARGS, (char *)"\n"
		"Date_getDateAsString(Date self) -> string\n"
		"\n"
		"Returns the Date as a string.\n"
		"\n"
		"@return the date as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setYear", _wrap_Date_setYear, METH_VARARGS, (char *)"\n"
		"Date_setYear(Date self, unsigned int year) -> int\n"
		"\n"
		"Sets the value of the year checking appropriateness.\n"
		" \n"
		"@param year an unsigned int representing the year to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setMonth", _wrap_Date_setMonth, METH_VARARGS, (char *)"\n"
		"Date_setMonth(Date self, unsigned int month) -> int\n"
		"\n"
		"Sets the value of the month checking appropriateness.\n"
		" \n"
		"@param month an unsigned int representing the month to set  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setDay", _wrap_Date_setDay, METH_VARARGS, (char *)"\n"
		"Date_setDay(Date self, unsigned int day) -> int\n"
		"\n"
		"Sets the value of the day checking appropriateness.\n"
		" \n"
		"@param day an unsigned int representing the day to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setHour", _wrap_Date_setHour, METH_VARARGS, (char *)"\n"
		"Date_setHour(Date self, unsigned int hour) -> int\n"
		"\n"
		"Sets the value of the hour checking appropriateness.\n"
		" \n"
		"@param hour an unsigned int representing the hour to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setMinute", _wrap_Date_setMinute, METH_VARARGS, (char *)"\n"
		"Date_setMinute(Date self, unsigned int minute) -> int\n"
		"\n"
		"Sets the value of the minute checking appropriateness.\n"
		" \n"
		"@param minute an unsigned int representing the minute to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setSecond", _wrap_Date_setSecond, METH_VARARGS, (char *)"\n"
		"Date_setSecond(Date self, unsigned int second) -> int\n"
		"\n"
		"Sets the value of the second checking appropriateness.\n"
		" \n"
		"@param second an unsigned int representing the second to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setSignOffset", _wrap_Date_setSignOffset, METH_VARARGS, (char *)"\n"
		"Date_setSignOffset(Date self, unsigned int sign) -> int\n"
		"\n"
		"Sets the value of the offset sign checking appropriateness.\n"
		" \n"
		"@param sign an unsigned int representing \n"
		"the sign of the offset to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setHoursOffset", _wrap_Date_setHoursOffset, METH_VARARGS, (char *)"\n"
		"Date_setHoursOffset(Date self, unsigned int hoursOffset) -> int\n"
		"\n"
		"Sets the value of the offset hour checking appropriateness.\n"
		" \n"
		"@param hoursOffset an unsigned int representing the hours of the \n"
		"offset to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setMinutesOffset", _wrap_Date_setMinutesOffset, METH_VARARGS, (char *)"\n"
		"Date_setMinutesOffset(Date self, unsigned int minutesOffset) -> int\n"
		"\n"
		"Sets the value of the offset minutes checking appropriateness.\n"
		" \n"
		"@param minutesOffset an unsigned int representing the minutes of the \n"
		"offset to set.  \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setDateAsString", _wrap_Date_setDateAsString, METH_VARARGS, (char *)"\n"
		"Date_setDateAsString(Date self, string date) -> int\n"
		"\n"
		"Sets the value of the date string checking appropriateness.\n"
		"\n"
		"@param date a string representing the date.\n"
		"\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note the string should be in W3CDTF format \n"
		"YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)\n"
		"where TZD is the time zone designator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_representsValidDate", _wrap_Date_representsValidDate, METH_VARARGS, (char *)"\n"
		"Date_representsValidDate(Date self) -> bool\n"
		"\n"
		"Sets the value of the date string checking appropriateness.\n"
		"\n"
		"@param date a string representing the date.\n"
		"\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note the string should be in W3CDTF format \n"
		"YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)\n"
		"where TZD is the time zone designator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_swigregister", Date_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_ModelCreator", _wrap_delete_ModelCreator, METH_VARARGS, (char *)"delete_ModelCreator(ModelCreator self)"},
	 { (char *)"new_ModelCreator", _wrap_new_ModelCreator, METH_VARARGS, (char *)"\n"
		"ModelCreator()\n"
		"ModelCreator(XMLNode creator)\n"
		"new_ModelCreator(ModelCreator orig) -> ModelCreator\n"
		"\n"
		"Copy constructor; creates a copy of the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_clone", _wrap_ModelCreator_clone, METH_VARARGS, (char *)"\n"
		"ModelCreator_clone(ModelCreator self) -> ModelCreator\n"
		"\n"
		"Creates and returns a copy of this ModelCreator.\n"
		"\n"
		"@return a (deep) copy of this ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getFamilyName", _wrap_ModelCreator_getFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_getFamilyName(ModelCreator self) -> string\n"
		"\n"
		"Returns the familyName from the ModelCreator.\n"
		"\n"
		"@return familyName from the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getGivenName", _wrap_ModelCreator_getGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_getGivenName(ModelCreator self) -> string\n"
		"\n"
		"Returns the givenName from the ModelCreator.\n"
		"\n"
		"@return givenName from the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getEmail", _wrap_ModelCreator_getEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_getEmail(ModelCreator self) -> string\n"
		"\n"
		"Returns the email from the ModelCreator.\n"
		"\n"
		"@return email from the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getOrganization", _wrap_ModelCreator_getOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_getOrganization(ModelCreator self) -> string\n"
		"\n"
		"Returns the organization from the ModelCreator.\n"
		"\n"
		"@return organization from the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getOrganisation", _wrap_ModelCreator_getOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_getOrganisation(ModelCreator self) -> string\n"
		"\n"
		"Returns the organization from the ModelCreator.\n"
		"\n"
		"@note This function is an alias of getOrganization().\n"
		"\n"
		"@return organization from the ModelCreator.\n"
		"\n"
		"@see getOrganization()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetFamilyName", _wrap_ModelCreator_isSetFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetFamilyName(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's familyName has been set.\n"
		"\n"
		"@return @c true if the familyName of this ModelCreator has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetGivenName", _wrap_ModelCreator_isSetGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetGivenName(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's givenName has been set.\n"
		"\n"
		"@return @c true if the givenName of this ModelCreator has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetEmail", _wrap_ModelCreator_isSetEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetEmail(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's email has been set.\n"
		"\n"
		"@return @c true if the email of this ModelCreator has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetOrganization", _wrap_ModelCreator_isSetOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetOrganization(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's organization has been set.\n"
		"\n"
		"@return @c true if the organization of this ModelCreator has been set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetOrganisation", _wrap_ModelCreator_isSetOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetOrganisation(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's organization has been set.\n"
		"\n"
		"@note This function is an alias of isSetOrganization().\n"
		"\n"
		"@return @c true if the organization of this ModelCreator has been set, @c false otherwise.\n"
		"\n"
		"@see isSetOrganization()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setFamilyName", _wrap_ModelCreator_setFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_setFamilyName(ModelCreator self, string familyName) -> int\n"
		"\n"
		"Sets the family name\n"
		" \n"
		"@param familyName a string representing the familyName of the ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setGivenName", _wrap_ModelCreator_setGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_setGivenName(ModelCreator self, string givenName) -> int\n"
		"\n"
		"Sets the given name\n"
		" \n"
		"@param givenName a string representing the givenName of the ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setEmail", _wrap_ModelCreator_setEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_setEmail(ModelCreator self, string email) -> int\n"
		"\n"
		"Sets the email\n"
		" \n"
		"@param email a string representing the email of the ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setOrganization", _wrap_ModelCreator_setOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_setOrganization(ModelCreator self, string organization) -> int\n"
		"\n"
		"Sets the organization\n"
		" \n"
		"@param organization a string representing the organization of the \n"
		"ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setOrganisation", _wrap_ModelCreator_setOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_setOrganisation(ModelCreator self, string organization) -> int\n"
		"\n"
		"Sets the organization\n"
		"\n"
		"@param organization a string representing the organization of the\n"
		"ModelCreator.\n"
		"\n"
		"@note This function is an alias of setOrganization(std::string organization).\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setOrganization(std::string organization)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetFamilyName", _wrap_ModelCreator_unsetFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetFamilyName(ModelCreator self) -> int\n"
		"\n"
		"Unsets the familyName of this ModelCreator.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetGivenName", _wrap_ModelCreator_unsetGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetGivenName(ModelCreator self) -> int\n"
		"\n"
		"Unsets the givenName of this ModelCreator.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetEmail", _wrap_ModelCreator_unsetEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetEmail(ModelCreator self) -> int\n"
		"\n"
		"Unsets the email of this ModelCreator.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetOrganization", _wrap_ModelCreator_unsetOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetOrganization(ModelCreator self) -> int\n"
		"\n"
		"Unsets the organization of this ModelCreator.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetOrganisation", _wrap_ModelCreator_unsetOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetOrganisation(ModelCreator self) -> int\n"
		"\n"
		"Unsets the organization of this ModelCreator.\n"
		"\n"
		"@note This function is an alias of unsetOrganization().\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see unsetOrganization()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_hasRequiredAttributes", _wrap_ModelCreator_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"ModelCreator_hasRequiredAttributes(ModelCreator self) -> bool\n"
		"\n"
		"Unsets the organization of this ModelCreator.\n"
		"\n"
		"@note This function is an alias of unsetOrganization().\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see unsetOrganization()\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"ModelCreator_swigregister", ModelCreator_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_ModelHistory", _wrap_delete_ModelHistory, METH_VARARGS, (char *)"delete_ModelHistory(ModelHistory self)"},
	 { (char *)"new_ModelHistory", _wrap_new_ModelHistory, METH_VARARGS, (char *)"\n"
		"ModelHistory()\n"
		"new_ModelHistory(ModelHistory orig) -> ModelHistory\n"
		"\n"
		"Copy constructor; creates a copy of the ModelHistory.\n"
		" \n"
		"\n"
		""},
	 { (char *)"ModelHistory_clone", _wrap_ModelHistory_clone, METH_VARARGS, (char *)"\n"
		"ModelHistory_clone(ModelHistory self) -> ModelHistory\n"
		"\n"
		"Creates and returns a copy of this ModelHistory.\n"
		"\n"
		"@return a (deep) copy of this ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getCreatedDate", _wrap_ModelHistory_getCreatedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_getCreatedDate(ModelHistory self) -> Date\n"
		"\n"
		"Returns the createdDate from the ModelHistory.\n"
		"\n"
		"@return Date object representing the createdDate\n"
		"from the ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_isSetCreatedDate", _wrap_ModelHistory_isSetCreatedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_isSetCreatedDate(ModelHistory self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelHistory's createdDate has been set.\n"
		"\n"
		"@return @c true if the createdDate of this ModelHistory has been set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_isSetModifiedDate", _wrap_ModelHistory_isSetModifiedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_isSetModifiedDate(ModelHistory self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelHistory's modifiedDate has been set.\n"
		"\n"
		"@return @c true if the modifiedDate of this ModelHistory has been set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_setCreatedDate", _wrap_ModelHistory_setCreatedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_setCreatedDate(ModelHistory self, Date date) -> int\n"
		"\n"
		"Sets the createdDate.\n"
		" \n"
		"@param date a Date object representing the date\n"
		"the ModelHistory was created. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_setModifiedDate", _wrap_ModelHistory_setModifiedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_setModifiedDate(ModelHistory self, Date date) -> int\n"
		"\n"
		"Sets the modifiedDate.\n"
		" \n"
		"@param date a Date object representing the date\n"
		"the ModelHistory was modified. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_addModifiedDate", _wrap_ModelHistory_addModifiedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_addModifiedDate(ModelHistory self, Date date) -> int\n"
		"\n"
		"Adds a modifiedDate.\n"
		" \n"
		"@param date a Date object representing the date\n"
		"the ModelHistory was modified. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getListModifiedDates", _wrap_ModelHistory_getListModifiedDates, METH_VARARGS, (char *)"\n"
		"ModelHistory_getListModifiedDates(ModelHistory self) -> List\n"
		"\n"
		"Get the list of ModifiedDate objects in this \n"
		"ModelHistory.\n"
		"\n"
		"@return the list of ModifiedDates for this ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getModifiedDate", _wrap_ModelHistory_getModifiedDate, METH_VARARGS, (char *)"\n"
		"getModifiedDate() -> Date\n"
		"ModelHistory_getModifiedDate(ModelHistory self, unsigned int n) -> Date\n"
		"\n"
		"Get the nth Date object in the list of ModifiedDates\n"
		"in this ModelHistory.\n"
		"\n"
		"@return the nth Date in the list of ModifiedDates of \n"
		"this ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getNumModifiedDates", _wrap_ModelHistory_getNumModifiedDates, METH_VARARGS, (char *)"\n"
		"ModelHistory_getNumModifiedDates(ModelHistory self) -> unsigned int\n"
		"\n"
		"Get the number of ModifiedDate objects in this \n"
		"ModelHistory.\n"
		"\n"
		"@return the number of ModifiedDates in this \n"
		"ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_addCreator", _wrap_ModelHistory_addCreator, METH_VARARGS, (char *)"\n"
		"ModelHistory_addCreator(ModelHistory self, ModelCreator mc) -> int\n"
		"\n"
		"Adds a copy of the given ModelCreator object to \n"
		"this ModelHistory.\n"
		"\n"
		"@param mc the ModelCreator to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getListCreators", _wrap_ModelHistory_getListCreators, METH_VARARGS, (char *)"\n"
		"ModelHistory_getListCreators(ModelHistory self) -> List\n"
		"\n"
		"Get the list of ModelCreator objects in this \n"
		"ModelHistory.\n"
		"\n"
		"@return the list of ModelCreators for this ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getCreator", _wrap_ModelHistory_getCreator, METH_VARARGS, (char *)"\n"
		"ModelHistory_getCreator(ModelHistory self, unsigned int n) -> ModelCreator\n"
		"\n"
		"Get the nth ModelCreator object in this ModelHistory.\n"
		"\n"
		"@return the nth ModelCreator of this ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getNumCreators", _wrap_ModelHistory_getNumCreators, METH_VARARGS, (char *)"\n"
		"ModelHistory_getNumCreators(ModelHistory self) -> unsigned int\n"
		"\n"
		"Get the number of ModelCreator objects in this \n"
		"ModelHistory.\n"
		"\n"
		"@return the number of ModelCreators in this \n"
		"ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_hasRequiredAttributes", _wrap_ModelHistory_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"ModelHistory_hasRequiredAttributes(ModelHistory self) -> bool\n"
		"\n"
		"Get the number of ModelCreator objects in this \n"
		"ModelHistory.\n"
		"\n"
		"@return the number of ModelCreators in this \n"
		"ModelHistory.\n"
		"@deprecated libSBML internal\n"
		"\n"
		"\n"
		""},
	 { (char *)"ModelHistory_swigregister", ModelHistory_swigregister, METH_VARARGS, NULL},
	 { (char *)"RDFAnnotationParser_createAnnotation", _wrap_RDFAnnotationParser_createAnnotation, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createAnnotation() -> XMLNode\n"
		"\n"
		"Creates a blank annotation and returns the XMLNode corresonding to it.\n"
		"\n"
		"The annotation created by this method is a completely empty SBML\n"
		"<code>&lt;annotation&gt;</code> element.  One use for this is to\n"
		"then call createRDFAnnotation() to construct RDF content for this\n"
		"empty annotation.\n"
		"\n"
		"@return a pointer to an XMLNode for the annotation\n"
		"\n"
		"@see createRDFAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_createRDFAnnotation", _wrap_RDFAnnotationParser_createRDFAnnotation, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createRDFAnnotation() -> XMLNode\n"
		"\n"
		"Creates blank RDF annotation content organized in the form defined in\n"
		"Section 6 of the SBML Level 2 Version 4 specification .\n"
		"\n"
		"The annotation created by this method has namespace declarations for\n"
		"all the relevant XML namespaces used in RDF annotations and also has\n"
		"an empty RDF element.  Note that this is not the containing\n"
		"<code>&lt;annotation&gt;</code> element; the method createAnnotation()\n"
		"is available for that purpose.\n"
		"\n"
		"@return a pointer to an XMLNode\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_deleteRDFAnnotation", _wrap_RDFAnnotationParser_deleteRDFAnnotation, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_deleteRDFAnnotation(XMLNode annotation) -> XMLNode\n"
		"\n"
		"Deletes any RDF annotation found in the given XMLNode tree and returns\n"
		"any remaining annotation content.\n"
		"\n"
		"The name of the given XMLNode must be 'annotation', or else this\n"
		"method returns NULL.\n"
		"\n"
		"@param annotation the annotation tree within which the RDF annotation\n"
		"is to be found and deleted\n"
		"\n"
		"@return the XMLNode structure with any RDF annotations deleted\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_createRDFDescription", _wrap_RDFAnnotationParser_createRDFDescription, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createRDFDescription(SBase object) -> XMLNode\n"
		"\n"
		"Takes an SBML object and creates an XMLNode corresponding to an\n"
		"RDF 'Description' element.\n"
		"\n"
		"This method is a handy way of creating RDF description objects linked\n"
		"by the appropriate 'metaid' field, for insertion into RDF annotations\n"
		"in a model.  (Note that this method does not create a complete\n"
		"annotation; it only creates a description element.  For creating empty\n"
		"RDF annotations that can serve as containers for RDF descriptions, see\n"
		"createRDFAnnotation().\n"
		"\n"
		"@param object the object to be annotated\n"
		"\n"
		"@return a new XMLNode containing the 'rdf:about' structure for an\n"
		"RDF 'Description' element.\n"
		"\n"
		"@see createRDFAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_createCVTerms", _wrap_RDFAnnotationParser_createCVTerms, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createCVTerms(SBase object) -> XMLNode\n"
		"\n"
		"Takes a list of CVTerms and creates a the RDF 'Description' element.\n"
		"\n"
		"This essentially takes the given SBML object, reads out the CVTerms\n"
		"attached to it, calls createRDFDescriptiom() to create an RDF\n"
		"'Description' element to hold the terms and adds each term with\n"
		"appropriate qualifiers.\n"
		"\n"
		"@param object the SBML object to start from\n"
		"\n"
		"@return the XMLNode tree corresponding to the Description element of\n"
		"an RDF annotation.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_parseCVTerms", _wrap_RDFAnnotationParser_parseCVTerms, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_parseCVTerms(SBase object) -> XMLNode\n"
		"\n"
		"Takes a list of CVTerms and creates a complete SBML annotation\n"
		"around it.\n"
		"\n"
		"This essentially takes the given SBML object, calls createCVTerms\n"
		"to read out the CVTerms\n"
		"attached to it, calls createRDFAnnotation() to create an RDF\n"
		"annotation to hold the terms, and finally calls createAnnotation() to\n"
		"wrap the result as an SBML <code>&lt;annotation&gt;</code> element.\n"
		"\n"
		"@param object the SBML object to start from\n"
		"\n"
		"@return the XMLNode tree corresponding to the annotation.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_parseModelHistory", _wrap_RDFAnnotationParser_parseModelHistory, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_parseModelHistory(SBase object) -> XMLNode\n"
		"\n"
		"Takes an SBML object, reads off the model history information\n"
		"stored in it, and creates a complete SBML annotation to store that\n"
		"history.\n"
		"\n"
		"@param object any SBase object\n"
		"\n"
		"@return the XMLNode corresponding to an annotation containing \n"
		"MIRIAM-compliant model history information in RDF format\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_parseRDFAnnotation", _wrap_RDFAnnotationParser_parseRDFAnnotation, METH_VARARGS, (char *)"\n"
		"parseRDFAnnotation(XMLNode annotation) -> ModelHistory\n"
		"RDFAnnotationParser_parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms)\n"
		"\n"
		"Parses an annotation into a ModelHistory class instance.\n"
		"\n"
		"This is used to take an annotation that has been read into an SBML\n"
		"model, identify the RDF elements representing model history\n"
		"information, and create a list of corresponding CVTerms.\n"
		"\n"
		"@param annotation XMLNode containing the annotation.\n"
		"\n"
		"@return a pointer to the ModelHistory created.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_RDFAnnotationParser", _wrap_new_RDFAnnotationParser, METH_VARARGS, (char *)"new_RDFAnnotationParser() -> RDFAnnotationParser"},
	 { (char *)"delete_RDFAnnotationParser", _wrap_delete_RDFAnnotationParser, METH_VARARGS, (char *)"delete_RDFAnnotationParser(RDFAnnotationParser self)"},
	 { (char *)"RDFAnnotationParser_swigregister", RDFAnnotationParser_swigregister, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_ConstraintTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Constraint *) x));
}
static void *_p_RateRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((RateRule *) x));
}
static void *_p_ListOfTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((ListOf *) x));
}
static void *_p_UnitTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Unit *) x));
}
static void *_p_ListOfFunctionDefinitionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfFunctionDefinitions *) x));
}
static void *_p_ListOfUnitDefinitionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfUnitDefinitions *) x));
}
static void *_p_SimpleSpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SimpleSpeciesReference *) x));
}
static void *_p_SpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (SimpleSpeciesReference *) ((SpeciesReference *) x));
}
static void *_p_ModifierSpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (SimpleSpeciesReference *) ((ModifierSpeciesReference *) x));
}
static void *_p_InitialAssignmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((InitialAssignment *) x));
}
static void *_p_RuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Rule *) x));
}
static void *_p_ListOfLocalParametersTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *)(ListOfParameters *) ((ListOfLocalParameters *) x));
}
static void *_p_ListOfParametersTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfParameters *) x));
}
static void *_p_EventAssignmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((EventAssignment *) x));
}
static void *_p_AssignmentRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((AssignmentRule *) x));
}
static void *_p_SBMLDocumentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SBMLDocument *) x));
}
static void *_p_FunctionDefinitionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((FunctionDefinition *) x));
}
static void *_p_UnitDefinitionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((UnitDefinition *) x));
}
static void *_p_ListOfInitialAssignmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfInitialAssignments *) x));
}
static void *_p_AlgebraicRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((AlgebraicRule *) x));
}
static void *_p_ListOfEventAssignmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfEventAssignments *) x));
}
static void *_p_ListOfCompartmentTypesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfCompartmentTypes *) x));
}
static void *_p_EventTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Event *) x));
}
static void *_p_CompartmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Compartment *) x));
}
static void *_p_KineticLawTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((KineticLaw *) x));
}
static void *_p_ListOfEventsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfEvents *) x));
}
static void *_p_StoichiometryMathTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((StoichiometryMath *) x));
}
static void *_p_ModelTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Model *) x));
}
static void *_p_ListOfSpeciesTypesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpeciesTypes *) x));
}
static void *_p_ListOfRulesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfRules *) x));
}
static void *_p_ListOfSpeciesReferencesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpeciesReferences *) x));
}
static void *_p_ListOfConstraintsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfConstraints *) x));
}
static void *_p_DelayTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Delay *) x));
}
static void *_p_CompartmentTypeTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((CompartmentType *) x));
}
static void *_p_ListOfReactionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfReactions *) x));
}
static void *_p_LocalParameterTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Parameter *) ((LocalParameter *) x));
}
static void *_p_ParameterTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Parameter *) x));
}
static void *_p_ListOfSpeciesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpecies *) x));
}
static void *_p_SpeciesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Species *) x));
}
static void *_p_TriggerTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Trigger *) x));
}
static void *_p_ListOfUnitsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfUnits *) x));
}
static void *_p_SpeciesTypeTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SpeciesType *) x));
}
static void *_p_ReactionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Reaction *) x));
}
static void *_p_ListOfCompartmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfCompartments *) x));
}
static void *_p_AlgebraicRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((AlgebraicRule *) x));
}
static void *_p_AssignmentRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((AssignmentRule *) x));
}
static void *_p_RateRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((RateRule *) x));
}
static void *_p_SBMLConstructorExceptionTo_p_std__invalid_argument(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::invalid_argument *)  ((SBMLConstructorException *) x));
}
static void *_p_XMLNodeTo_p_XMLToken(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLToken *)  ((XMLNode *) x));
}
static void *_p_SpeciesReferenceTo_p_SimpleSpeciesReference(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SimpleSpeciesReference *)  ((SpeciesReference *) x));
}
static void *_p_ModifierSpeciesReferenceTo_p_SimpleSpeciesReference(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SimpleSpeciesReference *)  ((ModifierSpeciesReference *) x));
}
static void *_p_std__basic_ostreamT_char_std__char_traitsT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ios< char,std::char_traits< char > > *)  ((std::basic_ostream< char,std::char_traits< char > > *) x));
}
static void *_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ios< char,std::char_traits< char > > *) (std::basic_ostream< char > *) ((std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *) x));
}
static void *_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ostream< char,std::char_traits< char > > *)  ((std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *) x));
}
static void *_p_ListOfLocalParametersTo_p_ListOfParameters(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOfParameters *)  ((ListOfLocalParameters *) x));
}
static void *_p_SBMLErrorLogTo_p_XMLErrorLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLErrorLog *)  ((SBMLErrorLog *) x));
}
static void *_p_XMLOutputStringStreamTo_p_XMLOutputStream(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLOutputStream *)  ((XMLOutputStringStream *) x));
}
static void *_p_XMLOutputFileStreamTo_p_XMLOutputStream(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLOutputStream *)  ((XMLOutputFileStream *) x));
}
static void *_p_SBMLErrorTo_p_XMLError(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLError *)  ((SBMLError *) x));
}
static void *_p_ListOfReactionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfReactions *) x));
}
static void *_p_ListOfLocalParametersTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *) (ListOfParameters *) ((ListOfLocalParameters *) x));
}
static void *_p_ListOfParametersTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfParameters *) x));
}
static void *_p_ListOfRulesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfRules *) x));
}
static void *_p_ListOfEventsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfEvents *) x));
}
static void *_p_ListOfCompartmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfCompartments *) x));
}
static void *_p_ListOfCompartmentTypesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfCompartmentTypes *) x));
}
static void *_p_ListOfUnitDefinitionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfUnitDefinitions *) x));
}
static void *_p_ListOfFunctionDefinitionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfFunctionDefinitions *) x));
}
static void *_p_ListOfSpeciesTypesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpeciesTypes *) x));
}
static void *_p_ListOfSpeciesReferencesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpeciesReferences *) x));
}
static void *_p_ListOfInitialAssignmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfInitialAssignments *) x));
}
static void *_p_ListOfEventAssignmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfEventAssignments *) x));
}
static void *_p_ListOfConstraintsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfConstraints *) x));
}
static void *_p_ListOfUnitsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfUnits *) x));
}
static void *_p_ListOfSpeciesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpecies *) x));
}
static void *_p_LocalParameterTo_p_Parameter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Parameter *)  ((LocalParameter *) x));
}
static swig_type_info _swigt__p_ASTNode = {"_p_ASTNode", "ASTNode *|ASTNode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ASTNodeType_t = {"_p_ASTNodeType_t", "enum ASTNodeType_t *|ASTNodeType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AlgebraicRule = {"_p_AlgebraicRule", "AlgebraicRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AssignmentRule = {"_p_AssignmentRule", "AssignmentRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BiolQualifierType_t = {"_p_BiolQualifierType_t", "enum BiolQualifierType_t *|BiolQualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CVTerm = {"_p_CVTerm", "CVTerm *|CVTerm_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Compartment = {"_p_Compartment", "Compartment_t *|Compartment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CompartmentType = {"_p_CompartmentType", "CompartmentType *|CompartmentType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Constraint = {"_p_Constraint", "Constraint_t *|Constraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Date = {"_p_Date", "Date *|Date_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Delay = {"_p_Delay", "Delay *|Delay_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Event = {"_p_Event", "Event *|Event_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EventAssignment = {"_p_EventAssignment", "EventAssignment_t *|EventAssignment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FunctionDefinition = {"_p_FunctionDefinition", "FunctionDefinition_t *|FunctionDefinition *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_InitialAssignment = {"_p_InitialAssignment", "InitialAssignment_t *|InitialAssignment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_KineticLaw = {"_p_KineticLaw", "KineticLaw *|KineticLaw_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_List = {"_p_List", "List *|List_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOf = {"_p_ListOf", "ListOf *|ListOf_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfCompartmentTypes = {"_p_ListOfCompartmentTypes", "ListOfCompartmentTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfCompartments = {"_p_ListOfCompartments", "ListOfCompartments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfConstraints = {"_p_ListOfConstraints", "ListOfConstraints *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfEventAssignments = {"_p_ListOfEventAssignments", "ListOfEventAssignments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfEvents = {"_p_ListOfEvents", "ListOfEvents *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfFunctionDefinitions = {"_p_ListOfFunctionDefinitions", "ListOfFunctionDefinitions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfInitialAssignments = {"_p_ListOfInitialAssignments", "ListOfInitialAssignments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfLocalParameters = {"_p_ListOfLocalParameters", "ListOfLocalParameters *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfParameters = {"_p_ListOfParameters", "ListOfParameters *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfReactions = {"_p_ListOfReactions", "ListOfReactions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfRules = {"_p_ListOfRules", "ListOfRules *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpecies = {"_p_ListOfSpecies", "ListOfSpecies *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpeciesReferences = {"_p_ListOfSpeciesReferences", "ListOfSpeciesReferences *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpeciesTypes = {"_p_ListOfSpeciesTypes", "ListOfSpeciesTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfUnitDefinitions = {"_p_ListOfUnitDefinitions", "ListOfUnitDefinitions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfUnits = {"_p_ListOfUnits", "ListOfUnits *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_ASTNode_t = {"_p_ListWrapperT_ASTNode_t", "ListWrapper< ASTNode > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_CVTerm_t = {"_p_ListWrapperT_CVTerm_t", "ListWrapper< CVTerm > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_Date_t = {"_p_ListWrapperT_Date_t", "ListWrapper< Date > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_ModelCreator_t = {"_p_ListWrapperT_ModelCreator_t", "ListWrapper< ModelCreator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LocalParameter = {"_p_LocalParameter", "LocalParameter *|LocalParameter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Model = {"_p_Model", "Model *|Model_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelCreator = {"_p_ModelCreator", "ModelCreator *|ModelCreator_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelHistory = {"_p_ModelHistory", "ModelHistory *|ModelHistory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelQualifierType_t = {"_p_ModelQualifierType_t", "enum ModelQualifierType_t *|ModelQualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModifierSpeciesReference = {"_p_ModifierSpeciesReference", "ModifierSpeciesReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OperationReturnValues_t = {"_p_OperationReturnValues_t", "enum OperationReturnValues_t *|OperationReturnValues_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Parameter = {"_p_Parameter", "Parameter *|Parameter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ParentMap__iterator = {"_p_ParentMap__iterator", "ParentIter *|ParentMap::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_QualifierType_t = {"_p_QualifierType_t", "enum QualifierType_t *|QualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RDFAnnotationParser = {"_p_RDFAnnotationParser", "RDFAnnotationParser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RateRule = {"_p_RateRule", "RateRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Reaction = {"_p_Reaction", "Reaction_t *|Reaction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rule = {"_p_Rule", "Rule_t *|Rule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RuleType_t = {"_p_RuleType_t", "enum RuleType_t *|RuleType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLDocument = {"_p_SBMLDocument", "SBMLDocument_t *|SBMLDocument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLError = {"_p_SBMLError", "SBMLError *|SBMLError_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorCategory_t = {"_p_SBMLErrorCategory_t", "enum SBMLErrorCategory_t *|SBMLErrorCategory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorCode_t = {"_p_SBMLErrorCode_t", "enum SBMLErrorCode_t *|SBMLErrorCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorLog = {"_p_SBMLErrorLog", "SBMLErrorLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorSeverity_t = {"_p_SBMLErrorSeverity_t", "enum SBMLErrorSeverity_t *|SBMLErrorSeverity_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLNamespaces = {"_p_SBMLNamespaces", "SBMLNamespaces_t *|SBMLNamespaces *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLReader = {"_p_SBMLReader", "SBMLReader *|SBMLReader_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLTransforms = {"_p_SBMLTransforms", "SBMLTransforms *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLTypeCode_t = {"_p_SBMLTypeCode_t", "enum SBMLTypeCode_t *|SBMLTypeCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLWriter = {"_p_SBMLWriter", "SBMLWriter *|SBMLWriter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBO = {"_p_SBO", "SBO *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBase = {"_p_SBase", "SBase_t *|SBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SimpleSpeciesReference = {"_p_SimpleSpeciesReference", "SimpleSpeciesReference *|SpeciesReference_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Species = {"_p_Species", "Species_t *|Species *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SpeciesReference = {"_p_SpeciesReference", "SpeciesReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SpeciesType = {"_p_SpeciesType", "SpeciesType *|SpeciesType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StoichiometryMath = {"_p_StoichiometryMath", "StoichiometryMath_t *|StoichiometryMath *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SyntaxChecker = {"_p_SyntaxChecker", "SyntaxChecker *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Trigger = {"_p_Trigger", "Trigger *|Trigger_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Unit = {"_p_Unit", "Unit_t *|Unit *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UnitDefinition = {"_p_UnitDefinition", "UnitDefinition_t *|UnitDefinition *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UnitKind_t = {"_p_UnitKind_t", "enum UnitKind_t *|UnitKind_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLAttributes = {"_p_XMLAttributes", "XMLAttributes *|XMLAttributes_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLError = {"_p_XMLError", "XMLError *|XMLError_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorCategory_t = {"_p_XMLErrorCategory_t", "enum XMLErrorCategory_t *|XMLErrorCategory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorCode_t = {"_p_XMLErrorCode_t", "enum XMLErrorCode_t *|XMLErrorCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorLog = {"_p_XMLErrorLog", "XMLErrorLog *|XMLErrorLog_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorSeverity_t = {"_p_XMLErrorSeverity_t", "enum XMLErrorSeverity_t *|XMLErrorSeverity_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLInputStream = {"_p_XMLInputStream", "XMLInputStream *|XMLInputStream_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLNamespaces = {"_p_XMLNamespaces", "XMLNamespaces_t *|XMLNamespaces *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLNode = {"_p_XMLNode", "XMLNode *|XMLNode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLOutputStream = {"_p_XMLOutputStream", "XMLOutputStream *|XMLOutputStream_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLOutputStringStream = {"_p_XMLOutputStringStream", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_XMLOutputFileStream = {"_p_XMLOutputFileStream", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_XMLToken = {"_p_XMLToken", "XMLToken_t *|XMLToken *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLTriple = {"_p_XMLTriple", "XMLTriple *|XMLTriple_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__CharT = {"_p__CharT", "_CharT *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char_type = {"_p_char_type", "char_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_reference = {"_p_const_reference", "const_reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int_type = {"_p_int_type", "int_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_off_type = {"_p_off_type", "off_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_PyObject = {"_p_p_PyObject", "PyObject **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pos_type = {"_p_pos_type", "pos_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_reference = {"_p_reference", "reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_state_type = {"_p_state_type", "state_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t = {"_p_std__basic_iosT_char_std__char_traitsT_char_t_t", "std::basic_ios< char > *|std::basic_ios< char,std::char_traits< char > > *|std::ios *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t = {"_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t", "std::basic_ostream< char > *|std::basic_ostream< char,std::char_traits< char > > *|std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t = {"_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t", "std::basic_ostringstream< char > *|std::ostringstream *|std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t = {"_p_std__basic_streambufT_char_std__char_traitsT_char_t_t", "std::basic_streambuf< char,std::char_traits< char > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t = {"_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t", "std::basic_string< char > *|std::basic_string< char,std::char_traits< char >,std::allocator< char > > *|std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator = {"_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator", "std::basic_string< char >::iterator *|std::basic_string< char,std::char_traits< char >,std::allocator< char > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLConstructorException = {"_p_SBMLConstructorException", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_std__ios_base__openmode = {"_p_std__ios_base__openmode", "std::ios_base::openmode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapT_int_int_t = {"_p_std__multimapT_int_int_t", "ParentMap *|std::multimap< int,int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t = {"_p_std__pairT_ParentMap__iterator_ParentMap__iterator_t", "ParentRange *|std::pair< ParentMap::iterator,ParentMap::iterator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t = {"_p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t", "PackageReqd *|std::pair< std::basic_string< char,std::char_traits< char >,std::allocator< char > >,bool > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__SwigPyIterator = {"_p_swig__SwigPyIterator", "swig::SwigPyIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_ASTNode,
  &_swigt__p_ASTNodeType_t,
  &_swigt__p_AlgebraicRule,
  &_swigt__p_AssignmentRule,
  &_swigt__p_BiolQualifierType_t,
  &_swigt__p_CVTerm,
  &_swigt__p_Compartment,
  &_swigt__p_CompartmentType,
  &_swigt__p_Constraint,
  &_swigt__p_Date,
  &_swigt__p_Delay,
  &_swigt__p_Event,
  &_swigt__p_EventAssignment,
  &_swigt__p_FunctionDefinition,
  &_swigt__p_InitialAssignment,
  &_swigt__p_KineticLaw,
  &_swigt__p_List,
  &_swigt__p_ListOf,
  &_swigt__p_ListOfCompartmentTypes,
  &_swigt__p_ListOfCompartments,
  &_swigt__p_ListOfConstraints,
  &_swigt__p_ListOfEventAssignments,
  &_swigt__p_ListOfEvents,
  &_swigt__p_ListOfFunctionDefinitions,
  &_swigt__p_ListOfInitialAssignments,
  &_swigt__p_ListOfLocalParameters,
  &_swigt__p_ListOfParameters,
  &_swigt__p_ListOfReactions,
  &_swigt__p_ListOfRules,
  &_swigt__p_ListOfSpecies,
  &_swigt__p_ListOfSpeciesReferences,
  &_swigt__p_ListOfSpeciesTypes,
  &_swigt__p_ListOfUnitDefinitions,
  &_swigt__p_ListOfUnits,
  &_swigt__p_ListWrapperT_ASTNode_t,
  &_swigt__p_ListWrapperT_CVTerm_t,
  &_swigt__p_ListWrapperT_Date_t,
  &_swigt__p_ListWrapperT_ModelCreator_t,
  &_swigt__p_LocalParameter,
  &_swigt__p_Model,
  &_swigt__p_ModelCreator,
  &_swigt__p_ModelHistory,
  &_swigt__p_ModelQualifierType_t,
  &_swigt__p_ModifierSpeciesReference,
  &_swigt__p_OperationReturnValues_t,
  &_swigt__p_Parameter,
  &_swigt__p_ParentMap__iterator,
  &_swigt__p_QualifierType_t,
  &_swigt__p_RDFAnnotationParser,
  &_swigt__p_RateRule,
  &_swigt__p_Reaction,
  &_swigt__p_Rule,
  &_swigt__p_RuleType_t,
  &_swigt__p_SBMLConstructorException,
  &_swigt__p_SBMLDocument,
  &_swigt__p_SBMLError,
  &_swigt__p_SBMLErrorCategory_t,
  &_swigt__p_SBMLErrorCode_t,
  &_swigt__p_SBMLErrorLog,
  &_swigt__p_SBMLErrorSeverity_t,
  &_swigt__p_SBMLNamespaces,
  &_swigt__p_SBMLReader,
  &_swigt__p_SBMLTransforms,
  &_swigt__p_SBMLTypeCode_t,
  &_swigt__p_SBMLWriter,
  &_swigt__p_SBO,
  &_swigt__p_SBase,
  &_swigt__p_SimpleSpeciesReference,
  &_swigt__p_Species,
  &_swigt__p_SpeciesReference,
  &_swigt__p_SpeciesType,
  &_swigt__p_StoichiometryMath,
  &_swigt__p_SyntaxChecker,
  &_swigt__p_Trigger,
  &_swigt__p_Unit,
  &_swigt__p_UnitDefinition,
  &_swigt__p_UnitKind_t,
  &_swigt__p_XMLAttributes,
  &_swigt__p_XMLError,
  &_swigt__p_XMLErrorCategory_t,
  &_swigt__p_XMLErrorCode_t,
  &_swigt__p_XMLErrorLog,
  &_swigt__p_XMLErrorSeverity_t,
  &_swigt__p_XMLInputStream,
  &_swigt__p_XMLNamespaces,
  &_swigt__p_XMLNode,
  &_swigt__p_XMLOutputFileStream,
  &_swigt__p_XMLOutputStream,
  &_swigt__p_XMLOutputStringStream,
  &_swigt__p_XMLToken,
  &_swigt__p_XMLTriple,
  &_swigt__p__CharT,
  &_swigt__p_allocator_type,
  &_swigt__p_char,
  &_swigt__p_char_type,
  &_swigt__p_const_reference,
  &_swigt__p_difference_type,
  &_swigt__p_int_type,
  &_swigt__p_off_type,
  &_swigt__p_p_PyObject,
  &_swigt__p_pos_type,
  &_swigt__p_reference,
  &_swigt__p_size_type,
  &_swigt__p_state_type,
  &_swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  &_swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  &_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,
  &_swigt__p_std__invalid_argument,
  &_swigt__p_std__ios_base__openmode,
  &_swigt__p_std__multimapT_int_int_t,
  &_swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t,
  &_swigt__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t,
  &_swigt__p_swig__SwigPyIterator,
  &_swigt__p_value_type,
};

static swig_cast_info _swigc__p_ASTNode[] = {  {&_swigt__p_ASTNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ASTNodeType_t[] = {  {&_swigt__p_ASTNodeType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AlgebraicRule[] = {  {&_swigt__p_AlgebraicRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AssignmentRule[] = {  {&_swigt__p_AssignmentRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BiolQualifierType_t[] = {  {&_swigt__p_BiolQualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CVTerm[] = {  {&_swigt__p_CVTerm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Compartment[] = {  {&_swigt__p_Compartment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CompartmentType[] = {  {&_swigt__p_CompartmentType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Constraint[] = {  {&_swigt__p_Constraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Date[] = {  {&_swigt__p_Date, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Delay[] = {  {&_swigt__p_Delay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Event[] = {  {&_swigt__p_Event, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EventAssignment[] = {  {&_swigt__p_EventAssignment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FunctionDefinition[] = {  {&_swigt__p_FunctionDefinition, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InitialAssignment[] = {  {&_swigt__p_InitialAssignment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_KineticLaw[] = {  {&_swigt__p_KineticLaw, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_List[] = {  {&_swigt__p_List, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOf[] = {  {&_swigt__p_ListOfReactions, _p_ListOfReactionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfParameters, _p_ListOfParametersTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfEvents, _p_ListOfEventsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfRules, _p_ListOfRulesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfCompartments, _p_ListOfCompartmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfCompartmentTypes, _p_ListOfCompartmentTypesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfUnitDefinitions, _p_ListOfUnitDefinitionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfFunctionDefinitions, _p_ListOfFunctionDefinitionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfSpeciesTypes, _p_ListOfSpeciesTypesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfSpeciesReferences, _p_ListOfSpeciesReferencesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfInitialAssignments, _p_ListOfInitialAssignmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfEventAssignments, _p_ListOfEventAssignmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfConstraints, _p_ListOfConstraintsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfUnits, _p_ListOfUnitsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOf, 0, 0, 0},  {&_swigt__p_ListOfSpecies, _p_ListOfSpeciesTo_p_ListOf, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfCompartmentTypes[] = {  {&_swigt__p_ListOfCompartmentTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfCompartments[] = {  {&_swigt__p_ListOfCompartments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfConstraints[] = {  {&_swigt__p_ListOfConstraints, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfEventAssignments[] = {  {&_swigt__p_ListOfEventAssignments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfEvents[] = {  {&_swigt__p_ListOfEvents, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfFunctionDefinitions[] = {  {&_swigt__p_ListOfFunctionDefinitions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfInitialAssignments[] = {  {&_swigt__p_ListOfInitialAssignments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfLocalParameters[] = {  {&_swigt__p_ListOfLocalParameters, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfParameters[] = {  {&_swigt__p_ListOfParameters, 0, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_ListOfParameters, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfReactions[] = {  {&_swigt__p_ListOfReactions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfRules[] = {  {&_swigt__p_ListOfRules, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpecies[] = {  {&_swigt__p_ListOfSpecies, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpeciesReferences[] = {  {&_swigt__p_ListOfSpeciesReferences, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpeciesTypes[] = {  {&_swigt__p_ListOfSpeciesTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfUnitDefinitions[] = {  {&_swigt__p_ListOfUnitDefinitions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfUnits[] = {  {&_swigt__p_ListOfUnits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_ASTNode_t[] = {  {&_swigt__p_ListWrapperT_ASTNode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_CVTerm_t[] = {  {&_swigt__p_ListWrapperT_CVTerm_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_Date_t[] = {  {&_swigt__p_ListWrapperT_Date_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_ModelCreator_t[] = {  {&_swigt__p_ListWrapperT_ModelCreator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LocalParameter[] = {  {&_swigt__p_LocalParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Model[] = {  {&_swigt__p_Model, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelCreator[] = {  {&_swigt__p_ModelCreator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelHistory[] = {  {&_swigt__p_ModelHistory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelQualifierType_t[] = {  {&_swigt__p_ModelQualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModifierSpeciesReference[] = {  {&_swigt__p_ModifierSpeciesReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OperationReturnValues_t[] = {  {&_swigt__p_OperationReturnValues_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Parameter[] = {  {&_swigt__p_Parameter, 0, 0, 0},  {&_swigt__p_LocalParameter, _p_LocalParameterTo_p_Parameter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ParentMap__iterator[] = {  {&_swigt__p_ParentMap__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_QualifierType_t[] = {  {&_swigt__p_QualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RDFAnnotationParser[] = {  {&_swigt__p_RDFAnnotationParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RateRule[] = {  {&_swigt__p_RateRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Reaction[] = {  {&_swigt__p_Reaction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rule[] = {  {&_swigt__p_Rule, 0, 0, 0},  {&_swigt__p_AlgebraicRule, _p_AlgebraicRuleTo_p_Rule, 0, 0},  {&_swigt__p_AssignmentRule, _p_AssignmentRuleTo_p_Rule, 0, 0},  {&_swigt__p_RateRule, _p_RateRuleTo_p_Rule, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RuleType_t[] = {  {&_swigt__p_RuleType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLDocument[] = {  {&_swigt__p_SBMLDocument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLError[] = {  {&_swigt__p_SBMLError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorCategory_t[] = {  {&_swigt__p_SBMLErrorCategory_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorCode_t[] = {  {&_swigt__p_SBMLErrorCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorLog[] = {  {&_swigt__p_SBMLErrorLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorSeverity_t[] = {  {&_swigt__p_SBMLErrorSeverity_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLNamespaces[] = {  {&_swigt__p_SBMLNamespaces, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLReader[] = {  {&_swigt__p_SBMLReader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLTransforms[] = {  {&_swigt__p_SBMLTransforms, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLTypeCode_t[] = {  {&_swigt__p_SBMLTypeCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLWriter[] = {  {&_swigt__p_SBMLWriter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBO[] = {  {&_swigt__p_SBO, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBase[] = {  {&_swigt__p_Constraint, _p_ConstraintTo_p_SBase, 0, 0},  {&_swigt__p_RateRule, _p_RateRuleTo_p_SBase, 0, 0},  {&_swigt__p_ListOfFunctionDefinitions, _p_ListOfFunctionDefinitionsTo_p_SBase, 0, 0},  {&_swigt__p_ListOfUnitDefinitions, _p_ListOfUnitDefinitionsTo_p_SBase, 0, 0},  {&_swigt__p_SimpleSpeciesReference, _p_SimpleSpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_SpeciesReference, _p_SpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_ModifierSpeciesReference, _p_ModifierSpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_Event, _p_EventTo_p_SBase, 0, 0},  {&_swigt__p_EventAssignment, _p_EventAssignmentTo_p_SBase, 0, 0},  {&_swigt__p_InitialAssignment, _p_InitialAssignmentTo_p_SBase, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_SBase, 0, 0},  {&_swigt__p_ListOfParameters, _p_ListOfParametersTo_p_SBase, 0, 0},  {&_swigt__p_AssignmentRule, _p_AssignmentRuleTo_p_SBase, 0, 0},  {&_swigt__p_SBMLDocument, _p_SBMLDocumentTo_p_SBase, 0, 0},  {&_swigt__p_FunctionDefinition, _p_FunctionDefinitionTo_p_SBase, 0, 0},  {&_swigt__p_UnitDefinition, _p_UnitDefinitionTo_p_SBase, 0, 0},  {&_swigt__p_Model, _p_ModelTo_p_SBase, 0, 0},  {&_swigt__p_ListOfInitialAssignments, _p_ListOfInitialAssignmentsTo_p_SBase, 0, 0},  {&_swigt__p_ListOfEventAssignments, _p_ListOfEventAssignmentsTo_p_SBase, 0, 0},  {&_swigt__p_AlgebraicRule, _p_AlgebraicRuleTo_p_SBase, 0, 0},  {&_swigt__p_Delay, _p_DelayTo_p_SBase, 0, 0},  {&_swigt__p_ListOf, _p_ListOfTo_p_SBase, 0, 0},  {&_swigt__p_ListOfCompartmentTypes, _p_ListOfCompartmentTypesTo_p_SBase, 0, 0},  {&_swigt__p_Compartment, _p_CompartmentTo_p_SBase, 0, 0},  {&_swigt__p_KineticLaw, _p_KineticLawTo_p_SBase, 0, 0},  {&_swigt__p_ListOfEvents, _p_ListOfEventsTo_p_SBase, 0, 0},  {&_swigt__p_StoichiometryMath, _p_StoichiometryMathTo_p_SBase, 0, 0},  {&_swigt__p_Unit, _p_UnitTo_p_SBase, 0, 0},  {&_swigt__p_SBase, 0, 0, 0},  {&_swigt__p_ListOfSpeciesReferences, _p_ListOfSpeciesReferencesTo_p_SBase, 0, 0},  {&_swigt__p_ListOfSpeciesTypes, _p_ListOfSpeciesTypesTo_p_SBase, 0, 0},  {&_swigt__p_ListOfRules, _p_ListOfRulesTo_p_SBase, 0, 0},  {&_swigt__p_Rule, _p_RuleTo_p_SBase, 0, 0},  {&_swigt__p_ListOfConstraints, _p_ListOfConstraintsTo_p_SBase, 0, 0},  {&_swigt__p_ListOfReactions, _p_ListOfReactionsTo_p_SBase, 0, 0},  {&_swigt__p_CompartmentType, _p_CompartmentTypeTo_p_SBase, 0, 0},  {&_swigt__p_LocalParameter, _p_LocalParameterTo_p_SBase, 0, 0},  {&_swigt__p_Parameter, _p_ParameterTo_p_SBase, 0, 0},  {&_swigt__p_ListOfSpecies, _p_ListOfSpeciesTo_p_SBase, 0, 0},  {&_swigt__p_Species, _p_SpeciesTo_p_SBase, 0, 0},  {&_swigt__p_Trigger, _p_TriggerTo_p_SBase, 0, 0},  {&_swigt__p_ListOfUnits, _p_ListOfUnitsTo_p_SBase, 0, 0},  {&_swigt__p_SpeciesType, _p_SpeciesTypeTo_p_SBase, 0, 0},  {&_swigt__p_ListOfCompartments, _p_ListOfCompartmentsTo_p_SBase, 0, 0},  {&_swigt__p_Reaction, _p_ReactionTo_p_SBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SimpleSpeciesReference[] = {  {&_swigt__p_SimpleSpeciesReference, 0, 0, 0},  {&_swigt__p_SpeciesReference, _p_SpeciesReferenceTo_p_SimpleSpeciesReference, 0, 0},  {&_swigt__p_ModifierSpeciesReference, _p_ModifierSpeciesReferenceTo_p_SimpleSpeciesReference, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Species[] = {  {&_swigt__p_Species, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SpeciesReference[] = {  {&_swigt__p_SpeciesReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SpeciesType[] = {  {&_swigt__p_SpeciesType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StoichiometryMath[] = {  {&_swigt__p_StoichiometryMath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SyntaxChecker[] = {  {&_swigt__p_SyntaxChecker, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Trigger[] = {  {&_swigt__p_Trigger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Unit[] = {  {&_swigt__p_Unit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UnitDefinition[] = {  {&_swigt__p_UnitDefinition, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UnitKind_t[] = {  {&_swigt__p_UnitKind_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLAttributes[] = {  {&_swigt__p_XMLAttributes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLError[] = {  {&_swigt__p_XMLError, 0, 0, 0},  {&_swigt__p_SBMLError, _p_SBMLErrorTo_p_XMLError, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorCategory_t[] = {  {&_swigt__p_XMLErrorCategory_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorCode_t[] = {  {&_swigt__p_XMLErrorCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorLog[] = {  {&_swigt__p_XMLErrorLog, 0, 0, 0},  {&_swigt__p_SBMLErrorLog, _p_SBMLErrorLogTo_p_XMLErrorLog, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorSeverity_t[] = {  {&_swigt__p_XMLErrorSeverity_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLInputStream[] = {  {&_swigt__p_XMLInputStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLNamespaces[] = {  {&_swigt__p_XMLNamespaces, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLNode[] = {  {&_swigt__p_XMLNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputStringStream[] = {{&_swigt__p_XMLOutputStringStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputFileStream[] = {{&_swigt__p_XMLOutputFileStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputStream[] = {  {&_swigt__p_XMLOutputStringStream, _p_XMLOutputStringStreamTo_p_XMLOutputStream, 0, 0},  {&_swigt__p_XMLOutputFileStream, _p_XMLOutputFileStreamTo_p_XMLOutputStream, 0, 0},  {&_swigt__p_XMLOutputStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLToken[] = {  {&_swigt__p_XMLToken, 0, 0, 0},  {&_swigt__p_XMLNode, _p_XMLNodeTo_p_XMLToken, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLTriple[] = {  {&_swigt__p_XMLTriple, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__CharT[] = {  {&_swigt__p__CharT, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char_type[] = {  {&_swigt__p_char_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_reference[] = {  {&_swigt__p_const_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int_type[] = {  {&_swigt__p_int_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_off_type[] = {  {&_swigt__p_off_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_PyObject[] = {  {&_swigt__p_p_PyObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pos_type[] = {  {&_swigt__p_pos_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_reference[] = {  {&_swigt__p_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_state_type[] = {  {&_swigt__p_state_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_iosT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0, 0},  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, _p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0},  {&_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, _p_std__basic_ostreamT_char_std__char_traitsT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, _p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0, 0},  {&_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t[] = {  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_streambufT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t[] = {  {&_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator[] = {  {&_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLConstructorException[] = {{&_swigt__p_SBMLConstructorException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_SBMLConstructorException, _p_SBMLConstructorExceptionTo_p_std__invalid_argument, 0, 0},  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ios_base__openmode[] = {  {&_swigt__p_std__ios_base__openmode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapT_int_int_t[] = {  {&_swigt__p_std__multimapT_int_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t[] = {  {&_swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t[] = {  {&_swigt__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__SwigPyIterator[] = {  {&_swigt__p_swig__SwigPyIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_ASTNode,
  _swigc__p_ASTNodeType_t,
  _swigc__p_AlgebraicRule,
  _swigc__p_AssignmentRule,
  _swigc__p_BiolQualifierType_t,
  _swigc__p_CVTerm,
  _swigc__p_Compartment,
  _swigc__p_CompartmentType,
  _swigc__p_Constraint,
  _swigc__p_Date,
  _swigc__p_Delay,
  _swigc__p_Event,
  _swigc__p_EventAssignment,
  _swigc__p_FunctionDefinition,
  _swigc__p_InitialAssignment,
  _swigc__p_KineticLaw,
  _swigc__p_List,
  _swigc__p_ListOf,
  _swigc__p_ListOfCompartmentTypes,
  _swigc__p_ListOfCompartments,
  _swigc__p_ListOfConstraints,
  _swigc__p_ListOfEventAssignments,
  _swigc__p_ListOfEvents,
  _swigc__p_ListOfFunctionDefinitions,
  _swigc__p_ListOfInitialAssignments,
  _swigc__p_ListOfLocalParameters,
  _swigc__p_ListOfParameters,
  _swigc__p_ListOfReactions,
  _swigc__p_ListOfRules,
  _swigc__p_ListOfSpecies,
  _swigc__p_ListOfSpeciesReferences,
  _swigc__p_ListOfSpeciesTypes,
  _swigc__p_ListOfUnitDefinitions,
  _swigc__p_ListOfUnits,
  _swigc__p_ListWrapperT_ASTNode_t,
  _swigc__p_ListWrapperT_CVTerm_t,
  _swigc__p_ListWrapperT_Date_t,
  _swigc__p_ListWrapperT_ModelCreator_t,
  _swigc__p_LocalParameter,
  _swigc__p_Model,
  _swigc__p_ModelCreator,
  _swigc__p_ModelHistory,
  _swigc__p_ModelQualifierType_t,
  _swigc__p_ModifierSpeciesReference,
  _swigc__p_OperationReturnValues_t,
  _swigc__p_Parameter,
  _swigc__p_ParentMap__iterator,
  _swigc__p_QualifierType_t,
  _swigc__p_RDFAnnotationParser,
  _swigc__p_RateRule,
  _swigc__p_Reaction,
  _swigc__p_Rule,
  _swigc__p_RuleType_t,
  _swigc__p_SBMLConstructorException,
  _swigc__p_SBMLDocument,
  _swigc__p_SBMLError,
  _swigc__p_SBMLErrorCategory_t,
  _swigc__p_SBMLErrorCode_t,
  _swigc__p_SBMLErrorLog,
  _swigc__p_SBMLErrorSeverity_t,
  _swigc__p_SBMLNamespaces,
  _swigc__p_SBMLReader,
  _swigc__p_SBMLTransforms,
  _swigc__p_SBMLTypeCode_t,
  _swigc__p_SBMLWriter,
  _swigc__p_SBO,
  _swigc__p_SBase,
  _swigc__p_SimpleSpeciesReference,
  _swigc__p_Species,
  _swigc__p_SpeciesReference,
  _swigc__p_SpeciesType,
  _swigc__p_StoichiometryMath,
  _swigc__p_SyntaxChecker,
  _swigc__p_Trigger,
  _swigc__p_Unit,
  _swigc__p_UnitDefinition,
  _swigc__p_UnitKind_t,
  _swigc__p_XMLAttributes,
  _swigc__p_XMLError,
  _swigc__p_XMLErrorCategory_t,
  _swigc__p_XMLErrorCode_t,
  _swigc__p_XMLErrorLog,
  _swigc__p_XMLErrorSeverity_t,
  _swigc__p_XMLInputStream,
  _swigc__p_XMLNamespaces,
  _swigc__p_XMLNode,
  _swigc__p_XMLOutputFileStream,
  _swigc__p_XMLOutputStream,
  _swigc__p_XMLOutputStringStream,
  _swigc__p_XMLToken,
  _swigc__p_XMLTriple,
  _swigc__p__CharT,
  _swigc__p_allocator_type,
  _swigc__p_char,
  _swigc__p_char_type,
  _swigc__p_const_reference,
  _swigc__p_difference_type,
  _swigc__p_int_type,
  _swigc__p_off_type,
  _swigc__p_p_PyObject,
  _swigc__p_pos_type,
  _swigc__p_reference,
  _swigc__p_size_type,
  _swigc__p_state_type,
  _swigc__p_std__basic_iosT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  _swigc__p_std__basic_streambufT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,
  _swigc__p_std__invalid_argument,
  _swigc__p_std__ios_base__openmode,
  _swigc__p_std__multimapT_int_int_t,
  _swigc__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t,
  _swigc__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t,
  _swigc__p_swig__SwigPyIterator,
  _swigc__p_value_type,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;
  
  clientdata = clientdata;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpeters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;  
    if (!type_init) {
      const PyTypeObject tmp
      = {
        /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* Number of items in variable part (ob_size) */
#endif
        (char *)"swigvarlink",              /* Type name (tp_name) */
        sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
        0,                                  /* Itemsize (tp_itemsize) */
        (destructor) swig_varlink_dealloc,  /* Deallocator (tp_dealloc) */ 
        (printfunc) swig_varlink_print,     /* Print (tp_print) */
        (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
        (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
        0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
      varlink_type = tmp;
      /* for Python 3 we already assigned ob_type in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
      varlink_type.ob_type = &PyType_Type;
#endif
      type_init = 1;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (c && (c = strstr(c, "swig_ptr: "))) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          size_t shift = (ci->ptype) - types;
          swig_type_info *ty = types_initial[shift];
          size_t ldoc = (c - methods[i].ml_doc);
          size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
          char *ndoc = (char*)malloc(ldoc + lptr + 10);
          if (ndoc) {
            char *buff = ndoc;
            void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
            if (ptr) {
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d;  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  d = PyModule_GetDict(m);
  
  SWIG_InitializeModule(0);
  SWIG_InstallConstants(d,swig_const_table);
  
  
  PyDict_SetItemString(d,(char*)"cvar", SWIG_globals());
  SWIG_addvarlink(SWIG_globals(),(char*)"string_npos",Swig_var_string_npos_get, Swig_var_string_npos_set);
  SWIG_addvarlink(SWIG_globals(),(char*)"cout",Swig_var_cout_get, Swig_var_cout_set);
  SWIG_addvarlink(SWIG_globals(),(char*)"cerr",Swig_var_cerr_get, Swig_var_cerr_set);
  SWIG_addvarlink(SWIG_globals(),(char*)"clog",Swig_var_clog_get, Swig_var_clog_set);
  SWIG_Python_SetConstant(d, "LIBSBML_DOTTED_VERSION",SWIG_FromCharPtr("4.1.0"));
  SWIG_Python_SetConstant(d, "LIBSBML_VERSION",SWIG_From_int(static_cast< int >(40100)));
  SWIG_Python_SetConstant(d, "LIBSBML_VERSION_STRING",SWIG_FromCharPtr("40100"));
  SWIG_Python_SetConstant(d, "LIBSBML_OPERATION_SUCCESS",SWIG_From_int(static_cast< int >(LIBSBML_OPERATION_SUCCESS)));
  SWIG_Python_SetConstant(d, "LIBSBML_INDEX_EXCEEDS_SIZE",SWIG_From_int(static_cast< int >(LIBSBML_INDEX_EXCEEDS_SIZE)));
  SWIG_Python_SetConstant(d, "LIBSBML_UNEXPECTED_ATTRIBUTE",SWIG_From_int(static_cast< int >(LIBSBML_UNEXPECTED_ATTRIBUTE)));
  SWIG_Python_SetConstant(d, "LIBSBML_OPERATION_FAILED",SWIG_From_int(static_cast< int >(LIBSBML_OPERATION_FAILED)));
  SWIG_Python_SetConstant(d, "LIBSBML_INVALID_ATTRIBUTE_VALUE",SWIG_From_int(static_cast< int >(LIBSBML_INVALID_ATTRIBUTE_VALUE)));
  SWIG_Python_SetConstant(d, "LIBSBML_INVALID_OBJECT",SWIG_From_int(static_cast< int >(LIBSBML_INVALID_OBJECT)));
  SWIG_Python_SetConstant(d, "LIBSBML_DUPLICATE_OBJECT_ID",SWIG_From_int(static_cast< int >(LIBSBML_DUPLICATE_OBJECT_ID)));
  SWIG_Python_SetConstant(d, "LIBSBML_LEVEL_MISMATCH",SWIG_From_int(static_cast< int >(LIBSBML_LEVEL_MISMATCH)));
  SWIG_Python_SetConstant(d, "LIBSBML_VERSION_MISMATCH",SWIG_From_int(static_cast< int >(LIBSBML_VERSION_MISMATCH)));
  SWIG_Python_SetConstant(d, "LIBSBML_INVALID_XML_OPERATION",SWIG_From_int(static_cast< int >(LIBSBML_INVALID_XML_OPERATION)));
  SWIG_Python_SetConstant(d, "SBML_UNKNOWN",SWIG_From_int(static_cast< int >(SBML_UNKNOWN)));
  SWIG_Python_SetConstant(d, "SBML_COMPARTMENT",SWIG_From_int(static_cast< int >(SBML_COMPARTMENT)));
  SWIG_Python_SetConstant(d, "SBML_COMPARTMENT_TYPE",SWIG_From_int(static_cast< int >(SBML_COMPARTMENT_TYPE)));
  SWIG_Python_SetConstant(d, "SBML_CONSTRAINT",SWIG_From_int(static_cast< int >(SBML_CONSTRAINT)));
  SWIG_Python_SetConstant(d, "SBML_DOCUMENT",SWIG_From_int(static_cast< int >(SBML_DOCUMENT)));
  SWIG_Python_SetConstant(d, "SBML_EVENT",SWIG_From_int(static_cast< int >(SBML_EVENT)));
  SWIG_Python_SetConstant(d, "SBML_EVENT_ASSIGNMENT",SWIG_From_int(static_cast< int >(SBML_EVENT_ASSIGNMENT)));
  SWIG_Python_SetConstant(d, "SBML_FUNCTION_DEFINITION",SWIG_From_int(static_cast< int >(SBML_FUNCTION_DEFINITION)));
  SWIG_Python_SetConstant(d, "SBML_INITIAL_ASSIGNMENT",SWIG_From_int(static_cast< int >(SBML_INITIAL_ASSIGNMENT)));
  SWIG_Python_SetConstant(d, "SBML_KINETIC_LAW",SWIG_From_int(static_cast< int >(SBML_KINETIC_LAW)));
  SWIG_Python_SetConstant(d, "SBML_LIST_OF",SWIG_From_int(static_cast< int >(SBML_LIST_OF)));
  SWIG_Python_SetConstant(d, "SBML_MODEL",SWIG_From_int(static_cast< int >(SBML_MODEL)));
  SWIG_Python_SetConstant(d, "SBML_PARAMETER",SWIG_From_int(static_cast< int >(SBML_PARAMETER)));
  SWIG_Python_SetConstant(d, "SBML_REACTION",SWIG_From_int(static_cast< int >(SBML_REACTION)));
  SWIG_Python_SetConstant(d, "SBML_RULE",SWIG_From_int(static_cast< int >(SBML_RULE)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES",SWIG_From_int(static_cast< int >(SBML_SPECIES)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES_REFERENCE",SWIG_From_int(static_cast< int >(SBML_SPECIES_REFERENCE)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES_TYPE",SWIG_From_int(static_cast< int >(SBML_SPECIES_TYPE)));
  SWIG_Python_SetConstant(d, "SBML_MODIFIER_SPECIES_REFERENCE",SWIG_From_int(static_cast< int >(SBML_MODIFIER_SPECIES_REFERENCE)));
  SWIG_Python_SetConstant(d, "SBML_UNIT_DEFINITION",SWIG_From_int(static_cast< int >(SBML_UNIT_DEFINITION)));
  SWIG_Python_SetConstant(d, "SBML_UNIT",SWIG_From_int(static_cast< int >(SBML_UNIT)));
  SWIG_Python_SetConstant(d, "SBML_ALGEBRAIC_RULE",SWIG_From_int(static_cast< int >(SBML_ALGEBRAIC_RULE)));
  SWIG_Python_SetConstant(d, "SBML_ASSIGNMENT_RULE",SWIG_From_int(static_cast< int >(SBML_ASSIGNMENT_RULE)));
  SWIG_Python_SetConstant(d, "SBML_RATE_RULE",SWIG_From_int(static_cast< int >(SBML_RATE_RULE)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES_CONCENTRATION_RULE",SWIG_From_int(static_cast< int >(SBML_SPECIES_CONCENTRATION_RULE)));
  SWIG_Python_SetConstant(d, "SBML_COMPARTMENT_VOLUME_RULE",SWIG_From_int(static_cast< int >(SBML_COMPARTMENT_VOLUME_RULE)));
  SWIG_Python_SetConstant(d, "SBML_PARAMETER_RULE",SWIG_From_int(static_cast< int >(SBML_PARAMETER_RULE)));
  SWIG_Python_SetConstant(d, "SBML_TRIGGER",SWIG_From_int(static_cast< int >(SBML_TRIGGER)));
  SWIG_Python_SetConstant(d, "SBML_DELAY",SWIG_From_int(static_cast< int >(SBML_DELAY)));
  SWIG_Python_SetConstant(d, "SBML_STOICHIOMETRY_MATH",SWIG_From_int(static_cast< int >(SBML_STOICHIOMETRY_MATH)));
  SWIG_Python_SetConstant(d, "SBML_LOCAL_PARAMETER",SWIG_From_int(static_cast< int >(SBML_LOCAL_PARAMETER)));
  SWIG_Python_SetConstant(d, "SBML_FORMULA_UNITS_DATA",SWIG_From_int(static_cast< int >(SBML_FORMULA_UNITS_DATA)));
  SWIG_Python_SetConstant(d, "SBML_LIST_FORMULA_UNITS_DATA",SWIG_From_int(static_cast< int >(SBML_LIST_FORMULA_UNITS_DATA)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_COMPARTMENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_COMPARTMENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_COMPARTMENT_TYPES",SWIG_From_int(static_cast< int >(SBML_LISTOF_COMPARTMENT_TYPES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_CONSTRAINTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_CONSTRAINTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_EVENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_EVENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_EVENT_ASSIGNMENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_EVENT_ASSIGNMENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_FUNCTION_DEFINITIONS",SWIG_From_int(static_cast< int >(SBML_LISTOF_FUNCTION_DEFINITIONS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_INITIAL_ASSIGNMENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_INITIAL_ASSIGNMENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_PARAMETERS",SWIG_From_int(static_cast< int >(SBML_LISTOF_PARAMETERS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_REACTIONS",SWIG_From_int(static_cast< int >(SBML_LISTOF_REACTIONS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_RULES",SWIG_From_int(static_cast< int >(SBML_LISTOF_RULES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_SPECIES",SWIG_From_int(static_cast< int >(SBML_LISTOF_SPECIES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_SPECIES_REFERENCES",SWIG_From_int(static_cast< int >(SBML_LISTOF_SPECIES_REFERENCES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_SPECIES_TYPES",SWIG_From_int(static_cast< int >(SBML_LISTOF_SPECIES_TYPES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_UNIT_DEFINITIONS",SWIG_From_int(static_cast< int >(SBML_LISTOF_UNIT_DEFINITIONS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_UNITS",SWIG_From_int(static_cast< int >(SBML_LISTOF_UNITS)));
  SWIG_Python_SetConstant(d, "IdCheckON",SWIG_From_int(static_cast< int >(0x01)));
  SWIG_Python_SetConstant(d, "IdCheckOFF",SWIG_From_int(static_cast< int >(0xfe)));
  SWIG_Python_SetConstant(d, "SBMLCheckON",SWIG_From_int(static_cast< int >(0x02)));
  SWIG_Python_SetConstant(d, "SBMLCheckOFF",SWIG_From_int(static_cast< int >(0xfd)));
  SWIG_Python_SetConstant(d, "SBOCheckON",SWIG_From_int(static_cast< int >(0x04)));
  SWIG_Python_SetConstant(d, "SBOCheckOFF",SWIG_From_int(static_cast< int >(0xfb)));
  SWIG_Python_SetConstant(d, "MathCheckON",SWIG_From_int(static_cast< int >(0x08)));
  SWIG_Python_SetConstant(d, "MathCheckOFF",SWIG_From_int(static_cast< int >(0xf7)));
  SWIG_Python_SetConstant(d, "UnitsCheckON",SWIG_From_int(static_cast< int >(0x10)));
  SWIG_Python_SetConstant(d, "UnitsCheckOFF",SWIG_From_int(static_cast< int >(0xef)));
  SWIG_Python_SetConstant(d, "OverdeterCheckON",SWIG_From_int(static_cast< int >(0x20)));
  SWIG_Python_SetConstant(d, "OverdeterCheckOFF",SWIG_From_int(static_cast< int >(0xdf)));
  SWIG_Python_SetConstant(d, "PracticeCheckON",SWIG_From_int(static_cast< int >(0x40)));
  SWIG_Python_SetConstant(d, "PracticeCheckOFF",SWIG_From_int(static_cast< int >(0xbf)));
  SWIG_Python_SetConstant(d, "AllChecksON",SWIG_From_int(static_cast< int >(0x7f)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_AMPERE",SWIG_From_int(static_cast< int >(UNIT_KIND_AMPERE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_AVOGADRO",SWIG_From_int(static_cast< int >(UNIT_KIND_AVOGADRO)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_BECQUEREL",SWIG_From_int(static_cast< int >(UNIT_KIND_BECQUEREL)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_CANDELA",SWIG_From_int(static_cast< int >(UNIT_KIND_CANDELA)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_CELSIUS",SWIG_From_int(static_cast< int >(UNIT_KIND_CELSIUS)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_COULOMB",SWIG_From_int(static_cast< int >(UNIT_KIND_COULOMB)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_DIMENSIONLESS",SWIG_From_int(static_cast< int >(UNIT_KIND_DIMENSIONLESS)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_FARAD",SWIG_From_int(static_cast< int >(UNIT_KIND_FARAD)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_GRAM",SWIG_From_int(static_cast< int >(UNIT_KIND_GRAM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_GRAY",SWIG_From_int(static_cast< int >(UNIT_KIND_GRAY)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_HENRY",SWIG_From_int(static_cast< int >(UNIT_KIND_HENRY)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_HERTZ",SWIG_From_int(static_cast< int >(UNIT_KIND_HERTZ)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_ITEM",SWIG_From_int(static_cast< int >(UNIT_KIND_ITEM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_JOULE",SWIG_From_int(static_cast< int >(UNIT_KIND_JOULE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_KATAL",SWIG_From_int(static_cast< int >(UNIT_KIND_KATAL)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_KELVIN",SWIG_From_int(static_cast< int >(UNIT_KIND_KELVIN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_KILOGRAM",SWIG_From_int(static_cast< int >(UNIT_KIND_KILOGRAM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LITER",SWIG_From_int(static_cast< int >(UNIT_KIND_LITER)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LITRE",SWIG_From_int(static_cast< int >(UNIT_KIND_LITRE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LUMEN",SWIG_From_int(static_cast< int >(UNIT_KIND_LUMEN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LUX",SWIG_From_int(static_cast< int >(UNIT_KIND_LUX)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_METER",SWIG_From_int(static_cast< int >(UNIT_KIND_METER)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_METRE",SWIG_From_int(static_cast< int >(UNIT_KIND_METRE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_MOLE",SWIG_From_int(static_cast< int >(UNIT_KIND_MOLE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_NEWTON",SWIG_From_int(static_cast< int >(UNIT_KIND_NEWTON)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_OHM",SWIG_From_int(static_cast< int >(UNIT_KIND_OHM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_PASCAL",SWIG_From_int(static_cast< int >(UNIT_KIND_PASCAL)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_RADIAN",SWIG_From_int(static_cast< int >(UNIT_KIND_RADIAN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_SECOND",SWIG_From_int(static_cast< int >(UNIT_KIND_SECOND)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_SIEMENS",SWIG_From_int(static_cast< int >(UNIT_KIND_SIEMENS)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_SIEVERT",SWIG_From_int(static_cast< int >(UNIT_KIND_SIEVERT)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_STERADIAN",SWIG_From_int(static_cast< int >(UNIT_KIND_STERADIAN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_TESLA",SWIG_From_int(static_cast< int >(UNIT_KIND_TESLA)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_VOLT",SWIG_From_int(static_cast< int >(UNIT_KIND_VOLT)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_WATT",SWIG_From_int(static_cast< int >(UNIT_KIND_WATT)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_WEBER",SWIG_From_int(static_cast< int >(UNIT_KIND_WEBER)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_INVALID",SWIG_From_int(static_cast< int >(UNIT_KIND_INVALID)));
  SWIG_Python_SetConstant(d, "RULE_TYPE_RATE",SWIG_From_int(static_cast< int >(RULE_TYPE_RATE)));
  SWIG_Python_SetConstant(d, "RULE_TYPE_SCALAR",SWIG_From_int(static_cast< int >(RULE_TYPE_SCALAR)));
  SWIG_Python_SetConstant(d, "RULE_TYPE_INVALID",SWIG_From_int(static_cast< int >(RULE_TYPE_INVALID)));
  SWIG_Python_SetConstant(d, "SBML_DEFAULT_LEVEL",SWIG_From_int(static_cast< int >(3)));
  SWIG_Python_SetConstant(d, "SBML_DEFAULT_VERSION",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L1",SWIG_FromCharPtr("http://www.sbml.org/sbml/level1"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V1",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V2",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2/version2"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V3",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2/version3"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V4",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2/version4"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L3V1",SWIG_FromCharPtr("http://www.sbml.org/sbml/level3/version1/core"));
  SWIG_Python_SetConstant(d, "AST_PLUS",SWIG_From_int(static_cast< int >(AST_PLUS)));
  SWIG_Python_SetConstant(d, "AST_MINUS",SWIG_From_int(static_cast< int >(AST_MINUS)));
  SWIG_Python_SetConstant(d, "AST_TIMES",SWIG_From_int(static_cast< int >(AST_TIMES)));
  SWIG_Python_SetConstant(d, "AST_DIVIDE",SWIG_From_int(static_cast< int >(AST_DIVIDE)));
  SWIG_Python_SetConstant(d, "AST_POWER",SWIG_From_int(static_cast< int >(AST_POWER)));
  SWIG_Python_SetConstant(d, "AST_INTEGER",SWIG_From_int(static_cast< int >(AST_INTEGER)));
  SWIG_Python_SetConstant(d, "AST_REAL",SWIG_From_int(static_cast< int >(AST_REAL)));
  SWIG_Python_SetConstant(d, "AST_REAL_E",SWIG_From_int(static_cast< int >(AST_REAL_E)));
  SWIG_Python_SetConstant(d, "AST_RATIONAL",SWIG_From_int(static_cast< int >(AST_RATIONAL)));
  SWIG_Python_SetConstant(d, "AST_NAME",SWIG_From_int(static_cast< int >(AST_NAME)));
  SWIG_Python_SetConstant(d, "AST_NAME_AVOGADRO",SWIG_From_int(static_cast< int >(AST_NAME_AVOGADRO)));
  SWIG_Python_SetConstant(d, "AST_NAME_TIME",SWIG_From_int(static_cast< int >(AST_NAME_TIME)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_E",SWIG_From_int(static_cast< int >(AST_CONSTANT_E)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_FALSE",SWIG_From_int(static_cast< int >(AST_CONSTANT_FALSE)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_PI",SWIG_From_int(static_cast< int >(AST_CONSTANT_PI)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_TRUE",SWIG_From_int(static_cast< int >(AST_CONSTANT_TRUE)));
  SWIG_Python_SetConstant(d, "AST_LAMBDA",SWIG_From_int(static_cast< int >(AST_LAMBDA)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION",SWIG_From_int(static_cast< int >(AST_FUNCTION)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ABS",SWIG_From_int(static_cast< int >(AST_FUNCTION_ABS)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOS",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOS)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOSH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOSH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOT",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOT)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOTH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOTH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCSC",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCSC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCSCH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCSCH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSEC",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSEC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSECH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSECH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSIN",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSIN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSINH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSINH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCTAN",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCTAN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCTANH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCTANH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_CEILING",SWIG_From_int(static_cast< int >(AST_FUNCTION_CEILING)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COS",SWIG_From_int(static_cast< int >(AST_FUNCTION_COS)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COSH",SWIG_From_int(static_cast< int >(AST_FUNCTION_COSH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COT",SWIG_From_int(static_cast< int >(AST_FUNCTION_COT)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COTH",SWIG_From_int(static_cast< int >(AST_FUNCTION_COTH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_CSC",SWIG_From_int(static_cast< int >(AST_FUNCTION_CSC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_CSCH",SWIG_From_int(static_cast< int >(AST_FUNCTION_CSCH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_DELAY",SWIG_From_int(static_cast< int >(AST_FUNCTION_DELAY)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_EXP",SWIG_From_int(static_cast< int >(AST_FUNCTION_EXP)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_FACTORIAL",SWIG_From_int(static_cast< int >(AST_FUNCTION_FACTORIAL)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_FLOOR",SWIG_From_int(static_cast< int >(AST_FUNCTION_FLOOR)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_LN",SWIG_From_int(static_cast< int >(AST_FUNCTION_LN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_LOG",SWIG_From_int(static_cast< int >(AST_FUNCTION_LOG)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_PIECEWISE",SWIG_From_int(static_cast< int >(AST_FUNCTION_PIECEWISE)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_POWER",SWIG_From_int(static_cast< int >(AST_FUNCTION_POWER)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ROOT",SWIG_From_int(static_cast< int >(AST_FUNCTION_ROOT)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SEC",SWIG_From_int(static_cast< int >(AST_FUNCTION_SEC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SECH",SWIG_From_int(static_cast< int >(AST_FUNCTION_SECH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SIN",SWIG_From_int(static_cast< int >(AST_FUNCTION_SIN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SINH",SWIG_From_int(static_cast< int >(AST_FUNCTION_SINH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_TAN",SWIG_From_int(static_cast< int >(AST_FUNCTION_TAN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_TANH",SWIG_From_int(static_cast< int >(AST_FUNCTION_TANH)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_AND",SWIG_From_int(static_cast< int >(AST_LOGICAL_AND)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_NOT",SWIG_From_int(static_cast< int >(AST_LOGICAL_NOT)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_OR",SWIG_From_int(static_cast< int >(AST_LOGICAL_OR)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_XOR",SWIG_From_int(static_cast< int >(AST_LOGICAL_XOR)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_EQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_EQ)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_GEQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_GEQ)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_GT",SWIG_From_int(static_cast< int >(AST_RELATIONAL_GT)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_LEQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_LEQ)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_LT",SWIG_From_int(static_cast< int >(AST_RELATIONAL_LT)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_NEQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_NEQ)));
  SWIG_Python_SetConstant(d, "AST_UNKNOWN",SWIG_From_int(static_cast< int >(AST_UNKNOWN)));
  SWIG_Python_SetConstant(d, "XMLUnknownError",SWIG_From_int(static_cast< int >(XMLUnknownError)));
  SWIG_Python_SetConstant(d, "XMLOutOfMemory",SWIG_From_int(static_cast< int >(XMLOutOfMemory)));
  SWIG_Python_SetConstant(d, "XMLFileUnreadable",SWIG_From_int(static_cast< int >(XMLFileUnreadable)));
  SWIG_Python_SetConstant(d, "XMLFileUnwritable",SWIG_From_int(static_cast< int >(XMLFileUnwritable)));
  SWIG_Python_SetConstant(d, "XMLFileOperationError",SWIG_From_int(static_cast< int >(XMLFileOperationError)));
  SWIG_Python_SetConstant(d, "XMLNetworkAccessError",SWIG_From_int(static_cast< int >(XMLNetworkAccessError)));
  SWIG_Python_SetConstant(d, "InternalXMLParserError",SWIG_From_int(static_cast< int >(InternalXMLParserError)));
  SWIG_Python_SetConstant(d, "UnrecognizedXMLParserCode",SWIG_From_int(static_cast< int >(UnrecognizedXMLParserCode)));
  SWIG_Python_SetConstant(d, "XMLTranscoderError",SWIG_From_int(static_cast< int >(XMLTranscoderError)));
  SWIG_Python_SetConstant(d, "MissingXMLDecl",SWIG_From_int(static_cast< int >(MissingXMLDecl)));
  SWIG_Python_SetConstant(d, "MissingXMLEncoding",SWIG_From_int(static_cast< int >(MissingXMLEncoding)));
  SWIG_Python_SetConstant(d, "BadXMLDecl",SWIG_From_int(static_cast< int >(BadXMLDecl)));
  SWIG_Python_SetConstant(d, "BadXMLDOCTYPE",SWIG_From_int(static_cast< int >(BadXMLDOCTYPE)));
  SWIG_Python_SetConstant(d, "InvalidCharInXML",SWIG_From_int(static_cast< int >(InvalidCharInXML)));
  SWIG_Python_SetConstant(d, "BadlyFormedXML",SWIG_From_int(static_cast< int >(BadlyFormedXML)));
  SWIG_Python_SetConstant(d, "UnclosedXMLToken",SWIG_From_int(static_cast< int >(UnclosedXMLToken)));
  SWIG_Python_SetConstant(d, "InvalidXMLConstruct",SWIG_From_int(static_cast< int >(InvalidXMLConstruct)));
  SWIG_Python_SetConstant(d, "XMLTagMismatch",SWIG_From_int(static_cast< int >(XMLTagMismatch)));
  SWIG_Python_SetConstant(d, "DuplicateXMLAttribute",SWIG_From_int(static_cast< int >(DuplicateXMLAttribute)));
  SWIG_Python_SetConstant(d, "UndefinedXMLEntity",SWIG_From_int(static_cast< int >(UndefinedXMLEntity)));
  SWIG_Python_SetConstant(d, "BadProcessingInstruction",SWIG_From_int(static_cast< int >(BadProcessingInstruction)));
  SWIG_Python_SetConstant(d, "BadXMLPrefix",SWIG_From_int(static_cast< int >(BadXMLPrefix)));
  SWIG_Python_SetConstant(d, "BadXMLPrefixValue",SWIG_From_int(static_cast< int >(BadXMLPrefixValue)));
  SWIG_Python_SetConstant(d, "MissingXMLRequiredAttribute",SWIG_From_int(static_cast< int >(MissingXMLRequiredAttribute)));
  SWIG_Python_SetConstant(d, "XMLAttributeTypeMismatch",SWIG_From_int(static_cast< int >(XMLAttributeTypeMismatch)));
  SWIG_Python_SetConstant(d, "XMLBadUTF8Content",SWIG_From_int(static_cast< int >(XMLBadUTF8Content)));
  SWIG_Python_SetConstant(d, "MissingXMLAttributeValue",SWIG_From_int(static_cast< int >(MissingXMLAttributeValue)));
  SWIG_Python_SetConstant(d, "BadXMLAttributeValue",SWIG_From_int(static_cast< int >(BadXMLAttributeValue)));
  SWIG_Python_SetConstant(d, "BadXMLAttribute",SWIG_From_int(static_cast< int >(BadXMLAttribute)));
  SWIG_Python_SetConstant(d, "UnrecognizedXMLElement",SWIG_From_int(static_cast< int >(UnrecognizedXMLElement)));
  SWIG_Python_SetConstant(d, "BadXMLComment",SWIG_From_int(static_cast< int >(BadXMLComment)));
  SWIG_Python_SetConstant(d, "BadXMLDeclLocation",SWIG_From_int(static_cast< int >(BadXMLDeclLocation)));
  SWIG_Python_SetConstant(d, "XMLUnexpectedEOF",SWIG_From_int(static_cast< int >(XMLUnexpectedEOF)));
  SWIG_Python_SetConstant(d, "BadXMLIDValue",SWIG_From_int(static_cast< int >(BadXMLIDValue)));
  SWIG_Python_SetConstant(d, "BadXMLIDRef",SWIG_From_int(static_cast< int >(BadXMLIDRef)));
  SWIG_Python_SetConstant(d, "UninterpretableXMLContent",SWIG_From_int(static_cast< int >(UninterpretableXMLContent)));
  SWIG_Python_SetConstant(d, "BadXMLDocumentStructure",SWIG_From_int(static_cast< int >(BadXMLDocumentStructure)));
  SWIG_Python_SetConstant(d, "InvalidAfterXMLContent",SWIG_From_int(static_cast< int >(InvalidAfterXMLContent)));
  SWIG_Python_SetConstant(d, "XMLExpectedQuotedString",SWIG_From_int(static_cast< int >(XMLExpectedQuotedString)));
  SWIG_Python_SetConstant(d, "XMLEmptyValueNotPermitted",SWIG_From_int(static_cast< int >(XMLEmptyValueNotPermitted)));
  SWIG_Python_SetConstant(d, "XMLBadNumber",SWIG_From_int(static_cast< int >(XMLBadNumber)));
  SWIG_Python_SetConstant(d, "XMLBadColon",SWIG_From_int(static_cast< int >(XMLBadColon)));
  SWIG_Python_SetConstant(d, "MissingXMLElements",SWIG_From_int(static_cast< int >(MissingXMLElements)));
  SWIG_Python_SetConstant(d, "XMLContentEmpty",SWIG_From_int(static_cast< int >(XMLContentEmpty)));
  SWIG_Python_SetConstant(d, "XMLErrorCodesUpperBound",SWIG_From_int(static_cast< int >(XMLErrorCodesUpperBound)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_INTERNAL",SWIG_From_int(static_cast< int >(LIBSBML_CAT_INTERNAL)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SYSTEM",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SYSTEM)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_XML",SWIG_From_int(static_cast< int >(LIBSBML_CAT_XML)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_INFO",SWIG_From_int(static_cast< int >(LIBSBML_SEV_INFO)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_WARNING",SWIG_From_int(static_cast< int >(LIBSBML_SEV_WARNING)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_ERROR",SWIG_From_int(static_cast< int >(LIBSBML_SEV_ERROR)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_FATAL",SWIG_From_int(static_cast< int >(LIBSBML_SEV_FATAL)));
  SWIG_Python_SetConstant(d, "UnknownError",SWIG_From_int(static_cast< int >(UnknownError)));
  SWIG_Python_SetConstant(d, "NotUTF8",SWIG_From_int(static_cast< int >(NotUTF8)));
  SWIG_Python_SetConstant(d, "UnrecognizedElement",SWIG_From_int(static_cast< int >(UnrecognizedElement)));
  SWIG_Python_SetConstant(d, "NotSchemaConformant",SWIG_From_int(static_cast< int >(NotSchemaConformant)));
  SWIG_Python_SetConstant(d, "L3NotSchemaConformant",SWIG_From_int(static_cast< int >(L3NotSchemaConformant)));
  SWIG_Python_SetConstant(d, "InvalidMathElement",SWIG_From_int(static_cast< int >(InvalidMathElement)));
  SWIG_Python_SetConstant(d, "DisallowedMathMLSymbol",SWIG_From_int(static_cast< int >(DisallowedMathMLSymbol)));
  SWIG_Python_SetConstant(d, "DisallowedMathMLEncodingUse",SWIG_From_int(static_cast< int >(DisallowedMathMLEncodingUse)));
  SWIG_Python_SetConstant(d, "DisallowedDefinitionURLUse",SWIG_From_int(static_cast< int >(DisallowedDefinitionURLUse)));
  SWIG_Python_SetConstant(d, "BadCsymbolDefinitionURLValue",SWIG_From_int(static_cast< int >(BadCsymbolDefinitionURLValue)));
  SWIG_Python_SetConstant(d, "DisallowedMathTypeAttributeUse",SWIG_From_int(static_cast< int >(DisallowedMathTypeAttributeUse)));
  SWIG_Python_SetConstant(d, "DisallowedMathTypeAttributeValue",SWIG_From_int(static_cast< int >(DisallowedMathTypeAttributeValue)));
  SWIG_Python_SetConstant(d, "LambdaOnlyAllowedInFunctionDef",SWIG_From_int(static_cast< int >(LambdaOnlyAllowedInFunctionDef)));
  SWIG_Python_SetConstant(d, "BooleanOpsNeedBooleanArgs",SWIG_From_int(static_cast< int >(BooleanOpsNeedBooleanArgs)));
  SWIG_Python_SetConstant(d, "NumericOpsNeedNumericArgs",SWIG_From_int(static_cast< int >(NumericOpsNeedNumericArgs)));
  SWIG_Python_SetConstant(d, "ArgsToEqNeedSameType",SWIG_From_int(static_cast< int >(ArgsToEqNeedSameType)));
  SWIG_Python_SetConstant(d, "PiecewiseNeedsConsistentTypes",SWIG_From_int(static_cast< int >(PiecewiseNeedsConsistentTypes)));
  SWIG_Python_SetConstant(d, "PieceNeedsBoolean",SWIG_From_int(static_cast< int >(PieceNeedsBoolean)));
  SWIG_Python_SetConstant(d, "ApplyCiMustBeUserFunction",SWIG_From_int(static_cast< int >(ApplyCiMustBeUserFunction)));
  SWIG_Python_SetConstant(d, "ApplyCiMustBeModelComponent",SWIG_From_int(static_cast< int >(ApplyCiMustBeModelComponent)));
  SWIG_Python_SetConstant(d, "KineticLawParametersAreLocalOnly",SWIG_From_int(static_cast< int >(KineticLawParametersAreLocalOnly)));
  SWIG_Python_SetConstant(d, "MathResultMustBeNumeric",SWIG_From_int(static_cast< int >(MathResultMustBeNumeric)));
  SWIG_Python_SetConstant(d, "OpsNeedCorrectNumberOfArgs",SWIG_From_int(static_cast< int >(OpsNeedCorrectNumberOfArgs)));
  SWIG_Python_SetConstant(d, "InvalidNoArgsPassedToFunctionDef",SWIG_From_int(static_cast< int >(InvalidNoArgsPassedToFunctionDef)));
  SWIG_Python_SetConstant(d, "DisallowedMathUnitsUse",SWIG_From_int(static_cast< int >(DisallowedMathUnitsUse)));
  SWIG_Python_SetConstant(d, "InvalidUnitsValue",SWIG_From_int(static_cast< int >(InvalidUnitsValue)));
  SWIG_Python_SetConstant(d, "DuplicateComponentId",SWIG_From_int(static_cast< int >(DuplicateComponentId)));
  SWIG_Python_SetConstant(d, "DuplicateUnitDefinitionId",SWIG_From_int(static_cast< int >(DuplicateUnitDefinitionId)));
  SWIG_Python_SetConstant(d, "DuplicateLocalParameterId",SWIG_From_int(static_cast< int >(DuplicateLocalParameterId)));
  SWIG_Python_SetConstant(d, "MultipleAssignmentOrRateRules",SWIG_From_int(static_cast< int >(MultipleAssignmentOrRateRules)));
  SWIG_Python_SetConstant(d, "MultipleEventAssignmentsForId",SWIG_From_int(static_cast< int >(MultipleEventAssignmentsForId)));
  SWIG_Python_SetConstant(d, "EventAndAssignmentRuleForId",SWIG_From_int(static_cast< int >(EventAndAssignmentRuleForId)));
  SWIG_Python_SetConstant(d, "DuplicateMetaId",SWIG_From_int(static_cast< int >(DuplicateMetaId)));
  SWIG_Python_SetConstant(d, "InvalidSBOTermSyntax",SWIG_From_int(static_cast< int >(InvalidSBOTermSyntax)));
  SWIG_Python_SetConstant(d, "InvalidMetaidSyntax",SWIG_From_int(static_cast< int >(InvalidMetaidSyntax)));
  SWIG_Python_SetConstant(d, "InvalidIdSyntax",SWIG_From_int(static_cast< int >(InvalidIdSyntax)));
  SWIG_Python_SetConstant(d, "InvalidUnitIdSyntax",SWIG_From_int(static_cast< int >(InvalidUnitIdSyntax)));
  SWIG_Python_SetConstant(d, "InvalidNameSyntax",SWIG_From_int(static_cast< int >(InvalidNameSyntax)));
  SWIG_Python_SetConstant(d, "MissingAnnotationNamespace",SWIG_From_int(static_cast< int >(MissingAnnotationNamespace)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationNamespaces",SWIG_From_int(static_cast< int >(DuplicateAnnotationNamespaces)));
  SWIG_Python_SetConstant(d, "SBMLNamespaceInAnnotation",SWIG_From_int(static_cast< int >(SBMLNamespaceInAnnotation)));
  SWIG_Python_SetConstant(d, "MultipleAnnotations",SWIG_From_int(static_cast< int >(MultipleAnnotations)));
  SWIG_Python_SetConstant(d, "InconsistentArgUnits",SWIG_From_int(static_cast< int >(InconsistentArgUnits)));
  SWIG_Python_SetConstant(d, "InconsistentKineticLawUnitsL3",SWIG_From_int(static_cast< int >(InconsistentKineticLawUnitsL3)));
  SWIG_Python_SetConstant(d, "AssignRuleCompartmentMismatch",SWIG_From_int(static_cast< int >(AssignRuleCompartmentMismatch)));
  SWIG_Python_SetConstant(d, "AssignRuleSpeciesMismatch",SWIG_From_int(static_cast< int >(AssignRuleSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "AssignRuleParameterMismatch",SWIG_From_int(static_cast< int >(AssignRuleParameterMismatch)));
  SWIG_Python_SetConstant(d, "AssignRuleStoichiometryMismatch",SWIG_From_int(static_cast< int >(AssignRuleStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignCompartmenMismatch",SWIG_From_int(static_cast< int >(InitAssignCompartmenMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignSpeciesMismatch",SWIG_From_int(static_cast< int >(InitAssignSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignParameterMismatch",SWIG_From_int(static_cast< int >(InitAssignParameterMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignStoichiometryMismatch",SWIG_From_int(static_cast< int >(InitAssignStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleCompartmentMismatch",SWIG_From_int(static_cast< int >(RateRuleCompartmentMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleSpeciesMismatch",SWIG_From_int(static_cast< int >(RateRuleSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleParameterMismatch",SWIG_From_int(static_cast< int >(RateRuleParameterMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleStoichiometryMismatch",SWIG_From_int(static_cast< int >(RateRuleStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "KineticLawNotSubstancePerTime",SWIG_From_int(static_cast< int >(KineticLawNotSubstancePerTime)));
  SWIG_Python_SetConstant(d, "SpeciesInvalidExtentUnits",SWIG_From_int(static_cast< int >(SpeciesInvalidExtentUnits)));
  SWIG_Python_SetConstant(d, "DelayUnitsNotTime",SWIG_From_int(static_cast< int >(DelayUnitsNotTime)));
  SWIG_Python_SetConstant(d, "EventAssignCompartmentMismatch",SWIG_From_int(static_cast< int >(EventAssignCompartmentMismatch)));
  SWIG_Python_SetConstant(d, "EventAssignSpeciesMismatch",SWIG_From_int(static_cast< int >(EventAssignSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "EventAssignParameterMismatch",SWIG_From_int(static_cast< int >(EventAssignParameterMismatch)));
  SWIG_Python_SetConstant(d, "EventAssignStoichiometryMismatch",SWIG_From_int(static_cast< int >(EventAssignStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "OverdeterminedSystem",SWIG_From_int(static_cast< int >(OverdeterminedSystem)));
  SWIG_Python_SetConstant(d, "InvalidModelSBOTerm",SWIG_From_int(static_cast< int >(InvalidModelSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidFunctionDefSBOTerm",SWIG_From_int(static_cast< int >(InvalidFunctionDefSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidParameterSBOTerm",SWIG_From_int(static_cast< int >(InvalidParameterSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidInitAssignSBOTerm",SWIG_From_int(static_cast< int >(InvalidInitAssignSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidRuleSBOTerm",SWIG_From_int(static_cast< int >(InvalidRuleSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidConstraintSBOTerm",SWIG_From_int(static_cast< int >(InvalidConstraintSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidReactionSBOTerm",SWIG_From_int(static_cast< int >(InvalidReactionSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesReferenceSBOTerm",SWIG_From_int(static_cast< int >(InvalidSpeciesReferenceSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidKineticLawSBOTerm",SWIG_From_int(static_cast< int >(InvalidKineticLawSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidEventSBOTerm",SWIG_From_int(static_cast< int >(InvalidEventSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidEventAssignmentSBOTerm",SWIG_From_int(static_cast< int >(InvalidEventAssignmentSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidCompartmentSBOTerm",SWIG_From_int(static_cast< int >(InvalidCompartmentSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesSBOTerm",SWIG_From_int(static_cast< int >(InvalidSpeciesSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidCompartmentTypeSBOTerm",SWIG_From_int(static_cast< int >(InvalidCompartmentTypeSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesTypeSBOTerm",SWIG_From_int(static_cast< int >(InvalidSpeciesTypeSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidTriggerSBOTerm",SWIG_From_int(static_cast< int >(InvalidTriggerSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidDelaySBOTerm",SWIG_From_int(static_cast< int >(InvalidDelaySBOTerm)));
  SWIG_Python_SetConstant(d, "NotesNotInXHTMLNamespace",SWIG_From_int(static_cast< int >(NotesNotInXHTMLNamespace)));
  SWIG_Python_SetConstant(d, "NotesContainsXMLDecl",SWIG_From_int(static_cast< int >(NotesContainsXMLDecl)));
  SWIG_Python_SetConstant(d, "NotesContainsDOCTYPE",SWIG_From_int(static_cast< int >(NotesContainsDOCTYPE)));
  SWIG_Python_SetConstant(d, "InvalidNotesContent",SWIG_From_int(static_cast< int >(InvalidNotesContent)));
  SWIG_Python_SetConstant(d, "OnlyOneNotesElementAllowed",SWIG_From_int(static_cast< int >(OnlyOneNotesElementAllowed)));
  SWIG_Python_SetConstant(d, "InvalidNamespaceOnSBML",SWIG_From_int(static_cast< int >(InvalidNamespaceOnSBML)));
  SWIG_Python_SetConstant(d, "MissingOrInconsistentLevel",SWIG_From_int(static_cast< int >(MissingOrInconsistentLevel)));
  SWIG_Python_SetConstant(d, "MissingOrInconsistentVersion",SWIG_From_int(static_cast< int >(MissingOrInconsistentVersion)));
  SWIG_Python_SetConstant(d, "PackageNSMustMatch",SWIG_From_int(static_cast< int >(PackageNSMustMatch)));
  SWIG_Python_SetConstant(d, "LevelPositiveInteger",SWIG_From_int(static_cast< int >(LevelPositiveInteger)));
  SWIG_Python_SetConstant(d, "VersionPositiveInteger",SWIG_From_int(static_cast< int >(VersionPositiveInteger)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnSBML",SWIG_From_int(static_cast< int >(AllowedAttributesOnSBML)));
  SWIG_Python_SetConstant(d, "MissingModel",SWIG_From_int(static_cast< int >(MissingModel)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInModel",SWIG_From_int(static_cast< int >(IncorrectOrderInModel)));
  SWIG_Python_SetConstant(d, "EmptyListElement",SWIG_From_int(static_cast< int >(EmptyListElement)));
  SWIG_Python_SetConstant(d, "NeedCompartmentIfHaveSpecies",SWIG_From_int(static_cast< int >(NeedCompartmentIfHaveSpecies)));
  SWIG_Python_SetConstant(d, "OneOfEachListOf",SWIG_From_int(static_cast< int >(OneOfEachListOf)));
  SWIG_Python_SetConstant(d, "OnlyFuncDefsInListOfFuncDefs",SWIG_From_int(static_cast< int >(OnlyFuncDefsInListOfFuncDefs)));
  SWIG_Python_SetConstant(d, "OnlyUnitDefsInListOfUnitDefs",SWIG_From_int(static_cast< int >(OnlyUnitDefsInListOfUnitDefs)));
  SWIG_Python_SetConstant(d, "OnlyCompartmentsInListOfCompartments",SWIG_From_int(static_cast< int >(OnlyCompartmentsInListOfCompartments)));
  SWIG_Python_SetConstant(d, "OnlySpeciesInListOfSpecies",SWIG_From_int(static_cast< int >(OnlySpeciesInListOfSpecies)));
  SWIG_Python_SetConstant(d, "OnlyParametersInListOfParameters",SWIG_From_int(static_cast< int >(OnlyParametersInListOfParameters)));
  SWIG_Python_SetConstant(d, "OnlyInitAssignsInListOfInitAssigns",SWIG_From_int(static_cast< int >(OnlyInitAssignsInListOfInitAssigns)));
  SWIG_Python_SetConstant(d, "OnlyRulesInListOfRules",SWIG_From_int(static_cast< int >(OnlyRulesInListOfRules)));
  SWIG_Python_SetConstant(d, "OnlyConstraintsInListOfConstraints",SWIG_From_int(static_cast< int >(OnlyConstraintsInListOfConstraints)));
  SWIG_Python_SetConstant(d, "OnlyReactionsInListOfReactions",SWIG_From_int(static_cast< int >(OnlyReactionsInListOfReactions)));
  SWIG_Python_SetConstant(d, "OnlyEventsInListOfEvents",SWIG_From_int(static_cast< int >(OnlyEventsInListOfEvents)));
  SWIG_Python_SetConstant(d, "L3ConversionFactorOnModel",SWIG_From_int(static_cast< int >(L3ConversionFactorOnModel)));
  SWIG_Python_SetConstant(d, "L3TimeUnitsOnModel",SWIG_From_int(static_cast< int >(L3TimeUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3VolumeUnitsOnModel",SWIG_From_int(static_cast< int >(L3VolumeUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3AreaUnitsOnModel",SWIG_From_int(static_cast< int >(L3AreaUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3LengthUnitsOnModel",SWIG_From_int(static_cast< int >(L3LengthUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3ExtentUnitsOnModel",SWIG_From_int(static_cast< int >(L3ExtentUnitsOnModel)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnModel",SWIG_From_int(static_cast< int >(AllowedAttributesOnModel)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfFuncs",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfFuncs)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfUnitDefs",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfUnitDefs)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfComps",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfComps)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfSpecies",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfSpecies)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfParams",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfParams)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfInitAssign",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfInitAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfRules",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfRules)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfConstraints",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfConstraints)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfReactions",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfReactions)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfEvents",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfEvents)));
  SWIG_Python_SetConstant(d, "FunctionDefMathNotLambda",SWIG_From_int(static_cast< int >(FunctionDefMathNotLambda)));
  SWIG_Python_SetConstant(d, "InvalidApplyCiInLambda",SWIG_From_int(static_cast< int >(InvalidApplyCiInLambda)));
  SWIG_Python_SetConstant(d, "RecursiveFunctionDefinition",SWIG_From_int(static_cast< int >(RecursiveFunctionDefinition)));
  SWIG_Python_SetConstant(d, "InvalidCiInLambda",SWIG_From_int(static_cast< int >(InvalidCiInLambda)));
  SWIG_Python_SetConstant(d, "InvalidFunctionDefReturnType",SWIG_From_int(static_cast< int >(InvalidFunctionDefReturnType)));
  SWIG_Python_SetConstant(d, "OneMathElementPerFunc",SWIG_From_int(static_cast< int >(OneMathElementPerFunc)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnFunc",SWIG_From_int(static_cast< int >(AllowedAttributesOnFunc)));
  SWIG_Python_SetConstant(d, "InvalidUnitDefId",SWIG_From_int(static_cast< int >(InvalidUnitDefId)));
  SWIG_Python_SetConstant(d, "InvalidSubstanceRedefinition",SWIG_From_int(static_cast< int >(InvalidSubstanceRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidLengthRedefinition",SWIG_From_int(static_cast< int >(InvalidLengthRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidAreaRedefinition",SWIG_From_int(static_cast< int >(InvalidAreaRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidTimeRedefinition",SWIG_From_int(static_cast< int >(InvalidTimeRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidVolumeRedefinition",SWIG_From_int(static_cast< int >(InvalidVolumeRedefinition)));
  SWIG_Python_SetConstant(d, "VolumeLitreDefExponentNotOne",SWIG_From_int(static_cast< int >(VolumeLitreDefExponentNotOne)));
  SWIG_Python_SetConstant(d, "VolumeMetreDefExponentNot3",SWIG_From_int(static_cast< int >(VolumeMetreDefExponentNot3)));
  SWIG_Python_SetConstant(d, "EmptyListOfUnits",SWIG_From_int(static_cast< int >(EmptyListOfUnits)));
  SWIG_Python_SetConstant(d, "InvalidUnitKind",SWIG_From_int(static_cast< int >(InvalidUnitKind)));
  SWIG_Python_SetConstant(d, "OffsetNoLongerValid",SWIG_From_int(static_cast< int >(OffsetNoLongerValid)));
  SWIG_Python_SetConstant(d, "CelsiusNoLongerValid",SWIG_From_int(static_cast< int >(CelsiusNoLongerValid)));
  SWIG_Python_SetConstant(d, "EmptyUnitListElement",SWIG_From_int(static_cast< int >(EmptyUnitListElement)));
  SWIG_Python_SetConstant(d, "OneListOfUnitsPerUnitDef",SWIG_From_int(static_cast< int >(OneListOfUnitsPerUnitDef)));
  SWIG_Python_SetConstant(d, "OnlyUnitsInListOfUnits",SWIG_From_int(static_cast< int >(OnlyUnitsInListOfUnits)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnUnitDefinition",SWIG_From_int(static_cast< int >(AllowedAttributesOnUnitDefinition)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfUnits",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfUnits)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnUnit",SWIG_From_int(static_cast< int >(AllowedAttributesOnUnit)));
  SWIG_Python_SetConstant(d, "ZeroDimensionalCompartmentSize",SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentSize)));
  SWIG_Python_SetConstant(d, "ZeroDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "ZeroDimensionalCompartmentConst",SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentConst)));
  SWIG_Python_SetConstant(d, "UndefinedOutsideCompartment",SWIG_From_int(static_cast< int >(UndefinedOutsideCompartment)));
  SWIG_Python_SetConstant(d, "RecursiveCompartmentContainment",SWIG_From_int(static_cast< int >(RecursiveCompartmentContainment)));
  SWIG_Python_SetConstant(d, "ZeroDCompartmentContainment",SWIG_From_int(static_cast< int >(ZeroDCompartmentContainment)));
  SWIG_Python_SetConstant(d, "Invalid1DCompartmentUnits",SWIG_From_int(static_cast< int >(Invalid1DCompartmentUnits)));
  SWIG_Python_SetConstant(d, "Invalid2DCompartmentUnits",SWIG_From_int(static_cast< int >(Invalid2DCompartmentUnits)));
  SWIG_Python_SetConstant(d, "Invalid3DCompartmentUnits",SWIG_From_int(static_cast< int >(Invalid3DCompartmentUnits)));
  SWIG_Python_SetConstant(d, "InvalidCompartmentTypeRef",SWIG_From_int(static_cast< int >(InvalidCompartmentTypeRef)));
  SWIG_Python_SetConstant(d, "OneDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(OneDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "TwoDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(TwoDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "ThreeDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(ThreeDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnCompartment",SWIG_From_int(static_cast< int >(AllowedAttributesOnCompartment)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesCompartmentRef",SWIG_From_int(static_cast< int >(InvalidSpeciesCompartmentRef)));
  SWIG_Python_SetConstant(d, "HasOnlySubsNoSpatialUnits",SWIG_From_int(static_cast< int >(HasOnlySubsNoSpatialUnits)));
  SWIG_Python_SetConstant(d, "NoSpatialUnitsInZeroD",SWIG_From_int(static_cast< int >(NoSpatialUnitsInZeroD)));
  SWIG_Python_SetConstant(d, "NoConcentrationInZeroD",SWIG_From_int(static_cast< int >(NoConcentrationInZeroD)));
  SWIG_Python_SetConstant(d, "SpatialUnitsInOneD",SWIG_From_int(static_cast< int >(SpatialUnitsInOneD)));
  SWIG_Python_SetConstant(d, "SpatialUnitsInTwoD",SWIG_From_int(static_cast< int >(SpatialUnitsInTwoD)));
  SWIG_Python_SetConstant(d, "SpatialUnitsInThreeD",SWIG_From_int(static_cast< int >(SpatialUnitsInThreeD)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesSusbstanceUnits",SWIG_From_int(static_cast< int >(InvalidSpeciesSusbstanceUnits)));
  SWIG_Python_SetConstant(d, "BothAmountAndConcentrationSet",SWIG_From_int(static_cast< int >(BothAmountAndConcentrationSet)));
  SWIG_Python_SetConstant(d, "NonBoundarySpeciesAssignedAndUsed",SWIG_From_int(static_cast< int >(NonBoundarySpeciesAssignedAndUsed)));
  SWIG_Python_SetConstant(d, "NonConstantSpeciesUsed",SWIG_From_int(static_cast< int >(NonConstantSpeciesUsed)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesTypeRef",SWIG_From_int(static_cast< int >(InvalidSpeciesTypeRef)));
  SWIG_Python_SetConstant(d, "MultSpeciesSameTypeInCompartment",SWIG_From_int(static_cast< int >(MultSpeciesSameTypeInCompartment)));
  SWIG_Python_SetConstant(d, "MissingSpeciesCompartment",SWIG_From_int(static_cast< int >(MissingSpeciesCompartment)));
  SWIG_Python_SetConstant(d, "SpatialSizeUnitsRemoved",SWIG_From_int(static_cast< int >(SpatialSizeUnitsRemoved)));
  SWIG_Python_SetConstant(d, "SubstanceUnitsOnSpecies",SWIG_From_int(static_cast< int >(SubstanceUnitsOnSpecies)));
  SWIG_Python_SetConstant(d, "ConversionFactorOnSpecies",SWIG_From_int(static_cast< int >(ConversionFactorOnSpecies)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnSpecies",SWIG_From_int(static_cast< int >(AllowedAttributesOnSpecies)));
  SWIG_Python_SetConstant(d, "InvalidParameterUnits",SWIG_From_int(static_cast< int >(InvalidParameterUnits)));
  SWIG_Python_SetConstant(d, "ParameterUnits",SWIG_From_int(static_cast< int >(ParameterUnits)));
  SWIG_Python_SetConstant(d, "ConversionFactorMustConstant",SWIG_From_int(static_cast< int >(ConversionFactorMustConstant)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnParameter",SWIG_From_int(static_cast< int >(AllowedAttributesOnParameter)));
  SWIG_Python_SetConstant(d, "InvalidInitAssignSymbol",SWIG_From_int(static_cast< int >(InvalidInitAssignSymbol)));
  SWIG_Python_SetConstant(d, "MultipleInitAssignments",SWIG_From_int(static_cast< int >(MultipleInitAssignments)));
  SWIG_Python_SetConstant(d, "InitAssignmentAndRuleForSameId",SWIG_From_int(static_cast< int >(InitAssignmentAndRuleForSameId)));
  SWIG_Python_SetConstant(d, "OneMathElementPerInitialAssign",SWIG_From_int(static_cast< int >(OneMathElementPerInitialAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnInitialAssign",SWIG_From_int(static_cast< int >(AllowedAttributesOnInitialAssign)));
  SWIG_Python_SetConstant(d, "InvalidAssignRuleVariable",SWIG_From_int(static_cast< int >(InvalidAssignRuleVariable)));
  SWIG_Python_SetConstant(d, "InvalidRateRuleVariable",SWIG_From_int(static_cast< int >(InvalidRateRuleVariable)));
  SWIG_Python_SetConstant(d, "AssignmentToConstantEntity",SWIG_From_int(static_cast< int >(AssignmentToConstantEntity)));
  SWIG_Python_SetConstant(d, "RateRuleForConstantEntity",SWIG_From_int(static_cast< int >(RateRuleForConstantEntity)));
  SWIG_Python_SetConstant(d, "RepeatedRule10304",SWIG_From_int(static_cast< int >(RepeatedRule10304)));
  SWIG_Python_SetConstant(d, "CircularRuleDependency",SWIG_From_int(static_cast< int >(CircularRuleDependency)));
  SWIG_Python_SetConstant(d, "OneMathElementPerRule",SWIG_From_int(static_cast< int >(OneMathElementPerRule)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnAssignRule",SWIG_From_int(static_cast< int >(AllowedAttributesOnAssignRule)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnRateRule",SWIG_From_int(static_cast< int >(AllowedAttributesOnRateRule)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnAlgRule",SWIG_From_int(static_cast< int >(AllowedAttributesOnAlgRule)));
  SWIG_Python_SetConstant(d, "ConstraintMathNotBoolean",SWIG_From_int(static_cast< int >(ConstraintMathNotBoolean)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInConstraint",SWIG_From_int(static_cast< int >(IncorrectOrderInConstraint)));
  SWIG_Python_SetConstant(d, "ConstraintNotInXHTMLNamespace",SWIG_From_int(static_cast< int >(ConstraintNotInXHTMLNamespace)));
  SWIG_Python_SetConstant(d, "ConstraintContainsXMLDecl",SWIG_From_int(static_cast< int >(ConstraintContainsXMLDecl)));
  SWIG_Python_SetConstant(d, "ConstraintContainsDOCTYPE",SWIG_From_int(static_cast< int >(ConstraintContainsDOCTYPE)));
  SWIG_Python_SetConstant(d, "InvalidConstraintContent",SWIG_From_int(static_cast< int >(InvalidConstraintContent)));
  SWIG_Python_SetConstant(d, "OneMathElementPerConstraint",SWIG_From_int(static_cast< int >(OneMathElementPerConstraint)));
  SWIG_Python_SetConstant(d, "OneMessageElementPerConstraint",SWIG_From_int(static_cast< int >(OneMessageElementPerConstraint)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnConstraint",SWIG_From_int(static_cast< int >(AllowedAttributesOnConstraint)));
  SWIG_Python_SetConstant(d, "NoReactantsOrProducts",SWIG_From_int(static_cast< int >(NoReactantsOrProducts)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInReaction",SWIG_From_int(static_cast< int >(IncorrectOrderInReaction)));
  SWIG_Python_SetConstant(d, "EmptyListInReaction",SWIG_From_int(static_cast< int >(EmptyListInReaction)));
  SWIG_Python_SetConstant(d, "InvalidReactantsProductsList",SWIG_From_int(static_cast< int >(InvalidReactantsProductsList)));
  SWIG_Python_SetConstant(d, "InvalidModifiersList",SWIG_From_int(static_cast< int >(InvalidModifiersList)));
  SWIG_Python_SetConstant(d, "OneSubElementPerReaction",SWIG_From_int(static_cast< int >(OneSubElementPerReaction)));
  SWIG_Python_SetConstant(d, "CompartmentOnReaction",SWIG_From_int(static_cast< int >(CompartmentOnReaction)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnReaction",SWIG_From_int(static_cast< int >(AllowedAttributesOnReaction)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesReference",SWIG_From_int(static_cast< int >(InvalidSpeciesReference)));
  SWIG_Python_SetConstant(d, "RepeatedRule20611",SWIG_From_int(static_cast< int >(RepeatedRule20611)));
  SWIG_Python_SetConstant(d, "BothStoichiometryAndMath",SWIG_From_int(static_cast< int >(BothStoichiometryAndMath)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnSpeciesReference",SWIG_From_int(static_cast< int >(AllowedAttributesOnSpeciesReference)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnModifier",SWIG_From_int(static_cast< int >(AllowedAttributesOnModifier)));
  SWIG_Python_SetConstant(d, "UndeclaredSpeciesRef",SWIG_From_int(static_cast< int >(UndeclaredSpeciesRef)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInKineticLaw",SWIG_From_int(static_cast< int >(IncorrectOrderInKineticLaw)));
  SWIG_Python_SetConstant(d, "EmptyListInKineticLaw",SWIG_From_int(static_cast< int >(EmptyListInKineticLaw)));
  SWIG_Python_SetConstant(d, "NonConstantLocalParameter",SWIG_From_int(static_cast< int >(NonConstantLocalParameter)));
  SWIG_Python_SetConstant(d, "SubsUnitsNoLongerValid",SWIG_From_int(static_cast< int >(SubsUnitsNoLongerValid)));
  SWIG_Python_SetConstant(d, "TimeUnitsNoLongerValid",SWIG_From_int(static_cast< int >(TimeUnitsNoLongerValid)));
  SWIG_Python_SetConstant(d, "OneListOfPerKineticLaw",SWIG_From_int(static_cast< int >(OneListOfPerKineticLaw)));
  SWIG_Python_SetConstant(d, "OnlyLocalParamsInListOfLocalParams",SWIG_From_int(static_cast< int >(OnlyLocalParamsInListOfLocalParams)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfLocalParam",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfLocalParam)));
  SWIG_Python_SetConstant(d, "OneMathPerKineticLaw",SWIG_From_int(static_cast< int >(OneMathPerKineticLaw)));
  SWIG_Python_SetConstant(d, "UndeclaredSpeciesInStoichMath",SWIG_From_int(static_cast< int >(UndeclaredSpeciesInStoichMath)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnKineticLaw",SWIG_From_int(static_cast< int >(AllowedAttributesOnKineticLaw)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfSpeciesRef",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfSpeciesRef)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfMods",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfMods)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnLocalParameter",SWIG_From_int(static_cast< int >(AllowedAttributesOnLocalParameter)));
  SWIG_Python_SetConstant(d, "MissingTriggerInEvent",SWIG_From_int(static_cast< int >(MissingTriggerInEvent)));
  SWIG_Python_SetConstant(d, "TriggerMathNotBoolean",SWIG_From_int(static_cast< int >(TriggerMathNotBoolean)));
  SWIG_Python_SetConstant(d, "MissingEventAssignment",SWIG_From_int(static_cast< int >(MissingEventAssignment)));
  SWIG_Python_SetConstant(d, "TimeUnitsEvent",SWIG_From_int(static_cast< int >(TimeUnitsEvent)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInEvent",SWIG_From_int(static_cast< int >(IncorrectOrderInEvent)));
  SWIG_Python_SetConstant(d, "ValuesFromTriggerTimeNeedDelay",SWIG_From_int(static_cast< int >(ValuesFromTriggerTimeNeedDelay)));
  SWIG_Python_SetConstant(d, "DelayNeedsValuesFromTriggerTime",SWIG_From_int(static_cast< int >(DelayNeedsValuesFromTriggerTime)));
  SWIG_Python_SetConstant(d, "OneMathPerTrigger",SWIG_From_int(static_cast< int >(OneMathPerTrigger)));
  SWIG_Python_SetConstant(d, "OneMathPerDelay",SWIG_From_int(static_cast< int >(OneMathPerDelay)));
  SWIG_Python_SetConstant(d, "InvalidEventAssignmentVariable",SWIG_From_int(static_cast< int >(InvalidEventAssignmentVariable)));
  SWIG_Python_SetConstant(d, "EventAssignmentForConstantEntity",SWIG_From_int(static_cast< int >(EventAssignmentForConstantEntity)));
  SWIG_Python_SetConstant(d, "OneMathPerEventAssignment",SWIG_From_int(static_cast< int >(OneMathPerEventAssignment)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnEventAssignment",SWIG_From_int(static_cast< int >(AllowedAttributesOnEventAssignment)));
  SWIG_Python_SetConstant(d, "OnlyOneDelayPerEvent",SWIG_From_int(static_cast< int >(OnlyOneDelayPerEvent)));
  SWIG_Python_SetConstant(d, "OneListOfEventAssignmentsPerEvent",SWIG_From_int(static_cast< int >(OneListOfEventAssignmentsPerEvent)));
  SWIG_Python_SetConstant(d, "OnlyEventAssignInListOfEventAssign",SWIG_From_int(static_cast< int >(OnlyEventAssignInListOfEventAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfEventAssign",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfEventAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnEvent",SWIG_From_int(static_cast< int >(AllowedAttributesOnEvent)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnTrigger",SWIG_From_int(static_cast< int >(AllowedAttributesOnTrigger)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnDelay",SWIG_From_int(static_cast< int >(AllowedAttributesOnDelay)));
  SWIG_Python_SetConstant(d, "GeneralWarningNotSpecified",SWIG_From_int(static_cast< int >(GeneralWarningNotSpecified)));
  SWIG_Python_SetConstant(d, "CompartmentShouldHaveSize",SWIG_From_int(static_cast< int >(CompartmentShouldHaveSize)));
  SWIG_Python_SetConstant(d, "ParameterShouldHaveUnits",SWIG_From_int(static_cast< int >(ParameterShouldHaveUnits)));
  SWIG_Python_SetConstant(d, "LocalParameterShadowsId",SWIG_From_int(static_cast< int >(LocalParameterShadowsId)));
  SWIG_Python_SetConstant(d, "LibSBMLAdditionalCodesLowerBound",SWIG_From_int(static_cast< int >(LibSBMLAdditionalCodesLowerBound)));
  SWIG_Python_SetConstant(d, "CannotConvertToL1V1",SWIG_From_int(static_cast< int >(CannotConvertToL1V1)));
  SWIG_Python_SetConstant(d, "NoEventsInL1",SWIG_From_int(static_cast< int >(NoEventsInL1)));
  SWIG_Python_SetConstant(d, "NoFunctionDefinitionsInL1",SWIG_From_int(static_cast< int >(NoFunctionDefinitionsInL1)));
  SWIG_Python_SetConstant(d, "NoConstraintsInL1",SWIG_From_int(static_cast< int >(NoConstraintsInL1)));
  SWIG_Python_SetConstant(d, "NoInitialAssignmentsInL1",SWIG_From_int(static_cast< int >(NoInitialAssignmentsInL1)));
  SWIG_Python_SetConstant(d, "NoSpeciesTypesInL1",SWIG_From_int(static_cast< int >(NoSpeciesTypesInL1)));
  SWIG_Python_SetConstant(d, "NoCompartmentTypeInL1",SWIG_From_int(static_cast< int >(NoCompartmentTypeInL1)));
  SWIG_Python_SetConstant(d, "NoNon3DComparmentsInL1",SWIG_From_int(static_cast< int >(NoNon3DComparmentsInL1)));
  SWIG_Python_SetConstant(d, "NoFancyStoichiometryMathInL1",SWIG_From_int(static_cast< int >(NoFancyStoichiometryMathInL1)));
  SWIG_Python_SetConstant(d, "NoNonIntegerStoichiometryInL1",SWIG_From_int(static_cast< int >(NoNonIntegerStoichiometryInL1)));
  SWIG_Python_SetConstant(d, "NoUnitMultipliersOrOffsetsInL1",SWIG_From_int(static_cast< int >(NoUnitMultipliersOrOffsetsInL1)));
  SWIG_Python_SetConstant(d, "SpeciesCompartmentRequiredInL1",SWIG_From_int(static_cast< int >(SpeciesCompartmentRequiredInL1)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL1",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL1)));
  SWIG_Python_SetConstant(d, "NoSBOTermsInL1",SWIG_From_int(static_cast< int >(NoSBOTermsInL1)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL1",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL1)));
  SWIG_Python_SetConstant(d, "NoConstraintsInL2v1",SWIG_From_int(static_cast< int >(NoConstraintsInL2v1)));
  SWIG_Python_SetConstant(d, "NoInitialAssignmentsInL2v1",SWIG_From_int(static_cast< int >(NoInitialAssignmentsInL2v1)));
  SWIG_Python_SetConstant(d, "NoSpeciesTypeInL2v1",SWIG_From_int(static_cast< int >(NoSpeciesTypeInL2v1)));
  SWIG_Python_SetConstant(d, "NoCompartmentTypeInL2v1",SWIG_From_int(static_cast< int >(NoCompartmentTypeInL2v1)));
  SWIG_Python_SetConstant(d, "NoSBOTermsInL2v1",SWIG_From_int(static_cast< int >(NoSBOTermsInL2v1)));
  SWIG_Python_SetConstant(d, "NoIdOnSpeciesReferenceInL2v1",SWIG_From_int(static_cast< int >(NoIdOnSpeciesReferenceInL2v1)));
  SWIG_Python_SetConstant(d, "NoDelayedEventAssignmentInL2v1",SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v1)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL2v1",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v1)));
  SWIG_Python_SetConstant(d, "SBOTermNotUniversalInL2v2",SWIG_From_int(static_cast< int >(SBOTermNotUniversalInL2v2)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL2v2",SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v2)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL2v2",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v2)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL2v2",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v2)));
  SWIG_Python_SetConstant(d, "NoDelayedEventAssignmentInL2v2",SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v2)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedBeyondL2v2",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedBeyondL2v2)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL2v2",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v2)));
  SWIG_Python_SetConstant(d, "StrictSBORequiredInL2v2",SWIG_From_int(static_cast< int >(StrictSBORequiredInL2v2)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL2v2",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v2)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL2v3",SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v3)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL2v3",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL2v3",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL2v3",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoEventTimeUnitsInL2v3",SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoDelayedEventAssignmentInL2v3",SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v3)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedBeyondL2v3",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedBeyondL2v3)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL2v3",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v3)));
  SWIG_Python_SetConstant(d, "StrictSBORequiredInL2v3",SWIG_From_int(static_cast< int >(StrictSBORequiredInL2v3)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL2v3",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v3)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL2v4",SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v4)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL2v4",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL2v4",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL2v4",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "NoEventTimeUnitsInL2v4",SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedInL2v4",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedInL2v4)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL2v4",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v4)));
  SWIG_Python_SetConstant(d, "NoSpeciesTypeInL3v1",SWIG_From_int(static_cast< int >(NoSpeciesTypeInL3v1)));
  SWIG_Python_SetConstant(d, "NoCompartmentTypeInL3v1",SWIG_From_int(static_cast< int >(NoCompartmentTypeInL3v1)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL3v1",SWIG_From_int(static_cast< int >(NoUnitOffsetInL3v1)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL3v1",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL3v1",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL3v1",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "NoEventTimeUnitsInL3v1",SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedInL3v1",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedInL3v1)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL3v1",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL3v1)));
  SWIG_Python_SetConstant(d, "NoCompartmentOutsideInL3v1",SWIG_From_int(static_cast< int >(NoCompartmentOutsideInL3v1)));
  SWIG_Python_SetConstant(d, "NoStoichiometryMathInL3v1",SWIG_From_int(static_cast< int >(NoStoichiometryMathInL3v1)));
  SWIG_Python_SetConstant(d, "InvalidSBMLLevelVersion",SWIG_From_int(static_cast< int >(InvalidSBMLLevelVersion)));
  SWIG_Python_SetConstant(d, "AnnotationNotesNotAllowedLevel1",SWIG_From_int(static_cast< int >(AnnotationNotesNotAllowedLevel1)));
  SWIG_Python_SetConstant(d, "InvalidRuleOrdering",SWIG_From_int(static_cast< int >(InvalidRuleOrdering)));
  SWIG_Python_SetConstant(d, "SubsUnitsAllowedInKL",SWIG_From_int(static_cast< int >(SubsUnitsAllowedInKL)));
  SWIG_Python_SetConstant(d, "TimeUnitsAllowedInKL",SWIG_From_int(static_cast< int >(TimeUnitsAllowedInKL)));
  SWIG_Python_SetConstant(d, "FormulaInLevel1KL",SWIG_From_int(static_cast< int >(FormulaInLevel1KL)));
  SWIG_Python_SetConstant(d, "TimeUnitsRemoved",SWIG_From_int(static_cast< int >(TimeUnitsRemoved)));
  SWIG_Python_SetConstant(d, "BadMathML",SWIG_From_int(static_cast< int >(BadMathML)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfDouble",SWIG_From_int(static_cast< int >(FailedMathMLReadOfDouble)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfInteger",SWIG_From_int(static_cast< int >(FailedMathMLReadOfInteger)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfExponential",SWIG_From_int(static_cast< int >(FailedMathMLReadOfExponential)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfRational",SWIG_From_int(static_cast< int >(FailedMathMLReadOfRational)));
  SWIG_Python_SetConstant(d, "BadMathMLNodeType",SWIG_From_int(static_cast< int >(BadMathMLNodeType)));
  SWIG_Python_SetConstant(d, "NoTimeSymbolInFunctionDef",SWIG_From_int(static_cast< int >(NoTimeSymbolInFunctionDef)));
  SWIG_Python_SetConstant(d, "InconsistentArgUnitsWarnings",SWIG_From_int(static_cast< int >(InconsistentArgUnitsWarnings)));
  SWIG_Python_SetConstant(d, "InconsistentPowerUnitsWarnings",SWIG_From_int(static_cast< int >(InconsistentPowerUnitsWarnings)));
  SWIG_Python_SetConstant(d, "InconsistentExponUnitsWarnings",SWIG_From_int(static_cast< int >(InconsistentExponUnitsWarnings)));
  SWIG_Python_SetConstant(d, "UndeclaredUnits",SWIG_From_int(static_cast< int >(UndeclaredUnits)));
  SWIG_Python_SetConstant(d, "UnrecognisedSBOTerm",SWIG_From_int(static_cast< int >(UnrecognisedSBOTerm)));
  SWIG_Python_SetConstant(d, "ObseleteSBOTerm",SWIG_From_int(static_cast< int >(ObseleteSBOTerm)));
  SWIG_Python_SetConstant(d, "IncorrectCompartmentSpatialDimensions",SWIG_From_int(static_cast< int >(IncorrectCompartmentSpatialDimensions)));
  SWIG_Python_SetConstant(d, "CompartmentTypeNotValidAttribute",SWIG_From_int(static_cast< int >(CompartmentTypeNotValidAttribute)));
  SWIG_Python_SetConstant(d, "ConstantNotValidAttribute",SWIG_From_int(static_cast< int >(ConstantNotValidAttribute)));
  SWIG_Python_SetConstant(d, "MetaIdNotValidAttribute",SWIG_From_int(static_cast< int >(MetaIdNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SBOTermNotValidAttributeBeforeL2V3",SWIG_From_int(static_cast< int >(SBOTermNotValidAttributeBeforeL2V3)));
  SWIG_Python_SetConstant(d, "InvalidL1CompartmentUnits",SWIG_From_int(static_cast< int >(InvalidL1CompartmentUnits)));
  SWIG_Python_SetConstant(d, "L1V1CompartmentVolumeReqd",SWIG_From_int(static_cast< int >(L1V1CompartmentVolumeReqd)));
  SWIG_Python_SetConstant(d, "CompartmentTypeNotValidComponent",SWIG_From_int(static_cast< int >(CompartmentTypeNotValidComponent)));
  SWIG_Python_SetConstant(d, "ConstraintNotValidComponent",SWIG_From_int(static_cast< int >(ConstraintNotValidComponent)));
  SWIG_Python_SetConstant(d, "EventNotValidComponent",SWIG_From_int(static_cast< int >(EventNotValidComponent)));
  SWIG_Python_SetConstant(d, "SBOTermNotValidAttributeBeforeL2V2",SWIG_From_int(static_cast< int >(SBOTermNotValidAttributeBeforeL2V2)));
  SWIG_Python_SetConstant(d, "FuncDefNotValidComponent",SWIG_From_int(static_cast< int >(FuncDefNotValidComponent)));
  SWIG_Python_SetConstant(d, "InitialAssignNotValidComponent",SWIG_From_int(static_cast< int >(InitialAssignNotValidComponent)));
  SWIG_Python_SetConstant(d, "VariableNotValidAttribute",SWIG_From_int(static_cast< int >(VariableNotValidAttribute)));
  SWIG_Python_SetConstant(d, "UnitsNotValidAttribute",SWIG_From_int(static_cast< int >(UnitsNotValidAttribute)));
  SWIG_Python_SetConstant(d, "ConstantSpeciesNotValidAttribute",SWIG_From_int(static_cast< int >(ConstantSpeciesNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SpatialSizeUnitsNotValidAttribute",SWIG_From_int(static_cast< int >(SpatialSizeUnitsNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SpeciesTypeNotValidAttribute",SWIG_From_int(static_cast< int >(SpeciesTypeNotValidAttribute)));
  SWIG_Python_SetConstant(d, "HasOnlySubsUnitsNotValidAttribute",SWIG_From_int(static_cast< int >(HasOnlySubsUnitsNotValidAttribute)));
  SWIG_Python_SetConstant(d, "IdNotValidAttribute",SWIG_From_int(static_cast< int >(IdNotValidAttribute)));
  SWIG_Python_SetConstant(d, "NameNotValidAttribute",SWIG_From_int(static_cast< int >(NameNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SpeciesTypeNotValidComponent",SWIG_From_int(static_cast< int >(SpeciesTypeNotValidComponent)));
  SWIG_Python_SetConstant(d, "StoichiometryMathNotValidComponent",SWIG_From_int(static_cast< int >(StoichiometryMathNotValidComponent)));
  SWIG_Python_SetConstant(d, "MultiplierNotValidAttribute",SWIG_From_int(static_cast< int >(MultiplierNotValidAttribute)));
  SWIG_Python_SetConstant(d, "OffsetNotValidAttribute",SWIG_From_int(static_cast< int >(OffsetNotValidAttribute)));
  SWIG_Python_SetConstant(d, "InvalidTargetLevelVersion",SWIG_From_int(static_cast< int >(InvalidTargetLevelVersion)));
  SWIG_Python_SetConstant(d, "L3NotSupported",SWIG_From_int(static_cast< int >(L3NotSupported)));
  SWIG_Python_SetConstant(d, "SBMLCodesUpperBound",SWIG_From_int(static_cast< int >(SBMLCodesUpperBound)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L1_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L1_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V1_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V1_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V2_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V2_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_GENERAL_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_GENERAL_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_IDENTIFIER_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_IDENTIFIER_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_UNITS_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_UNITS_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_MATHML_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_MATHML_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBO_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBO_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_OVERDETERMINED_MODEL",SWIG_From_int(static_cast< int >(LIBSBML_CAT_OVERDETERMINED_MODEL)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V3_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V3_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_MODELING_PRACTICE",SWIG_From_int(static_cast< int >(LIBSBML_CAT_MODELING_PRACTICE)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_INTERNAL_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_INTERNAL_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V4_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V4_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L3V1_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L3V1_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_SCHEMA_ERROR",SWIG_From_int(static_cast< int >(LIBSBML_SEV_SCHEMA_ERROR)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_GENERAL_WARNING",SWIG_From_int(static_cast< int >(LIBSBML_SEV_GENERAL_WARNING)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_NOT_APPLICABLE",SWIG_From_int(static_cast< int >(LIBSBML_SEV_NOT_APPLICABLE)));
  SWIG_Python_SetConstant(d, "MODEL_QUALIFIER",SWIG_From_int(static_cast< int >(MODEL_QUALIFIER)));
  SWIG_Python_SetConstant(d, "BIOLOGICAL_QUALIFIER",SWIG_From_int(static_cast< int >(BIOLOGICAL_QUALIFIER)));
  SWIG_Python_SetConstant(d, "UNKNOWN_QUALIFIER",SWIG_From_int(static_cast< int >(UNKNOWN_QUALIFIER)));
  SWIG_Python_SetConstant(d, "BQM_IS",SWIG_From_int(static_cast< int >(BQM_IS)));
  SWIG_Python_SetConstant(d, "BQM_IS_DESCRIBED_BY",SWIG_From_int(static_cast< int >(BQM_IS_DESCRIBED_BY)));
  SWIG_Python_SetConstant(d, "BQM_IS_DERIVED_FROM",SWIG_From_int(static_cast< int >(BQM_IS_DERIVED_FROM)));
  SWIG_Python_SetConstant(d, "BQM_UNKNOWN",SWIG_From_int(static_cast< int >(BQM_UNKNOWN)));
  SWIG_Python_SetConstant(d, "BQB_IS",SWIG_From_int(static_cast< int >(BQB_IS)));
  SWIG_Python_SetConstant(d, "BQB_HAS_PART",SWIG_From_int(static_cast< int >(BQB_HAS_PART)));
  SWIG_Python_SetConstant(d, "BQB_IS_PART_OF",SWIG_From_int(static_cast< int >(BQB_IS_PART_OF)));
  SWIG_Python_SetConstant(d, "BQB_IS_VERSION_OF",SWIG_From_int(static_cast< int >(BQB_IS_VERSION_OF)));
  SWIG_Python_SetConstant(d, "BQB_HAS_VERSION",SWIG_From_int(static_cast< int >(BQB_HAS_VERSION)));
  SWIG_Python_SetConstant(d, "BQB_IS_HOMOLOG_TO",SWIG_From_int(static_cast< int >(BQB_IS_HOMOLOG_TO)));
  SWIG_Python_SetConstant(d, "BQB_IS_DESCRIBED_BY",SWIG_From_int(static_cast< int >(BQB_IS_DESCRIBED_BY)));
  SWIG_Python_SetConstant(d, "BQB_IS_ENCODED_BY",SWIG_From_int(static_cast< int >(BQB_IS_ENCODED_BY)));
  SWIG_Python_SetConstant(d, "BQB_ENCODES",SWIG_From_int(static_cast< int >(BQB_ENCODES)));
  SWIG_Python_SetConstant(d, "BQB_OCCURS_IN",SWIG_From_int(static_cast< int >(BQB_OCCURS_IN)));
  SWIG_Python_SetConstant(d, "BQB_HAS_PROPERTY",SWIG_From_int(static_cast< int >(BQB_HAS_PROPERTY)));
  SWIG_Python_SetConstant(d, "BQB_IS_PROPERTY_OF",SWIG_From_int(static_cast< int >(BQB_IS_PROPERTY_OF)));
  SWIG_Python_SetConstant(d, "BQB_UNKNOWN",SWIG_From_int(static_cast< int >(BQB_UNKNOWN)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}


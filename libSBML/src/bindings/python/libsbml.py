from __future__ import generators
# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libsbml', [dirname(__file__)])
        except ImportError:
            import _libsbml
            return _libsbml
        if fp is not None:
            try:
                _mod = imp.load_module('_libsbml', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libsbml = swig_import_helper()
    del swig_import_helper
else:
    import _libsbml
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class ModelCreatorList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelCreatorList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelCreatorList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_ModelCreatorList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ModelCreatorList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.ModelCreatorList_add(self, *args)
    def get(self, *args): return _libsbml.ModelCreatorList_get(self, *args)
    def prepend(self, *args): return _libsbml.ModelCreatorList_prepend(self, *args)
    def remove(self, *args): return _libsbml.ModelCreatorList_remove(self, *args)
    def getSize(self): return _libsbml.ModelCreatorList_getSize(self)
ModelCreatorList_swigregister = _libsbml.ModelCreatorList_swigregister
ModelCreatorList_swigregister(ModelCreatorList)

class DateList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DateList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DateList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_DateList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_DateList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.DateList_add(self, *args)
    def get(self, *args): return _libsbml.DateList_get(self, *args)
    def prepend(self, *args): return _libsbml.DateList_prepend(self, *args)
    def remove(self, *args): return _libsbml.DateList_remove(self, *args)
    def getSize(self): return _libsbml.DateList_getSize(self)
DateList_swigregister = _libsbml.DateList_swigregister
DateList_swigregister(DateList)

class CVTermList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CVTermList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CVTermList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_CVTermList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_CVTermList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.CVTermList_add(self, *args)
    def get(self, *args): return _libsbml.CVTermList_get(self, *args)
    def prepend(self, *args): return _libsbml.CVTermList_prepend(self, *args)
    def remove(self, *args): return _libsbml.CVTermList_remove(self, *args)
    def getSize(self): return _libsbml.CVTermList_getSize(self)
CVTermList_swigregister = _libsbml.CVTermList_swigregister
CVTermList_swigregister(CVTermList)

class ASTNodeList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ASTNodeList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ASTNodeList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_ASTNodeList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ASTNodeList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.ASTNodeList_add(self, *args)
    def get(self, *args): return _libsbml.ASTNodeList_get(self, *args)
    def prepend(self, *args): return _libsbml.ASTNodeList_prepend(self, *args)
    def remove(self, *args): return _libsbml.ASTNodeList_remove(self, *args)
    def getSize(self): return _libsbml.ASTNodeList_getSize(self)
ASTNodeList_swigregister = _libsbml.ASTNodeList_swigregister
ASTNodeList_swigregister(ASTNodeList)

class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _libsbml.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _libsbml.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _libsbml.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _libsbml.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _libsbml.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _libsbml.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _libsbml.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _libsbml.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _libsbml.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _libsbml.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _libsbml.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _libsbml.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class string(_object):
    """Proxy of C++ std::basic_string<(char)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, string, name)
    __repr__ = _swig_repr
    def length(self):
        """length(self) -> size_type"""
        return _libsbml.string_length(self)

    def max_size(self):
        """max_size(self) -> size_type"""
        return _libsbml.string_max_size(self)

    def copy(self, *args):
        """
        copy(self, char __s, size_type __n, size_type __pos = 0) -> size_type
        copy(self, char __s, size_type __n) -> size_type
        """
        return _libsbml.string_copy(self, *args)

    def c_str(self):
        """c_str(self) -> char"""
        return _libsbml.string_c_str(self)

    def find(self, *args):
        """
        find(self, char __s, size_type __pos, size_type __n) -> size_type
        find(self, string __str, size_type __pos = 0) -> size_type
        find(self, string __str) -> size_type
        find(self, char __c, size_type __pos = 0) -> size_type
        find(self, char __c) -> size_type
        """
        return _libsbml.string_find(self, *args)

    def rfind(self, *args):
        """
        rfind(self, string __str, size_type __pos = std::basic_string< char >::npos) -> size_type
        rfind(self, string __str) -> size_type
        rfind(self, char __s, size_type __pos, size_type __n) -> size_type
        rfind(self, char __c, size_type __pos = std::basic_string< char >::npos) -> size_type
        rfind(self, char __c) -> size_type
        """
        return _libsbml.string_rfind(self, *args)

    def find_first_of(self, *args):
        """
        find_first_of(self, string __str, size_type __pos = 0) -> size_type
        find_first_of(self, string __str) -> size_type
        find_first_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_first_of(self, char __c, size_type __pos = 0) -> size_type
        find_first_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_first_of(self, *args)

    def find_last_of(self, *args):
        """
        find_last_of(self, string __str, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_of(self, string __str) -> size_type
        find_last_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_last_of(self, char __c, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_last_of(self, *args)

    def find_first_not_of(self, *args):
        """
        find_first_not_of(self, string __str, size_type __pos = 0) -> size_type
        find_first_not_of(self, string __str) -> size_type
        find_first_not_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_first_not_of(self, char __c, size_type __pos = 0) -> size_type
        find_first_not_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_first_not_of(self, *args)

    def find_last_not_of(self, *args):
        """
        find_last_not_of(self, string __str, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_not_of(self, string __str) -> size_type
        find_last_not_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_last_not_of(self, char __c, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_not_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_last_not_of(self, *args)

    def substr(self, *args):
        """
        substr(self, size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string
        substr(self, size_type __pos = 0) -> string
        substr(self) -> string
        """
        return _libsbml.string_substr(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _libsbml.string_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _libsbml.string_size(self)

    def swap(self, *args):
        """swap(self, string v)"""
        return _libsbml.string_swap(self, *args)

    def erase(self, *args):
        """
        erase(self, size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string
        erase(self, size_type __pos = 0) -> string
        erase(self) -> string
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _libsbml.string_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, char __s, size_type __n) -> string
        __init__(self) -> string
        __init__(self, string arg0) -> string
        __init__(self, size_type size, value_type value) -> string
        """
        this = _libsbml.new_string(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """
        assign(self, string __str) -> string
        assign(self, string __str, size_type __pos, size_type __n) -> string
        assign(self, char __s, size_type __n) -> string
        assign(self, size_type n, value_type x)
        """
        return _libsbml.string_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _libsbml.string_resize(self, *args)

    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _libsbml.string_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _libsbml.string___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _libsbml.string___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _libsbml.string___len__(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> string"""
        return _libsbml.string___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, string v)"""
        return _libsbml.string___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _libsbml.string___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _libsbml.string___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> string
        __getitem__(self, difference_type i) -> value_type
        """
        return _libsbml.string___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, string v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _libsbml.string___setitem__(self, *args)

    def insert(self, *args):
        """
        insert(self, size_type __pos1, string __str) -> string
        insert(self, size_type __pos1, string __str, size_type __pos2, size_type __n) -> string
        insert(self, size_type __pos, char __s, size_type __n) -> string
        insert(self, size_type __pos, size_type __n, char __c) -> string
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        insert(self, iterator __p, size_type __n, char __c)
        """
        return _libsbml.string_insert(self, *args)

    def replace(self, *args):
        """
        replace(self, size_type __pos, size_type __n, string __str) -> string
        replace(self, size_type __pos1, size_type __n1, string __str, size_type __pos2, 
            size_type __n2) -> string
        replace(self, size_type __pos, size_type __n1, char __s, size_type __n2) -> string
        replace(self, size_type __pos, size_type __n1, size_type __n2, char __c) -> string
        replace(self, iterator __i1, iterator __i2, string __str) -> string
        replace(self, iterator __i1, iterator __i2, char __s, size_type __n) -> string
        replace(self, iterator __i1, iterator __i2, size_type __n, char __c) -> string
        replace(self, iterator __i1, iterator __i2, char __k1, char __k2) -> string
        replace(self, iterator __i1, iterator __i2, const_iterator __k1, 
            const_iterator __k2) -> string
        """
        return _libsbml.string_replace(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, string v) -> string"""
        return _libsbml.string___iadd__(self, *args)

    def __add__(self, *args):
        """__add__(self, string v) -> string"""
        return _libsbml.string___add__(self, *args)

    def __radd__(self, *args):
        """__radd__(self, string v) -> string"""
        return _libsbml.string___radd__(self, *args)

    def __str__(self):
        """__str__(self) -> string"""
        return _libsbml.string___str__(self)

    def __rlshift__(self, *args):
        """__rlshift__(self, ostream out) -> ostream"""
        return _libsbml.string___rlshift__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, string v) -> bool"""
        return _libsbml.string___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, string v) -> bool"""
        return _libsbml.string___ne__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, string v) -> bool"""
        return _libsbml.string___gt__(self, *args)

    def __lt__(self, *args):
        """__lt__(self, string v) -> bool"""
        return _libsbml.string___lt__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, string v) -> bool"""
        return _libsbml.string___ge__(self, *args)

    def __le__(self, *args):
        """__le__(self, string v) -> bool"""
        return _libsbml.string___le__(self, *args)

    __swig_destroy__ = _libsbml.delete_string
    __del__ = lambda self : None;
string_swigregister = _libsbml.string_swigregister
string_swigregister(string)
cvar = _libsbml.cvar
string.npos = _libsbml.cvar.string_npos

class ostream(_object):
    """Proxy of C++ std::basic_ostream<(char)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ostream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ostream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, std::basic_streambuf<(char,std::char_traits<(char)>)> __sb) -> ostream"""
        this = _libsbml.new_ostream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ostream
    __del__ = lambda self : None;
ostream_swigregister = _libsbml.ostream_swigregister
ostream_swigregister(ostream)

class ostringstream(ostream):
    """Proxy of C++ std::basic_ostringstream<(char)> class"""
    __swig_setmethods__ = {}
    for _s in [ostream]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ostringstream, name, value)
    __swig_getmethods__ = {}
    for _s in [ostream]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ostringstream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, std::ios_base::openmode __mode = std::ios_base::out) -> ostringstream
        __init__(self) -> ostringstream
        """
        this = _libsbml.new_ostringstream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ostringstream
    __del__ = lambda self : None;
    def str(self, *args):
        """
        str(self) -> string
        str(self, string __s)
        """
        return _libsbml.ostringstream_str(self, *args)

ostringstream_swigregister = _libsbml.ostringstream_swigregister
ostringstream_swigregister(ostringstream)


def endl(*args):
  """endl(ostream arg0) -> ostream"""
  return _libsbml.endl(*args)

def flush(*args):
  """flush(ostream arg0) -> ostream"""
  return _libsbml.flush(*args)
import sys
import os.path


def conditional_abspath (filename):
  """conditional_abspath (filename) -> filename

  Returns filename with an absolute path prepended, if necessary.
  Some combinations of platforms and underlying XML parsers *require*
  an absolute path to a filename while others do not.  This function
  encapsulates the appropriate logic.  It is used by readSBML() and
  SBMLReader.readSBML().
  """
  if sys.platform.find('cygwin') != -1:
    return filename
  else:
    return os.path.abspath(filename)

def readSBML(*args):
  """readSBML(filename) -> SBMLDocument

  Reads an SBML document from the given file.  If filename does not exist
  or is not an SBML file, a fatal error will be logged.  Errors can be
  identified by their unique ids, e.g.:

    d = readSBML(filename)

    if d.getNumErrors() > 0:
      pm = d.getError(0)
      if pm.getErrorId() == libsbml.XMLFileUnreadable
      if pm.getErrorId() == libsbml.XMLTagMismatch: 

  """
  reader = SBMLReader()
  return reader.readSBML(args[0])


def ASTNode_true(*args):
  """ASTNode_true(ASTNode node) -> int"""
  return _libsbml.ASTNode_true(*args)
LIBSBML_DOTTED_VERSION = _libsbml.LIBSBML_DOTTED_VERSION
LIBSBML_VERSION = _libsbml.LIBSBML_VERSION
LIBSBML_VERSION_STRING = _libsbml.LIBSBML_VERSION_STRING

def getLibSBMLVersion():
  """
    getLibSBMLVersion() -> int

    Returns the libSBML version as an integer: version 1.2.3 becomes 10203.

    @return the libSBML version as an integer: version 1.2.3 becomes 10203.


    """
  return _libsbml.getLibSBMLVersion()

def getLibSBMLDottedVersion():
  """
    getLibSBMLDottedVersion() -> char

    Returns the libSBML version as a string of the form '1.2.3'.

    @return the libSBML version as a string of the form '1.2.3'.


    """
  return _libsbml.getLibSBMLDottedVersion()

def getLibSBMLVersionString():
  """
    getLibSBMLVersionString() -> char

    Returns the libSBML version as a string: version 1.2.3 becomes '10203'.

    @return the libSBML version as a string: version 1.2.3 becomes '10203'.


    """
  return _libsbml.getLibSBMLVersionString()
LIBSBML_OPERATION_SUCCESS = _libsbml.LIBSBML_OPERATION_SUCCESS
LIBSBML_INDEX_EXCEEDS_SIZE = _libsbml.LIBSBML_INDEX_EXCEEDS_SIZE
LIBSBML_UNEXPECTED_ATTRIBUTE = _libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE
LIBSBML_OPERATION_FAILED = _libsbml.LIBSBML_OPERATION_FAILED
LIBSBML_INVALID_ATTRIBUTE_VALUE = _libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE
LIBSBML_INVALID_OBJECT = _libsbml.LIBSBML_INVALID_OBJECT
LIBSBML_DUPLICATE_OBJECT_ID = _libsbml.LIBSBML_DUPLICATE_OBJECT_ID
LIBSBML_LEVEL_MISMATCH = _libsbml.LIBSBML_LEVEL_MISMATCH
LIBSBML_VERSION_MISMATCH = _libsbml.LIBSBML_VERSION_MISMATCH
LIBSBML_INVALID_XML_OPERATION = _libsbml.LIBSBML_INVALID_XML_OPERATION
class SBMLReader(_object):
    """
    Methods for reading SBML from files and text strings.

    @htmlinclude not-sbml-warning.html

    The SBMLReader class provides the main interface for reading SBML
    content from files and strings.  The methods for reading SBML all return
    an SBMLDocument object representing the results.

    In the case of failures (such as if the SBML contains errors or a file
    cannot be read), the errors will be recorded with the SBMLErrorLog
    object kept in the SBMLDocument returned by SBMLReader.  Consequently,
    immediately after calling a method on SBMLReader, callers should always
    check for errors and warnings using the methods for this purpose
    provided by SBMLDocument.

    For convenience as well as easy access from other languages besides C++,
    this file also defines two global functions, readSBMLFromFile() and
    readSBMLFromString().  They are equivalent to creating an SBMLReader
    object and then calling
    the @if clike SBMLReader::readSBML() @endif@if java SBMLReader::readSBML(String filename) @endif or
    @if clike SBMLReader::readSBMLFromString() @endif@if java SBMLReader::readSBMLFromString(String xml)  @endif methods, respectively.

    LibSBML also provides support for reading and writing compressed files
    and data streams.  It does this automatically and transparently if
    libSBML was configured and compiled with the compression support
    enabled.  If the given filename ends with the suffix @c '.gz' (for
    example, @c 'myfile.xml.gz'), then the file is assumed to be compressed
    in @em gzip format and will be automatically decompressed upon reading.
    Similarly, if the given filename ends with @c '.zip' or @c '.bz2', the
    file is assumed to be compressed in @em zip or @em bzip2 format
    (respectively).  Files whose names lack these suffixes will be read
    uncompressed.

    Applications may sometimes need to query whether the copy of the libSBML
    library that they're linked against does support reading and writing
    compressed files.  SBMLReader provides the methods hasZlib() and
    hasBzip2() and for this purpose.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLReader, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> SBMLReader

        Creates a new SBMLReader and returns it. 
          

        """
        this = _libsbml.new_SBMLReader()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLReader
    __del__ = lambda self : None;
    def readSBML(*args):
      """readSBML(filename) -> SBMLDocument

      Reads an SBML document from the given file.  If filename does not exist
      or is not an SBML file, a fatal error will be logged.  Errors can be
      identified by their unique ids, e.g.:

        reader = libsbml.SBMLReader()
        d      = reader.readSBML(filename)

        if d.getNumErrors() > 0:
          pm = d.getError(0)
          if pm.getErrorId() == libsbml.XMLFileUnreadable
          if pm.getErrorId() == libsbml.XMLTagMismatch: 
      """
      args_copy    = list(args)
      args_copy[1] = conditional_abspath(args[1])
      return _libsbml.SBMLReader_readSBML(*args_copy)


    def readSBMLFromFile(self, *args):
        """
        readSBMLFromFile(self, string filename) -> SBMLDocument

        Reads an SBML document from a file.

        If the file named @p filename does not exist or its content is not
        valid SBML, one or more errors will be logged with the SBMLDocument
        object returned by this method.  Callers can use the methods on
        SBMLDocument such as SBMLDocument::getNumErrors() and
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif to get the errors.  The object returned by
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif is an SBMLError object, and it has methods to
        get the error code, category, and severity level of the problem, as
        well as a textual description of the problem.  The possible severity
        levels range from informational messages to fatal errors; see the
        documentation for SBMLError for more information.

        If the file @p filename could not be read, the file-reading error will
        appear first.  The error code (a value drawn from the enumeration
        #XMLErrorCode_t) can provide a clue about what happened.  For example,
        a file might be unreadable (either because it does not actually exist
        or because the user does not have the necessary access priviledges to
        read it) or some sort of file operation error may have been reported
        by the underlying operating system.  Callers can check for these
        situations using a program fragment such as the following:
        @code
        SBMLReader* reader = new SBMLReader();
        SBMLDocument* doc  = reader.readSBML(filename);

        if (doc->getNumErrors() > 0)
        {
          if (doc->getError(0)->getId() == XMLError::FileUnreadable)
          {
            // Handle case of unreadable file here.
          } 
          else if (doc->getError(0)->getId() == XMLError::FileOperationError)
          {
            // Handle case of other file error here.
          }
          else
          {
            // Handle other cases -- see error codes defined in XMLErrorCode_t
            // for other possible cases to check.
          }
        }
        @endcode

        If the given filename ends with the suffix @c '.gz' (for example, @c
        'myfile.xml.gz'), the file is assumed to be compressed in @em gzip
        format and will be automatically decompressed upon reading.
        Similarly, if the given filename ends with @c '.zip' or @c '.bz2', the
        file is assumed to be compressed in @em zip or @em bzip2 format
        (respectively).  Files whose names lack these suffixes will be read
        uncompressed.  Note that if the file is in @em zip format but the
        archive contains more than one file, only the first file in the
        archive will be read and the rest ignored.

        @param filename the name or full pathname of the file to be read.

        @return a pointer to the SBMLDocument created from the SBML content.

        @see SBMLError

        @note LibSBML versions 2.x and later versions behave differently in
        error handling in several respects.  One difference is how early some
        errors are caught and whether libSBML continues processing a file in
        the face of some early errors.  In general, libSBML versions after 2.x
        stop parsing SBML inputs sooner than libSBML version 2.x in the face
        of XML errors, because the errors may invalidate any further SBML
        content.  For example, a missing XML declaration at the beginning of
        the file was ignored by libSBML 2.x but in version 3.x and later, it
        will cause libSBML to stop parsing the rest of the input altogether.
        While this behavior may seem more severe and intolerant, it was
        necessary in order to provide uniform behavior regardless of which
        underlying XML parser (Expat, Xerces, libxml2) is being used by
        libSBML.  The XML parsers themselves behave differently in their error
        reporting, and sometimes libSBML has to resort to the lowest common
        denominator.
        <br><br>
        @note To read a gzip/zip file, libSBML needs to be configured and
        linked with the <a href='http://www.zlib.net/'>zlib</a> library at
        compile time.  It also needs to be linked with the <a
        href=''>bzip2</a> library to read files in @em bzip2 format.  (Both of
        these are the default configurations for libSBML.)  Errors about
        unreadable files will be logged if a compressed filename is given and
        libSBML was @em not linked with the corresponding required library.
        <br><br>
        @note SBMLReader::hasZlib() and SBMLReader::hasBzip2() can be used to
        check whether libSBML has been linked with each library.
          

        """
        return _libsbml.SBMLReader_readSBMLFromFile(self, *args)

    def readSBMLFromString(self, *args):
        """
        readSBMLFromString(self, string xml) -> SBMLDocument

        Reads an SBML document from the given XML string.

        This method is flexible with respect to the presence of an XML
        declaration at the beginning of the string.  In particular, if the
        string in @p xml does not begin with the XML declaration
        <code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</code>, then this
        method will automatically prepend the declaration to @p xml.

        This method will log a fatal error if the content given in the
        parameter @p xml is not SBML.  See the method documentation for
        @if clike SBMLReader::readSBML() @endif@if java SBMLReader::readSBML(String filename) @endif for an example of code for testing the returned
        error code.

        @param xml a string containing a full SBML model

        @return a pointer to the SBMLDocument created from the SBML content.

        @if clike @see SBMLReader::readSBML() @endif@if java @see SBMLReader::readSBML(String filename) @endif
          

        """
        return _libsbml.SBMLReader_readSBMLFromString(self, *args)

    def hasZlib():
        """
        hasZlib() -> bool

        Predicate returning @c true if this copy
        of libSBML supports <i>gzip</I> and <i>zip</i> format compression.

        @return @c true if libSBML has been linked with the <i>zlib</i>
        library, @c false otherwise.

        @see hasBzip2()
          

        """
        return _libsbml.SBMLReader_hasZlib()

    if _newclass:hasZlib = staticmethod(hasZlib)
    __swig_getmethods__["hasZlib"] = lambda x: hasZlib
    def hasBzip2():
        """
        hasBzip2() -> bool

        Predicate returning @c true if
        this copy of libSBML supports <i>bzip2</i> format compression.

        @return @c true if libSBML has been linked with the <i>bzip2</i>
        libraries, @c false otherwise.

        @see hasZlib()
          

        """
        return _libsbml.SBMLReader_hasBzip2()

    if _newclass:hasBzip2 = staticmethod(hasBzip2)
    __swig_getmethods__["hasBzip2"] = lambda x: hasBzip2
    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBMLReader_swigregister = _libsbml.SBMLReader_swigregister
SBMLReader_swigregister(SBMLReader)
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

def SBMLReader_hasZlib():
  """
    SBMLReader_hasZlib() -> bool

    Predicate returning @c true if this copy
    of libSBML supports <i>gzip</I> and <i>zip</i> format compression.

    @return @c true if libSBML has been linked with the <i>zlib</i>
    library, @c false otherwise.

    @see hasBzip2()
      

    """
  return _libsbml.SBMLReader_hasZlib()

def SBMLReader_hasBzip2():
  """
    SBMLReader_hasBzip2() -> bool

    Predicate returning @c true if
    this copy of libSBML supports <i>bzip2</i> format compression.

    @return @c true if libSBML has been linked with the <i>bzip2</i>
    libraries, @c false otherwise.

    @see hasZlib()
      

    """
  return _libsbml.SBMLReader_hasBzip2()


def readSBMLFromFile(*args):
  """
    readSBMLFromFile(char filename) -> SBMLDocument_t

    Reads an SBML document from the given file @p filename.

    If @p filename does not exist, or it is not an SBML file, an error will
    be logged in the error log of the SBMLDocument object returned by this
    method.  Calling programs can inspect this error log to determine
    the nature of the problem.  Please refer to the definition of
    SBMLDocument for more information about the error reporting mechanism.

    @return a pointer to the SBMLDocument read.


    """
  return _libsbml.readSBMLFromFile(*args)

def readSBMLFromString(*args):
  """
    readSBMLFromString(char xml) -> SBMLDocument_t

    Reads an SBML document from a string assumed to be in XML format.

    If the string does not begin with XML declaration,
     @verbatim
     <?xml version='1.0' encoding='UTF-8'?>
     @endverbatim

    an XML declaration string will be prepended.

    This method will report an error if the given string @p xml is not SBML.
    The error will be logged in the error log of the SBMLDocument object
    returned by this method.  Calling programs can inspect this error log to
    determine the nature of the problem.  Please refer to the definition of
    SBMLDocument for more information about the error reporting mechanism.

    @return a pointer to the SBMLDocument read.


    """
  return _libsbml.readSBMLFromString(*args)
class SBMLWriter(_object):
    """
    Methods for writing SBML to files and text strings.

    @htmlinclude not-sbml-warning.html

    The SBMLWriter class is the converse of SBMLReader, and provides the
    main interface for serializing SBML models into XML and writing the
    result to files and text strings.  The methods for writing SBML all take
    an SBMLDocument object and a destination.  They return a boolean value
    to indicate success or failure.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLWriter, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> SBMLWriter

        Creates a new SBMLWriter.
          

        """
        this = _libsbml.new_SBMLWriter()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLWriter
    __del__ = lambda self : None;
    def setProgramName(self, *args):
        """
        setProgramName(self, string name) -> int

        Sets the name of this program, i.e., the program that is about to
        write out the SBMLDocument.

        If the program name and version are set (setProgramVersion()), the
        following XML comment, intended for human consumption, will be written
        at the beginning of the document:
          @verbatim
            <!-- Created by <program name> version <program version>
            on yyyy-MM-dd HH:mm with libsbml version <libsbml version>. -->
         @endverbatim

        @param name the name of this program (where 'this program' refers to
        program in which libSBML is embedded, not libSBML itself!)

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see setProgramVersion(const std::string& version)
          

        """
        return _libsbml.SBMLWriter_setProgramName(self, *args)

    def setProgramVersion(self, *args):
        """
        setProgramVersion(self, string version) -> int

        Sets the version of this program, i.e., the program that is about to
        write out the SBMLDocument.

        If the program version and name are set (setProgramName()), the
        following XML comment, intended for human consumption, will be written
        at the beginning of the document:
          @verbatim
            <!-- Created by <program name> version <program version>
            on yyyy-MM-dd HH:mm with libsbml version <libsbml version>. -->
         @endverbatim

        @param version the version of this program (where 'this program'
        refers to program in which libSBML is embedded, not libSBML itself!)

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see setProgramName(const std::string& name)
          

        """
        return _libsbml.SBMLWriter_setProgramVersion(self, *args)

    def writeSBML(self, *args):
        """
        writeSBML(self, SBMLDocument d, string filename) -> bool
        writeSBML(self, SBMLDocument d, ostream stream) -> bool

        Writes the given SBML document to the output stream.

        @param d the SBML document to be written

        @param stream the stream object where the SBML is to be written.

        @return @c true on success and @c false if one of the underlying
        parser components fail (rare).
          

        """
        return _libsbml.SBMLWriter_writeSBML(self, *args)

    def writeToString(self, *args):
        """
        writeToString(self, SBMLDocument d) -> char

        Writes the given SBML document to an in-memory string and returns a
        pointer to it.

        The string is owned by the caller and should be freed (with @c free())
        when no longer needed.

        @param d the SBML document to be written

        @return the string on success and @c 0 if one of the underlying parser
        components fail.
        @deprecated libSBML internal


        """
        return _libsbml.SBMLWriter_writeToString(self, *args)

    def writeSBMLToFile(self, *args):
        """
        writeSBMLToFile(self, SBMLDocument d, string filename) -> bool

        Writes the given SBML document to filename.

        If the given filename ends with the suffix @c '.gz' (for example, @c
        'myfile.xml.gz'), libSBML assumes the caller wants the file to be
        written compressed in @em gzip.  Similarly, if the given filename ends
        with @c '.zip' or @c '.bz2', libSBML assumes the caller wants the file
        to be compressed in @em zip or @em bzip2 format (respectively).  Files
        whose names lack these suffixes will be written uncompressed.
        <em>Special considerations for the zip format</em>: If the given
        filename ends with @c '.zip', the file placed in the zip archive will
        have the suffix @c '.xml' or @c '.sbml'.  For example, the file in
        the zip archive will be named @c 'test.xml' if the given filename is
        @c 'test.xml.zip' or @c 'test.zip'.  Similarly, the filename in the
        archive will be @c 'test.sbml' if the given filename is @c
        'test.sbml.zip'.

        @note To write a gzip/zip file, libSBML needs to be configured and
        linked with the <a href='http://www.zlib.net/'>zlib</a> library at
        compile time.  It also needs to be linked with the <a
        href=''>bzip2</a> library to write files in @em bzip2 format.  (Both
        of these are the default configurations for libSBML.)  Errors about
        unreadable files will be logged and this method will return @c false
        if a compressed filename is given and libSBML was @em not linked with
        the corresponding required library.

        @note SBMLReader::hasZlib() and SBMLReader::hasBzip2() can be used to
        check whether libSBML has been linked with each library.

        @param d the SBML document to be written

        @param filename the name or full pathname of the file where the SBML
        is to be written. 

        @return @c true on success and @c false if the filename could not be
        opened for writing.
          

        """
        return _libsbml.SBMLWriter_writeSBMLToFile(self, *args)

    def writeSBMLToString(self, *args):
        """
        writeSBMLToString(self, SBMLDocument d) -> char

        Writes the given SBML document to an in-memory string and returns a
        pointer to it.

        The string is owned by the caller and should be freed (with @c free())
        when no longer needed.

        @param d the SBML document to be written

        @return the string on success and @c 0 if one of the underlying parser
        components fail.
          

        """
        return _libsbml.SBMLWriter_writeSBMLToString(self, *args)

    def hasZlib():
        """
        hasZlib() -> bool

        Predicate returning @c true if
        underlying libSBML is linked with zlib.

        LibSBML supports reading and writing files compressed with either
        bzip2 or zip/gzip compression.  The facility depends on libSBML having
        been compiled with the necessary support libraries.  This method
        allows a calling program to inquire whether that is the case for the
        copy of libSBML it is running.

        @return @c true if libSBML is linked with zlib, @c false otherwise.
          

        """
        return _libsbml.SBMLWriter_hasZlib()

    if _newclass:hasZlib = staticmethod(hasZlib)
    __swig_getmethods__["hasZlib"] = lambda x: hasZlib
    def hasBzip2():
        """
        hasBzip2() -> bool

        Predicate returning @c true if
        underlying libSBML is linked with bzip2.

        LibSBML supports reading and writing files compressed with either
        bzip2 or zip/gzip compression.  The facility depends on libSBML having
        been compiled with the necessary support libraries.  This method
        allows a calling program to inquire whether that is the case for the
        copy of libSBML it is running.

        @return @c true if libSBML is linked with bzip2, @c false otherwise.
        @deprecated libSBML internal


        """
        return _libsbml.SBMLWriter_hasBzip2()

    if _newclass:hasBzip2 = staticmethod(hasBzip2)
    __swig_getmethods__["hasBzip2"] = lambda x: hasBzip2
    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBMLWriter_swigregister = _libsbml.SBMLWriter_swigregister
SBMLWriter_swigregister(SBMLWriter)

def SBMLWriter_hasZlib():
  """
    SBMLWriter_hasZlib() -> bool

    Predicate returning @c true if
    underlying libSBML is linked with zlib.

    LibSBML supports reading and writing files compressed with either
    bzip2 or zip/gzip compression.  The facility depends on libSBML having
    been compiled with the necessary support libraries.  This method
    allows a calling program to inquire whether that is the case for the
    copy of libSBML it is running.

    @return @c true if libSBML is linked with zlib, @c false otherwise.
      

    """
  return _libsbml.SBMLWriter_hasZlib()

def SBMLWriter_hasBzip2():
  """
    SBMLWriter_hasBzip2() -> bool

    Predicate returning @c true if
    underlying libSBML is linked with bzip2.

    LibSBML supports reading and writing files compressed with either
    bzip2 or zip/gzip compression.  The facility depends on libSBML having
    been compiled with the necessary support libraries.  This method
    allows a calling program to inquire whether that is the case for the
    copy of libSBML it is running.

    @return @c true if libSBML is linked with bzip2, @c false otherwise.
    @deprecated libSBML internal


    """
  return _libsbml.SBMLWriter_hasBzip2()


def writeSBML(*args):
  """
    writeSBML(SBMLDocument_t d, char filename) -> int

    Writes the given SBML document to filename.  This convenience function
    is functionally equivalent to:

      SBMLWriter_writeSBML(SBMLWriter_create(), d, filename);

    @return non-zero on success and zero if the filename could not be opened
    for writing.


    """
  return _libsbml.writeSBML(*args)

def writeSBMLToString(*args):
  """
    writeSBMLToString(SBMLDocument_t d) -> char

    Writes the given SBML document to an in-memory string and returns a
    pointer to it.  The string is owned by the caller and should be freed
    (with free()) when no longer needed.  This convenience function is
    functionally equivalent to:

      SBMLWriter_writeSBMLToString(SBMLWriter_create(), d);

    @return the string on success and @c NULL if one of the underlying parser
    components fail (rare).


    """
  return _libsbml.writeSBMLToString(*args)

def writeSBMLToFile(*args):
  """
    writeSBMLToFile(SBMLDocument_t d, char filename) -> int

    Writes the given SBML document to an in-memory string and returns a
    pointer to it.  The string is owned by the caller and should be freed
    (with free()) when no longer needed.  This convenience function is
    functionally equivalent to:

      SBMLWriter_writeSBMLToString(SBMLWriter_create(), d);

    @return the string on success and @c NULL if one of the underlying parser
    components fail (rare).


    """
  return _libsbml.writeSBMLToFile(*args)
SBML_UNKNOWN = _libsbml.SBML_UNKNOWN
SBML_COMPARTMENT = _libsbml.SBML_COMPARTMENT
SBML_COMPARTMENT_TYPE = _libsbml.SBML_COMPARTMENT_TYPE
SBML_CONSTRAINT = _libsbml.SBML_CONSTRAINT
SBML_DOCUMENT = _libsbml.SBML_DOCUMENT
SBML_EVENT = _libsbml.SBML_EVENT
SBML_EVENT_ASSIGNMENT = _libsbml.SBML_EVENT_ASSIGNMENT
SBML_FUNCTION_DEFINITION = _libsbml.SBML_FUNCTION_DEFINITION
SBML_INITIAL_ASSIGNMENT = _libsbml.SBML_INITIAL_ASSIGNMENT
SBML_KINETIC_LAW = _libsbml.SBML_KINETIC_LAW
SBML_LIST_OF = _libsbml.SBML_LIST_OF
SBML_MODEL = _libsbml.SBML_MODEL
SBML_PARAMETER = _libsbml.SBML_PARAMETER
SBML_REACTION = _libsbml.SBML_REACTION
SBML_RULE = _libsbml.SBML_RULE
SBML_SPECIES = _libsbml.SBML_SPECIES
SBML_SPECIES_REFERENCE = _libsbml.SBML_SPECIES_REFERENCE
SBML_SPECIES_TYPE = _libsbml.SBML_SPECIES_TYPE
SBML_MODIFIER_SPECIES_REFERENCE = _libsbml.SBML_MODIFIER_SPECIES_REFERENCE
SBML_UNIT_DEFINITION = _libsbml.SBML_UNIT_DEFINITION
SBML_UNIT = _libsbml.SBML_UNIT
SBML_ALGEBRAIC_RULE = _libsbml.SBML_ALGEBRAIC_RULE
SBML_ASSIGNMENT_RULE = _libsbml.SBML_ASSIGNMENT_RULE
SBML_RATE_RULE = _libsbml.SBML_RATE_RULE
SBML_SPECIES_CONCENTRATION_RULE = _libsbml.SBML_SPECIES_CONCENTRATION_RULE
SBML_COMPARTMENT_VOLUME_RULE = _libsbml.SBML_COMPARTMENT_VOLUME_RULE
SBML_PARAMETER_RULE = _libsbml.SBML_PARAMETER_RULE
SBML_TRIGGER = _libsbml.SBML_TRIGGER
SBML_DELAY = _libsbml.SBML_DELAY
SBML_STOICHIOMETRY_MATH = _libsbml.SBML_STOICHIOMETRY_MATH
SBML_LOCAL_PARAMETER = _libsbml.SBML_LOCAL_PARAMETER
SBML_FORMULA_UNITS_DATA = _libsbml.SBML_FORMULA_UNITS_DATA
SBML_LIST_FORMULA_UNITS_DATA = _libsbml.SBML_LIST_FORMULA_UNITS_DATA
SBML_LISTOF_COMPARTMENTS = _libsbml.SBML_LISTOF_COMPARTMENTS
SBML_LISTOF_COMPARTMENT_TYPES = _libsbml.SBML_LISTOF_COMPARTMENT_TYPES
SBML_LISTOF_CONSTRAINTS = _libsbml.SBML_LISTOF_CONSTRAINTS
SBML_LISTOF_EVENTS = _libsbml.SBML_LISTOF_EVENTS
SBML_LISTOF_EVENT_ASSIGNMENTS = _libsbml.SBML_LISTOF_EVENT_ASSIGNMENTS
SBML_LISTOF_FUNCTION_DEFINITIONS = _libsbml.SBML_LISTOF_FUNCTION_DEFINITIONS
SBML_LISTOF_INITIAL_ASSIGNMENTS = _libsbml.SBML_LISTOF_INITIAL_ASSIGNMENTS
SBML_LISTOF_PARAMETERS = _libsbml.SBML_LISTOF_PARAMETERS
SBML_LISTOF_REACTIONS = _libsbml.SBML_LISTOF_REACTIONS
SBML_LISTOF_RULES = _libsbml.SBML_LISTOF_RULES
SBML_LISTOF_SPECIES = _libsbml.SBML_LISTOF_SPECIES
SBML_LISTOF_SPECIES_REFERENCES = _libsbml.SBML_LISTOF_SPECIES_REFERENCES
SBML_LISTOF_SPECIES_TYPES = _libsbml.SBML_LISTOF_SPECIES_TYPES
SBML_LISTOF_UNIT_DEFINITIONS = _libsbml.SBML_LISTOF_UNIT_DEFINITIONS
SBML_LISTOF_UNITS = _libsbml.SBML_LISTOF_UNITS

def SBMLTypeCode_toString(*args):
  """
    SBMLTypeCode_toString(SBMLTypeCode_t tc) -> char

    This method takes an SBML type code and returns a string representing
    the code.

    @if clike LibSBML attaches an identifying code to every
    kind of SBML object.  These are known as <em>SBML type codes</em>.
    The set of possible type codes is defined in the enumeration
    #SBMLTypeCode_t.  The names of the type codes all begin with the
    characters @c SBML_. @endif@if java LibSBML attaches an
    identifying code to every kind of SBML object.  These are known as
    <em>SBML type codes</em>.  In other languages, the set of type codes
    is stored in an enumeration; in the Java language interface for
    libSBML, the type codes are defined as static integer constants in
    interface class {@link libsbmlConstants}.  The names of the type codes
    all begin with the characters @c SBML_. @endif
    This method takes a type code as argument, and returns a string name
    corresponding to that code.  For example, passing it the type code
    <code>SBML_COMPARTMENT</code> will return the string
    '<code>Compartment</code>'. 

    @return a human readable name for the given #SBMLTypeCode_t.

    @note The caller does not own the returned string and is therefore not
    allowed to modify it.


    """
  return _libsbml.SBMLTypeCode_toString(*args)
class SBase(_object):
    """
    LibSBML implementation of %SBase, the base class of most SBML objects.

    Most components in SBML are derived from a single abstract base type,
    SBase.  In addition to serving as the parent class for most other
    classes of objects in SBML, this base type is designed to allow a
    modeler or a software package to attach arbitrary information to each
    major element or list in an SBML model.

    SBase has an optional subelement called 'notes'.  It is intended to
    serve as a place for storing optional information intended to be seen by
    humans.  An example use of the 'notes' element would be to contain
    formatted user comments about the model element in which the 'notes'
    element is enclosed.  There are certain conditions on the XHTML content
    permitted inside the 'notes' element; please consult the <a
    target='_blank' href='http://sbml.org/Documents/Specifications'>SBML
    specification document</a> corresponding to the SBML Level and Version
    of your model for more information about the requirements for 'notes'
    content.

    SBase has another optional subelement called 'annotation'.  Whereas the
    'notes' element described above is a container for content to be shown
    directly to humans, the 'annotation' element is a container for optional
    software-generated content @em not meant to be shown to humans.  The
    element's content type is <a target='_blank'
    href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
    'any'</a>, allowing essentially arbitrary data content.  SBML places
    only a few restrictions on the organization of the content; these are
    intended to help software tools read and write the data as well as help
    reduce conflicts between annotations added by different tools.  As is
    the case with 'notes', it is important to refer to the <a
    target='_blank' href='http://sbml.org/Documents/Specifications'>SBML
    specification document</a> corresponding to the SBML Level and Version
    of your model for more information about the requirements for
    'annotation' content.

    It is worth pointing out that the 'annotation' element in the definition
    of SBase exists in order that software developers may attach optional
    application-specific data to the elements in an SBML model.  However, it
    is important that this facility not be misused.  In particular, it is
    <em>critical</em> that data essential to a model definition or that can
    be encoded in existing SBML elements is <em>not</em> stored in
    'annotation'. Parameter values, functional dependencies between model
    elements, etc., should not be recorded as annotations.  It is crucial to
    keep in mind the fact that data placed in annotations can be freely
    ignored by software applications.  If such data affects the
    interpretation of a model, then software interoperability is greatly
    impeded.

    SBML Level 2 introduced an optional SBase attribute named 'metaid' for
    supporting metadata annotations using RDF (<a target='_blank'
    href='http://www.w3.org/RDF/'>Resource Description Format</a>). The
    attribute value has the data type <a
    href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML identifier
    type, which means each 'metaid' value must be globally unique within an
    SBML file.  (Importantly, this uniqueness criterion applies across any
    attribute with type <a href='http://www.w3.org/TR/REC-xml/#id'>XML
    ID</a>, not just the 'metaid' attribute used by SBML&mdash;something to
    be aware of if your application-specific XML content inside the
    'annotation' subelement happens to use <a
    href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)  The 'metaid' value
    serves to identify a model component for purposes such as referencing
    that component from metadata placed within 'annotation' subelements.

    Beginning with SBML Level 2 Version 3, SBase also has an optional
    attribute named 'sboTerm' for supporting the use of the Systems Biology
    Ontology.  In SBML proper, the data type of the attribute is a string of
    the form 'SBO:NNNNNNN', where 'NNNNNNN' is a seven digit integer number;
    libSBML simplifies the representation by only storing the NNNNNNN
    integer portion.  Thus, in libSBML, the 'sboTerm' attribute on SBase has
    data type @c int, and SBO identifiers are stored simply as integers.
    (For convenience, SBase offers methods for returning both the integer
    form and a text-string form of the SBO identifier.)  SBO terms are a
    type of optional annotation, and each different class of SBML object
    derived from SBase imposes its own requirements about the values
    permitted for 'sboTerm'.  Please consult the SBML Level&nbsp;2
    Version&nbsp;4 specification for more information about the use of SBO
    and the 'sboTerm' attribute.

    Finally, note that, in the list of methods on SBase, there is no public
    constructor because SBase is an abstract class.  The constructors reside
    in the subclasses derived from SBase.


    @section sbase-miriam Standard format for annotations linking data resources

    SBML Level 2 Versions 2, 3 and 4 define a proposed regular format for
    encoding two particular categories of annotations: (a) references to
    controlled vocabulary terms and database identifiers which define and
    describe biological and biochemical entities in a model; and (b)
    descriptions of the provenance of a model, including its author(s) and
    modification history.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SBase
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBase

        Creates and returns a deep copy of this SBase object.

        @return a (deep) copy of this SBase object.
          

        """
        return _libsbml.SBase_clone(self)

    def getMetaId(self):
        """
        getMetaId(self) -> string

        Returns the value of the 'metaid' attribute of this object.

        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF
        (Resource Description Format).  The attribute value has the data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML
        identifier type, which means each 'metaid' value must be globally
        unique within an SBML file.  (Importantly, this uniqueness criterion
        applies across any attribute with type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the
        'metaid' attribute used by SBML&mdash;something to be aware of if your
        application-specific XML content inside the 'annotation' subelement
        happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)
        The 'metaid' value serves to identify a model
        component for purposes such as referencing that component from
        metadata placed within 'annotation' subelements.
         
        @return the metaid of this SBML object, as a string.

        @see isSetMetaId()
        @see setMetaId(const std::string& metaid)
          

        """
        return _libsbml.SBase_getMetaId(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'metaid' attribute of this object.

        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF
        (Resource Description Format).  The attribute value has the data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML
        identifier type, which means each 'metaid' value must be globally
        unique within an SBML file.  (Importantly, this uniqueness criterion
        applies across any attribute with type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the
        'metaid' attribute used by SBML&mdash;something to be aware of if your
        application-specific XML content inside the 'annotation' subelement
        happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)
        The 'metaid' value serves to identify a model
        component for purposes such as referencing that component from
        metadata placed within 'annotation' subelements.
         
        @return the metaid of this SBML object, as a string.

        @see isSetMetaId()
        @see setMetaId(const std::string& metaid)
        @deprecated libSBML internal


        """
        return _libsbml.SBase_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'metaid' attribute of this object.

        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF
        (Resource Description Format).  The attribute value has the data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML
        identifier type, which means each 'metaid' value must be globally
        unique within an SBML file.  (Importantly, this uniqueness criterion
        applies across any attribute with type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the
        'metaid' attribute used by SBML&mdash;something to be aware of if your
        application-specific XML content inside the 'annotation' subelement
        happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)
        The 'metaid' value serves to identify a model
        component for purposes such as referencing that component from
        metadata placed within 'annotation' subelements.
         
        @return the metaid of this SBML object, as a string.

        @see isSetMetaId()
        @see setMetaId(const std::string& metaid)
        @deprecated libSBML internal


        """
        return _libsbml.SBase_getName(self)

    def getNotes(self):
        """
        getNotes(self) -> XMLNode

        Returns the content of the 'notes' subelement of this object as
        a tree of XMLNode objects.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        The 'notes' element content returned by this method will be in XML
        form, but libSBML does not provide an object model specifically for
        the content of notes.  Callers will need to traverse the XML tree
        structure using the facilities available on XMLNode and related
        objects.  For an alternative method of accessing the notes, see
        getNotesString().

        @return the content of the 'notes' subelement of this SBML object as a
        tree structure composed of XMLNode objects.

        @see getNotesString()
        @see isSetNotes()
        @see setNotes(const XMLNode* notes)
        @see setNotes(const std::string& notes)
        @see appendNotes(const XMLNode* notes)
        @see appendNotes(const std::string& notes)
        @see unsetNotes()
        @see SyntaxChecker::hasExpectedXHTMLSyntax()
          

        """
        return _libsbml.SBase_getNotes(self)

    def getNotesString(self):
        """
        getNotesString(self) -> string

        Returns the content of the 'notes' subelement of this object as a
        string.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        For an alternative method of accessing the notes, see getNotes(),
        which returns the content as an XMLNode tree structure.  Depending on
        an application's needs, one or the other method may be more
        convenient.

        @return the content of the 'notes' subelement of this SBML object as a
        string.

        @see getNotes()
        @see isSetNotes()
        @see setNotes(const XMLNode* notes)
        @see setNotes(const std::string& notes)
        @see appendNotes(const XMLNode* notes)
        @see appendNotes(const std::string& notes)
        @see unsetNotes()
        @see SyntaxChecker::hasExpectedXHTMLSyntax()
          

        """
        return _libsbml.SBase_getNotesString(self)

    def getAnnotation(self):
        """
        getAnnotation(self) -> XMLNode

        Returns the content of the 'annotation' subelement of this object as
        a tree of XMLNode objects.

        Whereas the SBML 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        The annotations returned by this method will be in XML form.  LibSBML
        provides an object model and related interfaces for certain specific
        kinds of annotations, namely model history information and RDF
        content.  See the ModelHistory, CVTerm and RDFAnnotationParser classes
        for more information about the facilities available.

        @return the annotation of this SBML object as a tree of XMLNode objects.

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation(const XMLNode* annotation)
        @see setAnnotation(const std::string& annotation)
        @see appendAnnotation(const XMLNode* annotation)
        @see appendAnnotation(const std::string& annotation)
        @see unsetAnnotation()
          

        """
        return _libsbml.SBase_getAnnotation(self)

    def getAnnotationString(self):
        """
        getAnnotationString(self) -> string

        Returns the content of the 'annotation' subelement of this object as a
        character string.

        Whereas the SBML 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        The annotations returned by this method will be in string form.

        @return the annotation of this SBML object as a character string.

        @see getAnnotation()
        @see isSetAnnotation()
        @see setAnnotation(const XMLNode* annotation)
        @see setAnnotation(const std::string& annotation)
        @see appendAnnotation(const XMLNode* annotation)
        @see appendAnnotation(const std::string& annotation)
        @see unsetAnnotation()
          

        """
        return _libsbml.SBase_getAnnotationString(self)

    def getNamespaces(self):
        """
        getNamespaces(self) -> XMLNamespaces

        Returns a list of the XML Namespaces declared on this SBML document.

        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and
        (in SBML Level&nbsp;3) packages used in addition to SBML Level&nbsp;3
        Core.

        @return the XML Namespaces associated with this SBML object

        @see getLevel()
        @see getVersion()
          

        """
        return _libsbml.SBase_getNamespaces(self)

    def getSBMLDocument(self, *args):
        """
        getSBMLDocument(self) -> SBMLDocument
        getSBMLDocument(self) -> SBMLDocument

        Returns the SBMLDocument object containing @em this object instance.

        LibSBML uses the class SBMLDocument as a top-level container for
        storing SBML content and data associated with it (such as warnings and
        error messages).  An SBML model in libSBML is contained inside an
        SBMLDocument object.  SBMLDocument corresponds roughly to the class
        <i>SBML</i> defined in the SBML Level&nbsp;3 and Level&nbsp;2
        specifications, but it does not have a direct correspondence in SBML
        Level&nbsp;1.  (But, it is created by libSBML no matter whether the
        model is Level&nbsp;1, Level&nbsp;2 or Level&nbsp;3.)

        This method allows the caller to obtain the SBMLDocument for the
        current object.

        @return the parent SBMLDocument object of this SBML object.

        @see getParentSBMLObject()
        @see getModel()
          

        """
        return _libsbml.SBase_getSBMLDocument(self, *args)

    def getParentSBMLObject(self):
        """
        getParentSBMLObject(self) -> SBase

        Returns the parent SBML object containing this object.

        This returns the immediately-containing object.  This method is
        convenient when holding an object nested inside other objects in an
        SBML model.  

        @return the parent SBML object of this SBML object.

        @see getSBMLDocument()
        @see getModel()
          

        """
        return _libsbml.SBase_getParentSBMLObject(self)

    def getAncestorOfType(self, *args):
        """
        getAncestorOfType(self, SBMLTypeCode_t type) -> SBase

        Returns the ancestor SBML object that corresponds to the given
        #SBMLTypeCode_t value.

        This function allows any object to determine its exact
        location/function within a model.  For example, in SBML Level&nbsp;2 a
        StoichiometryMath object has ancestors (in order) of type
        SpeciesReference, ListOfSpeciesReferences, Reaction, ListOfReactions
        and Model, any of which can be accessed via this function.

        @param type the #SBMLTypeCode_t of the ancestor being sought.

        @return the ancestor SBML object of this SBML object that corresponds
        to the given #SBMLTypeCode_t, or @c NULL if none exists.
          

        """
        return _libsbml.SBase_getAncestorOfType(self, *args)

    def getSBOTerm(self):
        """
        getSBOTerm(self) -> int

        Returns the integer portion of the value of the 'sboTerm' attribute of
        this object.

        Beginning with SBML Level 2 Version 3, objects derived from SBase have
        an optional attribute named 'sboTerm' for supporting the use of the
        Systems Biology Ontology.  In SBML proper, the data type of the
        attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a
        seven digit integer number; libSBML simplifies the representation by
        only storing the NNNNNNN integer portion.  Thus, in libSBML, the
        'sboTerm' attribute on SBase has data type @c int, and SBO identifiers
        are stored simply as integers.  (For convenience, libSBML offers
        methods for returning both the integer form and a text-string form of
        the SBO identifier.)

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @return the value of the 'sboTerm' attribute as an integer, or @c -1
        if the value is not set.
          

        """
        return _libsbml.SBase_getSBOTerm(self)

    def getSBOTermID(self):
        """
        getSBOTermID(self) -> string

        Returns the string representation of the 'sboTerm' attribute of
        this object.

        Beginning with SBML Level 2 Version 3, objects derived from SBase have
        an optional attribute named 'sboTerm' for supporting the use of the
        Systems Biology Ontology.  In SBML proper, the data type of the
        attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a
        seven digit integer number; libSBML simplifies the representation by
        only storing the NNNNNNN integer portion.  Thus, in libSBML, the
        'sboTerm' attribute on SBase has data type @c int, and SBO identifiers
        are stored simply as integers.  This method returns the entire SBO
        identifier as a text string in the form 'SBO:NNNNNNN'.

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @return the value of the 'sboTerm' attribute as a string (its value
        will be of the form <code>SBO:NNNNNNN</code>), or an empty string if
        the value is not set.
          

        """
        return _libsbml.SBase_getSBOTermID(self)

    def getLine(self):
        """
        getLine(self) -> unsigned int

        Returns the line number on which this object first appears in the XML
        representation of the SBML document.

        @return the line number of this SBML object.

        @see getColumn()

        @note The line number for each construct in an SBML model is set upon
        reading the model.  The accuracy of the line number depends on the
        correctness of the XML representation of the model, and on the
        particular XML parser library being used.  The former limitation
        relates to the following problem: if the model is actually invalid
        XML, then the parser may not be able to interpret the data correctly
        and consequently may not be able to establish the real line number.
        The latter limitation is simply that different parsers seem to have
        their own accuracy limitations, and out of all the parsers supported
        by libSBML, none have been 100% accurate in all situations. (At this
        time, libSBML supports the use of <a target='_blank'
        href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'
        href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'
        href='http://http://xerces.apache.org/xerces-c/'>Xerces</a>.)
          

        """
        return _libsbml.SBase_getLine(self)

    def getColumn(self):
        """
        getColumn(self) -> unsigned int

        Returns the column number on which this object first appears in the XML
        representation of the SBML document.

        @return the column number of this SBML object.

        @see getLine()

        @note The column number for each construct in an SBML model is set
        upon reading the model.  The accuracy of the column number depends on
        the correctness of the XML representation of the model, and on the
        particular XML parser library being used.  The former limitation
        relates to the following problem: if the model is actually invalid
        XML, then the parser may not be able to interpret the data correctly
        and consequently may not be able to establish the real column number.
        The latter limitation is simply that different parsers seem to have
        their own accuracy limitations, and out of all the parsers supported
        by libSBML, none have been 100% accurate in all situations. (At this
        time, libSBML supports the use of <a target='_blank'
        href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'
        href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'
        href='http://http://xerces.apache.org/xerces-c/'>Xerces</a>.)
          

        """
        return _libsbml.SBase_getColumn(self)

    def getModelHistory(self, *args):
        """
        getModelHistory(self) -> ModelHistory
        getModelHistory(self) -> ModelHistory

        Returns the ModelHistory object, if any, attached to this object.

        @return the ModelHistory object attached to this object, or @c NULL if
        none exist.

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.
          

        """
        return _libsbml.SBase_getModelHistory(self, *args)

    def isSetMetaId(self):
        """
        isSetMetaId(self) -> bool

        Predicate returning @c true if this
        object's 'metaid' attribute has been set.

        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF
        (Resource Description Format). The attribute value has the data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML
        identifier type, which means each 'metaid' value must be globally
        unique within an SBML file.  (Importantly, this uniqueness criterion
        applies across any attribute with type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the
        'metaid' attribute used by SBML&mdash;something to be aware of if your
        application-specific XML content inside the 'annotation' subelement
        happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)
        The 'metaid' value serves to identify a model component for purposes
        such as referencing that component from metadata placed within
        'annotation' subelements.

        @return @c true if the 'metaid' attribute of this SBML object has been
        set, @c false otherwise.

        @see getMetaId()
        @see setMetaId(const std::string& metaid)
          

        """
        return _libsbml.SBase_isSetMetaId(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        object's 'metaid' attribute has been set.

        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF
        (Resource Description Format). The attribute value has the data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML
        identifier type, which means each 'metaid' value must be globally
        unique within an SBML file.  (Importantly, this uniqueness criterion
        applies across any attribute with type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the
        'metaid' attribute used by SBML&mdash;something to be aware of if your
        application-specific XML content inside the 'annotation' subelement
        happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)
        The 'metaid' value serves to identify a model component for purposes
        such as referencing that component from metadata placed within
        'annotation' subelements.

        @return @c true if the 'metaid' attribute of this SBML object has been
        set, @c false otherwise.

        @see getMetaId()
        @see setMetaId(const std::string& metaid)
        @deprecated libSBML internal


        """
        return _libsbml.SBase_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        object's 'metaid' attribute has been set.

        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF
        (Resource Description Format). The attribute value has the data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML
        identifier type, which means each 'metaid' value must be globally
        unique within an SBML file.  (Importantly, this uniqueness criterion
        applies across any attribute with type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the
        'metaid' attribute used by SBML&mdash;something to be aware of if your
        application-specific XML content inside the 'annotation' subelement
        happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)
        The 'metaid' value serves to identify a model component for purposes
        such as referencing that component from metadata placed within
        'annotation' subelements.

        @return @c true if the 'metaid' attribute of this SBML object has been
        set, @c false otherwise.

        @see getMetaId()
        @see setMetaId(const std::string& metaid)
        @deprecated libSBML internal


        """
        return _libsbml.SBase_isSetName(self)

    def isSetNotes(self):
        """
        isSetNotes(self) -> bool

        Predicate returning @c true if this
        object's 'notes' subelement exists and has content.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @return @c true if a 'notes' subelement exists, @c false otherwise.

        @see getNotes()
        @see getNotesString()
        @see setNotes(const XMLNode* notes)
        @see setNotes(const std::string& notes)
        @see appendNotes(const XMLNode* notes)
        @see appendNotes(const std::string& notes)
        @see unsetNotes()
        @see SyntaxChecker::hasExpectedXHTMLSyntax()
          

        """
        return _libsbml.SBase_isSetNotes(self)

    def isSetAnnotation(self):
        """
        isSetAnnotation(self) -> bool

        Predicate returning @c true if this
        object's 'annotation' subelement exists and has content.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        @return @c true if a 'annotation' subelement exists, @c false
        otherwise.

        @see getAnnotation()
        @see getAnnotationString()
        @see setAnnotation(const XMLNode* annotation)
        @see setAnnotation(const std::string& annotation)
        @see appendAnnotation(const XMLNode* annotation)
        @see appendAnnotation(const std::string& annotation)
        @see unsetAnnotation()
          

        """
        return _libsbml.SBase_isSetAnnotation(self)

    def isSetSBOTerm(self):
        """
        isSetSBOTerm(self) -> bool

        Predicate returning @c true if this
        object's 'sboTerm' attribute has been set.

        @return @c true if the 'sboTerm' attribute of this SBML object has been
        set, @c false otherwise.
          

        """
        return _libsbml.SBase_isSetSBOTerm(self)

    def setMetaId(self, *args):
        """
        setMetaId(self, string metaid) -> int

        Sets the value of the 'metaid' attribute of this object.

        The string @p metaid is copied.  The value of @p metaid must be an
        identifier conforming to the syntax defined by the XML 1.0 data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>ID</a>.  Among other
        things, this type requires that a value is unique among all the values
        of type XML ID in an SBMLDocument.  Although SBML only uses <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a> for the 'metaid'
        attribute, callers should be careful if they use
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>'s in XML
        portions of a model that are not defined by SBML, such as in the
        application-specific content of the 'annotation' subelement.

        @param metaid the identifier string to use as the value of the
        'metaid' attribute

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @see getMetaId()
        @see isSetMetaId()
          

        """
        return _libsbml.SBase_setMetaId(self, *args)

    def isSetModelHistory(self):
        """
        isSetModelHistory(self) -> bool

        Predicate returning @c true if this
        object has a ModelHistory object attached to it.

        @return @c true if the ModelHistory of this object has been set, @c
        false otherwise.

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.
          

        """
        return _libsbml.SBase_isSetModelHistory(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Predicate returning @c true if this
        object has a ModelHistory object attached to it.

        @return @c true if the ModelHistory of this object has been set, @c
        false otherwise.

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.
        @deprecated libSBML internal


        """
        return _libsbml.SBase_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Predicate returning @c true if this
        object has a ModelHistory object attached to it.

        @return @c true if the ModelHistory of this object has been set, @c
        false otherwise.

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.
        @deprecated libSBML internal


        """
        return _libsbml.SBase_setName(self, *args)

    def setAnnotation(self, *args):
        """
        setAnnotation(self, XMLNode annotation) -> int
        setAnnotation(self, string annotation) -> int

        Sets the value of the 'annotation' subelement of this SBML object.

        The content of @p annotation is copied, and any previous content of
        this object's 'annotation' subelement is deleted.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        Call this method will result in any existing content of the
        'annotation' subelement to be discarded.  Unless you have taken steps
        to first copy and reconstitute any existing annotations into the @p
        annotation that is about to be assigned, it is likely that performing
        such wholesale replacement is unfriendly towards other software
        applications whose annotations are discarded.  An alternative may be
        to use SBase::appendAnnotation(const XMLNode* annotation) or
        SBase::appendAnnotation(const std::string& annotation).

        @param annotation an XML string that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation(const XMLNode* annotation)
        @see appendAnnotation(const XMLNode* annotation)
        @see appendAnnotation(const std::string& annotation)
        @see unsetAnnotation()
          

        """
        return _libsbml.SBase_setAnnotation(self, *args)

    def appendAnnotation(self, *args):
        """
        appendAnnotation(self, XMLNode annotation) -> int
        appendAnnotation(self, string annotation) -> int

        Appends the given @p annotation to the 'annotation' subelement of this
        object.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a
        target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type 'any'</a>,
        allowing essentially arbitrary well-formed XML data content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        Unlike SBase::setAnnotation(const XMLNode* annotation) or
        SBase::setAnnotation(const std::string& annotation), this method
        allows other annotations to be preserved when an application adds its
        own data.

        @param annotation an XML string that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation(const XMLNode* annotation)
        @see setAnnotation(const std::string& annotation)
        @see appendAnnotation(const XMLNode* annotation)
        @see unsetAnnotation()
          

        """
        return _libsbml.SBase_appendAnnotation(self, *args)

    def setNotes(self, *args):
        """
        setNotes(self, XMLNode notes) -> int
        setNotes(self, string notes) -> int

        Sets the value of the 'notes' subelement of this SBML object to a copy
        of the string @p notes.

        The content of @p notes is copied, and any existing content of this
        object's 'notes' subelement is deleted.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @param notes an XML string that is to be used as the content of the
        'notes' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes(const XMLNode* notes)
        @see appendNotes(const XMLNode* notes)
        @see appendNotes(const std::string& notes)
        @see unsetNotes()
        @see SyntaxChecker::hasExpectedXHTMLSyntax()
          

        """
        return _libsbml.SBase_setNotes(self, *args)

    def appendNotes(self, *args):
        """
        appendNotes(self, XMLNode notes) -> int
        appendNotes(self, string notes) -> int

        Appends the given @p notes to the 'notes' subelement of this object.

        The content of the parameter @p notes is copied.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @param notes an XML string that is to appended to the content of
        the 'notes' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes(const XMLNode* notes)
        @see setNotes(const std::string& notes)
        @see appendNotes(const XMLNode* notes)
        @see unsetNotes()
        @see SyntaxChecker::hasExpectedXHTMLSyntax()
          

        """
        return _libsbml.SBase_appendNotes(self, *args)

    def setModelHistory(self, *args):
        """
        setModelHistory(self, ModelHistory history) -> int

        Sets the ModelHistory of this object.

        The content of @p history is copied, and this object's existing model
        history content is deleted.

        @param history ModelHistory of this object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.
          

        """
        return _libsbml.SBase_setModelHistory(self, *args)

    def setSBOTerm(self, *args):
        """
        setSBOTerm(self, int value) -> int
        setSBOTerm(self, string sboid) -> int

        Sets the value of the 'sboTerm' attribute by string.

        Beginning with SBML Level 2 Version 3, objects derived from SBase have
        an optional attribute named 'sboTerm' for supporting the use of the
        Systems Biology Ontology.  In SBML proper, the data type of the
        attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a
        seven digit integer number; libSBML simplifies the representation by
        only storing the NNNNNNN integer portion.  Thus, in libSBML, the
        'sboTerm' attribute on SBase has data type @c int, and SBO identifiers
        are stored simply as integers.  This method lets you set the value of
        'sboTerm' as a complete string of the form 'SBO:NNNNNNN', whereas
        setSBOTerm(int value) allows you to set it using the integer form.

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @param sboid the SBO identifier string of the form SBO:NNNNNNN

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @see setSBOTerm(int value)
          

        """
        return _libsbml.SBase_setSBOTerm(self, *args)

    def setNamespaces(self, *args):
        """
        setNamespaces(self, XMLNamespaces xmlns) -> int

        Sets the namespaces relevant of this SBML object.

        The content of @p xmlns is copied, and this object's existing
        namespace content is deleted.

        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and
        (in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.

        @param xmlns the namespaces to set

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.SBase_setNamespaces(self, *args)

    def unsetMetaId(self):
        """
        unsetMetaId(self) -> int

        Unsets the value of the 'metaid' attribute of this SBML object.

        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF
        (Resource Description Format). The attribute value has the data type
        <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML
        identifier type, which means each 'metaid' value must be globally
        unique within an SBML file.  (Importantly, this uniqueness criterion
        applies across any attribute with type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the
        'metaid' attribute used by SBML&mdash;something to be aware of if your
        application-specific XML content inside the 'annotation' subelement
        happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)
        The 'metaid' value serves to identify a model component for purposes
        such as referencing that component from metadata placed within
        'annotation' subelements.
         
        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.SBase_unsetMetaId(self)

    def unsetNotes(self):
        """
        unsetNotes(self) -> int

        Unsets the value of the 'notes' subelement of this SBML object.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker::hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes(const XMLNode* notes)
        @see setNotes(const std::string& notes)
        @see appendNotes(const XMLNode* notes)
        @see appendNotes(const std::string& notes)
        @see SyntaxChecker::hasExpectedXHTMLSyntax()
          

        """
        return _libsbml.SBase_unsetNotes(self)

    def unsetAnnotation(self):
        """
        unsetAnnotation(self) -> int

        Unsets the value of the 'annotation' subelement of this SBML object.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see getAnnotation()
        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation(const XMLNode* annotation)
        @see setAnnotation(const std::string& annotation)
        @see appendAnnotation(const XMLNode* annotation)
        @see appendAnnotation(const std::string& annotation)
          

        """
        return _libsbml.SBase_unsetAnnotation(self)

    def unsetSBOTerm(self):
        """
        unsetSBOTerm(self) -> int

        Unsets the value of the 'sboTerm' attribute of this SBML object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.SBase_unsetSBOTerm(self)

    def addCVTerm(self, *args):
        """
        addCVTerm(self, CVTerm term, bool newBag = False) -> int
        addCVTerm(self, CVTerm term) -> int

        Adds a copy of the given CVTerm object to this SBML object.

        @param term the CVTerm to assign

        @param newBag if @c true, creates a new RDF bag with the same identifier
        as a previous bag, and if @c false, adds the term to an existing
        RDF bag with the same type of qualifier as the term being added.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink, if
        this object lacks a 'metaid' attribute
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink

        @note Since the CV Term uses the 'metaid' attribute of the object as a
        reference, if the object has no 'metaid' attribute value set, then the
        CVTerm will not be added.

        @warning The fact that this method @em copies the object passed to it
        means that the caller will be left holding a physically different
        object instance than the one contained in @em this object.  Changes
        made to the original object instance (such as resetting attribute
        values) will <em>not affect the instance added here</em>.  In
        addition, the caller should make sure to free the original object if
        it is no longer being used, or else a memory leak will result.
          

        """
        return _libsbml.SBase_addCVTerm(self, *args)

    def getCVTerms(self):
      """
      getCVTerms(self) -> CVTermList

      Get the CVTermList of CVTerm objects in this SBase.

      @return the CVTermList for this SBase.


      """
      return _libsbml.SBase_getCVTerms(self)


    def getNumCVTerms(self):
        """
        getNumCVTerms(self) -> unsigned int

        Returns the number of CVTerm objects in the annotations of this SBML
        object.

        @return the number of CVTerms for this SBML object.
          

        """
        return _libsbml.SBase_getNumCVTerms(self)

    def getCVTerm(self, *args):
        """
        getCVTerm(self, unsigned int n) -> CVTerm

        Returns the nth CVTerm in the list of CVTerms of this SBML
        object.

        @param n unsigned int the index of the CVTerm to retrieve

        @return the nth CVTerm in the list of CVTerms for this SBML object.
          

        """
        return _libsbml.SBase_getCVTerm(self, *args)

    def unsetCVTerms(self):
        """
        unsetCVTerms(self) -> int

        Clears the list of CVTerm objects attached to this SBML object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.SBase_unsetCVTerms(self)

    def unsetModelHistory(self):
        """
        unsetModelHistory(self) -> int

        Unsets the ModelHistory object attached to this object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.
          

        """
        return _libsbml.SBase_unsetModelHistory(self)

    def getResourceBiologicalQualifier(self, *args):
        """
        getResourceBiologicalQualifier(self, string resource) -> BiolQualifierType_t

        Returns the MIRIAM <em>biological qualifier</em> associated with the
        given resource.

        In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,
        qualifiers are an optional means of indicating the relationship
        between a model component and its annotations.  There are two broad
        kinds of annotations: <em>model</em> and <em>biological</em>.  The
        latter kind is used to qualify the relationship between a model
        component and a biological entity which it represents.  Examples of
        relationships include 'is' and 'has part', but many others are
        possible.  MIRIAM defines <a target='_blank'
        href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous
        relationship qualifiers</a> to enable different software tools to
        qualify biological annotations in the same standardized way.  In
        libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model
        element are represented using lists of CVTerm objects, and the
        enumeration #BiolQualifierType_t corresponds to the list of MIRIAM
        biological qualifiers.

        This method method searches the controlled-vocabulary annotations
        (i.e., the list of CVTerm objects) on the present object, then out of
        those that have biological qualifiers, looks for an annotation to the
        given @p resource.  If such an annotation is found, it returns the
        type of biological qualifier associated with that resource as a 
        value from  #BiolQualifierType_t.

        @param resource string representing the resource; e.g.,
        @c 'http://www.geneontology.org/#GO:0005892'

        @return the #BiolQualifierType_t value associated with the resource,
        or @link BiolQualifierType_t#BQB_UNKNOWN BQB_UNKNOWN@endlink if the
        resource does not exist.

        @note The set of MIRIAM biological qualifiers grows over time,
        although relatively slowly.  The values in the enumeration
        #BiolQualifierType_t are up to date with MIRIAM at the time of a given
        libSBML release.  The set of values may be expanded in later libSBML
        releases, to match the values defined by MIRIAM at that later time.
          

        """
        return _libsbml.SBase_getResourceBiologicalQualifier(self, *args)

    def getResourceModelQualifier(self, *args):
        """
        getResourceModelQualifier(self, string resource) -> ModelQualifierType_t

        Returns the MIRIAM <em>model qualifier</em> associated with the
        given resource.

        In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,
        qualifiers are an optional means of indicating the relationship
        between a model component and its annotations.  There are two broad
        kinds of annotations: <em>model</em> and <em>biological</em>.  The
        former kind is used to qualify the relationship between a model
        component and another modeling object.  An example qualifier is
        'isDerivedFrom', to indicate that a given component of the model is
        derived from the modeling object represented by the referenced
        resource.  MIRIAM defines <a target='_blank'
        href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous
        relationship qualifiers</a> to enable different software tools to
        qualify model annotations in the same standardized way.  In libSBML,
        the MIRIAM controlled-vocabulary annotations on an SBML model element
        are represented using lists of CVTerm objects, and the enumeration
        #ModelQualifierType_t corresponds to the list of MIRIAM model
        qualifiers.

        This method method searches the controlled-vocabulary annotations
        (i.e., the list of CVTerm objects) on the present object, then out of
        those that have model qualifiers, looks for an annotation to the given
        @p resource.  If such an annotation is found, it returns the type of
        model qualifier associated with that resource as a value from
        #ModelQualifierType_t.

        @param resource string representing the resource; e.g., @c
        'http://www.geneontology.org/#GO:0005892'

        @return the #ModelQualifierType_t value associated with the resource,
        or @link ModelQualifierType_t#BQM_UNKNOWN BQM_UNKNOWN@endlink if the
        resource does not exist.

        @note The set of MIRIAM model qualifiers grows over time,
        although relatively slowly.  The values in the enumeration
        #ModelQualifierType_t are up to date with MIRIAM at the time of a given
        libSBML release.  The set of values may be expanded in later libSBML
        releases, to match the values defined by MIRIAM at that later time.
          

        """
        return _libsbml.SBase_getResourceModelQualifier(self, *args)

    def getModel(self):
        """
        getModel(self) -> Model

        Returns the Model object in which the current object is located.

        @return the parent Model of this SBML object.

        @see getParentSBMLObject()
        @see getSBMLDocument()
          

        """
        return _libsbml.SBase_getModel(self)

    def getLevel(self):
        """
        getLevel(self) -> unsigned int

        Returns the SBML Level of the SBMLDocument object containing this
        object.

        @return the SBML level of this SBML object.

        @see getVersion()
        @see getNamespaces()
          

        """
        return _libsbml.SBase_getLevel(self)

    def getVersion(self):
        """
        getVersion(self) -> unsigned int

        Returns the Version within the SBML Level of the SBMLDocument object
        containing this object.

        @return the SBML version of this SBML object.

        @see getLevel()
        @see getNamespaces()
          

        """
        return _libsbml.SBase_getVersion(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this object.

        This method may return the type code of this SBML object, or it may
        return @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink.  This
        is because subclasses of SBase are not required to implement this
        method to return a type code.  This method is meant primarily for the
        LibSBML C interface, in which class and subclass information is not
        readily available.

        @return the #SBMLTypeCode_t value of this SBML object or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.SBase_getTypeCode(self)

    def hasValidLevelVersionNamespaceCombination(self):
        """
        hasValidLevelVersionNamespaceCombination(self) -> bool

        Predicate returning @c true if this
        object's level/version and namespace values correspond to a valid
        SBML specification.

        The valid combinations of SBML Level, Version and Namespace as of this
        release of libSBML are the following:
        <ul>
        <li> Level&nbsp;1 Version&nbsp;2: <code>'http://www.sbml.org/sbml/level1'</code>
        <li> Level&nbsp;2 Version&nbsp;1: <code>'http://www.sbml.org/sbml/level2'</code>
        <li> Level&nbsp;2 Version&nbsp;2: <code>'http://www.sbml.org/sbml/level2/version2'</code>
        <li> Level&nbsp;2 Version&nbsp;3: <code>'http://www.sbml.org/sbml/level2/version3'</code>
        <li> Level&nbsp;2 Version&nbsp;4: <code>'http://www.sbml.org/sbml/level2/version4'</code>
        <li> Level&nbsp;3 Version&nbsp;1 Core: <code>'http://www.sbml.org/sbml/level3/version1/core'</code>
        </ul>

        @return @c true if the level, version and namespace values of this 
        SBML object correspond to a valid set of values, @c false otherwise.
          

        """
        return _libsbml.SBase_hasValidLevelVersionNamespaceCombination(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        This is overridden by subclasses to return a string appropriate to the
        SBML component.  For example, Model defines it as returning @c
        'model', CompartmentType defines it as returning @c 'compartmentType',
        and so on.
          

        """
        return _libsbml.SBase_getElementName(self)

    def toSBML(self):
        """
        toSBML(self) -> char

        Returns a string consisting of a partial SBML corresponding to just
        this object.

        @return the partial SBML that describes this SBML object.

        @warning This is primarily provided for testing and debugging
        purposes.  It may be removed in a future version of libSBML.
          

        """
        return _libsbml.SBase_toSBML(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Subclasses should override this method to write out their contained
        SBML objects as XML elements.  Be sure to call your parents
        implementation of this method as well.  For example:

          SBase::writeElements(stream);
          mReactans.write(stream);
          mProducts.write(stream);
          ...
        @deprecated libSBML internal


        """
        return _libsbml.SBase_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Subclasses should override this method to write out their contained
        SBML objects as XML elements.  Be sure to call your parents
        implementation of this method as well.  For example:

          SBase::writeElements(stream);
          mReactans.write(stream);
          mProducts.write(stream);
          ...
        @deprecated libSBML internal


        """
        return _libsbml.SBase_hasRequiredElements(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBase_swigregister = _libsbml.SBase_swigregister
SBase_swigregister(SBase)

class ListOf(SBase):
    """
    Parent class for the various SBML 'ListOfXYZ' classes.

    @htmlinclude not-sbml-warning.html


    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOf, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOf, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ListOf
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> ListOf
        __init__(self, ListOf orig) -> ListOf

        Copy constructor.  Creates a copy of this ListOf.
          

        """
        this = _libsbml.new_ListOf(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBase

        Creates and returns a deep copy of this ListOf.

        @return a (deep) copy of this ListOf.
          

        """
        return _libsbml.ListOf_clone(self)

    def append(self, *args):
        """
        append(self, SBase item)

        Adds item to the end of this ListOf.

        This variant of the method makes a clone of the @p item handed to it.
        This means that when the ListOf is destroyed, the original items will
        not be destroyed.

        @param item the item to be added to the list.

        @see appendAndOwn(SBase* item)
          

        """
        return _libsbml.ListOf_append(self, *args)

    def appendAndOwn(self, *args):
        """
        appendAndOwn(self, SBase item)

        Adds item to the end of this ListOf.

        This variant of the method does not clone the @p item handed to it;
        instead, it assumes ownership of it.  This means that when the ListOf
        is destroyed, the item will be destroyed along with it.

        @param item the item to be added to the list.

        @see append(const SBase* item)
          

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ListOf_appendAndOwn(self, *args)

    def get(self, *args):
        """
        get(self, unsigned int n) -> SBase
        get(self, unsigned int n) -> SBase

        Get an item from the list based on its identifier.

        @param sid a string representing the the identifier of the item to get.

        @return item in this ListOf items with the given id or NULL if no such
        item exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOf_get(self, *args)

    def clear(self, doDelete = True):
        """
        clear(self, bool doDelete = True)
        clear(self)

        Removes all items in this ListOf object.

        If doDelete is true (default), all items in this ListOf object are deleted
        and cleared, and thus the caller doesn't have to delete those items.
        Otherwise, all items are just cleared from this ListOf object and the caller 
        is responsible for deleting all items (In this case, pointers to all items 
        should be stored elsewhere before calling this function by the caller).

        @param doDelete if true (default), all items are deleted and cleared.
        Otherwise, all items are just cleared and not deleted. 
           

        """
        return _libsbml.ListOf_clear(self, doDelete)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> SBase

        Removes item in this ListOf items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOf_remove(self, *args)

    def size(self):
        """
        size(self) -> unsigned int

        Get the size of this ListOf.

        @return the number of items in this ListOf items.
          

        """
        return _libsbml.ListOf_size(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this object, namely, @c
        SBML_LIST_OF.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOf_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Get the type code of the objects contained in this ListOf.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).
          

        """
        return _libsbml.ListOf_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for ListOf, is
        always @c 'listOf'.

        @return the XML name of this element.
          

        """
        return _libsbml.ListOf_getElementName(self)

    def __len__(self):
        """__len__(self) -> int"""
        return _libsbml.ListOf___len__(self)

    def __getitem__(self, key):

      try:
         keyIsSlice = isinstance(key, slice)
      except:
         keyIsSlice = 0

      if keyIsSlice:
        start = key.start
        if start is None:
          start = 0
        stop = key.stop
        if stop is None:
          stop = self.size()
        return [self[i] for i in range(
          self._fixNegativeIndex(start), self._fixNegativeIndex(stop)
        )]

      key = self._fixNegativeIndex(key)
      if key < 0 or key >= self.size():
        raise IndexError(key)
      return self.get(key)


    def _fixNegativeIndex(self, index):
      if index < 0:
        return index + self.size()
      else:
        return index


    def __iter__(self):
      for i in range(self.size()):
        yield self[i]


    def __repr__(self):
      return "[" + ", ".join([repr(self[i]) for i in range(len(self))]) + "]"


    def __str__(self):
      return repr(self)

ListOf_swigregister = _libsbml.ListOf_swigregister
ListOf_swigregister(ListOf)

class Model(SBase):
    """
    LibSBML implementation of %SBML's %Model construct.

    In an SBML model definition, a single object of class Model serves as
    the overall container for the lists of the various model components.
    All of the lists are optional, but if a given list container is present
    within the model, the list must not be empty; that is, it must have
    length one or more.  The following are the components and lists
    permitted in different Levels and Versions of SBML as of this version
    of libSBML (4.1):
    <ul>
    <li> In SBML Level 1, the components are: UnitDefinition, Compartment,
    Species, Parameter, Rule, and Reaction.  Instances of the classes are
    placed inside instances of classes ListOfUnitDefinitions,
    ListOfCompartments, ListOfSpecies, ListOfParameters, ListOfRules, and
    ListOfReactions.

    <li> In SBML Level 2 Version 1, the components are: FunctionDefinition,
    UnitDefinition, Compartment, Species, Parameter, Rule, Reaction and
    Event.  Instances of the classes are placed inside instances of classes
    ListOfFunctionDefinitions, ListOfUnitDefinitions, ListOfCompartments,
    ListOfSpecies, ListOfParameters, ListOfRules, ListOfReactions, and
    ListOfEvents.

    <li> In SBML Level 2 Versions 2, 3 and 4, the components are:
    FunctionDefinition, UnitDefinition, CompartmentType, SpeciesType,
    Compartment, Species, Parameter, InitialAssignment, Rule, Constraint,
    Reaction and Event.  Instances of the classes are placed inside
    instances of classes ListOfFunctionDefinitions, ListOfUnitDefinitions,
    ListOfCompartmentTypes, ListOfSpeciesTypes, ListOfCompartments,
    ListOfSpecies, ListOfParameters, ListOfInitialAssignments, ListOfRules,
    ListOfConstraints, ListOfReactions, and ListOfEvents.

    <li> In SBML Level 3 Version 1, the components are: FunctionDefinition,
    UnitDefinition, Compartment, Species, Parameter, InitialAssignment,
    Rule, Constraint, Reaction and Event.  Instances of the classes are
    placed inside instances of classes ListOfFunctionDefinitions,
    ListOfUnitDefinitions, ListOfCompartments, ListOfSpecies,
    ListOfParameters, ListOfInitialAssignments, ListOfRules,
    ListOfConstraints, ListOfReactions, and ListOfEvents.  
    </ul>

    Although all the lists are optional, there are dependencies between SBML
    components such that defining some components requires defining others.
    An example is that defining a species requires defining a compartment,
    and defining a reaction requires defining a species.  The dependencies
    are explained in more detail in the SBML specifications.

    In addition to the above lists and attributes, the Model class in both
    SBML Level&nbsp;2 and Level&nbsp;3 has the usual two attributes of 'id'
    and 'name', and both are optional.  As is the case for other SBML
    components with 'id' and 'name' attributes, they must be used according
    to the guidelines described in the SBML specifications.  (Within the
    frameworks of SBML Level&nbsp;2 and Level&nbsp;3 Version&nbsp;1 Core, a
    Model object identifier has no assigned meaning, but extension packages
    planned for SBML Level&nbsp;3 are likely to make use of this
    identifier.)

    Finally, SBML Level&nbsp;3 has introduced a number of additional Model
    attributes.  They are discussed in a separate section below.


    @section approaches Approaches to creating objects using the libSBML API

    LibSBML provides two main mechanisms for creating objects: class
    constructors (e.g., @if clike @link Species::Species() Species()
    @endlink @endif@if java <a
    href='org/sbml/libsbml/Species.html'>Species()</a> @endif), and
    <code>create<span class='placeholder'><em>Object</em></span>()</code>
    methods (such as Model::createSpecies()) provided by certain <span
    class='placeholder'><em>Object</em></span> classes such as Model.  These
    multiple mechanisms are provided by libSBML for flexibility and to
    support different use-cases, but they also have different implications
    for the overall model structure.

    In general, the recommended approach is to use the <code>create<span
    class='placeholder'><em>Object</em></span>()</code> methods.  These
    methods both create an object @em and link it to the parent in one step.
    Here is an example:
      @verbatim
     // Create an SBMLDocument object in Level 3 Version 1 format:

     SBMLDocument* sbmlDoc = new SBMLDocument(3, 1);

     // Create a Model object inside the SBMLDocument object and set
     // its identifier.  The call returns a pointer to the Model object
     // created, and methods called on that object affect the attributes
     // of the object attached to the model (as expected).

     Model* model = sbmlDoc->createModel();
     model->setId('MyModel');

     // Create a Species object inside the Model and set its identifier.
     // Similar to the lines above, this call returns a pointer to the Species
     // object created, and methods called on that object affect the attributes
     // of the object attached to the model (as expected).

     Species *sp = model->createSpecies();
     sp->setId('MySpecies');
     @endverbatim

    The <code>create<span
    class='placeholder'><em>Object</em></span>()</code> methods return a
    pointer to the object created, but they also add the object to the
    relevant list of object instances contained in the parent.  (These lists
    become the <code>&lt;listOf<i>Object</i>s&gt;</code> elements in the
    finished XML rendition of SBML.)  In the example above,
    Model::createSpecies() adds the created species directly to the
    <code>&lt;listOfSpecies&gt;</code> list in the model.  Subsequently,
    methods called on the species change the species in the model (which is
    what is expected in most situations).

    By contrast, the other main way of creating an object and adding it to a
    parent makes a @em copy of the object, and requires more care on the
    part of the caller.  Here is an example of this alternative approach:
      @verbatim
     // Create a Species object and add it to the model.
     // This uses the Species class constructor:

     Species *newsp = Species('MySpecies');
     model->addSpecies(newsp); // Warning! This makes a COPY inside 'model'.

     // addSpecies(...) copies the object, with the result that
     // 'newsp' still refers to the original.  The following may not
     // do what is expected:

     newsp.setId('NewId');    // Warning -- doesn't change the species in 'model'!

     // If 'newsp' object isn't going to be used further, it needs
     // to be deleted to avoid a memory leak.

     delete newsp;
     @endverbatim

    The key point of the example above is that, because the @if clike
    Model::addSpecies() @endif@if java Model::addSpecies(Species s) @endif
    call makes a copy of the object handed to it, care is needed both when
    attempting to make changes to the object, and when the original object
    is no longer needed.

    @section checking Consistency and adherence to SBML specifications

    To make it easier for applications to do whatever they need,
    libSBML&nbsp;4.x is relatively lax when it comes to enforcing
    correctness and completeness of models @em during model construction and
    editing.  Essentially, libSBML @em will @em not in most cases check
    automatically that a model's components have valid attribute values, or
    that the overall model is consistent and free of errors&mdash;even
    obvious errors such as duplication of identifiers.  This allows
    applications great leeway in how they build their models, but it means
    that software authors must take deliberate steps to ensure that the
    model will be, in the end, valid SBML.  These steps include such things
    as keeping track of the identifiers used in a model, manually performing
    updates in certain situations where an entity is referenced in more than
    one place (e.g., a species that is referenced by multiple
    SpeciesReference objects), and so on.

    That said, libSBML does provide powerful features for deliberately
    performing validation of SBML when an application decides it is time to
    do so.  The interfaces to these facilities are on the SBMLDocument
    class, in the form of SBMLDocument::checkInternalConsistency() and
    SBMLDocument::checkConsistency().  Please refer to the documentation for
    SBMLDocument for more information about this.

    While applications may play fast and loose and live like free spirits
    during the construction and editing of SBML models, they should always
    make sure to call SBMLDocument::checkInternalConsistency() and/or
    SBMLDocument::checkConsistency() before writing out the final version of
    an SBML model.


    @section model-l3-attrib Model attributes introduced in SBML Level&nbsp;3

    As mentioned above, the Model class has a number of optional attributes
    in SBML Level&nbsp;3 Version&nbsp;1 Core.  These are 'substanceUnits',
    'timeUnits', 'volumeUnits', 'areaUnits', 'lengthUnits', 'extentUnits',
    and 'conversionFactor.  The following provide more information about
    them.

    @subsection model-l3-substanceunits The 'substanceUnits' attribute

    The 'substanceUnits' attribute is used to specify the unit of
    measurement associated with substance quantities of Species objects that
    do not specify units explicitly.  If a given Species object definition
    does not specify its unit of substance quantity via the 'substanceUnits'
    attribute on the Species object instance, then that species inherits the
    value of the Model 'substanceUnits' attribute.  If the Model does not
    define a value for this attribute, then there is no unit to inherit, and
    all species that do not specify individual 'substanceUnits' attribute
    values then have <em>no</em> declared units for their quantities.  The
    SBML Level&nbsp;3 Version&nbsp;1 Core specification provides more
    details.

    Note that when the identifier of a species appears in a model's
    mathematical expressions, the unit of measurement associated with that
    identifier is <em>not solely determined</em> by setting 'substanceUnits'
    on Model or Species.  Please see the discussion about units given in
    the documentation for the Species class.


    @subsection model-l3-timeunits The 'timeUnits' attribute

    The 'timeUnits' attribute on SBML Level&nbsp;3's Model object is used to
    specify the unit in which time is measured in the model.  This attribute
    on Model is the <em>only</em> way to specify a unit for time in a model.
    It is a global attribute; time is measured in the model everywhere in
    the same way.  This is particularly relevant to Reaction and RateRule
    objects in a model: all Reaction and RateRule objects in SBML define
    per-time values, and the unit of time is given by the 'timeUnits'
    attribute on the Model object instance.  If the Model 'timeUnits'
    attribute has no value, it means that the unit of time is not defined
    for the model's reactions and rate rules.  Leaving it unspecified in an
    SBML model does not result in an invalid model in SBML Level&nbsp;3;
    however, as a matter of best practice, we strongly recommend that all
    models specify units of measurement for time.


    @subsection model-l3-voletc The 'volumeUnits', 'areaUnits', and 'lengthUnits' attributes

    The attributes 'volumeUnits', 'areaUnits' and 'lengthUnits' together are
    used to set the units of measurements for the sizes of Compartment
    objects in an SBML Level&nbsp;3 model when those objects do not
    otherwise specify units.  The three attributes correspond to the most
    common cases of compartment dimensions: 'volumeUnits' for compartments
    having a 'spatialDimensions' attribute value of @c '3', 'areaUnits' for
    compartments having a 'spatialDimensions' attribute value of @c '2', and
    'lengthUnits' for compartments having a 'spatialDimensions' attribute
    value of @c '1'.  The attributes are not applicable to compartments
    whose 'spatialDimensions' attribute values are @em not one of @c '1', @c
    '2' or @c '3'.

    If a given Compartment object instance does not provide a value for its
    'units' attribute, then the unit of measurement of that compartment's
    size is inherited from the value specified by the Model 'volumeUnits',
    'areaUnits' or 'lengthUnits' attribute, as appropriate based on the
    Compartment object's 'spatialDimensions' attribute value.  If the Model
    object does not define the relevant attribute, then there are no units
    to inherit, and all Compartment objects that do not set a value for
    their 'units' attribute then have <em>no</em> units associated with
    their compartment sizes.

    The use of three separate attributes is a carry-over from SBML
    Level&nbsp;2.  Note that it is entirely possible for a model to define a
    value for two or more of the attributes 'volumeUnits', 'areaUnits' and
    'lengthUnits' simultaneously, because SBML models may contain
    compartments with different numbers of dimensions.


    @subsection model-l3-extentunits The 'extentUnits' attribute

    Reactions are processes that occur over time.  These processes involve
    events of some sort, where a single ``reaction event'' is one in which
    some set of entities (known as reactants, products and modifiers in
    SBML) interact, once.  The <em>extent</em> of a reaction is a measure of
    how many times the reaction has occurred, while the time derivative of
    the extent gives the instantaneous rate at which the reaction is
    occurring.  Thus, what is colloquially referred to as the 'rate of the
    reaction' is in fact equal to the rate of change of reaction extent.

    In SBML Level&nbsp;3, the combination of 'extentUnits' and 'timeUnits'
    defines the units of kinetic laws in SBML and establishes how the
    numerical value of each KineticLaw object's mathematical formula is
    meant to be interpreted in a model.  The units of the kinetic laws are
    taken to be 'extentUnits' divided by 'timeUnits'.

    Note that this embodies an important principle in SBML Level&nbsp;3
    models: <em>all reactions in an SBML model must have the same units</em>
    for the rate of change of extent.  In other words, the units of all
    reaction rates in the model <em>must be the same</em>.  There is only
    one global value for 'extentUnits' and one global value for 'timeUnits'.


    @subsection model-l3-convfactor The 'conversionFactor' attribute

    The attribute 'conversionFactor' in SBML Level&nbsp;3's Model object
    defines a global value inherited by all Species object instances that do
    not define separate values for their 'conversionFactor' attributes.  The
    value of this attribute must refer to a Parameter object instance
    defined in the model.  The Parameter object in question must be a
    constant; ie it must have its 'constant' attribute value set to @c
    'true'.

    If a given Species object definition does not specify a conversion
    factor via the 'conversionFactor' attribute on Species, then the species
    inherits the conversion factor specified by the Model 'conversionFactor'
    attribute.  If the Model does not define a value for this attribute,
    then there is no conversion factor to inherit.  More information about
    conversion factors is provided in the SBML Level&nbsp;3 Version&nbsp;1
    specification.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Model
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Model
        __init__(self, SBMLNamespaces sbmlns) -> Model
        __init__(self, Model orig) -> Model

        Removes the Event object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the Event objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the Event object to remove

        @return the Event object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Event
        object with the identifier exists in this Model object.

        @deprecated libSBML internal


        """
        this = _libsbml.new_Model(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Model

        Creates and returns a deep copy of this Model object.

        @return a (deep) copy of this Model.
          

        """
        return _libsbml.Model_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Model.

        @return the id of this Model.
          

        """
        return _libsbml.Model_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Model.

        @return the name of this Model.
          

        """
        return _libsbml.Model_getName(self)

    def getSubstanceUnits(self):
        """
        getSubstanceUnits(self) -> string

        Returns the value of the 'substanceUnits' attribute of this Model.

        @return the substanceUnits of this Model.

        @note The 'substanceUnits' attribute is available in
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_getSubstanceUnits(self)

    def getTimeUnits(self):
        """
        getTimeUnits(self) -> string

        Returns the value of the 'timeUnits' attribute of this Model.

        @return the timeUnits of this Model.

        @note The 'timeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_getTimeUnits(self)

    def getVolumeUnits(self):
        """
        getVolumeUnits(self) -> string

        Returns the value of the 'volumeUnits' attribute of this Model.

        @return the volumeUnits of this Model.

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_getVolumeUnits(self)

    def getAreaUnits(self):
        """
        getAreaUnits(self) -> string

        Returns the value of the 'areaUnits' attribute of this Model.

        @return the areaUnits of this Model.

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_getAreaUnits(self)

    def getLengthUnits(self):
        """
        getLengthUnits(self) -> string

        Returns the value of the 'lengthUnits' attribute of this Model.

        @return the lengthUnits of this Model.

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_getLengthUnits(self)

    def getExtentUnits(self):
        """
        getExtentUnits(self) -> string

        Returns the value of the 'extentUnits' attribute of this Model.

        @return the extentUnits of this Model.

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_getExtentUnits(self)

    def getConversionFactor(self):
        """
        getConversionFactor(self) -> string

        Returns the value of the 'conversionFactor' attribute of this Model.

        @return the conversionFactor of this Model.

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_getConversionFactor(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        Model's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this Model has been
        set, @c false otherwise.
          

        """
        return _libsbml.Model_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        Model's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this Model has been
        set, @c false otherwise.
          

        """
        return _libsbml.Model_isSetName(self)

    def isSetSubstanceUnits(self):
        """
        isSetSubstanceUnits(self) -> bool

        Predicate returning @c true if this
        Model's 'substanceUnits' attribute has been set.

        @return @c true if the 'substanceUnits' attribute of this Model has been
        set, @c false otherwise.

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_isSetSubstanceUnits(self)

    def isSetTimeUnits(self):
        """
        isSetTimeUnits(self) -> bool

        Predicate returning @c true if this
        Model's 'timeUnits' attribute has been set.

        @return @c true if the 'timeUnits' attribute of this Model has been
        set, @c false otherwise.

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_isSetTimeUnits(self)

    def isSetVolumeUnits(self):
        """
        isSetVolumeUnits(self) -> bool

        Predicate returning @c true if this
        Model's 'volumeUnits' attribute has been set.

        @return @c true if the 'volumeUnits' attribute of this Model has been
        set, @c false otherwise.

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_isSetVolumeUnits(self)

    def isSetAreaUnits(self):
        """
        isSetAreaUnits(self) -> bool

        Predicate returning @c true if this
        Model's 'areaUnits' attribute has been set.

        @return @c true if the 'areaUnits' attribute of this Model has been
        set, @c false otherwise.

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_isSetAreaUnits(self)

    def isSetLengthUnits(self):
        """
        isSetLengthUnits(self) -> bool

        Predicate returning @c true if this
        Model's 'lengthUnits' attribute has been set.

        @return @c true if the 'lengthUnits' attribute of this Model has been
        set, @c false otherwise.

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_isSetLengthUnits(self)

    def isSetExtentUnits(self):
        """
        isSetExtentUnits(self) -> bool

        Predicate returning @c true if this
        Model's 'extentUnits' attribute has been set.

        @return @c true if the 'extentUnits' attribute of this Model has been
        set, @c false otherwise.

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_isSetExtentUnits(self)

    def isSetConversionFactor(self):
        """
        isSetConversionFactor(self) -> bool

        Predicate returning @c true if this
        Model's 'conversionFactor' attribute has been set.

        @return @c true if the 'conversionFactor' attribute of this Model has been
        set, @c false otherwise.

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_isSetConversionFactor(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Model.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Model_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Model.

        The string in @p name is copied.

        @param name the new name for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Model_setName(self, *args)

    def setSubstanceUnits(self, *args):
        """
        setSubstanceUnits(self, string units) -> int

        Sets the value of the 'substanceUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new substanceUnits for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_setSubstanceUnits(self, *args)

    def setTimeUnits(self, *args):
        """
        setTimeUnits(self, string units) -> int

        Sets the value of the 'timeUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new timeUnits for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'timeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_setTimeUnits(self, *args)

    def setVolumeUnits(self, *args):
        """
        setVolumeUnits(self, string units) -> int

        Sets the value of the 'volumeUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new volumeUnits for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_setVolumeUnits(self, *args)

    def setAreaUnits(self, *args):
        """
        setAreaUnits(self, string units) -> int

        Sets the value of the 'areaUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new areaUnits for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_setAreaUnits(self, *args)

    def setLengthUnits(self, *args):
        """
        setLengthUnits(self, string units) -> int

        Sets the value of the 'lengthUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new lengthUnits for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_setLengthUnits(self, *args)

    def setExtentUnits(self, *args):
        """
        setExtentUnits(self, string units) -> int

        Sets the value of the 'extentUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new extentUnits for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_setExtentUnits(self, *args)

    def setConversionFactor(self, *args):
        """
        setConversionFactor(self, string units) -> int

        Sets the value of the 'conversionFactor' attribute of this Model.

        The string in @p units is copied.

        @param units the new conversionFactor for the Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_setConversionFactor(self, *args)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the value of the 'id' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Model_unsetId(self)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Model_unsetName(self)

    def unsetSubstanceUnits(self):
        """
        unsetSubstanceUnits(self) -> int

        Unsets the value of the 'substanceUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_unsetSubstanceUnits(self)

    def unsetTimeUnits(self):
        """
        unsetTimeUnits(self) -> int

        Unsets the value of the 'timeUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'timeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_unsetTimeUnits(self)

    def unsetVolumeUnits(self):
        """
        unsetVolumeUnits(self) -> int

        Unsets the value of the 'volumeUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_unsetVolumeUnits(self)

    def unsetAreaUnits(self):
        """
        unsetAreaUnits(self) -> int

        Unsets the value of the 'areaUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_unsetAreaUnits(self)

    def unsetLengthUnits(self):
        """
        unsetLengthUnits(self) -> int

        Unsets the value of the 'lengthUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_unsetLengthUnits(self)

    def unsetExtentUnits(self):
        """
        unsetExtentUnits(self) -> int

        Unsets the value of the 'extentUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_unsetExtentUnits(self)

    def unsetConversionFactor(self):
        """
        unsetConversionFactor(self) -> int

        Unsets the value of the 'conversionFactor' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.
          

        """
        return _libsbml.Model_unsetConversionFactor(self)

    def addFunctionDefinition(self, *args):
        """
        addFunctionDefinition(self, FunctionDefinition fd) -> int

        Adds a copy of the given FunctionDefinition object to this Model.

        @param fd the FunctionDefinition to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createFunctionDefinition()
        for a method that does not lead to these issues.

        @see createFunctionDefinition()
          

        """
        return _libsbml.Model_addFunctionDefinition(self, *args)

    def addUnitDefinition(self, *args):
        """
        addUnitDefinition(self, UnitDefinition ud) -> int

        Adds a copy of the given UnitDefinition object to this Model.

        @param ud the UnitDefinition object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createUnitDefinition() for
        a method that does not lead to these issues.

        @see createUnitDefinition()
          

        """
        return _libsbml.Model_addUnitDefinition(self, *args)

    def addCompartmentType(self, *args):
        """
        addCompartmentType(self, CompartmentType ct) -> int

        Adds a copy of the given CompartmentType object to this Model.

        @param ct the CompartmentType object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createCompartmentType()
        for a method that does not lead to these issues.

        @see createCompartmentType()

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_addCompartmentType(self, *args)

    def addSpeciesType(self, *args):
        """
        addSpeciesType(self, SpeciesType st) -> int

        Adds a copy of the given SpeciesType object to this Model.

        @param st the SpeciesType object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createSpeciesType() for a
        method that does not lead to these issues.

        @see createSpeciesType()

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_addSpeciesType(self, *args)

    def addCompartment(self, *args):
        """
        addCompartment(self, Compartment c) -> int

        Adds a copy of the given Compartment object to this Model.

        @param c the Compartment object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createCompartment() for a
        method that does not lead to these issues.

        @see createCompartment()
          

        """
        return _libsbml.Model_addCompartment(self, *args)

    def addSpecies(self, *args):
        """
        addSpecies(self, Species s) -> int

        Adds a copy of the given Species object to this Model.

        @param s the Species object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createSpecies() for a
        method that does not lead to these issues.

        @see createSpecies()
          

        """
        return _libsbml.Model_addSpecies(self, *args)

    def addParameter(self, *args):
        """
        addParameter(self, Parameter p) -> int

        Adds a copy of the given Parameter object to this Model.

        @param p the Parameter object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createParameter() for a
        method that does not lead to these issues.

        @see createParameter()
          

        """
        return _libsbml.Model_addParameter(self, *args)

    def addInitialAssignment(self, *args):
        """
        addInitialAssignment(self, InitialAssignment ia) -> int

        Adds a copy of the given InitialAssignment object to this Model.

        @param ia the InitialAssignment object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createInitialAssignment()
        for a method that does not lead to these issues.

        @see createInitialAssignment()
          

        """
        return _libsbml.Model_addInitialAssignment(self, *args)

    def addRule(self, *args):
        """
        addRule(self, Rule r) -> int

        Adds a copy of the given Rule object to this Model.

        @param r the Rule object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see the methods
        Model::createAlgebraicRule(), Model::createAssignmentRule() and
        Model::createRateRule() for methods that do not lead to these issues.

        @see createAlgebraicRule()
        @see createAssignmentRule()
        @see createRateRule()
          

        """
        return _libsbml.Model_addRule(self, *args)

    def addConstraint(self, *args):
        """
        addConstraint(self, Constraint c) -> int

        Adds a copy of the given Constraint object to this Model.

        @param c the Constraint object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createConstraint() for a
        method that does not lead to these issues.

        @see createConstraint()
          

        """
        return _libsbml.Model_addConstraint(self, *args)

    def addReaction(self, *args):
        """
        addReaction(self, Reaction r) -> int

        Adds a copy of the given Reaction object to this Model.

        @param r the Reaction object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createReaction() for a
        method that does not lead to these issues.

        @see createReaction()
          

        """
        return _libsbml.Model_addReaction(self, *args)

    def addEvent(self, *args):
        """
        addEvent(self, Event e) -> int

        Adds a copy of the given Event object to this Model.

        @param e the Event object to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Model.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Model</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Model::createEvent() for a method
        that does not lead to these issues.

        @see createEvent()
          

        """
        return _libsbml.Model_addEvent(self, *args)

    def createFunctionDefinition(self):
        """
        createFunctionDefinition(self) -> FunctionDefinition

        Creates a new FunctionDefinition inside this Model and returns it.

        @return the FunctionDefinition object created

        @see addFunctionDefinition(const FunctionDefinition* fd)
          

        """
        return _libsbml.Model_createFunctionDefinition(self)

    def createUnitDefinition(self):
        """
        createUnitDefinition(self) -> UnitDefinition

        Creates a new UnitDefinition inside this Model and returns it.

        @return the UnitDefinition object created

        @see addUnitDefinition(const UnitDefinition* ud)
          

        """
        return _libsbml.Model_createUnitDefinition(self)

    def createUnit(self):
        """
        createUnit(self) -> Unit

        Creates a new Unit object within the last UnitDefinition object
        created in this model and returns a pointer to it.

        The mechanism by which the UnitDefinition was created is not
        significant.  If a UnitDefinition object does not exist in this model,
        a new Unit is @em not created and @c NULL is returned instead.

        @return the Unit object created

        @see addUnitDefinition(const UnitDefinition* ud)
          

        """
        return _libsbml.Model_createUnit(self)

    def createCompartmentType(self):
        """
        createCompartmentType(self) -> CompartmentType

        Creates a new CompartmentType inside this Model and returns it.

        @return the CompartmentType object created

        @see addCompartmentType(const CompartmentType* ct)

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_createCompartmentType(self)

    def createSpeciesType(self):
        """
        createSpeciesType(self) -> SpeciesType

        Creates a new SpeciesType inside this Model and returns it.

        @return the SpeciesType object created

        @see addSpeciesType(const SpeciesType* st)

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_createSpeciesType(self)

    def createCompartment(self):
        """
        createCompartment(self) -> Compartment

        Creates a new Compartment inside this Model and returns it.

        @return the Compartment object created

        @see addCompartment(const Compartment *c)
          

        """
        return _libsbml.Model_createCompartment(self)

    def createSpecies(self):
        """
        createSpecies(self) -> Species

        Creates a new Species inside this Model and returns it.

        @return the Species object created

        @see addSpecies(const Species *s)
          

        """
        return _libsbml.Model_createSpecies(self)

    def createParameter(self):
        """
        createParameter(self) -> Parameter

        Creates a new Parameter inside this Model and returns it.

        @return the Parameter object created

        @see addParameter(const Parameter *p)
          

        """
        return _libsbml.Model_createParameter(self)

    def createInitialAssignment(self):
        """
        createInitialAssignment(self) -> InitialAssignment

        Creates a new InitialAssignment inside this Model and returns it.

        @return the InitialAssignment object created

        @see addInitialAssignment(const InitialAssignment* ia)
          

        """
        return _libsbml.Model_createInitialAssignment(self)

    def createAlgebraicRule(self):
        """
        createAlgebraicRule(self) -> AlgebraicRule

        Creates a new AlgebraicRule inside this Model and returns it.

        @return the AlgebraicRule object created

        @see addRule(const Rule* r)
          

        """
        return _libsbml.Model_createAlgebraicRule(self)

    def createAssignmentRule(self):
        """
        createAssignmentRule(self) -> AssignmentRule

        Creates a new AssignmentRule inside this Model and returns it.

        @return the AssignmentRule object created

        @see addRule(const Rule* r)
          

        """
        return _libsbml.Model_createAssignmentRule(self)

    def createRateRule(self):
        """
        createRateRule(self) -> RateRule

        Creates a new RateRule inside this Model and returns it.

        @return the RateRule object created

        @see addRule(const Rule* r)
          

        """
        return _libsbml.Model_createRateRule(self)

    def createConstraint(self):
        """
        createConstraint(self) -> Constraint

        Creates a new Constraint inside this Model and returns it.

        @return the Constraint object created

        @see addConstraint(const Constraint *c)
          

        """
        return _libsbml.Model_createConstraint(self)

    def createReaction(self):
        """
        createReaction(self) -> Reaction

        Creates a new Reaction inside this Model and returns it.

        @return the Reaction object created

        @see addReaction(const Reaction *r)
          

        """
        return _libsbml.Model_createReaction(self)

    def createReactant(self):
        """
        createReactant(self) -> SpeciesReference

        Creates a new SpeciesReference object for a reactant inside the last
        Reaction object in this Model, and returns a pointer to it.

        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, a new SpeciesReference is @em not
        created and @c NULL is returned instead.

        @return the SpeciesReference object created
          

        """
        return _libsbml.Model_createReactant(self)

    def createProduct(self):
        """
        createProduct(self) -> SpeciesReference

        Creates a new SpeciesReference object for a product inside the last
        Reaction object in this Model, and returns a pointer to it.

        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, a new SpeciesReference is @em not
        created and @c NULL is returned instead.

        @return the SpeciesReference object created
          

        """
        return _libsbml.Model_createProduct(self)

    def createModifier(self):
        """
        createModifier(self) -> ModifierSpeciesReference

        Creates a new ModifierSpeciesReference object for a modifier species
        inside the last Reaction object in this Model, and returns a pointer
        to it.

        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, a new ModifierSpeciesReference is @em
        not created and @c NULL is returned instead.

        @return the SpeciesReference object created
          

        """
        return _libsbml.Model_createModifier(self)

    def createKineticLaw(self):
        """
        createKineticLaw(self) -> KineticLaw

        Creates a new KineticLaw inside the last Reaction object created in
        this Model, and returns a pointer to it.

        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, or a Reaction exists but already has a
        KineticLaw, a new KineticLaw is @em not created and @c NULL is returned
        instead.

        @return the KineticLaw object created
          

        """
        return _libsbml.Model_createKineticLaw(self)

    def createKineticLawParameter(self):
        """
        createKineticLawParameter(self) -> Parameter

        Creates a new local Parameter inside the KineticLaw object of the last
        Reaction created inside this Model, and returns a pointer to it.

        The last KineticLaw object in this Model could have been created in a
        variety of ways.  For example, it could have been added using
        createKineticLaw(), or it could be the result of using
        Reaction::createKineticLaw() on the Reaction object created by a
        createReaction().  If a Reaction does not exist for this model, or the
        last Reaction does not contain a KineticLaw object, a new Parameter is
        @em not created and @c NULL is returned instead.

        @return the Parameter object created
          

        """
        return _libsbml.Model_createKineticLawParameter(self)

    def createKineticLawLocalParameter(self):
        """
        createKineticLawLocalParameter(self) -> LocalParameter

        Creates a new LocalParameter inside the KineticLaw object of the last
        Reaction created inside this Model, and returns a pointer to it.

        The last KineticLaw object in this Model could have been created in a
        variety of ways.  For example, it could have been added using
        createKineticLaw(), or it could be the result of using
        Reaction::createKineticLaw() on the Reaction object created by a
        createReaction().  If a Reaction does not exist for this model, or the
        last Reaction does not contain a KineticLaw object, a new Parameter is
        @em not created and @c NULL is returned instead.

        @return the Parameter object created
          

        """
        return _libsbml.Model_createKineticLawLocalParameter(self)

    def createEvent(self):
        """
        createEvent(self) -> Event

        Creates a new Event inside this Model and returns it.

        @return the Event object created
          

        """
        return _libsbml.Model_createEvent(self)

    def createEventAssignment(self):
        """
        createEventAssignment(self) -> EventAssignment

        Creates a new EventAssignment inside the last Event object created in
        this Model, and returns a pointer to it.

        The mechanism by which the last Event object in this model was created
        is not significant.  It could have been created in a variety of ways,
        for example by using createEvent().  If no Event object exists in this
        Model object, a new EventAssignment is @em not created and @c NULL is
        returned instead.

        @return the EventAssignment object created
          

        """
        return _libsbml.Model_createEventAssignment(self)

    def createTrigger(self):
        """
        createTrigger(self) -> Trigger

        Creates a new Trigger inside the last Event object created in
        this Model, and returns a pointer to it.

        The mechanism by which the last Event object in this model was created
        is not significant.  It could have been created in a variety of ways,
        for example by using createEvent().  If no Event object exists in this
        Model object, a new Trigger is @em not created and @c NULL is
        returned instead.

        @return the Trigger object created
          

        """
        return _libsbml.Model_createTrigger(self)

    def createDelay(self):
        """
        createDelay(self) -> Delay

        Creates a new Delay inside the last Event object created in
        this Model, and returns a pointer to it.

        The mechanism by which the last Event object in this model was created
        is not significant.  It could have been created in a variety of ways,
        for example by using createEvent().  If no Event object exists in this
        Model object, a new Delay is @em not created and @c NULL is
        returned instead.

        @return the Delay object created
          

        """
        return _libsbml.Model_createDelay(self)

    def setAnnotation(self, *args):
        """
        setAnnotation(self, XMLNode annotation) -> int
        setAnnotation(self, string annotation) -> int

        Sets the value of the 'annotation' subelement of this SBML object to a
        copy of @p annotation.

        Any existing content of the 'annotation' subelement is discarded.
        Unless you have taken steps to first copy and reconstitute any
        existing annotations into the @p annotation that is about to be
        assigned, it is likely that performing such wholesale replacement is
        unfriendly towards other software applications whose annotations are
        discarded.  An alternative may be to use appendAnnotation().

        @param annotation an XML string that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see appendAnnotation(const std::string& annotation)
          

        """
        return _libsbml.Model_setAnnotation(self, *args)

    def appendAnnotation(self, *args):
        """
        appendAnnotation(self, XMLNode annotation) -> int
        appendAnnotation(self, string annotation) -> int

        Appends annotation content to any existing content in the 'annotation'
        subelement of this object.

        The content in @p annotation is copied.  Unlike setAnnotation(), this 
        method allows other annotations to be preserved when an application
        adds its own data.

        @param annotation an XML string that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see setAnnotation(const std::string& annotation)
          

        """
        return _libsbml.Model_appendAnnotation(self, *args)

    def getListOfFunctionDefinitions(self, *args):
        """
        getListOfFunctionDefinitions(self) -> ListOfFunctionDefinitions
        getListOfFunctionDefinitions(self) -> ListOfFunctionDefinitions

        Get the ListOfFunctionDefinitions object in this Model.

        @return the list of FunctionDefinitions for this Model.
          

        """
        return _libsbml.Model_getListOfFunctionDefinitions(self, *args)

    def getListOfUnitDefinitions(self, *args):
        """
        getListOfUnitDefinitions(self) -> ListOfUnitDefinitions
        getListOfUnitDefinitions(self) -> ListOfUnitDefinitions

        Get the ListOfUnitDefinitions object in this Model.

        @return the list of UnitDefinitions for this Model.
          

        """
        return _libsbml.Model_getListOfUnitDefinitions(self, *args)

    def getListOfCompartmentTypes(self, *args):
        """
        getListOfCompartmentTypes(self) -> ListOfCompartmentTypes
        getListOfCompartmentTypes(self) -> ListOfCompartmentTypes

        Get the ListOfCompartmentTypes object in this Model.

        @return the list of CompartmentTypes for this Model.

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_getListOfCompartmentTypes(self, *args)

    def getListOfSpeciesTypes(self, *args):
        """
        getListOfSpeciesTypes(self) -> ListOfSpeciesTypes
        getListOfSpeciesTypes(self) -> ListOfSpeciesTypes

        Get the ListOfSpeciesTypes object in this Model.

        @return the list of SpeciesTypes for this Model.

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_getListOfSpeciesTypes(self, *args)

    def getListOfCompartments(self, *args):
        """
        getListOfCompartments(self) -> ListOfCompartments
        getListOfCompartments(self) -> ListOfCompartments

        Get the ListOfCompartments object in this Model.

        @return the list of Compartments for this Model.
          

        """
        return _libsbml.Model_getListOfCompartments(self, *args)

    def getListOfSpecies(self, *args):
        """
        getListOfSpecies(self) -> ListOfSpecies
        getListOfSpecies(self) -> ListOfSpecies

        Get the ListOfSpecies object in this Model.

        @return the list of Species for this Model.
          

        """
        return _libsbml.Model_getListOfSpecies(self, *args)

    def getListOfParameters(self, *args):
        """
        getListOfParameters(self) -> ListOfParameters
        getListOfParameters(self) -> ListOfParameters

        Get the ListOfParameters object in this Model.

        @return the list of Parameters for this Model.
          

        """
        return _libsbml.Model_getListOfParameters(self, *args)

    def getListOfInitialAssignments(self, *args):
        """
        getListOfInitialAssignments(self) -> ListOfInitialAssignments
        getListOfInitialAssignments(self) -> ListOfInitialAssignments

        Get the ListOfInitialAssignments object in this Model.

        @return the list of InitialAssignment for this Model.
          

        """
        return _libsbml.Model_getListOfInitialAssignments(self, *args)

    def getListOfRules(self, *args):
        """
        getListOfRules(self) -> ListOfRules
        getListOfRules(self) -> ListOfRules

        Get the ListOfRules object in this Model.

        @return the list of Rules for this Model.
          

        """
        return _libsbml.Model_getListOfRules(self, *args)

    def getListOfConstraints(self, *args):
        """
        getListOfConstraints(self) -> ListOfConstraints
        getListOfConstraints(self) -> ListOfConstraints

        Get the ListOfConstraints object in this Model.

        @return the list of Constraints for this Model.
          

        """
        return _libsbml.Model_getListOfConstraints(self, *args)

    def getListOfReactions(self, *args):
        """
        getListOfReactions(self) -> ListOfReactions
        getListOfReactions(self) -> ListOfReactions

        Get the ListOfReactions object in this Model.

        @return the list of Reactions for this Model.
          

        """
        return _libsbml.Model_getListOfReactions(self, *args)

    def getListOfEvents(self, *args):
        """
        getListOfEvents(self) -> ListOfEvents
        getListOfEvents(self) -> ListOfEvents

        Get the ListOfEvents object in this Model.

        @return the list of Events for this Model.
          

        """
        return _libsbml.Model_getListOfEvents(self, *args)

    def getFunctionDefinition(self, *args):
        """
        getFunctionDefinition(self, unsigned int n) -> FunctionDefinition
        getFunctionDefinition(self, unsigned int n) -> FunctionDefinition
        getFunctionDefinition(self, string sid) -> FunctionDefinition
        getFunctionDefinition(self, string sid) -> FunctionDefinition

        Get a FunctionDefinition object based on its identifier.

        @return the FunctionDefinition in this Model with the identifier
        @p sid or @c NULL if no such FunctionDefinition exists.
          

        """
        return _libsbml.Model_getFunctionDefinition(self, *args)

    def getUnitDefinition(self, *args):
        """
        getUnitDefinition(self, unsigned int n) -> UnitDefinition
        getUnitDefinition(self, unsigned int n) -> UnitDefinition
        getUnitDefinition(self, string sid) -> UnitDefinition
        getUnitDefinition(self, string sid) -> UnitDefinition

        Get a UnitDefinition based on its identifier.

        @return the UnitDefinition in this Model with the identifier @p sid or
        @c NULL if no such UnitDefinition exists.
          

        """
        return _libsbml.Model_getUnitDefinition(self, *args)

    def getCompartmentType(self, *args):
        """
        getCompartmentType(self, unsigned int n) -> CompartmentType
        getCompartmentType(self, unsigned int n) -> CompartmentType
        getCompartmentType(self, string sid) -> CompartmentType
        getCompartmentType(self, string sid) -> CompartmentType

        Get a CompartmentType object based on its identifier.

        @return the CompartmentType in this Model with the identifier @p sid
        or @c NULL if no such CompartmentType exists.

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_getCompartmentType(self, *args)

    def getSpeciesType(self, *args):
        """
        getSpeciesType(self, unsigned int n) -> SpeciesType
        getSpeciesType(self, unsigned int n) -> SpeciesType
        getSpeciesType(self, string sid) -> SpeciesType
        getSpeciesType(self, string sid) -> SpeciesType

        Get a SpeciesType object based on its identifier.

        @return the SpeciesType in this Model with the identifier @p sid or
        @c NULL if no such SpeciesType exists.

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_getSpeciesType(self, *args)

    def getCompartment(self, *args):
        """
        getCompartment(self, unsigned int n) -> Compartment
        getCompartment(self, unsigned int n) -> Compartment
        getCompartment(self, string sid) -> Compartment
        getCompartment(self, string sid) -> Compartment

        Get a Compartment object based on its identifier.

        @return the Compartment in this Model with the identifier @p sid or
        @c NULL if no such Compartment exists.
          

        """
        return _libsbml.Model_getCompartment(self, *args)

    def getSpecies(self, *args):
        """
        getSpecies(self, unsigned int n) -> Species
        getSpecies(self, unsigned int n) -> Species
        getSpecies(self, string sid) -> Species
        getSpecies(self, string sid) -> Species

        Get a Species object based on its identifier.

        @return the Species in this Model with the identifier @p sid or @c NULL
        if no such Species exists.
          

        """
        return _libsbml.Model_getSpecies(self, *args)

    def getParameter(self, *args):
        """
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, string sid) -> Parameter
        getParameter(self, string sid) -> Parameter

        Get a Parameter object based on its identifier.

        @return the Parameter in this Model with the identifier @p sid or @c NULL
        if no such Parameter exists.
          

        """
        return _libsbml.Model_getParameter(self, *args)

    def getInitialAssignment(self, *args):
        """
        getInitialAssignment(self, unsigned int n) -> InitialAssignment
        getInitialAssignment(self, unsigned int n) -> InitialAssignment
        getInitialAssignment(self, string symbol) -> InitialAssignment
        getInitialAssignment(self, string symbol) -> InitialAssignment

        Get an InitialAssignment object based on the symbol to which it
        assigns a value.

        @return the InitialAssignment in this Model with the given 'symbol'
        attribute value or @c NULL if no such InitialAssignment exists.
          

        """
        return _libsbml.Model_getInitialAssignment(self, *args)

    def getRule(self, *args):
        """
        getRule(self, unsigned int n) -> Rule
        getRule(self, unsigned int n) -> Rule
        getRule(self, string variable) -> Rule
        getRule(self, string variable) -> Rule

        Get a Rule object based on the variable to which it assigns a value.

        @return the Rule in this Model with the given 'variable' attribute
        value or @c NULL if no such Rule exists.
          

        """
        return _libsbml.Model_getRule(self, *args)

    def getConstraint(self, *args):
        """
        getConstraint(self, unsigned int n) -> Constraint
        getConstraint(self, unsigned int n) -> Constraint

        Get the nth Constraint object in this Model.

        @return the nth Constraint of this Model.
          

        """
        return _libsbml.Model_getConstraint(self, *args)

    def getReaction(self, *args):
        """
        getReaction(self, unsigned int n) -> Reaction
        getReaction(self, unsigned int n) -> Reaction
        getReaction(self, string sid) -> Reaction
        getReaction(self, string sid) -> Reaction

        Get a Reaction object based on its identifier.

        @return the Reaction in this Model with the identifier @p sid or @c NULL
        if no such Reaction exists.
          

        """
        return _libsbml.Model_getReaction(self, *args)

    def getSpeciesReference(self, *args):
        """
        getSpeciesReference(self, string sid) -> SpeciesReference
        getSpeciesReference(self, string sid) -> SpeciesReference

        Get a SpeciesReference object based on its identifier.

        @return the SpeciesReference in this Model with the identifier @p sid or @c NULL
        if no such SpeciesReference exists.
          

        """
        return _libsbml.Model_getSpeciesReference(self, *args)

    def getEvent(self, *args):
        """
        getEvent(self, unsigned int n) -> Event
        getEvent(self, unsigned int n) -> Event
        getEvent(self, string sid) -> Event
        getEvent(self, string sid) -> Event

        Get an Event object based on its identifier.

        @return the Event in this Model with the identifier @p sid or @c NULL if
        no such Event exists.
          

        """
        return _libsbml.Model_getEvent(self, *args)

    def getNumFunctionDefinitions(self):
        """
        getNumFunctionDefinitions(self) -> unsigned int

        Get the number of FunctionDefinition objects in this Model.

        @return the number of FunctionDefinitions in this Model.
          

        """
        return _libsbml.Model_getNumFunctionDefinitions(self)

    def getNumUnitDefinitions(self):
        """
        getNumUnitDefinitions(self) -> unsigned int

        Get the number of UnitDefinition objects in this Model.

        @return the number of UnitDefinitions in this Model.
          

        """
        return _libsbml.Model_getNumUnitDefinitions(self)

    def getNumCompartmentTypes(self):
        """
        getNumCompartmentTypes(self) -> unsigned int

        Get the number of CompartmentType objects in this Model.

        @return the number of CompartmentTypes in this Model.

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_getNumCompartmentTypes(self)

    def getNumSpeciesTypes(self):
        """
        getNumSpeciesTypes(self) -> unsigned int

        Get the number of SpeciesType objects in this Model.

        @return the number of SpeciesTypes in this Model.

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
          

        """
        return _libsbml.Model_getNumSpeciesTypes(self)

    def getNumCompartments(self):
        """
        getNumCompartments(self) -> unsigned int

        Get the number of Compartment objects in this Model.

        @return the number of Compartments in this Model.
          

        """
        return _libsbml.Model_getNumCompartments(self)

    def getNumSpecies(self):
        """
        getNumSpecies(self) -> unsigned int

        Get the number of Specie objects in this Model.

        @return the number of Species in this Model.
          

        """
        return _libsbml.Model_getNumSpecies(self)

    def getNumSpeciesWithBoundaryCondition(self):
        """
        getNumSpeciesWithBoundaryCondition(self) -> unsigned int

        Get the number of Species in this Model having their
        'boundaryCondition' attribute value set to @c true.

        @return the number of Species in this Model with boundaryCondition set
        to true.
          

        """
        return _libsbml.Model_getNumSpeciesWithBoundaryCondition(self)

    def getNumParameters(self):
        """
        getNumParameters(self) -> unsigned int

        Get the number of Parameter objects in this Model.

        @return the number of Parameters in this Model.  Parameters defined in
        KineticLaws are not included.
          

        """
        return _libsbml.Model_getNumParameters(self)

    def getNumInitialAssignments(self):
        """
        getNumInitialAssignments(self) -> unsigned int

        Get the number of InitialAssignment objects in this Model.

        @return the number of InitialAssignments in this Model.
          

        """
        return _libsbml.Model_getNumInitialAssignments(self)

    def getNumRules(self):
        """
        getNumRules(self) -> unsigned int

        Get the number of Rule objects in this Model.

        @return the number of Rules in this Model.
          

        """
        return _libsbml.Model_getNumRules(self)

    def getNumConstraints(self):
        """
        getNumConstraints(self) -> unsigned int

        Get the number of Constraint objects in this Model.

        @return the number of Constraints in this Model.
          

        """
        return _libsbml.Model_getNumConstraints(self)

    def getNumReactions(self):
        """
        getNumReactions(self) -> unsigned int

        Get the number of Reaction objects in this Model.

        @return the number of Reactions in this Model.
          

        """
        return _libsbml.Model_getNumReactions(self)

    def getNumEvents(self):
        """
        getNumEvents(self) -> unsigned int

        Get the number of Event objects in this Model.

        @return the number of Events in this Model.
          

        """
        return _libsbml.Model_getNumEvents(self)

    def convertL1ToL2(self):
        """
        convertL1ToL2(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_convertL1ToL2(self)

    def convertL1ToL3(self):
        """
        convertL1ToL3(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_convertL1ToL3(self)

    def convertL2ToL3(self):
        """
        convertL2ToL3(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_convertL2ToL3(self)

    def convertL2ToL1(self, strict = False):
        """
        convertL2ToL1(self, bool strict = False)
        convertL2ToL1(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_convertL2ToL1(self, strict)

    def addModifiers(self):
        """
        addModifiers(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_addModifiers(self)

    def addConstantAttribute(self):
        """
        addConstantAttribute(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_addConstantAttribute(self)

    def setSpatialDimensions(self, dims = 3.0):
        """
        setSpatialDimensions(self, double dims = 3.0)
        setSpatialDimensions(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_setSpatialDimensions(self, dims)

    def addDefinitionsForDefaultUnits(self):
        """
        addDefinitionsForDefaultUnits(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_addDefinitionsForDefaultUnits(self)

    def convertParametersToLocals(self):
        """
        convertParametersToLocals(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_convertParametersToLocals(self)

    def setSpeciesReferenceConstantValue(self):
        """
        setSpeciesReferenceConstantValue(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_setSpeciesReferenceConstantValue(self)

    def removeParameterRuleUnits(self):
        """
        removeParameterRuleUnits(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_removeParameterRuleUnits(self)

    def convertStoichiometryMath(self):
        """
        convertStoichiometryMath(self)

        Predicate returning @c true if the
        given ASTNode is a boolean.

        Often times, this question can be answered with the ASTNode's own
        isBoolean() method, but if the AST is an expression that calls a
        function defined in the Model's ListOfFunctionDefinitions, the model
        is needed for lookup context.

        @return true if the given ASTNode is a boolean.
        @deprecated libSBML internal


        """
        return _libsbml.Model_convertStoichiometryMath(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Model_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Model, is
        always @c 'model'.

        @return the name of this element, i.e., @c 'model'.
          

        """
        return _libsbml.Model_getElementName(self)

    def populateListFormulaUnitsData(self):
        """
        populateListFormulaUnitsData(self)

        Populates the list of FormulaDataUnits with the units derived 
        for the model. The list contains elements of class
        FormulaUnitsData. 

        The first element of the list refers to the default units
        of 'substance per time' derived from the model and has the
        unitReferenceId 'subs_per_time'. This facilitates the comparison of units
        derived from mathematical formula with the expected units.

        The next elements of the list record the units of the 
        compartments and species established from either explicitly
        declared or default units.

        The next elements record the units of any parameters.

        Subsequent elements of the list record the units derived for
        each mathematical expression encountered within the model.

        @note This function is utilised by the Unit Consistency Validator.
        The list is populated prior to running the validation and thus
        the consistency of units can be checked by accessing the members
        of the list and comparing the appropriate data.
          

        """
        return _libsbml.Model_populateListFormulaUnitsData(self)

    def isPopulatedListFormulaUnitsData(self):
        """
        isPopulatedListFormulaUnitsData(self) -> bool

        Predicate returning @c true if 
        the list of FormulaUnitsData has been populated.

        @return @c true if the list of FormulaUnitsData has been populated, 
        @c false otherwise.
          

        """
        return _libsbml.Model_isPopulatedListFormulaUnitsData(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this Model object
        have been set.

        @note The required elements for a Model object are:
        listOfCompartments (L1 only); listOfSpecies (L1V1 only);
        listOfReactions(L1V1 only)

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.Model_hasRequiredElements(self)

    def removeFunctionDefinition(self, *args):
        """
        removeFunctionDefinition(self, unsigned int n) -> FunctionDefinition
        removeFunctionDefinition(self, string sid) -> FunctionDefinition

        Removes the FunctionDefinition object with the given identifier from this Model 
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the FunctionDefinition objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the FunctionDefinition object to remove

        @return the FunctionDefinition object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no FunctionDefinition
        object with the identifier exists in this Model object.
          

        """
        return _libsbml.Model_removeFunctionDefinition(self, *args)

    def removeUnitDefinition(self, *args):
        """
        removeUnitDefinition(self, unsigned int n) -> UnitDefinition
        removeUnitDefinition(self, string sid) -> UnitDefinition

        Removes the UnitDefinition object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the UnitDefinition objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the UnitDefinition object to remove

        @return the UnitDefinition object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no UnitDefinition
        object with the identifier exists in this Model object.
          

        """
        return _libsbml.Model_removeUnitDefinition(self, *args)

    def removeCompartmentType(self, *args):
        """
        removeCompartmentType(self, unsigned int n) -> CompartmentType
        removeCompartmentType(self, string sid) -> CompartmentType

        Removes the CompartmentType object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the CompartmentType objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the object to remove

        @return the CompartmentType object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no CompartmentType
        object with the identifier exists in this Model object.
          

        """
        return _libsbml.Model_removeCompartmentType(self, *args)

    def removeSpeciesType(self, *args):
        """
        removeSpeciesType(self, unsigned int n) -> SpeciesType
        removeSpeciesType(self, string sid) -> SpeciesType

        Removes the SpeciesType object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the SpeciesType objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the SpeciesType object to remove

        @return the SpeciesType object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no SpeciesType
        object with the identifier exists in this Model object.

          

        """
        return _libsbml.Model_removeSpeciesType(self, *args)

    def removeCompartment(self, *args):
        """
        removeCompartment(self, unsigned int n) -> Compartment
        removeCompartment(self, string sid) -> Compartment

        Removes the Compartment object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the Compartment objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the Compartment object to remove

        @return the Compartment object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Compartment
        object with the identifier exists in this Model object.
          

        """
        return _libsbml.Model_removeCompartment(self, *args)

    def removeSpecies(self, *args):
        """
        removeSpecies(self, unsigned int n) -> Species
        removeSpecies(self, string sid) -> Species

        Removes the Species object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the Species objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the Species object to remove

        @return the Species object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Species
        object with the identifier exists in this Model object.

          

        """
        return _libsbml.Model_removeSpecies(self, *args)

    def removeParameter(self, *args):
        """
        removeParameter(self, unsigned int n) -> Parameter
        removeParameter(self, string sid) -> Parameter

        Removes the Parameter object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the Parameter objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the Parameter object to remove

        @return the Parameter object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Parameter
        object with the identifier exists in this Model object.
          

        """
        return _libsbml.Model_removeParameter(self, *args)

    def removeInitialAssignment(self, *args):
        """
        removeInitialAssignment(self, unsigned int n) -> InitialAssignment
        removeInitialAssignment(self, string symbol) -> InitialAssignment

        Removes the InitialAssignment object with the given 'symbol' attribute 
        from this Model object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the InitialAssignment objects in this Model object have the
        'symbol' attribute @p symbol, then @c NULL is returned.

        @param symbol the 'symbol' attribute of the InitialAssignment object to remove

        @return the InitialAssignment object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no InitialAssignment
        object with the 'symbol' attribute exists in this Model object.
          

        """
        return _libsbml.Model_removeInitialAssignment(self, *args)

    def removeRule(self, *args):
        """
        removeRule(self, unsigned int n) -> Rule
        removeRule(self, string variable) -> Rule

        Removes the Rule object with the given 'variable' attribute from this Model 
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the Rule objects in this Model object have the 'variable' attribute
        @p variable, then @c NULL is returned.

        @param variable the 'variable' attribute of the Rule object to remove

        @return the Rule object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Rule
        object with the 'variable' attribute exists in this Model object.
          

        """
        return _libsbml.Model_removeRule(self, *args)

    def removeConstraint(self, *args):
        """
        removeConstraint(self, unsigned int n) -> Constraint

        Removes the nth Constraint object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Constraint object to remove

        @return the Constraint object removed.  As mentioned above, 
        the caller owns the returned item. @c NULL is returned if the given index 
        is out of range.

          

        """
        return _libsbml.Model_removeConstraint(self, *args)

    def removeReaction(self, *args):
        """
        removeReaction(self, unsigned int n) -> Reaction
        removeReaction(self, string sid) -> Reaction

        Removes the Reaction object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the Reaction objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the Reaction object to remove

        @return the Reaction object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Reaction
        object with the identifier exists in this Model object.

          

        """
        return _libsbml.Model_removeReaction(self, *args)

    def removeEvent(self, *args):
        """
        removeEvent(self, unsigned int n) -> Event
        removeEvent(self, string sid) -> Event

        Removes the Event object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the Event objects in this Model object have the identifier 
        @p sid, then @c NULL is returned.

        @param sid the identifier of the Event object to remove

        @return the Event object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Event
        object with the identifier exists in this Model object.

          

        """
        return _libsbml.Model_removeEvent(self, *args)

Model_swigregister = _libsbml.Model_swigregister
Model_swigregister(Model)

IdCheckON = _libsbml.IdCheckON
IdCheckOFF = _libsbml.IdCheckOFF
SBMLCheckON = _libsbml.SBMLCheckON
SBMLCheckOFF = _libsbml.SBMLCheckOFF
SBOCheckON = _libsbml.SBOCheckON
SBOCheckOFF = _libsbml.SBOCheckOFF
MathCheckON = _libsbml.MathCheckON
MathCheckOFF = _libsbml.MathCheckOFF
UnitsCheckON = _libsbml.UnitsCheckON
UnitsCheckOFF = _libsbml.UnitsCheckOFF
OverdeterCheckON = _libsbml.OverdeterCheckON
OverdeterCheckOFF = _libsbml.OverdeterCheckOFF
PracticeCheckON = _libsbml.PracticeCheckON
PracticeCheckOFF = _libsbml.PracticeCheckOFF
AllChecksON = _libsbml.AllChecksON
class SBMLDocument(SBase):
    """
    Container for an SBML document and interface for global operations
    on SBML documents.

    @if clike LibSBML uses the class SBMLDocument as a
    top-level container for storing SBML content and data associated with it
    (such as warnings and error messages).  The two primary means of reading
    an SBML model, SBMLReader::readSBML() and
    SBMLReader::readSBMLFromString(), both return a pointer to an
    SBMLDocument object.  From there, callers can inquire about any errors
    encountered (e.g., using SBMLDocument::getNumErrors()), access the Model
    object, and perform other actions such as consistency-checking and model
    translation. @endif@if java LibSBML uses the class
    SBMLDocument as a top-level container for storing SBML content and data
    associated with it (such as warnings and error messages).  The two
    primary means of reading an SBML model, SBMLReader::readSBML(String
    filename) and SBMLReader::readSBMLFromString(String xml), both return a
    pointer to an SBMLDocument object.  From there, callers can inquire
    about any errors encountered (e.g., using SBMLDocument::getNumErrors()),
    access the Model object, and perform other actions such as
    consistency-checking and model translation. @endif

    When creating fresh models programmatically, the starting point is
    typically the creation of an SBMLDocument object instance.  The
    SBMLDocument constructor accepts arguments for the SBML Level and
    Version of the model to be created.  After creating the SBMLDocument
    object, calling programs then typically call SBMLDocument::createModel()
    almost immediately, and then proceed to call the methods on the Model
    object to fill out the model's contents.

    SBMLDocument corresponds roughly to the class <i>Sbml</i> defined in the
    SBML Level&nbsp;2 specification.  It does not have a direct
    correspondence in SBML Level&nbsp;1.  (However, to make matters simpler
    for applications, libSBML creates an SBMLDocument no matter whether the model
    is Level&nbsp;1 or Level&nbsp;2.)  In its barest form, when written out
    in XML format for SBML Level&nbsp;2 Version&nbsp;4, the corresponding
    structure is the following:
      @verbatim
     <sbml xmlns='http://www.sbml.org/sbml/level2/version4' level='2' version='4'
       ...
     </sbml>
     @endverbatim

    SBMLDocument is derived from SBase, and therefore contains the usual SBase
    attributes (in SBML Level&nbsp;2 Version&nbsp;4) of 'metaid' and 'sboTerm', as
    well as the subelements 'notes' and 'annotation'.  It also contains the
    attributes 'level' and 'version' indicating the Level and Version of the
    SBML data structure.  These can be accessed using the methods defined by
    the SBase class for that purpose.

    @section checking Checking consistency and adherence to SBML specifications

    One of the most important features of libSBML is its ability to perform
    SBML validation to ensure that a model adheres to the SBML specification
    for whatever Level+Version combination the model uses.  SBMLDocument
    provides the methods for running consistency-checking and validation
    rules on the SBML content.

    First, a brief explanation of the rationale is in order.  In libSBML
    versions up to and including the version 3.3.x series, the individual
    methods for creating and setting attributes and other components are
    quite lenient, and allow a caller to compose SBML entities that may not,
    in the end, represent valid SBML.  This allows applications the freedom
    to do things such as save incomplete models (which is useful when models
    are being developed over long periods of time), but at the same time, it
    means that a separate validation step is necessary when a calling
    program finally wants to finish a complete SBML document.

    The primary interface to this facility is SBMLDocument's
    SBMLDocument::checkInternalConsistency() and
    SBMLDocument::checkConsistency().  The former verifies the basic
    internal consistency and syntax of an SBML document, and the latter
    implements more elaborate validation rules (both those defined by the
    SBML specifications, as well as additional rules offered by libSBML).

    @if clike The checks performed by
    SBMLDocument::checkInternalConsistency() are hardwired and cannot be
    changed by calling programs, but the validation performed by
    SBMLDocument::checkConsistency() is under program control using the
    method SBMLDocument::setConsistencyChecks().  Applications can
    selectively disable specific kinds of checks that they may not be
    interested in, by calling SBMLDocument::setConsistencyChecks() with
    appropriate parameters.  @endif@if java The checks
    performed by SBMLDocument::checkInternalConsistency() are hardwired and
    cannot be changed by calling programs, but the validation performed by
    SBMLDocument::checkConsistency() is under program control using the
    method SBMLDocument::setConsistencyChecks(int categ, boolean onoff).
    Applications can selectively disable specific kinds of checks that they
    may not be interested by calling SBMLDocument::setConsistencyChecks(int
    categ, boolean onoff) with appropriate parameters. @endif

    These methods have slightly different relevance depending on whether a
    model is created programmaticaly from scratch, or whether it is read in
    from a file or data stream.  The following table summarizes the possible
    scenarios.

    <center>
    <table border='0' class='text-table width80 normal-font alt-row-colors'>
     <tr style='background: lightgray; font-size: 14px;'>
         <th align='left' width='200'>Scenario</th>
         <th align='left'>Relevant methods</th>
     </tr>
    <tr><td>Creating a model from scratch</td>
    <td>Before writing out the model:<ol>

    <li style='margin-bottom: 0.5em'>Call
    SBMLDocument::checkInternalConsistency(), then inquire about the results by
    calling SBMLDocument::getNumErrors()</li>

    <li style='margin-bottom: 0.5em'>
    Call @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif to configure which checks
    will be performed by SBMLDocument::checkConsistency()</li>

    <li>Call SBMLDocument::checkConsistency(), then inquire about the results by
    calling SBMLDocument::getNumErrors()</li>
    </ol>
    </td>
    <tr><td>Reading a model from a file or data stream</td>
    <td>After reading the model:<ol>

    <li style='margin-bottom: 0.5em'>Basic consistency checks will have been
    performed automatically by libSBML upon reading the content&mdash;only need
    to inquire about the results by using SBMLDocument::getNumErrors()</li>

    <li style='margin-bottom: 0.5em'>
    Call @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif to configure which
    checks are performed by SBMLDocument::checkConsistency()</li>

    <li>Call SBMLDocument::checkConsistency(), then inquire about the results
    by calling SBMLDocument::getNumErrors()</li>
    </ol>
    </td>
    </table>
    </center>

    @if clike An example of using the consistency-checking
    and validation facilities is provided in this manual in the
    section @ref libsbml-example. @endif

    @section converting Converting documents between Levels and Versions of SBML

    LibSBML provides facilities for limited translation of SBML between
    Levels and Versions of the SBML specifications.  The method for doing is
    is @if clike SBMLDocument::setLevelAndVersion() @endif@if java SBMLDocument::setLevelAndVersion(long lev, long ver, boolean strict) @endif.  In 
    general, models can be converted upward without difficulty (e.g., from
    SBML Level&nbsp;1 to Level&nbsp;2, or from an earlier Version of
    Level&nbsp;2 to the latest Version of Level&nbsp;2).  Sometimes models
    can be translated downward as well, if they do not use constructs
    specific to more advanced Levels of SBML.

    Calling @if clike SBMLDocument::setLevelAndVersion() @endif@if java SBMLDocument::setLevelAndVersion(long lev, long ver, boolean strict) @endif will not @em necessarily lead
    to a successful conversion.  The method will return a boolean value
    to indicate success or failure.  Callers must check the error log (see 
    next section) attached to the SBMLDocument object after calling
    @if clike SBMLDocument::setLevelAndVersion() @endif@if java SBMLDocument::setLevelAndVersion(long lev, long ver) @endif in order to assess whether any
    problems arose.

    If an application is interested in translating to a lower Level and/or
    Version of SBML within a Level, the following methods allow for prior
    assessment of whether there is sufficient compatibility to make a
    translation possible:

    @li SBMLDocument::checkL1Compatibility(),
    @li SBMLDocument::checkL2v1Compatibility(),
    @li SBMLDocument::checkL2v2Compatibility(),
    @li SBMLDocument::checkL2v3Compatibility(), and
    @li SBMLDocument::checkL2v4Compatibility().

    Some changes between Versions of SBML Level&nbsp;2 may lead to
    unexpected behaviors when attempting conversions in either direction.
    For example, SBML Level&nbsp;2 Version&nbsp;4 relaxed the requirement
    for consistency in units of measurement between expressions annd
    quantities in a model.  As a result, a model written in Version&nbsp;4,
    if converted to Version&nbsp;3 with no other changes, may fail
    validation as a Version&nbsp;3 model because Version&nbsp;3 imposed
    stricter requirements on unit consistency.

    @section errors Error handling

    Upon reading a model, SBMLDocument logs any problems encountered while
    reading the model from the file or data stream.  The log contains
    objects that record diagnostic information about any notable issues that
    arose.  Whether the problems are warnings or errors, they are both
    reported through a single common interface involving the object class
    SBMLError.

    The methods SBMLDocument::getNumErrors(), @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif and
    SBMLDocument::printErrors() allow callers to interact with the warnings
    or errors logged.  Alternatively, callers may retrieve the entire log as
    an SBMLErrorLog object using the method SBMLDocument::getErrorLog().
    The SBMLErrorLog object provides some alternative methods for
    interacting with the set of errors and warnings.  In either case,
    applications typically should first call SBMLDocument::getNumErrors() to
    find out if any issues have been logged after specific libSBML
    operations such as the ones discussed in the sections above.  If they
    have, then an application will should proceed to inspect the individual
    reports using either the direct interfaces on SBMLDocument or using the
    methods on the SBMLErrorLog object.

    @if clike An example of using the error facility is
    provided in this manual in the
    section @ref libsbml-example. @endif


    <hr style='margin: 1em auto'>

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLDocument, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLDocument, name)
    __repr__ = _swig_repr
    def getDefaultLevel():
        """
        getDefaultLevel() -> unsigned int

        The default SBML Level of new SBMLDocument objects.

        This 'default level' corresponds to the most recent SBML specification
        Level available at the time this version of libSBML was released.  For
        this copy of libSBML, the value is <code>2</code>.  The default Level
        is used by SBMLDocument if no Level is explicitly specified at the
        time of the construction of an SBMLDocument instance. 

        @return an integer indicating the most recent SBML specification Level

        @see getDefaultVersion()
          

        """
        return _libsbml.SBMLDocument_getDefaultLevel()

    if _newclass:getDefaultLevel = staticmethod(getDefaultLevel)
    __swig_getmethods__["getDefaultLevel"] = lambda x: getDefaultLevel
    def getDefaultVersion():
        """
        getDefaultVersion() -> unsigned int

        The default Version of new SBMLDocument objects.

        This 'default version' corresponds to the most recent SBML Version
        within the most recent Level of SBML available at the time this
        version of libSBML was released.  For this copy of libSBML, the value
        is <code>4</code>.  The default Version is used by SBMLDocument if no
        Version is explicitly specified at the time of the construction of an
        SBMLDocument instance.

        @return an integer indicating the most recent SBML specification
        Version

        @see getDefaultLevel()
          

        """
        return _libsbml.SBMLDocument_getDefaultVersion()

    if _newclass:getDefaultVersion = staticmethod(getDefaultVersion)
    __swig_getmethods__["getDefaultVersion"] = lambda x: getDefaultVersion
    __swig_destroy__ = _libsbml.delete_SBMLDocument
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level = 0, unsigned int version = 0) -> SBMLDocument
        __init__(self, unsigned int level = 0) -> SBMLDocument
        __init__(self) -> SBMLDocument
        __init__(self, SBMLDocument rhs) -> SBMLDocument

        Copy constructor; creates a copy of this SBMLDocument.
          

        """
        this = _libsbml.new_SBMLDocument(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLDocument

        Creates and returns a deep copy of this SBMLDocument.

        @return a (deep) copy of this SBMLDocument.
          

        """
        return _libsbml.SBMLDocument_clone(self)

    def getModel(self, *args):
        """
        getModel(self) -> Model
        getModel(self) -> Model

        Returns the Model object stored in this SBMLDocument.

        It is important to note that this method <em>does not create</em> a
        Model instance.  The model in the SBMLDocument must have been created
        at some prior time, for example using SBMLDocument::createModel() 
        or @if clike SBMLDocument::setModel() @endif@if java SBMLDocument::setModel(Model m) @endif.
        This method returns @c NULL if a model does not yet exist.

        @return the Model contained in this SBMLDocument.

        @see createModel()
          

        """
        return _libsbml.SBMLDocument_getModel(self, *args)

    def expandFunctionDefinitions(self):
        """
        expandFunctionDefinitions(self) -> bool

        Removes any FunctionDefinitions from the document and expands
        any instances of their use within &lt;math&gt; elements.

        For example a Model contains a FunctionDefinition with id f
        representing the math expression: f(x, y) = x * y.
        The math element of the KineticLaw uses f(s, p).
        The outcome of the function is that the math of the KineticLaw
        now represents the math expression: s * p and the model no longer
        contains any FunctionDefinitions.

        @return bool @c true if the transformation was successful, 
        @c false, otherwise.

        @note This function will check the consistency of a model
        before attemptimg the transformation.  In the case of a model
        with invalid SBML the transformation will not be done and the
        function will return @c false.

          

        """
        return _libsbml.SBMLDocument_expandFunctionDefinitions(self)

    def expandInitialAssignments(self):
        """
        expandInitialAssignments(self) -> bool

        Removes any InitialAssignments from the document and replaces
        the appropriate values.

        For example a Model contains a InitialAssignment with symbol k
        where k is the id of a Parameter.
        The outcome of the function is that the value attribute of
        the Parameter is the value calculated using the math expression
        of the InitialAssignment and the corresponding InitialAssignment
        has been removed from the Model.

        @return bool @c true if the transformation was successful, 
        @c false, otherwise.

        @note This function will check the consistency of a model
        before attemptimg the transformation.  In the case of a model
        with invalid SBML the transformation will not be done and the
        function will return @c false.  As part of the process the 
        function will check that it has values for any components
        referred to by the math elements of InitialAssignments.  In
        the case where not all values have been declared the particular
        InitialAssignment will not be removed and the function will 
        return @c false.
          

        """
        return _libsbml.SBMLDocument_expandInitialAssignments(self)

    def setLevelAndVersion(self, *args):
        """
        setLevelAndVersion(self, unsigned int level, unsigned int version, bool strict = True) -> bool
        setLevelAndVersion(self, unsigned int level, unsigned int version) -> bool

        Sets the SBML Level and Version of this SBMLDocument instance,
        attempting to convert the model as needed.

        This method is the principal way in libSBML to convert models between
        Levels and Versions of SBML.  Generally, models can be converted
        upward without difficulty (e.g., from SBML Level&nbsp;1 to
        Level&nbsp;2, or from an earlier Version of Level&nbsp;2 to the latest
        Version of Level&nbsp;2).  Sometimes models can be translated downward
        as well, if they do not use constructs specific to more advanced
        Levels of SBML.

        Before calling this method, callers may check compatibility directly
        using the methods SBMLDocument::checkL1Compatibility(),
        SBMLDocument::checkL2v1Compatibility(),
        SBMLDocument::checkL2v2Compatibility(),
        SBMLDocument::checkL2v3Compatibility() and
        SBMLDocument::checkL2v4Compatibility().

        The valid combinations of SBML Level and Version as of this release
        of libSBML are the following: 
        <ul>
        <li> Level&nbsp;1 Version&nbsp;2
        <li> Level&nbsp;2 Version&nbsp;1
        <li> Level&nbsp;2 Version&nbsp;2
        <li> Level&nbsp;2 Version&nbsp;3
        <li> Level&nbsp;2 Version&nbsp;4
        </ul>

        @param level the desired SBML Level
         
        @param version the desired Version within the SBML Level

        @param strict boolean indicating whether to check consistency
        of both the source and target model when performing
        conversion (defaults to <code> true </code>)

        @note Calling this method will not @em necessarily lead to a successful
        conversion.  If the conversion fails, it will be logged in the error
        list associated with this SBMLDocument.  Callers should consult
        getNumErrors() to find out if the conversion succeeded without
        problems.  For conversions from Level&nbsp;2 to Level&nbsp;1, callers
        can also check the Level of the model after calling this method to
        find out whether it is Level&nbsp;1.  (If the conversion to
        Level&nbsp;1 failed, the Level of this model will be left unchanged.)

        @see checkL1Compatibility()
        @see checkL2v1Compatibility()
        @see checkL2v2Compatibility()
        @see checkL2v3Compatibility()
        @see checkL2v4Compatibility()

        Strict conversion applies the additional criteria that both the source
        and the target model must be consistent SBML.  Users can control the
        consistency checks that are applied using the 
        SBMLDocument::setConsistencyChecksForConversion function.  If either 
        the source
        or the potential target model have validation errors, the conversion
        is not performed.  When a strict conversion is successful, the
        underlying SBML object model is altered to reflect the new level
        and version.  Thus information that cannot be converted (e.g. sboTerms)
        will be lost.   
          

        """
        return _libsbml.SBMLDocument_setLevelAndVersion(self, *args)

    def setModel(self, *args):
        """
        setModel(self, Model m) -> int

        Sets the Model for this SBMLDocument to a copy of the given Model.

        @param m the new Model to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink

        @see createModel()
        @see getModel()
          

        """
        return _libsbml.SBMLDocument_setModel(self, *args)

    def createModel(self, sid = ""):
        """
        createModel(self, string sid = "") -> Model
        createModel(self) -> Model

        Creates a new Model inside this SBMLDocument, and returns a pointer to
        it.

        In SBML Level&nbsp;2, the use of an identifier on a Model object is
        optional.  This method takes an optional argument, @p sid, for setting
        the identifier.  If not supplied, the identifier attribute on the
        Model instance is not set.

        @param sid the identifier of the new Model to create.

        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif

        @see getModel()
        @see @if clike SBMLDocument::setModel() @endif@if java SBMLDocument::setModel(Model m) @endif
          

        """
        return _libsbml.SBMLDocument_createModel(self, sid)

    def setConsistencyChecks(self, *args):
        """
        setConsistencyChecks(self, SBMLErrorCategory_t category, bool apply)

        Controls the consistency checks that are performed when
        SBMLDocument::checkConsistency() is called.

        This method works by adding or subtracting consistency checks from the
        set of all possible checks that SBMLDocument::checkConsistency() knows
        how to perform.  This method may need to be called multiple times in
        order to achieve the desired combination of checks.  The first
        argument (@p category) in a call to this method indicates the category
        of consistency/error checks that are to be turned on or off, and the
        second argument (@p apply, a boolean) indicates whether to turn it on
        (value of @c true) or off (value of @c false).

        The possible categories (values to the argument @p category) are the
        set of values from the enumeration #SBMLErrorCategory_t.  The
        following are the possible choices in libSBML version&nbsp;3.3.x:

        @li @c LIBSBML_CAT_GENERAL_CONSISTENCY: Correctness and consistency of
        specific SBML language constructs.  Performing this set of checks is
        highly recommended.  With respect to the SBML specification, these
        concern failures in applying the validation rules numbered 2xxxx in
        the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4 specifications.

        @li @c LIBSBML_CAT_IDENTIFIER_CONSISTENCY: Correctness and consistency
        of identifiers used for model entities.  An example of inconsistency
        would be using a species identifier in a reaction rate formula without
        first having declared the species.  With respect to the SBML
        specification, these concern failures in applying the validation rules
        numbered 103xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4
        specifications.

        @li @c LIBSBML_CAT_UNITS_CONSISTENCY: Consistency of measurement units
        associated with quantities in a model.  With respect to the SBML
        specification, these concern failures in applying the validation rules
        numbered 105xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4
        specifications.

        @li @c LIBSBML_CAT_MATHML_CONSISTENCY: Syntax of MathML constructs.
        With respect to the SBML specification, these concern failures in
        applying the validation rules numbered 102xx in the Level&nbsp;2
        Versions&nbsp;2, 3 and&nbsp;4 specifications.

        @li @c LIBSBML_CAT_SBO_CONSISTENCY: Consistency and validity of SBO
        identifiers (if any) used in the model.  With respect to the SBML
        specification, these concern failures in applying the validation rules
        numbered 107xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4
        specifications.

        @li @c LIBSBML_CAT_OVERDETERMINED_MODEL: Static analysis of
        whether the system of equations implied by a model is mathematically
        overdetermined.  With respect to the SBML specification, this is
        validation rule #10601 in the SBML Level&nbsp;2 Versions&nbsp;2, 3
        and&nbsp;4 specifications.

        @li @c LIBSBML_CAT_MODELING_PRACTICE: Additional checks for
        recommended good modeling practice. (These are tests performed by
        libSBML and do not have equivalent SBML validation rules.)

        <em>By default, all validation checks are applied</em> to the model in
        an SBMLDocument object @em unless @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif is called to
        indicate that only a subset should be applied.  Further, this default
        (i.e., performing all checks) applies separately to <em>each new
        SBMLDocument object</em> created.  In other words, each time a model
        is read using @if clike SBMLReader::readSBML() @endif@if java SBMLReader::readSBML(String filename) @endif, @if clike SBMLReader::readSBMLFromString() @endif@if java SBMLReader::readSBMLFromString(String xml) @endif,
        or the global functions readSBML() and readSBMLFromString(), a new
        SBMLDocument is created and for that document, a call to
        SBMLDocument::checkConsistency() will default to applying all possible checks.
        Calling programs must invoke @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif for each such new
        model if they wish to change the consistency checks applied.

        @param category a value drawn from #SBMLErrorCategory_t indicating the
        consistency checking/validation to be turned on or off

        @param apply a boolean indicating whether the checks indicated by
        @p category should be applied or not.

        @see SBMLDocument::checkConsistency()
          

        """
        return _libsbml.SBMLDocument_setConsistencyChecks(self, *args)

    def setConsistencyChecksForConversion(self, *args):
        """
        setConsistencyChecksForConversion(self, SBMLErrorCategory_t category, bool apply)

        Controls the consistency checks that are performed when
        SBMLDocument::setLevelAndVersion() is called.

        This method works by adding or subtracting consistency checks from the
        set of all possible checks that may be performed to avoid conversion
        to or from an invalid document.  This method may need to be called 
        multiple times in
        order to achieve the desired combination of checks.  The first
        argument (@p category) in a call to this method indicates the category
        of consistency/error checks that are to be turned on or off, and the
        second argument (@p apply, a boolean) indicates whether to turn it on
        (value of @c true) or off (value of @c false).

        The possible categories (values to the argument @p category) are the
        set of values from the enumeration #SBMLErrorCategory_t.  The
        following are the possible choices in libSBML version&nbsp;4.x.x:

        @li @c LIBSBML_CAT_GENERAL_CONSISTENCY: Correctness and consistency of
        specific SBML language constructs.  Performing this set of checks is
        highly recommended.  With respect to the SBML specification, these
        concern failures in applying the validation rules numbered 2xxxx in
        the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4 specifications.

        @li @c LIBSBML_CAT_IDENTIFIER_CONSISTENCY: Correctness and consistency
        of identifiers used for model entities.  An example of inconsistency
        would be using a species identifier in a reaction rate formula without
        first having declared the species.  With respect to the SBML
        specification, these concern failures in applying the validation rules
        numbered 103xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4
        specifications.

        @li @c LIBSBML_CAT_UNITS_CONSISTENCY: Consistency of measurement units
        associated with quantities in a model.  With respect to the SBML
        specification, these concern failures in applying the validation rules
        numbered 105xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4
        specifications.

        @li @c LIBSBML_CAT_MATHML_CONSISTENCY: Syntax of MathML constructs.
        With respect to the SBML specification, these concern failures in
        applying the validation rules numbered 102xx in the Level&nbsp;2
        Versions&nbsp;2, 3 and&nbsp;4 specifications.

        @li @c LIBSBML_CAT_SBO_CONSISTENCY: Consistency and validity of SBO
        identifiers (if any) used in the model.  With respect to the SBML
        specification, these concern failures in applying the validation rules
        numbered 107xx in the Level&nbsp;2 Versions&nbsp;2, 3 and&nbsp;4
        specifications.

        @li @c LIBSBML_CAT_OVERDETERMINED_MODEL: Static analysis of
        whether the system of equations implied by a model is mathematically
        overdetermined.  With respect to the SBML specification, this is
        validation rule #10601 in the SBML Level&nbsp;2 Versions&nbsp;2, 3
        and&nbsp;4 specifications.

        @li @c LIBSBML_CAT_MODELING_PRACTICE: Additional checks for
        recommended good modeling practice. (These are tests performed by
        libSBML and do not have equivalent SBML validation rules.)

        <em>By default, all validation checks are applied</em> to the model in
        an SBMLDocument object @em unless @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif is called to
        indicate that only a subset should be applied.  Further, this default
        (i.e., performing all checks) applies separately to <em>each new
        SBMLDocument object</em> created.  In other words, each time a model
        is read using @if clike SBMLReader::readSBML() @endif@if java SBMLReader::readSBML(String filename) @endif, @if clike SBMLReader::readSBMLFromString() @endif@if java SBMLReader::readSBMLFromString(String xml) @endif,
        or the global functions readSBML() and readSBMLFromString(), a new
        SBMLDocument is created and for that document, a call to
        SBMLDocument::checkConsistency() will default to applying all possible checks.
        Calling programs must invoke @if clike SBMLDocument::setConsistencyChecks() @endif@if java SBMLDocument::setConsistencyChecks(int categ, boolean onoff) @endif for each such new
        model if they wish to change the consistency checks applied.

        @param category a value drawn from #SBMLErrorCategory_t indicating the
        consistency checking/validation to be turned on or off

        @param apply a boolean indicating whether the checks indicated by
        @p category should be applied or not.

        @see @if clike SBMLDocument::setLevelAndVersion() @endif@if java SBMLDocument::setLevelAndVersion(long lev, long ver, boolean strict) @endif
          

        """
        return _libsbml.SBMLDocument_setConsistencyChecksForConversion(self, *args)

    def checkConsistency(self):
        """
        checkConsistency(self) -> unsigned int

        Performs consistency checking and validation on this SBML document.

        If this method returns a nonzero value (meaning, one or more
        consistency checks have failed for SBML document), the failures may be
        due to warnings @em or errors.  Callers should inspect the severity
        flag in the individual SBMLError objects returned by
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif to determine the nature of the failures.

        @return the number of failed checks (errors) encountered.

        @see SBMLDocument::checkInternalConsistency()
          

        """
        return _libsbml.SBMLDocument_checkConsistency(self)

    def checkInternalConsistency(self):
        """
        checkInternalConsistency(self) -> unsigned int

        Performs consistency checking on libSBML's internal representation of 
        an SBML Model.

        Callers should query the results of the consistency check by calling
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.

        @return the number of failed checks (errors) encountered.

        The distinction between this method and
        SBMLDocument::checkConsistency() is that this method reports on
        fundamental syntactic and structural errors that violate the XML
        Schema for SBML; by contrast, SBMLDocument::checkConsistency()
        performs more elaborate model verifications and also validation
        according to the validation rules written in the appendices of the
        SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 specification documents.

        @see SBMLDocument::checkConsistency()
          

        """
        return _libsbml.SBMLDocument_checkInternalConsistency(self)

    def checkL1Compatibility(self):
        """
        checkL1Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;1 and can be converted
        to Level&nbsp;1.

        Callers should query the results of the consistency check by calling
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.

        @return the number of failed checks (errors) encountered.
          

        """
        return _libsbml.SBMLDocument_checkL1Compatibility(self)

    def checkL2v1Compatibility(self):
        """
        checkL2v1Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;1 and can
        be converted to Level&nbsp;2 Version&nbsp;1.

        Callers should query the results of the consistency check by calling
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.

        @return the number of failed checks (errors) encountered.
          

        """
        return _libsbml.SBMLDocument_checkL2v1Compatibility(self)

    def checkL2v2Compatibility(self):
        """
        checkL2v2Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;2 and can
        be converted to Level&nbsp;2 Version&nbsp;2.

        Callers should query the results of the consistency check by calling
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.

        @return the number of failed checks (errors) encountered.
          

        """
        return _libsbml.SBMLDocument_checkL2v2Compatibility(self)

    def checkL2v3Compatibility(self):
        """
        checkL2v3Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;3 and can
        be converted to Level&nbsp;2 Version&nbsp;3.

        Callers should query the results of the consistency check by calling
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.

        @return the number of failed checks (errors) encountered.
          

        """
        return _libsbml.SBMLDocument_checkL2v3Compatibility(self)

    def checkL2v4Compatibility(self):
        """
        checkL2v4Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;4 and can
        be converted to Level&nbsp;2 Version&nbsp;4.

        Callers should query the results of the consistency check by calling
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.

        @return the number of failed checks (errors) encountered.
          

        """
        return _libsbml.SBMLDocument_checkL2v4Compatibility(self)

    def checkL3v1Compatibility(self):
        """
        checkL3v1Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;3 Version&nbsp;1 and can
        be converted to Level&nbsp;3 Version&nbsp;1.

        Callers should query the results of the consistency check by calling
        @if clike SBMLDocument::getError() @endif@if java SBMLDocument::getError(long n) @endif.

        @return the number of failed checks (errors) encountered.
          

        """
        return _libsbml.SBMLDocument_checkL3v1Compatibility(self)

    def getError(self, *args):
        """
        getError(self, unsigned int n) -> SBMLError

        Returns the nth error or warning encountered during parsing,
        consistency checking, or attempted translation of this model.

        Callers can use method XMLError::getSeverity() on the result to assess
        the severity of the problem.  The possible severity levels range from
        informational messages to fatal errors.

        @return the error or warning indexed by integer @p n, or return @c
        NULL if <code>n &gt; (getNumErrors() - 1)</code>.

        @param n the integer index of the error sought.

        @see SBMLDocument::getNumErrors()
          

        """
        return _libsbml.SBMLDocument_getError(self, *args)

    def getNumErrors(self):
        """
        getNumErrors(self) -> unsigned int

        Returns the number of errors or warnings encountered during parsing,
        consistency checking, or attempted translation of this model.

        @return the number of errors or warnings encountered

        @see SBMLDocument::getError(unsigned int n)
          

        """
        return _libsbml.SBMLDocument_getNumErrors(self)

    def printErrors(self, *args):
        """
        printErrors(self, ostream stream = cerr)
        printErrors(self)

        Prints to the given output stream all the errors or warnings
        encountered during parsing, consistency checking, or attempted
        translation of this model.

        If no errors have occurred, i.e., <code>getNumErrors() == 0</code>, no
        output will be sent to the stream.

        The format of the output is:
          @verbatim
            N error(s):
              line NNN: (id) message
         @endverbatim

        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
          

        """
        return _libsbml.SBMLDocument_printErrors(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see SBMLDocument::getElementName()
          

        """
        return _libsbml.SBMLDocument_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for SBMLDocument,
        is always @c 'sbml'.

        @return the name of this element, i.e., @c 'sbml'.
          

        """
        return _libsbml.SBMLDocument_getElementName(self)

    def getErrorLog(self):
        """
        getErrorLog(self) -> SBMLErrorLog

        Returns the list of errors or warnings logged during parsing, 
        consistency checking, or attempted translation of this model.

        @return the SBMLErrorLog used for this SBMLDocument

        @see SBMLDocument::getNumErrors()
          

        """
        return _libsbml.SBMLDocument_getErrorLog(self)

    def getNamespaces(self):
        """
        getNamespaces(self) -> XMLNamespaces

        Returns a list of XML Namespaces associated with the XML content
        of this SBML document.

        @return the XML Namespaces associated with this SBML object
          

        """
        return _libsbml.SBMLDocument_getNamespaces(self)

SBMLDocument_swigregister = _libsbml.SBMLDocument_swigregister
SBMLDocument_swigregister(SBMLDocument)

def SBMLDocument_getDefaultLevel():
  """
    SBMLDocument_getDefaultLevel() -> unsigned int

    The default SBML Level of new SBMLDocument objects.

    This 'default level' corresponds to the most recent SBML specification
    Level available at the time this version of libSBML was released.  For
    this copy of libSBML, the value is <code>2</code>.  The default Level
    is used by SBMLDocument if no Level is explicitly specified at the
    time of the construction of an SBMLDocument instance. 

    @return an integer indicating the most recent SBML specification Level

    @see getDefaultVersion()
      

    """
  return _libsbml.SBMLDocument_getDefaultLevel()

def SBMLDocument_getDefaultVersion():
  """
    SBMLDocument_getDefaultVersion() -> unsigned int

    The default Version of new SBMLDocument objects.

    This 'default version' corresponds to the most recent SBML Version
    within the most recent Level of SBML available at the time this
    version of libSBML was released.  For this copy of libSBML, the value
    is <code>4</code>.  The default Version is used by SBMLDocument if no
    Version is explicitly specified at the time of the construction of an
    SBMLDocument instance.

    @return an integer indicating the most recent SBML specification
    Version

    @see getDefaultLevel()
      

    """
  return _libsbml.SBMLDocument_getDefaultVersion()

class FunctionDefinition(SBase):
    """
    LibSBML implementation of %SBML's %FunctionDefinition construct.

    The FunctionDefinition structure associates an identifier with a
    function definition.  This identifier can then be used as the function
    called in subsequent MathML content elsewhere in an SBML model.

    FunctionDefinition has one required attribute, 'id', to give the
    function a unique identifier by which other parts of an SBML model
    definition can refer to it.  A FunctionDefinition instance can also have
    an optional 'name' attribute of type @c string.  Identifiers and names
    must be used according to the guidelines described in the %SBML
    specification (e.g., Section 3.3 in the Level 2 Version 4
    specification).

    FunctionDefinition has a required 'math' subelement containing a MathML
    expression defining the function body.  The content of this element can
    only be a MathML 'lambda' element.  The 'lambda' element must begin with
    zero or more 'bvar' elements, followed by any other of the elements in
    the MathML subset allowed in SBML Level 2 @em except 'lambda' (i.e., a
    'lambda' element cannot contain another 'lambda' element).  This is the
    only place in SBML where a 'lambda' element can be used.  The function
    defined by a FunctionDefinition is only available for use in other
    MathML elements that @em follow the FunctionDefinition definition in the
    model.  (These restrictions prevent recursive and mutually-recursive
    functions from being expressed.)

    A further restriction on the content of 'math' is that it cannot contain
    references to variables other than the variables declared to the
    'lambda' itself.  That is, the contents of MathML 'ci' elements inside
    the body of the 'lambda' can only be the variables declared by its
    'bvar' elements, or the identifiers of other FunctionDefinition
    instances earlier in the model.  This means must be written so that all
    variables or parameters used in the MathML content are passed to them
    via their function parameters.

    @note Function definitions (also informally known as user-defined
    functions) were introduced in SBML Level 2.  They have purposefully
    limited capabilities.  A function cannot reference parameters or other
    model quantities outside of itself; values must be passed as parameters
    to the function.  Moreover, recursive and mutually-recursive functions
    are not permitted.  The purpose of these limitations is to balance power
    against complexity of implementation.  With the restrictions as they
    are, function definitions could be implemented as textual
    substitutions&mdash;they are simply macros.  Software implementations
    therefore do not need the full function-definition machinery typically
    associated with programming languages.

    @note Another important point to note is FunctionDefinition does not
    have a separate attribute for defining the units of the value returned
    by the function.  The units associated with the function's return value,
    when the function is called from within MathML expressions elsewhere in
    SBML, are simply the overall units of the expression in
    FunctionDefinition's 'math' subelement when applied to the arguments
    supplied in the call to the function.  Ascertaining these units requires
    performing dimensional analysis on the expression.  (Readers may wonder
    why there is no attribute.  The reason is that having a separate
    attribute for declaring the units would not only be redundant, but also
    lead to the potential for having conflicting information.  In the case
    of a conflict between the declared units and those of the value actually
    returned by the function, the only logical resolution rule would be to
    assume that the correct units are those of the expression anyway.)

    <!---------------------------------------------------------------------- -->


    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FunctionDefinition, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_FunctionDefinition
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> FunctionDefinition
        __init__(self, SBMLNamespaces sbmlns) -> FunctionDefinition
        __init__(self, FunctionDefinition orig) -> FunctionDefinition

        Predicate returning @c true if
        all the required elements for this FunctionDefinition object
        have been set.

        @note The required elements for a FunctionDefinition object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_FunctionDefinition(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> FunctionDefinition

        Creates and returns a deep copy of this FunctionDefinition.

        @return a (deep) copy of this FunctionDefinition.
          

        """
        return _libsbml.FunctionDefinition_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this FunctionDefinition.

        @return the id of this FunctionDefinition.
          

        """
        return _libsbml.FunctionDefinition_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this FunctionDefinition.

        @return the name of this FunctionDefinition.
          

        """
        return _libsbml.FunctionDefinition_getName(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula of this FunctionDefinition.

        @return an ASTNode, the value of the 'math' subelement of this
        FunctionDefinition
          

        """
        return _libsbml.FunctionDefinition_getMath(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        FunctionDefinition's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this FunctionDefinition has been
        set, @c false otherwise.
          

        """
        return _libsbml.FunctionDefinition_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        FunctionDefinition's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this FunctionDefinition has been
        set, @c false otherwise.
          

        """
        return _libsbml.FunctionDefinition_isSetName(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c true if this
        FunctionDefinition's 'math' subelement contains a value.

        @return @c true if the 'math' for this FunctionDefinition has been set,
        @c false otherwise.
          

        """
        return _libsbml.FunctionDefinition_isSetMath(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this FunctionDefinition.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this FunctionDefinition

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.FunctionDefinition_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this FunctionDefinition.

        The string in @p name is copied.

        @param name the new name for the FunctionDefinition

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.FunctionDefinition_setName(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this FunctionDefinition to the Abstract
        Syntax Tree given in @p math.

        @param math an AST containing the mathematical expression to
        be used as the formula for this FunctionDefinition.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.FunctionDefinition_setMath(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this FunctionDefinition.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.FunctionDefinition_unsetName(self)

    def getArgument(self, *args):
        """
        getArgument(self, unsigned int n) -> ASTNode
        getArgument(self, string name) -> ASTNode

        Get the argument named @p name to this FunctionDefinition.

        @param name the exact name (case-sensitive) of the sought-after
        argument

        @return the argument (bound variable) having the given name, or @c NULL if
        no such argument exists.
          

        """
        return _libsbml.FunctionDefinition_getArgument(self, *args)

    def getBody(self, *args):
        """
        getBody(self) -> ASTNode
        getBody(self) -> ASTNode

        Get the mathematical expression that is the body of this
        FunctionDefinition object.

        @return the body of this FunctionDefinition as an Abstract Syntax
        Tree, or @c NULL if no body is defined.
          

        """
        return _libsbml.FunctionDefinition_getBody(self, *args)

    def getNumArguments(self):
        """
        getNumArguments(self) -> unsigned int

        Get the number of arguments (bound variables) taken by this
        FunctionDefinition.

        @return the number of arguments (bound variables) that must be passed
        to this FunctionDefinition.
          

        """
        return _libsbml.FunctionDefinition_getNumArguments(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.FunctionDefinition_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        FunctionDefinition, is always @c 'functionDefinition'.

        @return the name of this element, i.e., @c 'functionDefinition'.
          

        """
        return _libsbml.FunctionDefinition_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this FunctionDefinition object
        have been set.

        @note The required attributes for a FunctionDefinition object are:
        @li 'id'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.FunctionDefinition_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this FunctionDefinition object
        have been set.

        @note The required elements for a FunctionDefinition object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.FunctionDefinition_hasRequiredElements(self)

FunctionDefinition_swigregister = _libsbml.FunctionDefinition_swigregister
FunctionDefinition_swigregister(FunctionDefinition)

class ListOfFunctionDefinitions(ListOf):
    """
    LibSBML implementation of SBML's %ListOfFunctionDefinitions construct.

    The various ListOf___ classes in %SBML are merely containers used for
    organizing the main components of an %SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an %SBML model is
    illustrated by the following (for %SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfFunctionDefinitions, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfFunctionDefinitions, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfFunctionDefinitions

        Creates and returns a deep copy of this ListOfFunctionDefinitions instance.

        @return a (deep) copy of this ListOfFunctionDefinitions.
          

        """
        return _libsbml.ListOfFunctionDefinitions_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfFunctionDefinitions_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., FunctionDefinition objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfFunctionDefinitions_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfFunctionDefinitions, the XML element name is @c
        'listOfFunctionDefinitions'.

        @return the name of this element, i.e., @c 'listOfFunctionDefinitions'.
          

        """
        return _libsbml.ListOfFunctionDefinitions_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> FunctionDefinition
        get(self, unsigned int n) -> FunctionDefinition
        get(self, string sid) -> FunctionDefinition
        get(self, string sid) -> FunctionDefinition

        Get a FunctionDefinition from the ListOfFunctionDefinitions
        based on its identifier.

        @param sid a string representing the identifier 
        of the FunctionDefinition to get.

        @return FunctionDefinition in this ListOfFunctionDefinitions
        with the given id or @c NULL if no such
        FunctionDefinition exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfFunctionDefinitions_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> FunctionDefinition
        remove(self, string sid) -> FunctionDefinition

        Removes item in this ListOfFunctionDefinitions items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfFunctionDefinitions_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfFunctionDefinitions"""
        this = _libsbml.new_ListOfFunctionDefinitions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfFunctionDefinitions
    __del__ = lambda self : None;
ListOfFunctionDefinitions_swigregister = _libsbml.ListOfFunctionDefinitions_swigregister
ListOfFunctionDefinitions_swigregister(ListOfFunctionDefinitions)

UNIT_KIND_AMPERE = _libsbml.UNIT_KIND_AMPERE
UNIT_KIND_AVOGADRO = _libsbml.UNIT_KIND_AVOGADRO
UNIT_KIND_BECQUEREL = _libsbml.UNIT_KIND_BECQUEREL
UNIT_KIND_CANDELA = _libsbml.UNIT_KIND_CANDELA
UNIT_KIND_CELSIUS = _libsbml.UNIT_KIND_CELSIUS
UNIT_KIND_COULOMB = _libsbml.UNIT_KIND_COULOMB
UNIT_KIND_DIMENSIONLESS = _libsbml.UNIT_KIND_DIMENSIONLESS
UNIT_KIND_FARAD = _libsbml.UNIT_KIND_FARAD
UNIT_KIND_GRAM = _libsbml.UNIT_KIND_GRAM
UNIT_KIND_GRAY = _libsbml.UNIT_KIND_GRAY
UNIT_KIND_HENRY = _libsbml.UNIT_KIND_HENRY
UNIT_KIND_HERTZ = _libsbml.UNIT_KIND_HERTZ
UNIT_KIND_ITEM = _libsbml.UNIT_KIND_ITEM
UNIT_KIND_JOULE = _libsbml.UNIT_KIND_JOULE
UNIT_KIND_KATAL = _libsbml.UNIT_KIND_KATAL
UNIT_KIND_KELVIN = _libsbml.UNIT_KIND_KELVIN
UNIT_KIND_KILOGRAM = _libsbml.UNIT_KIND_KILOGRAM
UNIT_KIND_LITER = _libsbml.UNIT_KIND_LITER
UNIT_KIND_LITRE = _libsbml.UNIT_KIND_LITRE
UNIT_KIND_LUMEN = _libsbml.UNIT_KIND_LUMEN
UNIT_KIND_LUX = _libsbml.UNIT_KIND_LUX
UNIT_KIND_METER = _libsbml.UNIT_KIND_METER
UNIT_KIND_METRE = _libsbml.UNIT_KIND_METRE
UNIT_KIND_MOLE = _libsbml.UNIT_KIND_MOLE
UNIT_KIND_NEWTON = _libsbml.UNIT_KIND_NEWTON
UNIT_KIND_OHM = _libsbml.UNIT_KIND_OHM
UNIT_KIND_PASCAL = _libsbml.UNIT_KIND_PASCAL
UNIT_KIND_RADIAN = _libsbml.UNIT_KIND_RADIAN
UNIT_KIND_SECOND = _libsbml.UNIT_KIND_SECOND
UNIT_KIND_SIEMENS = _libsbml.UNIT_KIND_SIEMENS
UNIT_KIND_SIEVERT = _libsbml.UNIT_KIND_SIEVERT
UNIT_KIND_STERADIAN = _libsbml.UNIT_KIND_STERADIAN
UNIT_KIND_TESLA = _libsbml.UNIT_KIND_TESLA
UNIT_KIND_VOLT = _libsbml.UNIT_KIND_VOLT
UNIT_KIND_WATT = _libsbml.UNIT_KIND_WATT
UNIT_KIND_WEBER = _libsbml.UNIT_KIND_WEBER
UNIT_KIND_INVALID = _libsbml.UNIT_KIND_INVALID

def UnitKind_equals(*args):
  """
    UnitKind_equals(UnitKind_t uk1, UnitKind_t uk2) -> int

    Tests for logical equality between two given UnitKind_t values.

    This function behaves exactly like C's <tt>==</tt> operator, except for
    the following two cases:

    @li UNIT_KIND_LITER <code>==</code> UNIT_KIND_LITRE
    @li UNIT_KIND_METER <code>==</code> UNIT_KIND_METRE

    C equality comparison would yield false (because each of the above is a
    distinct enumeration value), but UnitKind_equals() returns true.

    @param uk1 a UnitKind_t enumeration value 
    @param uk2 the UnitKind_t enumeration value to compare to @p uk1

    @return nonzero (for true) if uk1 is logically equivalent to uk2,
    zero (0) otherwise.

    @note For more information about the UnitKind_t enumeration, please
    refer to the class documentation for Unit.


    """
  return _libsbml.UnitKind_equals(*args)

def UnitKind_forName(*args):
  """
    UnitKind_forName(char name) -> UnitKind_t

    Converts a string to its corresponding UnitKind_t enumeration value.

    @param name a string, the name of a predefined base unit in SBML

    @return a value from UnitKind_t corresponding to the given name
    (determined in a case-insensitive manner).

    @note For more information about the UnitKind_t enumeration, please
    refer to the class documentation for Unit.


    """
  return _libsbml.UnitKind_forName(*args)

def UnitKind_toString(*args):
  """
    UnitKind_toString(UnitKind_t uk) -> char

    Converts a UnitKind_t enumeration value to a text string equivalent.

    @param uk the UnitKind_t value to convert

    @return the name of the given UnitKind.

    @note The string returned is a static data value.  The caller does not
    own the returned string and is therefore not allowed to modify it.

    @note For more information about the UnitKind_t enumeration, please
    refer to the class documentation for Unit.


    """
  return _libsbml.UnitKind_toString(*args)

def UnitKind_isValidUnitKindString(*args):
  """
    UnitKind_isValidUnitKindString(char string, unsigned int level, unsigned int version) -> int

    Predicate for testing whether a given string corresponds to a
    predefined UnitKind_t enumeration value.

    @return nonzero (for true) if string is the name of a valid
    UnitKind_t enumeration value, zero (0) otherwise.

    @note For more information about the UnitKind_t enumeration, please
    refer to the class documentation for Unit.


    """
  return _libsbml.UnitKind_isValidUnitKindString(*args)
class Unit(SBase):
    """
    LibSBML implementation of SBML's %Unit construct.

    The SBML unit definition facility uses two classes of objects,
    UnitDefinition and Unit.  The approach to defining units in %SBML is
    compositional; for example, <em>meter second<sup> &ndash;2</sup></em> is
    constructed by combining a Unit object representing <em>meter</em> with
    another Unit object representing <em>second<sup> &ndash;2</sup></em>.
    The combination is wrapped inside a UnitDefinition, which provides for
    assigning an identifier and optional name to the combination.  The
    identifier can then be referenced from elsewhere in a model.  Thus, the
    UnitDefinition class is the container, and Unit instances are placed
    inside UnitDefinition instances.

    A Unit structure has four attributes named 'kind', 'exponent', 'scale'
    and 'multiplier'.  It represents a (possibly transformed) reference to a
    base unit.  The attribute 'kind' on Unit indicates the chosen base unit.
    Its value must be one of the text strings listed below; this list
    corresponds to SBML Level&nbsp;3 Version&nbsp;1 Core:

    @htmlinclude base-units.html

    This list of predefined base units is nearly identical in SBML
    Level&nbsp;2 Version&nbsp;4, the exception being that Level&nbsp;2 does
    not define @c avogadro.  In SBML Level&nbsp;2 Version&nbsp;1 models, the
    string @c Celsius is also permitted.  In SBML Level&nbsp;1 models, the
    strings @c meter and @c liter are also permitted.  In libSBML, each of
    the predefined base unit names is represented by an enumeration value in
    #UnitKind_t, discussed in a separate section below.

    The attribute named 'exponent' on Unit represents an exponent on the
    unit.  In SBML Level&nbsp;2, the attribute is optional and has a default
    value of @c 1 (one); in SBML Level&nbsp;3, the attribute is mandatory
    and there is no default value.  A Unit structure also has an attribute
    called 'scale'; its value must be an integer exponent for a power-of-ten
    multiplier used to set the scale of the unit.  For example, a unit
    having a 'kind' value of @c gram and a 'scale' value of @c -3 signifies
    10<sup>&nbsp;&ndash;3</sup> * gram, or milligrams.  In SBML
    Level&nbsp;2, the attribute is optional and has a default value of @c 0
    (zero), because 10<sup> 0</sup> = 1; in SBML Level&nbsp;3, the attribute
    is mandatory and has no default value.  Lastly, the attribute named
    'multiplier' can be used to multiply the unit by a real-numbered factor;
    this enables the definition of units that are not power-of-ten multiples
    of SI units.  For instance, a multiplier of 0.3048 could be used to
    define @c foot as a measure of length in terms of a @c metre.  The
    'multiplier' attribute is optional in SBML Level&nbsp;2, where it has a
    default value of @c 1 (one); in SBML Level&nbsp;3, the attribute is
    mandatory and has not default value.

    <h3><a class='anchor' name='UnitKind_t'>UnitKind_t</a></h3>

    As discussed above, SBML defines a set of base units which serves as the
    starting point for new unit definitions.  This set of base units
    consists of the SI units and a small number of additional convenience
    units.

    @if clike Until SBML Level&nbsp;2 Version&nbsp;3, there
    existed a data type in the SBML specifications called @c UnitKind,
    enumerating the possible SBML base units.  Although SBML Level&nbsp;2
    Version&nbsp;3 removed this type from the language specification,
    libSBML maintains the corresponding enumeration type #UnitKind_t as a
    convenience and as a way to provide backward compatibility to previous
    SBML Level/Version specifications.  (The removal in SBML Level&nbsp;2
    Version&nbsp;3 of the enumeration @c UnitKind was also accompanied by
    the redefinition of the data type @c UnitSId to include the previous @c
    UnitKind values as reserved symbols in the @c UnitSId space.  This
    change has no net effect on permissible models, their representation or
    their syntax.  The purpose of the change in the SBML specification was
    simply to clean up an inconsistency about the contexts in which these
    values were usable.)
    @endif@if java In SBML Level&nbsp;2 Versions before
    Version&nbsp;3, there existed an enumeration of units called @c
    UnitKind.  In Version&nbsp;3, this enumeration was removed and the
    identifier class @c UnitSId redefined to include the previous @c
    UnitKind values as reserved symbols.  This change has no net effect on
    permissible models, their representation or their syntax.  The purpose
    of the change in the SBML specification was simply to clean up an
    inconsistency about the contexts in which these values were usable.
    However, LibSBML maintains UnitKind in the form of of a set of static
    integer constants whose names begin with the characters
    <code>UNIT_KIND_</code>.  These constants are defined in the class
    <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>.
    @endif

    As a consequence of the fact that libSBML supports models in all Levels
    and Versions of SBML, libSBML's set of @c UNIT_KIND_ values is a union
    of all the possible base unit names defined in the different SBML
    specifications.  However, not every base unit is allowed in every
    Level+Version combination of SBML.  Note in particular the following
    exceptions:
    <ul>
    <li> The alternate spelling @c 'meter' is included in
    addition to the official SI spelling @c 'metre'.  This spelling is only
    permitted in SBML Level&nbsp;1 models.

    <li> The alternate spelling @c 'liter' is included in addition to the
    official SI spelling @c 'litre'.  This spelling is only permitted in
    SBML Level&nbsp;1 models.

    <li> The unit @c 'Celsius' is included because of its presence in
    specifications of SBML prior to SBML Level&nbsp;2 Version&nbsp;3.

    <li> The unit @c avogadro was introduced in SBML Level&nbsp;3, and
    is only permitted for use in SBML Level&nbsp;3 models.
    </ul>

    @if clike The table below lists the symbols defined in the
    @c UnitKind_t enumeration, and their
    meanings. @endif@if java The table below lists the unit
    constants defined in libSBML, and their meanings. @endif

    @htmlinclude unitkind-table.html

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Unit, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Unit, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Unit
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Unit
        __init__(self, SBMLNamespaces sbmlns) -> Unit
        __init__(self, Unit orig) -> Unit

        Predicate returning @c true if
        all the required attributes for this Unit object
        have been set.

        @note The required attributes for a Unit object are:
        @li 'kind'
        @li 'exponent' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)
        @li 'multiplier' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)
        @li 'scale' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Unit(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Unit

        Creates and returns a deep copy of this Unit.

        @return a (deep) copy of this Unit.
          

        """
        return _libsbml.Unit_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Unit object to 'typical' default
        values.

        The SBML Unit component has slightly different aspects and default
        attribute values in different SBML Levels and Versions.  This method
        sets the values to certain common defaults, based mostly on what they
        are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets attribute 'exponent' to @c 1
        <li> Sets attribute 'scale' to @c 0
        <li> Sets attribute 'multiplier' to @c 1.0
        </ul>

        The 'kind' attribute is left unchanged.
          

        """
        return _libsbml.Unit_initDefaults(self)

    def getKind(self):
        """
        getKind(self) -> UnitKind_t

        Returns the 'kind' of Unit this is.

        @return the value of the 'kind' attribute of this Unit as a value from
        the <a class='el' href='#UnitKind_t'>UnitKind_t</a> enumeration.
          

        """
        return _libsbml.Unit_getKind(self)

    def getExponent(self):
        """
        getExponent(self) -> int

        Returns the value of the 'exponent' attribute of this unit.

        @return the 'exponent' value of this Unit, as an integer.
          

        """
        return _libsbml.Unit_getExponent(self)

    def getExponentAsDouble(self):
        """
        getExponentAsDouble(self) -> double

        Returns the value of the 'exponent' attribute of this unit.

        @return the 'exponent' value of this Unit, as a double.
          

        """
        return _libsbml.Unit_getExponentAsDouble(self)

    def getScale(self):
        """
        getScale(self) -> int

        Returns the value of the 'scale' attribute of this unit.

        @return the 'scale' value of this Unit, as an integer.
          

        """
        return _libsbml.Unit_getScale(self)

    def getMultiplier(self):
        """
        getMultiplier(self) -> double

        Returns the value of the 'multiplier' attribute of this Unit.

        @return the 'multiplier' value of this Unit, as a double.
          

        """
        return _libsbml.Unit_getMultiplier(self)

    def getOffset(self):
        """
        getOffset(self) -> double

        Returns the value of the 'offset' attribute of this Unit.

        @warning The 'offset' attribute is only available in SBML Level&nbsp;2
        Version&nbsp;1.  This attribute is not present in SBML Level&nbsp;2
        Version&nbsp;2 or above.  When producing SBML models using these later
        specifications, modelers and software tools need to account for units
        with offsets explicitly.  The %SBML specification document offers a
        number of suggestions for how to achieve this.  LibSBML methods such
        as this one related to 'offset' are retained for compatibility with
        earlier versions of SBML Level&nbsp;2, but their use is strongly
        discouraged.

        @return the 'offset' value of this Unit, as a double.
          

        """
        return _libsbml.Unit_getOffset(self)

    def isAmpere(self):
        """
        isAmpere(self) -> bool

        Predicate for testing whether this Unit is of the kind @c ampere.

        @return @c true if the kind of this Unit is @c ampere, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isAmpere(self)

    def isAvogadro(self):
        """
        isAvogadro(self) -> bool

        Predicate for testing whether this Unit is of the kind @c avogadro.

        @return @c true if the kind of this Unit is @c avogadro, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isAvogadro(self)

    def isBecquerel(self):
        """
        isBecquerel(self) -> bool

        Predicate for testing whether this Unit is of the kind @c becquerel

        @return @c true if the kind of this Unit is @c becquerel, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isBecquerel(self)

    def isCandela(self):
        """
        isCandela(self) -> bool

        Predicate for testing whether this Unit is of the kind @c candela

        @return @c true if the kind of this Unit is @c candela, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isCandela(self)

    def isCelsius(self):
        """
        isCelsius(self) -> bool

        Predicate for testing whether this Unit is of the kind @c Celsius

        @return @c true if the kind of this Unit is @c Celsius, @c false
        otherwise. 

        @warning The predefined unit @c Celsius was removed from the list of
        predefined units in SBML Level&nbsp;2 Version&nbsp;2 at the same time
        that the 'offset' attribute was removed from Unit definitions.
        LibSBML methods such as this one related to @c Celsius are retained in
        order to support SBML Level&nbsp;2 Version&nbsp;1, but their use is
        strongly discouraged.
          

        """
        return _libsbml.Unit_isCelsius(self)

    def isCoulomb(self):
        """
        isCoulomb(self) -> bool

        Predicate for testing whether this Unit is of the kind @c coulomb

        @return @c true if the kind of this Unit is @c coulomb, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isCoulomb(self)

    def isDimensionless(self):
        """
        isDimensionless(self) -> bool

        Predicate for testing whether this Unit is of the kind @c
        dimensionless.

        @return @c true if the kind of this Unit is @c dimensionless, @c false

        otherwise.
          

        """
        return _libsbml.Unit_isDimensionless(self)

    def isFarad(self):
        """
        isFarad(self) -> bool

        Predicate for testing whether this Unit is of the kind @c farad

        @return @c true if the kind of this Unit is @c farad, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isFarad(self)

    def isGram(self):
        """
        isGram(self) -> bool

        Predicate for testing whether this Unit is of the kind @c gram

        @return @c true if the kind of this Unit is @c gram, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isGram(self)

    def isGray(self):
        """
        isGray(self) -> bool

        Predicate for testing whether this Unit is of the kind @c gray

        @return @c true if the kind of this Unit is @c gray, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isGray(self)

    def isHenry(self):
        """
        isHenry(self) -> bool

        Predicate for testing whether this Unit is of the kind @c henry

        @return @c true if the kind of this Unit is @c henry, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isHenry(self)

    def isHertz(self):
        """
        isHertz(self) -> bool

        Predicate for testing whether this Unit is of the kind @c hertz

        @return @c true if the kind of this Unit is @c hertz, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isHertz(self)

    def isItem(self):
        """
        isItem(self) -> bool

        Predicate for testing whether this Unit is of the kind @c item

        @return @c true if the kind of this Unit is @c item, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isItem(self)

    def isJoule(self):
        """
        isJoule(self) -> bool

        Predicate for testing whether this Unit is of the kind @c joule

        @return @c true if the kind of this Unit is @c joule, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isJoule(self)

    def isKatal(self):
        """
        isKatal(self) -> bool

        Predicate for testing whether this Unit is of the kind @c katal

        @return @c true if the kind of this Unit is @c katal, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isKatal(self)

    def isKelvin(self):
        """
        isKelvin(self) -> bool

        Predicate for testing whether this Unit is of the kind @c kelvin

        @return @c true if the kind of this Unit is @c kelvin, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isKelvin(self)

    def isKilogram(self):
        """
        isKilogram(self) -> bool

        Predicate for testing whether this Unit is of the kind @c kilogram

        @return @c true if the kind of this Unit is @c kilogram, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isKilogram(self)

    def isLitre(self):
        """
        isLitre(self) -> bool

        Predicate for testing whether this Unit is of the kind @c litre

        @return @c true if the kind of this Unit is @c litre or 'liter', @c
        false 
        otherwise.
          

        """
        return _libsbml.Unit_isLitre(self)

    def isLumen(self):
        """
        isLumen(self) -> bool

        Predicate for testing whether this Unit is of the kind @c lumen

        @return @c true if the kind of this Unit is @c lumen, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isLumen(self)

    def isLux(self):
        """
        isLux(self) -> bool

        Predicate for testing whether this Unit is of the kind @c lux

        @return @c true if the kind of this Unit is @c lux, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isLux(self)

    def isMetre(self):
        """
        isMetre(self) -> bool

        Predicate for testing whether this Unit is of the kind @c metre

        @return @c true if the kind of this Unit is @c metre or 'meter', @c
        false 
        otherwise.
          

        """
        return _libsbml.Unit_isMetre(self)

    def isMole(self):
        """
        isMole(self) -> bool

        Predicate for testing whether this Unit is of the kind @c mole

        @return @c true if the kind of this Unit is @c mole, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isMole(self)

    def isNewton(self):
        """
        isNewton(self) -> bool

        Predicate for testing whether this Unit is of the kind @c newton

        @return @c true if the kind of this Unit is @c newton, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isNewton(self)

    def isOhm(self):
        """
        isOhm(self) -> bool

        Predicate for testing whether this Unit is of the kind @c ohm

        @return @c true if the kind of this Unit is @c ohm, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isOhm(self)

    def isPascal(self):
        """
        isPascal(self) -> bool

        Predicate for testing whether this Unit is of the kind @c pascal

        @return @c true if the kind of this Unit is @c pascal, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isPascal(self)

    def isRadian(self):
        """
        isRadian(self) -> bool

        Predicate for testing whether this Unit is of the kind @c radian

        @return @c true if the kind of this Unit is @c radian, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isRadian(self)

    def isSecond(self):
        """
        isSecond(self) -> bool

        Predicate for testing whether this Unit is of the kind @c second

        @return @c true if the kind of this Unit is @c second, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isSecond(self)

    def isSiemens(self):
        """
        isSiemens(self) -> bool

        Predicate for testing whether this Unit is of the kind @c siemens

        @return @c true if the kind of this Unit is @c siemens, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isSiemens(self)

    def isSievert(self):
        """
        isSievert(self) -> bool

        Predicate for testing whether this Unit is of the kind @c sievert

        @return @c true if the kind of this Unit is @c sievert, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isSievert(self)

    def isSteradian(self):
        """
        isSteradian(self) -> bool

        Predicate for testing whether this Unit is of the kind @c steradian

        @return @c true if the kind of this Unit is @c steradian, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isSteradian(self)

    def isTesla(self):
        """
        isTesla(self) -> bool

        Predicate for testing whether this Unit is of the kind @c tesla

        @return @c true if the kind of this Unit is @c tesla, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isTesla(self)

    def isVolt(self):
        """
        isVolt(self) -> bool

        Predicate for testing whether this Unit is of the kind @c volt

        @return @c true if the kind of this Unit is @c volt, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isVolt(self)

    def isWatt(self):
        """
        isWatt(self) -> bool

        Predicate for testing whether this Unit is of the kind @c watt

        @return @c true if the kind of this Unit is @c watt, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isWatt(self)

    def isWeber(self):
        """
        isWeber(self) -> bool

        Predicate for testing whether this Unit is of the kind @c weber

        @return @c true if the kind of this Unit is @c weber, @c false
        otherwise. 
          

        """
        return _libsbml.Unit_isWeber(self)

    def isSetKind(self):
        """
        isSetKind(self) -> bool

        Predicate to test whether the 'kind' attribute of this Unit has been set.

        @return @c true if the 'kind' attribute of this Unit has been set, @c
        false otherwise.
          

        """
        return _libsbml.Unit_isSetKind(self)

    def isSetExponent(self):
        """
        isSetExponent(self) -> bool

        Predicate to test whether the 'exponent' attribute of this Unit 
        has been set.

        @return @c true if the 'exponent' attribute of this Unit has been set, 
        @c false otherwise.
          

        """
        return _libsbml.Unit_isSetExponent(self)

    def isSetScale(self):
        """
        isSetScale(self) -> bool

        Predicate to test whether the 'scale' attribute of this Unit 
        has been set.

        @return @c true if the 'scale' attribute of this Unit has been set, 
        @c false otherwise.
          

        """
        return _libsbml.Unit_isSetScale(self)

    def isSetMultiplier(self):
        """
        isSetMultiplier(self) -> bool

        Predicate to test whether the 'multiplier' attribute of this Unit 
        has been set.

        @return @c true if the 'multiplier' attribute of this Unit has been set, 
        @c false otherwise.
          

        """
        return _libsbml.Unit_isSetMultiplier(self)

    def setKind(self, *args):
        """
        setKind(self, UnitKind_t kind) -> int

        Sets the 'kind' attribute value of this Unit.

        @param kind a value from the <a class='el'
        href='#UnitKind_t'>UnitKind_t</a> enumeration

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Unit_setKind(self, *args)

    def setExponent(self, *args):
        """
        setExponent(self, int value) -> int
        setExponent(self, double value) -> int

        Sets the 'exponent' attribute value of this Unit.

        @param value the double to which the attribute 'exponent' should be set

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.Unit_setExponent(self, *args)

    def setScale(self, *args):
        """
        setScale(self, int value) -> int

        Sets the 'scale' attribute value of this Unit.

        @param value the integer to which the attribute 'scale' should be set

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.Unit_setScale(self, *args)

    def setMultiplier(self, *args):
        """
        setMultiplier(self, double value) -> int

        Sets the 'multipler' attribute value of this Unit.

        @param value the floating-point value to which the attribute
        'multiplier' should be set

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Unit_setMultiplier(self, *args)

    def setOffset(self, *args):
        """
        setOffset(self, double value) -> int

        Sets the 'offset' attribute value of this Unit.

        @param value the float-point value to which the attribute 'offset'
        should set

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @warning The 'offset' attribute is only available in SBML Level&nbsp;2
        Version&nbsp;1.  This attribute is not present in SBML Level&nbsp;2
        Version&nbsp;2 or above.  When producing SBML models using these later
        specifications, modelers and software tools need to account for units
        with offsets explicitly.  The %SBML specification document offers a
        number of suggestions for how to achieve this.  LibSBML methods such
        as this one related to 'offset' are retained for compatibility with
        earlier versions of SBML Level&nbsp;2, but their use is strongly
        discouraged.
          

        """
        return _libsbml.Unit_setOffset(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code of this object instance.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Unit_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Unit, is
        always @c 'unit'.

        @return the name of this element, i.e., @c 'unit'. 
          

        """
        return _libsbml.Unit_getElementName(self)

    def isBuiltIn(*args):
        """
        isBuiltIn(string name, unsigned int level) -> bool

        Predicate to test whether a given string is the name of a
        predefined SBML unit.

        @param name a string to be tested against the predefined unit names

        @param level the Level of SBML for which the determination should be
        made.  This is necessary because there are a few small differences
        in allowed units between SBML Level&nbsp;1 and Level&nbsp;2.

        @return @c true if @p name is one of the five SBML predefined unit
        identifiers (@c 'substance', @c 'volume', @c 'area', @c 'length' or @c
        'time'), @c false otherwise.

        @note The predefined unit identifiers @c 'length' and @c 'area' were
        added in Level&nbsp;2 Version&nbsp;1
          

        """
        return _libsbml.Unit_isBuiltIn(*args)

    if _newclass:isBuiltIn = staticmethod(isBuiltIn)
    __swig_getmethods__["isBuiltIn"] = lambda x: isBuiltIn
    def isUnitKind(*args):
        """
        isUnitKind(string name, unsigned int level, unsigned int version) -> bool

        Predicate to test whether a given string is the name of a valid
        base unit in SBML (such as @c 'gram' or @c 'mole').

        This method exists because prior to SBML Level&nbsp;2 Version&nbsp;3,
        an enumeration called @c UnitKind was defined by SBML.  This enumeration
        was removed in SBML Level&nbsp;2 Version&nbsp;3 and its values were
        folded into the space of values of a type called @c UnitSId.  This method
        therefore has less significance in SBML Level&nbsp;2 Version&nbsp;3
        and Level&nbsp;2 Version&nbsp;4, but remains for backward
        compatibility and support for reading models in older Versions of
        Level&nbsp;2.

        @param name a string to be tested

        @param level an unsigned int representing the SBML specification
        Level 

        @param version an unsigned int representing the SBML specification
        Version

        @return @c true if name is a valid UnitKind, @c false otherwise

        @note The allowed unit names differ between SBML Levels&nbsp;1
        and&nbsp;2 and again slightly between Level&nbsp;2 Versions&nbsp;1
        and&nbsp;2.
          

        """
        return _libsbml.Unit_isUnitKind(*args)

    if _newclass:isUnitKind = staticmethod(isUnitKind)
    __swig_getmethods__["isUnitKind"] = lambda x: isUnitKind
    def areIdentical(*args):
        """
        areIdentical(Unit unit1, Unit unit2) -> bool

        Predicate returning @c true if two
        Unit objects are identical.

        Two Unit objects are considered to be @em identical if they match in
        all attributes.  (Contrast this to the method areEquivalent(), which
        compares Unit objects only with respect to certain attributes.)

        @param unit1 the first Unit object to compare
        @param unit2 the second Unit object to compare

        @return @c true if all the attributes of unit1 are identical
        to the attributes of unit2, @c false otherwise.

        @see areEquivalent()
         

        """
        return _libsbml.Unit_areIdentical(*args)

    if _newclass:areIdentical = staticmethod(areIdentical)
    __swig_getmethods__["areIdentical"] = lambda x: areIdentical
    def areEquivalent(*args):
        """
        areEquivalent(Unit unit1, Unit unit2) -> bool

        Predicate returning @c true if 
        Unit objects are equivalent.

        Two Unit objects are considered to be @em equivalent either if (1) both
        have a 'kind' attribute value of @c dimensionless, or (2) their 'kind',
        'exponent' and (for SBML Level&nbsp;2 Version&nbsp;1) 'offset'
        attribute values are equal. (Contrast this to the method
        areIdentical(), which compares Unit objects with respect to all
        attributes, not just the 'kind' and 'exponent'.)

        @param unit1 the first Unit object to compare
        @param unit2 the second Unit object to compare

        @return @c true if the 'kind' and 'exponent' attributes of unit1 are
        identical to the kind and exponent attributes of unit2, @c false
        otherwise.

        @see areIdentical()
         

        """
        return _libsbml.Unit_areEquivalent(*args)

    if _newclass:areEquivalent = staticmethod(areEquivalent)
    __swig_getmethods__["areEquivalent"] = lambda x: areEquivalent
    def removeScale(*args):
        """
        removeScale(Unit unit) -> int

        Manipulates the attributes of the Unit to express the unit with the 
        value of the scale attribute reduced to zero.

        For example, 1 millimetre can be expressed as a Unit with kind=@c
        'metre' multiplier=@c '1' scale=@c '-3' exponent=@c '1'. It can also be
        expressed as a Unit with kind=@c 'metre'
        multiplier=<code>'0.001'</code> scale=@c '0' exponent=@c '1'.

        @param unit the Unit object to manipulate.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see convertToSI()
        @see merge()
         

        """
        return _libsbml.Unit_removeScale(*args)

    if _newclass:removeScale = staticmethod(removeScale)
    __swig_getmethods__["removeScale"] = lambda x: removeScale
    def merge(*args):
        """
        merge(Unit unit1, Unit unit2)

        Merges two Unit objects with the same 'kind' attribute value into a
        single Unit.

        For example, the following,
        @code
        <unit kind='metre' exponent='2'/>
        <unit kind='metre' exponent='1'/>
        @endcode
        would be merged to become
        @code
        <unit kind='metre' exponent='3'/>
        @endcode

        @param unit1 the first Unit object; the result of the operation is
        left as a new version of this unit, modified in-place.

        @param unit2 the second Unit object to merge with the first

        @see convertToSI()
        @see removeScale()
         

        """
        return _libsbml.Unit_merge(*args)

    if _newclass:merge = staticmethod(merge)
    __swig_getmethods__["merge"] = lambda x: merge
    def convertToSI(*args):
        """
        convertToSI(Unit unit) -> UnitDefinition

        Returns a UnitDefinition object containing the given @p unit converted
        to the appropriate SI unit.

        This method exists because some units can be expressed in terms of
        others when the same physical dimension is involved.  For example, one
        hertz is identical to 1&nbsp;sec<sup>-1</sup>, one litre is equivalent
        to 1 cubic decametre, and so on.

        @param unit the Unit object to convert to SI

        @return a UnitDefinition object containing the SI unit.

        @see merge()
         

        """
        return _libsbml.Unit_convertToSI(*args)

    if _newclass:convertToSI = staticmethod(convertToSI)
    __swig_getmethods__["convertToSI"] = lambda x: convertToSI
    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this Unit object
        have been set.

        @note The required attributes for a Unit object are:
        @li 'kind'
        @li 'exponent' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)
        @li 'multiplier' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)
        @li 'scale' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.Unit_hasRequiredAttributes(self)

Unit_swigregister = _libsbml.Unit_swigregister
Unit_swigregister(Unit)

def Unit_isBuiltIn(*args):
  """
    Unit_isBuiltIn(string name, unsigned int level) -> bool

    Predicate to test whether a given string is the name of a
    predefined SBML unit.

    @param name a string to be tested against the predefined unit names

    @param level the Level of SBML for which the determination should be
    made.  This is necessary because there are a few small differences
    in allowed units between SBML Level&nbsp;1 and Level&nbsp;2.

    @return @c true if @p name is one of the five SBML predefined unit
    identifiers (@c 'substance', @c 'volume', @c 'area', @c 'length' or @c
    'time'), @c false otherwise.

    @note The predefined unit identifiers @c 'length' and @c 'area' were
    added in Level&nbsp;2 Version&nbsp;1
      

    """
  return _libsbml.Unit_isBuiltIn(*args)

def Unit_isUnitKind(*args):
  """
    Unit_isUnitKind(string name, unsigned int level, unsigned int version) -> bool

    Predicate to test whether a given string is the name of a valid
    base unit in SBML (such as @c 'gram' or @c 'mole').

    This method exists because prior to SBML Level&nbsp;2 Version&nbsp;3,
    an enumeration called @c UnitKind was defined by SBML.  This enumeration
    was removed in SBML Level&nbsp;2 Version&nbsp;3 and its values were
    folded into the space of values of a type called @c UnitSId.  This method
    therefore has less significance in SBML Level&nbsp;2 Version&nbsp;3
    and Level&nbsp;2 Version&nbsp;4, but remains for backward
    compatibility and support for reading models in older Versions of
    Level&nbsp;2.

    @param name a string to be tested

    @param level an unsigned int representing the SBML specification
    Level 

    @param version an unsigned int representing the SBML specification
    Version

    @return @c true if name is a valid UnitKind, @c false otherwise

    @note The allowed unit names differ between SBML Levels&nbsp;1
    and&nbsp;2 and again slightly between Level&nbsp;2 Versions&nbsp;1
    and&nbsp;2.
      

    """
  return _libsbml.Unit_isUnitKind(*args)

def Unit_areIdentical(*args):
  """
    Unit_areIdentical(Unit unit1, Unit unit2) -> bool

    Predicate returning @c true if two
    Unit objects are identical.

    Two Unit objects are considered to be @em identical if they match in
    all attributes.  (Contrast this to the method areEquivalent(), which
    compares Unit objects only with respect to certain attributes.)

    @param unit1 the first Unit object to compare
    @param unit2 the second Unit object to compare

    @return @c true if all the attributes of unit1 are identical
    to the attributes of unit2, @c false otherwise.

    @see areEquivalent()
     

    """
  return _libsbml.Unit_areIdentical(*args)

def Unit_areEquivalent(*args):
  """
    Unit_areEquivalent(Unit unit1, Unit unit2) -> bool

    Predicate returning @c true if 
    Unit objects are equivalent.

    Two Unit objects are considered to be @em equivalent either if (1) both
    have a 'kind' attribute value of @c dimensionless, or (2) their 'kind',
    'exponent' and (for SBML Level&nbsp;2 Version&nbsp;1) 'offset'
    attribute values are equal. (Contrast this to the method
    areIdentical(), which compares Unit objects with respect to all
    attributes, not just the 'kind' and 'exponent'.)

    @param unit1 the first Unit object to compare
    @param unit2 the second Unit object to compare

    @return @c true if the 'kind' and 'exponent' attributes of unit1 are
    identical to the kind and exponent attributes of unit2, @c false
    otherwise.

    @see areIdentical()
     

    """
  return _libsbml.Unit_areEquivalent(*args)

def Unit_removeScale(*args):
  """
    Unit_removeScale(Unit unit) -> int

    Manipulates the attributes of the Unit to express the unit with the 
    value of the scale attribute reduced to zero.

    For example, 1 millimetre can be expressed as a Unit with kind=@c
    'metre' multiplier=@c '1' scale=@c '-3' exponent=@c '1'. It can also be
    expressed as a Unit with kind=@c 'metre'
    multiplier=<code>'0.001'</code> scale=@c '0' exponent=@c '1'.

    @param unit the Unit object to manipulate.

    @return integer value indicating success/failure of the function.  The
    possible values returned by this function are:
    @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

    @see convertToSI()
    @see merge()
     

    """
  return _libsbml.Unit_removeScale(*args)

def Unit_merge(*args):
  """
    Unit_merge(Unit unit1, Unit unit2)

    Merges two Unit objects with the same 'kind' attribute value into a
    single Unit.

    For example, the following,
    @code
    <unit kind='metre' exponent='2'/>
    <unit kind='metre' exponent='1'/>
    @endcode
    would be merged to become
    @code
    <unit kind='metre' exponent='3'/>
    @endcode

    @param unit1 the first Unit object; the result of the operation is
    left as a new version of this unit, modified in-place.

    @param unit2 the second Unit object to merge with the first

    @see convertToSI()
    @see removeScale()
     

    """
  return _libsbml.Unit_merge(*args)

def Unit_convertToSI(*args):
  """
    Unit_convertToSI(Unit unit) -> UnitDefinition

    Returns a UnitDefinition object containing the given @p unit converted
    to the appropriate SI unit.

    This method exists because some units can be expressed in terms of
    others when the same physical dimension is involved.  For example, one
    hertz is identical to 1&nbsp;sec<sup>-1</sup>, one litre is equivalent
    to 1 cubic decametre, and so on.

    @param unit the Unit object to convert to SI

    @return a UnitDefinition object containing the SI unit.

    @see merge()
     

    """
  return _libsbml.Unit_convertToSI(*args)

class ListOfUnits(ListOf):
    """
    LibSBML implementation of SBML's %ListOfUnits construct.

    The various ListOf___ classes in %SBML are merely containers used for
    organizing the main components of an %SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    ListOfUnits is entirely contained within UnitDefinition.

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfUnits, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfUnits, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfUnits

        Creates and returns a deep copy of this ListOfUnits.

        @return a (deep) copy of this ListOfUnits.
          

        """
        return _libsbml.ListOfUnits_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfUnits_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Unit objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfUnits_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfUnits, the XML element name is @c 'listOfUnits'.

        @return the name of this element, i.e., @c 'listOfUnits'.
          

        """
        return _libsbml.ListOfUnits_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Unit
        get(self, unsigned int n) -> Unit

        Get a Unit from the ListOfUnits.

        @param n the index number of the Unit to get.

        @return the nth Unit in this ListOfUnits.

        @see size()
          

        """
        return _libsbml.ListOfUnits_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Unit

        Removes the nth item from this ListOfUnits items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
          

        """
        return _libsbml.ListOfUnits_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfUnits"""
        this = _libsbml.new_ListOfUnits()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfUnits
    __del__ = lambda self : None;
ListOfUnits_swigregister = _libsbml.ListOfUnits_swigregister
ListOfUnits_swigregister(ListOfUnits)

class UnitDefinition(SBase):
    """
    LibSBML implementation of SBML's %UnitDefinition construct.

    Units of measurement may be supplied in a number of contexts in an SBML
    model.  The SBML unit definition facility uses two classes of objects,
    UnitDefinition and Unit.  The approach to defining units in SBML is
    compositional; for example, <em>meter second<sup> &ndash;2</sup></em> is
    constructed by combining a Unit object representing <em>meter</em> with
    another Unit object representing <em>second<sup> &ndash;2</sup></em>.
    The combination is wrapped inside a UnitDefinition, which provides for
    assigning an identifier and optional name to the combination.  The
    identifier can then be referenced from elsewhere in a model.  Thus, the
    UnitDefinition class is the container, and Unit instances are placed
    inside UnitDefinition instances.

    Two points are worth discussing in the context of SBML units.  First,
    unit declarations in SBML models are \@em optional.  The consequence of
    this is that a model must be numerically self-consistent independently
    of unit declarations, for the benefit of software tools that cannot
    interpret or manipulate units.  Unit declarations in SBML are thus more
    akin to a type of annotation; they can indicate intentions, and can be
    used by model readers for checking the consistency of the model,
    labeling simulation output, etc., but any transformations of values
    implied by different units must be incorporated \@em explicitly into a
    model.

    Second, the vast majority of situations that require new SBML unit
    definitions involve simple multiplicative combinations of base units and
    factors.  An example is <em>moles per litre per second</em>.  What
    distinguishes these sorts of unit definitions from more complex ones is
    that they may be expressed without the use of an additive offset from a
    zero point.  The use of offsets complicates all unit definition systems,
    yet in the domain of SBML, the real-life cases requiring offsets are few
    (and in fact, to the best of our knowledge, only involve temperature).
    Consequently, the SBML unit system has been consciously designed to
    simplify implementation of unit support for the most common cases in
    systems biology.  The cost of this simplification is to require units
    with offsets to be handled explicitly by the modeler.

    @section unitdef-summary Summary of the UnitDefinition construct

    UnitDefinition has two attributes and one subelement.  The two
    attributes are 'id' and 'name', and the subelement is ListOfUnits.

    The required attribute 'id' and optional attribute 'name' are both
    strings.  The 'id' attribute is used to give the defined unit a unique
    identifier by which other parts of an SBML model definition can refer to
    it.  The 'name' attribute is intended to be used for giving the unit
    definition an optional human-readable name.  Please see the <a
    href='#unitdef-id'>next section</a> for information about the values
    permitted for 'id'.

    A UnitDefinition must contain exactly one ListOfUnits, and this list
    must contain one or more Unit definitions; see the definitions of these
    other object classes for more information about them.  The following
    example illustrates a complete unit definition (when written in XML)
    when they all the pieces are combined together.  This defines 'mmls'
    to be millimoles per litre per second.
    @code
    <listOfUnitDefinitions>
        <unitDefinition id='mmls'>
            <listOfUnits>
                <unit kind='mole'   scale='-3'/>
                <unit kind='litre'  exponent='-1'/>
                <unit kind='second' exponent='-1'/>
            </listOfUnits>
        </unitDefinition>
    </listOfUnitDefinitions>
    @endcode

    @section unitdef-id Special considerations for Unit object identifiers

    The attribute 'id' in UnitDefinition cannot be given simply any value,
    and the precise details of the values permitted differ slightly between
    Levels of SBML:
    <ul>

    <li> The 'id' of a UnitDefinition must @em not contain a value from the
    list of SBML's predefined base unit names (i.e., the strings @c gram, @c
    litre, etc.).  In SBML Level&nbsp;3, this list consists of the
    following:

    @htmlinclude base-units2.html

    This list of predefined base units is nearly identical in SBML
    Level&nbsp;2 Version&nbsp;4, the exception being that Level&nbsp;2 does
    not define @c avogadro.  SBML Level&nbsp;2 Version&nbsp;1 (and only this
    Level+Version combination) provides an additional predefined unit name,
    @c Celsius.  SBML Level&nbsp;1 Versions&nbsp;2&ndash;3 provide two more
    additional predefined unit names, @c meter and @c liter.

    <li> In SBML Level&nbsp;2 (all Versions), there is an additional set of
    reserved identifiers: @c substance, @c volume, @c area, @c length, and
    @c time.  Using one of these values for the attribute 'id' of a
    UnitDefinition has the effect of redefining the model-wide default units
    for the corresponding quantities.  The list of special unit names in
    SBML Level&nbsp;2 is given in the table below:

      @htmlinclude predefined-units.html

    Also, SBML Level&nbsp;2 imposes two limitations on redefining the
    predefined unit @c substance, @c volume, @c area, @c length, and @c
    time: (1) The UnitDefinition of a predefined SBML unit can only contain
    a single Unit object within it.  (2) The value of the 'kind' attribute
    in a Unit instance must be drawn from one of the values in the second
    column of the table above.

    The special unit names @c substance, @c volume, @c area, @c length, and
    @c time are not defined by SBML Level&nbsp;3, which uses a different
    approach to setting model-wide inherited units.

    </ul>


    @section sbml-units-limits Further comments about SBML's unit definition system

    The vast majority of modeling situations requiring new SBML unit
    definitions involve simple multiplicative combinations of base units and
    factors.  An example of this might be <em>moles per litre per
    second</em>.  What distinguishes these sorts of simpler unit definitions
    from more complex ones is that they may be expressed without the use of
    an additive offset from a zero point.  The use of offsets complicates
    all unit definition systems, yet in the domain of SBML the real-life
    cases requiring offsets are few (and in fact, to the best of our
    knowledge, only involve temperature).  Consequently, the SBML unit
    system has been consciously designed in a way that attempts to simplify
    implementation of unit support for the most common cases in systems
    biology.

    As of SBML Level&nbsp;2 Version&nbsp;2, Unit no longer has the
    attribute called 'offset' introduced in SBML Level&nbsp;2
    Version&nbsp;1.  It turned out that the general case involving units
    with offsets was incorrectly defined, and few (if any) developers even
    attempted to support offset-based units in their software.  In the
    development of Level&nbsp;2 Version&nbsp;2, a consensus among SBML
    developers emerged that a fully generalized unit scheme is @em so
    confusing and complicated that it actually @em impedes interoperability.
    SBML Level&nbsp;2 Version&nbsp;2, Version&nbsp;3 and Version&nbsp;4 acknowledge this
    reality by reducing and simplifying the unit system, specifically by
    removing the 'offset' attribute on Unit and @c Celsius as a pre-defined
    unit.

    The following guidelines suggest methods for handling units that do
    require the use of zero offsets for their definitions:
    <ul>
    <li> <em>Handling Celsius</em>.  A model in which certain quantities are
      temperatures measured in degrees Celsius can be converted
      straightforwardly to a model in which those temperatures are in
      kelvin.  A software tool could do this by performing a straightforward
      substitution using the following relationship: T<sub> kelvin</sub> =
      T<sub> Celsius</sub> + 273.15.  In every mathematical formula of the
      model where a quantity (call it @em x) in degrees Celsius appears,
      replace @em x with x<sub> k</sub>+ 273.15, where x<sub> k</sub> is now
      in kelvin.  An alternative approach would be to use a
      FunctionDefinition to define a function encapsulating this
      relationship above and then using that in the rest of the model as
      needed.  Since Celsius is a commonly-used unit, software tools could
      help users by providing users with the ability to express temperatures
      in Celsius in the tools' interfaces, and making substitutions
      automatically when writing out the SBML.

    <li> <em>Other units requiring offsets</em>.  One approach to handling
      other kinds of units is to use a FunctionDefinition to define a function
      encapsulating the necessary mathematical relationship, then
      substituting a call to this function wherever the original quantity
      appeared in the model.  For example, here is a possible definition for
      converting Fahrenheit to Celsius degrees:
      @code
    <functionDefinition id='Fahrenheit_to_kelvin'>
        <math xmlns='http://www.w3.org/1998/Math/MathML'>
            <lambda>
                <bvar><ci> temp_in_fahrenheit </ci></bvar>
                <apply>
                    <divide/>
                    <apply>
                        <plus/>
                        <ci> temp_in_fahrenheit </ci>
                        <cn> 459.67 </cn>
                    </apply>
                    <cn> 1.8 </cn>
                </apply>
            </lambda>
        </math>
    </functionDefinition>
      @endcode
        
    <li> An alternative approach not requiring the use of function definitions
      is to use an AssignmentRule for each variable in Fahrenheit units.
      The AssignmentRule could compute the conversion from Fahrenheit to
      (say) kelvin, assign its value to a variable (in Kelvin units), and
      then that variable could be used elsewhere in the model.

    <li> Still another approach is to rewrite the mathematical formulas of a
      model to directly incorporate the conversion formula wherever the
      original quantity appeared.
    </ul>

    Please consult the SBML specifications for more information about this
    and other issues involving units.
     
    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnitDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnitDefinition, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_UnitDefinition
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> UnitDefinition
        __init__(self, SBMLNamespaces sbmlns) -> UnitDefinition
        __init__(self, UnitDefinition orig) -> UnitDefinition

        Predicate returning @c true if
        all the required elements for this UnitDefinition object
        have been set.

        @note The required elements for a Constraint object are:
        @li 'listOfUnits' (required in SBML Level&nbsp;2 only, optional in Level&nbsp;3)

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_UnitDefinition(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> UnitDefinition

        Creates and returns a deep copy of this UnitDefinition.

        @return a (deep) copy of this UnitDefinition.
          

        """
        return _libsbml.UnitDefinition_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this UnitDefinition.

        @return the id of this UnitDefinition.
          

        """
        return _libsbml.UnitDefinition_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this UnitDefinition.

        @return the name of this UnitDefinition.
          

        """
        return _libsbml.UnitDefinition_getName(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        UnitDefinition's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this UnitDefinition has been
        set, @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        UnitDefinition's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this UnitDefinition has been
        set, @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isSetName(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this UnitDefinition.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this UnitDefinition

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.UnitDefinition_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this UnitDefinition.

        The string in @p name is copied.

        @param name the new name for the UnitDefinition

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.UnitDefinition_setName(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this UnitDefinition.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.UnitDefinition_unsetName(self)

    def isVariantOfArea(self):
        """
        isVariantOfArea(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'area'.

        @return @c true if this UnitDefinition is a variant of the predefined
        unit @c area, meaning square metres with only abritrary variations
        in scale or multiplier values; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfArea(self)

    def isVariantOfLength(self):
        """
        isVariantOfLength(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'length'.

        @return @c true if this UnitDefinition is a variant of the predefined
        unit @c length, meaning metres with only abritrary variations in scale
        or multiplier values; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfLength(self)

    def isVariantOfSubstance(self):
        """
        isVariantOfSubstance(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'substance'.

        @return @c true if this UnitDefinition is a variant of the predefined
        unit @c substance, meaning moles or items (and grams or kilograms from
        SBML Level&nbsp;2 Version&nbsp;2 onwards) with only abritrary variations
        in scale or multiplier values; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfSubstance(self)

    def isVariantOfTime(self):
        """
        isVariantOfTime(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'time'.

        @return @c true if this UnitDefinition is a variant of the predefined
        unit @c time, meaning seconds with only abritrary variations in scale or
        multiplier values; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfTime(self)

    def isVariantOfVolume(self):
        """
        isVariantOfVolume(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'volume'.

        @return @c true if this UnitDefinition is a variant of the predefined
        unit @c volume, meaning litre or cubic metre with only abritrary
        variations in scale or multiplier values; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfVolume(self)

    def isVariantOfDimensionless(self):
        """
        isVariantOfDimensionless(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the unit @c 'dimensionless'.

        @return @c true if this UnitDefinition is a variant of @c
        dimensionless, meaning dimensionless with only abritrary variations in
        scale or multiplier values; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfDimensionless(self)

    def isVariantOfMass(self):
        """
        isVariantOfMass(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'mass'.

        @return @c true if this UnitDefinition is a variant of mass units,
        meaning gram or kilogram with only abritrary variations in scale or
        multiplier values; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfMass(self)

    def isVariantOfSubstancePerTime(self):
        """
        isVariantOfSubstancePerTime(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit @c 'substance' divided by the predefined
        unit @c 'time'.

        @return @c true if this UnitDefinition is a variant of the predefined
        unit @c substance per predefined unit @c time, meaning it contains two
        units one of which is a variant of substance and the other is a
        variant of time which an exponent of -1; @c false otherwise.
          

        """
        return _libsbml.UnitDefinition_isVariantOfSubstancePerTime(self)

    def addUnit(self, *args):
        """
        addUnit(self, Unit u) -> int

        Adds a copy of the given Unit to this UnitDefinition.

        @param u the Unit instance to add to this UnitDefinition.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this UnitDefinition.  Changes made to the original
        object instance (such as resetting attribute values) will <em>not
        affect the instance in the UnitDefinition</em>.  In addition, the
        caller should make sure to free the original object if it is no longer
        being used, or else a memory leak will result.  Please see
        UnitDefinition::createUnit() for a method that does not lead to these
        issues.

        @see createUnit()
          

        """
        return _libsbml.UnitDefinition_addUnit(self, *args)

    def createUnit(self):
        """
        createUnit(self) -> Unit

        Creates a new and empty Unit, adds it to this UnitDefinition's list of
        units, and returns it.

        @return a newly constructed (and empty) Unit instance.

        @note It is worth emphasizing that the attribute 'kind' value of a
        Unit is a required attribute for a valid Unit definition.  The
        createUnit() method does not assign a valid kind to the constructed
        unit (instead, it sets the 'kind' to @c UNIT_KIND_INVALID).  Callers
        are cautioned to set the newly-constructed Unit's kind using
        Unit::setKind() soon after calling this method.

        @see addUnit(const Unit* u)
          

        """
        return _libsbml.UnitDefinition_createUnit(self)

    def getListOfUnits(self, *args):
        """
        getListOfUnits(self) -> ListOfUnits
        getListOfUnits(self) -> ListOfUnits

        Returns the list of Units for this UnitDefinition instance.
        @return the ListOfUnits value for this UnitDefinition.
          

        """
        return _libsbml.UnitDefinition_getListOfUnits(self, *args)

    def getUnit(self, *args):
        """
        getUnit(self, unsigned int n) -> Unit
        getUnit(self, unsigned int n) -> Unit

        Returns a specific Unit instance belonging to this UnitDefinition.

        @param n an integer, the index of the Unit to be returned.

        @return the nth Unit of this UnitDefinition.
          

        """
        return _libsbml.UnitDefinition_getUnit(self, *args)

    def getNumUnits(self):
        """
        getNumUnits(self) -> unsigned int

        Returns the number of Unit objects contained within this
        UnitDefinition.

        @return an integer representing the number of Units in this
        UnitDefinition.
          

        """
        return _libsbml.UnitDefinition_getNumUnits(self)

    def removeUnit(self, *args):
        """
        removeUnit(self, unsigned int n) -> Unit

        Removes the nth Unit object from this UnitDefinition object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Unit object to remove

        @return the Unit object removed, or @c NULL if the given index 
        is out of range.

          

        """
        return _libsbml.UnitDefinition_removeUnit(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this object instance.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.UnitDefinition_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for UnitDefinition,
        is always @c 'unitDefinition'.

        @return the name of this element, i.e., @c 'unitDefinition'.
          

        """
        return _libsbml.UnitDefinition_getElementName(self)

    def simplify(*args):
        """
        simplify(UnitDefinition ud)

        Simplifies the UnitDefinition such that any given kind of Unit object
        occurs only once in the ListOfUnits.

        For example, the following definition,
        @code
        <unitDefinition>
         <listOfUnits>
           <unit kind='metre' exponent='1'/>
           <unit kind='metre' exponent='2'/>
         </listOfUnits>
        <unitDefinition>
        @endcode
        will be simplified to 
        @code
        <unitDefinition>
          <listOfUnits>
            <unit kind='metre' exponent='3'/>
          </listOfUnits>
        <unitDefinition>
        @endcode

        @param ud the UnitDefinition object to be simplified.
          

        """
        return _libsbml.UnitDefinition_simplify(*args)

    if _newclass:simplify = staticmethod(simplify)
    __swig_getmethods__["simplify"] = lambda x: simplify
    def reorder(*args):
        """
        reorder(UnitDefinition ud)

        Alphabetically orders the Unit objects within the ListOfUnits of a
        UnitDefinition.

        @param ud the UnitDefinition object whose units are to be reordered.
          

        """
        return _libsbml.UnitDefinition_reorder(*args)

    if _newclass:reorder = staticmethod(reorder)
    __swig_getmethods__["reorder"] = lambda x: reorder
    def convertToSI(*args):
        """
        convertToSI(UnitDefinition arg0) -> UnitDefinition

        Convert a given UnitDefinition into a new UnitDefinition object
        that uses SI units.

        @param ud the UnitDefinition object to convert to SI

        @return a new UnitDefinition object representing the results of the
        conversion.
          

        """
        return _libsbml.UnitDefinition_convertToSI(*args)

    if _newclass:convertToSI = staticmethod(convertToSI)
    __swig_getmethods__["convertToSI"] = lambda x: convertToSI
    def areIdentical(*args):
        """
        areIdentical(UnitDefinition ud1, UnitDefinition ud2) -> bool

        Predicate returning @c true if two
        UnitDefinition objects are identical.

        For the purposes of performing this comparison, two UnitDefinition
        objects are considered identical when they contain identical lists of
        Unit objects.  Pairs of Unit objects in the lists are in turn
        considered identical if they satisfy the predicate
        Unit::areIdentical().  The predicate compares every attribute of the
        Unit objects.

        @param ud1 the first UnitDefinition object to compare
        @param ud2 the second UnitDefinition object to compare

        @return @c true if all the Unit objects in ud1 are identical to the
        Unit objects of ud2, @c false otherwise.

        @see areEquivalent(const UnitDefinition * ud1, const %UnitDefinition * ud2)
        @see Unit::areIdentical(Unit * unit1, %Unit * unit2)
          

        """
        return _libsbml.UnitDefinition_areIdentical(*args)

    if _newclass:areIdentical = staticmethod(areIdentical)
    __swig_getmethods__["areIdentical"] = lambda x: areIdentical
    def areEquivalent(*args):
        """
        areEquivalent(UnitDefinition ud1, UnitDefinition ud2) -> bool

        Predicate returning @c true if two
        UnitDefinition objects are equivalent.

        For the purposes of performing this comparison, two UnitDefinition
        objects are considered equivalent when they contain @em equivalent
        list of Unit objects.  Unit objects are in turn considered equivalent
        if they satisfy the predicate Unit::areEquivalent().  The predicate
        tests a subset of the objects's attributes.

        @param ud1 the first UnitDefinition object to compare

        @param ud2 the second UnitDefinition object to compare

        @return @c true if all the Unit objects in ud1 are equivalent
        to the Unit objects in ud2, @c false otherwise.

        @see areIdentical(const UnitDefinition * ud1, const %UnitDefinition * ud2)
        @see Unit::areEquivalent(Unit * unit1, %Unit * unit2)
          

        """
        return _libsbml.UnitDefinition_areEquivalent(*args)

    if _newclass:areEquivalent = staticmethod(areEquivalent)
    __swig_getmethods__["areEquivalent"] = lambda x: areEquivalent
    def combine(*args):
        """
        combine(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition

        Combines two UnitDefinition objects into a single UnitDefinition.

        This takes UnitDefinition objects @p ud1 and @p ud2, and creates a
        UnitDefinition object that expresses the product of the units of @p
        ud1 and @p ud2.

        @param ud1 the first UnitDefinition object 
        @param ud2 the second UnitDefinition object

        @return a UnitDefinition which represents the product of the 
        units of the two argument UnitDefinitions.
          

        """
        return _libsbml.UnitDefinition_combine(*args)

    if _newclass:combine = staticmethod(combine)
    __swig_getmethods__["combine"] = lambda x: combine
    def printUnits(*args):
        """
        printUnits(UnitDefinition ud, bool compact = False) -> string
        printUnits(UnitDefinition ud) -> string

        Expresses the given definition in a plain-text form.

        For example, printUnits() applied to
        @code
        <unitDefinition>
         <listOfUnits>
           <unit kind='metre' exponent='1'/>
           <unit kind='second' exponent='-2'/>
         </listOfUnits>
        <unitDefinition>
        @endcode
        will return the string <code>'metre (exponent = 1, multiplier = 1,
        scale = 0) second (exponent = -2, multiplier = 1, scale = 0)'</code>
        or, if the optional parameter @p compact is given the value @c true,
        the string <code>'(1 metre)^1 (1 second)^-2'</code>.  This method may
        be useful for printing unit information to human users, or in
        debugging software, or other situations.

        @param ud the UnitDefinition object
        @param compact boolean indicating whether the compact form
        should be used (defaults to false)

        @return a string expressing the unit definition defined by the given
        UnitDefinition object @p ud.
          

        """
        return _libsbml.UnitDefinition_printUnits(*args)

    if _newclass:printUnits = staticmethod(printUnits)
    __swig_getmethods__["printUnits"] = lambda x: printUnits
    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this UnitDefinition object
        have been set.

        @note The required attributes for a UnitDefinition object are:
        @li 'id'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.UnitDefinition_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this UnitDefinition object
        have been set.

        @note The required elements for a Constraint object are:
        @li 'listOfUnits' (required in SBML Level&nbsp;2 only, optional in Level&nbsp;3)

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.UnitDefinition_hasRequiredElements(self)

UnitDefinition_swigregister = _libsbml.UnitDefinition_swigregister
UnitDefinition_swigregister(UnitDefinition)

def UnitDefinition_simplify(*args):
  """
    UnitDefinition_simplify(UnitDefinition ud)

    Simplifies the UnitDefinition such that any given kind of Unit object
    occurs only once in the ListOfUnits.

    For example, the following definition,
    @code
    <unitDefinition>
     <listOfUnits>
       <unit kind='metre' exponent='1'/>
       <unit kind='metre' exponent='2'/>
     </listOfUnits>
    <unitDefinition>
    @endcode
    will be simplified to 
    @code
    <unitDefinition>
      <listOfUnits>
        <unit kind='metre' exponent='3'/>
      </listOfUnits>
    <unitDefinition>
    @endcode

    @param ud the UnitDefinition object to be simplified.
      

    """
  return _libsbml.UnitDefinition_simplify(*args)

def UnitDefinition_reorder(*args):
  """
    UnitDefinition_reorder(UnitDefinition ud)

    Alphabetically orders the Unit objects within the ListOfUnits of a
    UnitDefinition.

    @param ud the UnitDefinition object whose units are to be reordered.
      

    """
  return _libsbml.UnitDefinition_reorder(*args)

def UnitDefinition_convertToSI(*args):
  """
    UnitDefinition_convertToSI(UnitDefinition arg0) -> UnitDefinition

    Convert a given UnitDefinition into a new UnitDefinition object
    that uses SI units.

    @param ud the UnitDefinition object to convert to SI

    @return a new UnitDefinition object representing the results of the
    conversion.
      

    """
  return _libsbml.UnitDefinition_convertToSI(*args)

def UnitDefinition_areIdentical(*args):
  """
    UnitDefinition_areIdentical(UnitDefinition ud1, UnitDefinition ud2) -> bool

    Predicate returning @c true if two
    UnitDefinition objects are identical.

    For the purposes of performing this comparison, two UnitDefinition
    objects are considered identical when they contain identical lists of
    Unit objects.  Pairs of Unit objects in the lists are in turn
    considered identical if they satisfy the predicate
    Unit::areIdentical().  The predicate compares every attribute of the
    Unit objects.

    @param ud1 the first UnitDefinition object to compare
    @param ud2 the second UnitDefinition object to compare

    @return @c true if all the Unit objects in ud1 are identical to the
    Unit objects of ud2, @c false otherwise.

    @see areEquivalent(const UnitDefinition * ud1, const %UnitDefinition * ud2)
    @see Unit::areIdentical(Unit * unit1, %Unit * unit2)
      

    """
  return _libsbml.UnitDefinition_areIdentical(*args)

def UnitDefinition_areEquivalent(*args):
  """
    UnitDefinition_areEquivalent(UnitDefinition ud1, UnitDefinition ud2) -> bool

    Predicate returning @c true if two
    UnitDefinition objects are equivalent.

    For the purposes of performing this comparison, two UnitDefinition
    objects are considered equivalent when they contain @em equivalent
    list of Unit objects.  Unit objects are in turn considered equivalent
    if they satisfy the predicate Unit::areEquivalent().  The predicate
    tests a subset of the objects's attributes.

    @param ud1 the first UnitDefinition object to compare

    @param ud2 the second UnitDefinition object to compare

    @return @c true if all the Unit objects in ud1 are equivalent
    to the Unit objects in ud2, @c false otherwise.

    @see areIdentical(const UnitDefinition * ud1, const %UnitDefinition * ud2)
    @see Unit::areEquivalent(Unit * unit1, %Unit * unit2)
      

    """
  return _libsbml.UnitDefinition_areEquivalent(*args)

def UnitDefinition_combine(*args):
  """
    UnitDefinition_combine(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition

    Combines two UnitDefinition objects into a single UnitDefinition.

    This takes UnitDefinition objects @p ud1 and @p ud2, and creates a
    UnitDefinition object that expresses the product of the units of @p
    ud1 and @p ud2.

    @param ud1 the first UnitDefinition object 
    @param ud2 the second UnitDefinition object

    @return a UnitDefinition which represents the product of the 
    units of the two argument UnitDefinitions.
      

    """
  return _libsbml.UnitDefinition_combine(*args)

def UnitDefinition_printUnits(*args):
  """
    printUnits(UnitDefinition ud, bool compact = False) -> string
    UnitDefinition_printUnits(UnitDefinition ud) -> string

    Expresses the given definition in a plain-text form.

    For example, printUnits() applied to
    @code
    <unitDefinition>
     <listOfUnits>
       <unit kind='metre' exponent='1'/>
       <unit kind='second' exponent='-2'/>
     </listOfUnits>
    <unitDefinition>
    @endcode
    will return the string <code>'metre (exponent = 1, multiplier = 1,
    scale = 0) second (exponent = -2, multiplier = 1, scale = 0)'</code>
    or, if the optional parameter @p compact is given the value @c true,
    the string <code>'(1 metre)^1 (1 second)^-2'</code>.  This method may
    be useful for printing unit information to human users, or in
    debugging software, or other situations.

    @param ud the UnitDefinition object
    @param compact boolean indicating whether the compact form
    should be used (defaults to false)

    @return a string expressing the unit definition defined by the given
    UnitDefinition object @p ud.
      

    """
  return _libsbml.UnitDefinition_printUnits(*args)

class ListOfUnitDefinitions(ListOf):
    """
    LibSBML implementation of SBML's %ListOfUnitDefinitions construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfUnitDefinitions, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfUnitDefinitions, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfUnitDefinitions

        Creates and returns a deep copy of this ListOfUnitDefinitions instance.

        @return a (deep) copy of this ListOfUnitDefinitions.
          

        """
        return _libsbml.ListOfUnitDefinitions_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfUnitDefinitions_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., UnitDefinition objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfUnitDefinitions_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfUnitDefinitions, the XML element name is @c
        'listOfUnitDefinitions'.

        @return the name of this element, i.e., @c 'listOfUnitDefinitions'.
          

        """
        return _libsbml.ListOfUnitDefinitions_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> UnitDefinition
        get(self, unsigned int n) -> UnitDefinition
        get(self, string sid) -> UnitDefinition
        get(self, string sid) -> UnitDefinition

        Get a UnitDefinition from the ListOfUnitDefinitions
        based on its identifier.

        @param sid a string representing the identifier 
        of the UnitDefinition to get.

        @return UnitDefinition in this ListOfUnitDefinitions
        with the given id or @c NULL if no such
        UnitDefinition exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfUnitDefinitions_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> UnitDefinition
        remove(self, string sid) -> UnitDefinition

        Removes item in this ListOfUnitDefinitions items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfUnitDefinitions_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfUnitDefinitions"""
        this = _libsbml.new_ListOfUnitDefinitions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfUnitDefinitions
    __del__ = lambda self : None;
ListOfUnitDefinitions_swigregister = _libsbml.ListOfUnitDefinitions_swigregister
ListOfUnitDefinitions_swigregister(ListOfUnitDefinitions)

class CompartmentType(SBase):
    """
    LibSBML implementation of SBML's Level&nbsp;2's %CompartmentType construct.

    SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 provide the <em>compartment
    type</em> as a grouping construct that can be used to establish a
    relationship between multiple Compartment objects.  A CompartmentType
    object only has an identity, and this identity can only be used to
    indicate that particular Compartment objects in the model belong to this
    type.  This may be useful for conveying a modeling intention, such as
    when a model contains many similar compartments, either by their
    biological function or the reactions they carry.  Without a compartment
    type construct, it would be impossible within SBML itself to indicate
    that all of the compartments share an underlying conceptual relationship
    because each SBML compartment must be given a unique and separate
    identity.  Compartment types have no mathematical meaning in
    SBML&mdash;they have no effect on a model's mathematical interpretation.
    Simulators and other numerical analysis software may ignore
    CompartmentType definitions and references to them in a model.

    There is no mechanism in SBML Level 2 for representing hierarchies of
    compartment types.  One CompartmentType instance cannot be the subtype
    of another CompartmentType instance; SBML provides no means of defining
    such relationships.

    As with other major structures in SBML, CompartmentType has a mandatory
    attribute, 'id', used to give the compartment type an identifier.  The
    identifier must be a text %string conforming to the identifer syntax
    permitted in SBML.  CompartmentType also has an optional 'name'
    attribute, of type @c string.  The 'id' and 'name' must be used
    according to the guidelines described in the SBML specification (e.g.,
    Section 3.3 in the Level 2 Version 4 specification).

    CompartmentType was introduced in SBML Level 2 Version 2.  It is not
    available in SBML Level&nbsp;1 nor in Level&nbsp;3.

    @see Compartment
    @see ListOfCompartmentTypes
    @see SpeciesType
    @see ListOfSpeciesTypes



    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompartmentType, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CompartmentType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_CompartmentType
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> CompartmentType
        __init__(self, SBMLNamespaces sbmlns) -> CompartmentType
        __init__(self, CompartmentType orig) -> CompartmentType

        Predicate returning @c true if
        all the required attributes for this CompartmentType object
        have been set.

        @note The required attributes for a CompartmentType object are:
        @li 'id'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_CompartmentType(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> CompartmentType

        Creates and returns a deep copy of this CompartmentType.

        @return a (deep) copy of this CompartmentType.
          

        """
        return _libsbml.CompartmentType_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this CompartmentType.

        @return the id of this CompartmentType.
          

        """
        return _libsbml.CompartmentType_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this CompartmentType.

        @return the name of this CompartmentType.
          

        """
        return _libsbml.CompartmentType_getName(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        CompartmentType's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this CompartmentType has been
        set, @c false otherwise.
          

        """
        return _libsbml.CompartmentType_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        CompartmentType's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this CompartmentTypeType has been
        set, @c false otherwise.
          

        """
        return _libsbml.CompartmentType_isSetName(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this CompartmentType.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this CompartmentType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.CompartmentType_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this CompartmentType.

        The string in @p name is copied.

        @param name the new name for the CompartmentType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.CompartmentType_setName(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this CompartmentType.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.CompartmentType_unsetName(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.CompartmentType_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        CompartmentType, is always @c 'compartmentType'.

        @return the name of this element, i.e., @c 'compartmentType'.
          

        """
        return _libsbml.CompartmentType_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this CompartmentType object
        have been set.

        @note The required attributes for a CompartmentType object are:
        @li 'id'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.CompartmentType_hasRequiredAttributes(self)

CompartmentType_swigregister = _libsbml.CompartmentType_swigregister
CompartmentType_swigregister(CompartmentType)

class ListOfCompartmentTypes(ListOf):
    """
    LibSBML implementation of SBML's %ListOfCompartmentTypes construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfCompartmentTypes, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfCompartmentTypes, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfCompartmentTypes

        Creates and returns a deep copy of this ListOfCompartmentTypes instance.

        @return a (deep) copy of this ListOfCompartmentTypes.
          

        """
        return _libsbml.ListOfCompartmentTypes_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfCompartmentTypes_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., CompartmentType objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfCompartmentTypes_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfCompartmentTypes, the XML element name is @c
        'listOfCompartmentTypes'.

        @return the name of this element, i.e., @c 'listOfCompartmentTypes'.
          

        """
        return _libsbml.ListOfCompartmentTypes_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> CompartmentType
        get(self, unsigned int n) -> CompartmentType
        get(self, string sid) -> CompartmentType
        get(self, string sid) -> CompartmentType

        Get a CompartmentType from the ListOfCompartmentTypes
        based on its identifier.

        @param sid a string representing the identifier 
        of the CompartmentType to get.

        @return CompartmentType in this ListOfCompartmentTypes
        with the given id or @c NULL if no such
        CompartmentType exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfCompartmentTypes_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> CompartmentType
        remove(self, string sid) -> CompartmentType

        Removes item in this ListOfCompartmentTypes items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfCompartmentTypes_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfCompartmentTypes"""
        this = _libsbml.new_ListOfCompartmentTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfCompartmentTypes
    __del__ = lambda self : None;
ListOfCompartmentTypes_swigregister = _libsbml.ListOfCompartmentTypes_swigregister
ListOfCompartmentTypes_swigregister(ListOfCompartmentTypes)

class SpeciesType(SBase):
    """
    LibSBML implementation of SBML Level&nbsp;2's %SpeciesType construct.

    The term @em species @em type refers to reacting entities independent of
    location.  These include simple ions (e.g., protons, calcium), simple
    molecules (e.g., glucose, ATP), large molecules (e.g., RNA,
    polysaccharides, and proteins), and others.

    SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 provide an explicit
    SpeciesType class of object to enable Species objects of the same type
    to be related together.  SpeciesType is a conceptual construct; the
    existence of SpeciesType objects in a model has no effect on the model's
    numerical interpretation.  Except for the requirement for uniqueness of
    species/species type combinations located in compartments, simulators
    and other numerical analysis software may ignore SpeciesType definitions
    and references to them in a model.

    There is no mechanism in SBML Level 2 for representing hierarchies of
    species types.  One SpeciesType object cannot be the subtype of another
    SpeciesType object; SBML provides no means of defining such
    relationships.

    As with other major structures in SBML, SpeciesType has a mandatory
    attribute, 'id', used to give the species type an identifier.  The
    identifier must be a text string conforming to the identifer syntax
    permitted in SBML.  SpeciesType also has an optional 'name' attribute,
    of type @c string.  The 'id' and 'name' must be used according to the
    guidelines described in the SBML specification (e.g., Section 3.3 in
    the Level&nbsp;2 Version&nbsp;4 specification).

    SpeciesType was introduced in SBML Level 2 Version 2.  It is not
    available in SBML Level&nbsp;1 nor in Level&nbsp;3.

    @see Species
    @see ListOfSpeciesTypes
    @see CompartmentType
    @see ListOfCompartmentTypes

    <!---------------------------------------------------------------------- -->


    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeciesType, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeciesType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SpeciesType
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> SpeciesType
        __init__(self, SBMLNamespaces sbmlns) -> SpeciesType
        __init__(self, SpeciesType orig) -> SpeciesType

        Predicate returning @c true if
        all the required attributes for this SpeciesType object
        have been set.

        @note The required attributes for a SpeciesType object are:
        @li 'id'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_SpeciesType(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SpeciesType

        Creates and returns a deep copy of this SpeciesType.

        @return a (deep) copy of this SpeciesType.
          

        """
        return _libsbml.SpeciesType_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this SpeciesType.

        @return the id of this SpeciesType.
          

        """
        return _libsbml.SpeciesType_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this SpeciesType.

        @return the name of this SpeciesType.
          

        """
        return _libsbml.SpeciesType_getName(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        SpeciesType's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this SpeciesType has been
        set, @c false otherwise.
          

        """
        return _libsbml.SpeciesType_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        SpeciesType's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this SpeciesType has been
        set, @c false otherwise.
          

        """
        return _libsbml.SpeciesType_isSetName(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this SpeciesType.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this SpeciesType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.SpeciesType_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this SpeciesType.

        The string in @p name is copied.

        @param name the new name for the SpeciesType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.SpeciesType_setName(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this SpeciesType.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.SpeciesType_unsetName(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.SpeciesType_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        SpeciesType, is always @c 'compartmentType'.

        @return the name of this element, i.e., @c 'compartmentType'.
          

        """
        return _libsbml.SpeciesType_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this SpeciesType object
        have been set.

        @note The required attributes for a SpeciesType object are:
        @li 'id'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.SpeciesType_hasRequiredAttributes(self)

SpeciesType_swigregister = _libsbml.SpeciesType_swigregister
SpeciesType_swigregister(SpeciesType)

class ListOfSpeciesTypes(ListOf):
    """
    LibSBML implementation of SBML's %ListOfSpeciesTypes construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfSpeciesTypes, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfSpeciesTypes, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfSpeciesTypes

        Creates and returns a deep copy of this ListOfSpeciesTypes instance.

        @return a (deep) copy of this ListOfSpeciesTypes.
          

        """
        return _libsbml.ListOfSpeciesTypes_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfSpeciesTypes_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., SpeciesType objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfSpeciesTypes_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfSpeciesTypes, the XML element name is @c
        'listOfSpeciesTypes'.

        @return the name of this element, i.e., @c 'listOfSpeciesTypes'.
          

        """
        return _libsbml.ListOfSpeciesTypes_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> SpeciesType
        get(self, unsigned int n) -> SpeciesType
        get(self, string sid) -> SpeciesType
        get(self, string sid) -> SpeciesType

        Get a SpeciesType from the ListOfSpeciesTypes
        based on its identifier.

        @param sid a string representing the identifier 
        of the SpeciesType to get.

        @return SpeciesType in this ListOfSpeciesTypes
        with the given id or @c NULL if no such
        SpeciesType exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfSpeciesTypes_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> SpeciesType
        remove(self, string sid) -> SpeciesType

        Removes item in this ListOfSpeciesTypes items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfSpeciesTypes_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfSpeciesTypes"""
        this = _libsbml.new_ListOfSpeciesTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfSpeciesTypes
    __del__ = lambda self : None;
ListOfSpeciesTypes_swigregister = _libsbml.ListOfSpeciesTypes_swigregister
ListOfSpeciesTypes_swigregister(ListOfSpeciesTypes)

class Compartment(SBase):
    """
    LibSBML implementation of SBML's %Compartment construct.

    A compartment in SBML represents a bounded space in which species are
    located.  Compartments do not necessarily have to correspond to actual
    structures inside or outside of a biological cell.

    It is important to note that although compartments are optional in the
    overall definition of Model, every species in an SBML model must be
    located in a compartment.  This in turn means that if a model defines
    any species, the model must also define at least one compartment.  The
    reason is simply that species represent physical things, and therefore
    must exist @em somewhere.  Compartments represent the @em somewhere.

    Compartment has one required attribute, 'id', to give the compartment a
    unique identifier by which other parts of an SBML model definition can
    refer to it.  A compartment can also have an optional 'name' attribute
    of type @c string.  Identifiers and names must be used according to the
    guidelines described in the SBML specifications.

    Compartment also has an optional attribute 'spatialDimensions' that is
    used to indicate the number of spatial dimensions possessed by the
    compartment.  Most modeling scenarios involve compartments with integer
    values of 'spatialDimensions' of @c 3 (i.e., a three-dimensional
    compartment, which is to say, a volume), or 2 (a two-dimensional
    compartment, a surface), or @c 1 (a one-dimensional compartment, a
    line).  In SBML Level&nbsp;3, the type of this attribute is @c double,
    there are no restrictions on the permitted values of the
    'spatialDimensions' attribute, and there are no default values.  In SBML
    Level&nbsp;2, the value must be a positive @c integer, and the default
    value is @c 3; the permissible values in SBML Level&nbsp;2 are @c 3, @c
    2, @c 1, and @c 0 (for a point).

    Another optional attribute on Compartment is 'size', representing the
    @em initial total size of that compartment in the model.  The 'size'
    attribute must be a floating-point value and may represent a volume (if
    the compartment is a three-dimensional one), or an area (if the
    compartment is two-dimensional), or a length (if the compartment is
    one-dimensional).  There is no default value of compartment size in SBML
    Level&nbsp;2 or Level&nbsp;3.  In particular, a missing 'size' value
    <em>does not imply that the compartment size is 1</em>.  (This is unlike
    the definition of compartment 'volume' in SBML Level&nbsp;1.)  When the
    compartment's 'spatialDimensions' attribute does not have a value of @c
    0, a missing value of 'size' for a given compartment signifies that the
    value either is unknown, or to be obtained from an external source, or
    determined by an InitialAssignment, AssignmentRule, AlgebraicRule or
    RateRule elsewhere in the model.  In SBML Level&nbsp;2, there are
    additional special requirements on the values of 'size'; we discuss them
    in a <a href='#comp-l2'>separate section below</a>.

    The units associated with a compartment's 'size' attribute value may be
    set using the optional attribute 'units'.  The rules for setting and
    using compartment size units differ between SBML Level&nbsp;2 and
    Level&nbsp;3, and are discussed separately below.

    Finally, the optional Compartment attribute named 'constant' is used to
    indicate whether the compartment's size stays constant after simulation
    begins.  A value of @c true indicates the compartment's 'size' cannot be
    changed by any other construct except InitialAssignment; a value of @c
    false indicates the compartment's 'size' can be changed by other
    constructs in SBML.  In SBML Level&nbsp;2, there is an additional
    explicit restriction that if 'spatialDimensions'=@c '0', the value
    cannot be changed by InitialAssignment either.  Further, in
    Level&nbsp;2, 'constant' has a default value of @c true.  In SBML
    Level&nbsp;3, there is no default value for the 'constant' attribute.


    @section comp-l2 Additional considerations in SBML Level&nbsp;2

    In SBML Level&nbsp;2, the default units of compartment size, and the
    kinds of units allowed as values of the attribute 'units', interact with
    the number of spatial dimensions of the compartment.  The value of the
    'units' attribute of a Compartment object must be one of the base units
    (see Unit), or the predefined unit identifiers @c volume, @c area, @c
    length or @c dimensionless, or a new unit defined by a UnitDefinition
    object in the enclosing Model, subject to the restrictions detailed in
    the following table:

    @htmlinclude compartment-size-restrictions.html 

    In SBML Level&nbsp;2, the units of the compartment size, as defined by the
    'units' attribute or (if 'units' is not set) the default value listed in
    the table above, are used in the following ways when the compartment has
    a 'spatialDimensions' value greater than @c 0:
    <ul>
    <li> The value of the 'units' attribute is used as the units of the
    compartment identifier when the identifier appears as a numerical
    quantity in a mathematical formula expressed in MathML.

    <li> The @c math element of an AssignmentRule or InitialAssignment
    referring to this compartment must have identical units.

    <li> In RateRule objects that set the rate of change of the compartment's
    size, the units of the rule's @c math element must be identical to the
    compartment's 'units' attribute divided by the default @em time units.
    (In other words, the units for the rate of change of compartment size
    are <em>compartment size</em>/<em>time</em> units.

    <li> When a Species is to be treated in terms of concentrations or
    density, the units of the spatial size portion of the concentration
    value (i.e., the denominator in the units formula @em substance/@em
    size) are those indicated by the value of the 'units' attribute on the
    compartment in which the species is located.
    </ul>

    Compartments with 'spatialDimensions'=@c 0 require special treatment in
    this framework.  As implied above, the 'size' attribute must not have a
    value on an SBML Level&nbsp;2 Compartment object if the
    'spatialDimensions' attribute has a value of @c 0.  An additional
    related restriction is that the 'constant' attribute must default to or
    be set to @c true if the value of the 'spatialDimensions' attribute is
    @c 0, because a zero-dimensional compartment cannot ever have a size.

    If a compartment has no size or dimensional units, how should such a
    compartment's identifier be interpreted when it appears in mathematical
    formulas?  The answer is that such a compartment's identifier should not
    appear in mathematical formulas in the first place&mdash;it has no
    value, and its value cannot change.  Note also that a zero-dimensional
    compartment is a point, and species located at points can only be
    described in terms of amounts, not spatially-dependent measures such as
    concentration.  Since SBML KineticLaw formulas are already in terms of
    @em substance/@em time and not (say) @em concentration/@em time, volume
    or other factors in principle are not needed for species located in
    zero-dimensional compartments.

    Finally, in SBML Level&nbsp;2 Versions 2&ndash;4, each compartment in a
    model may optionally be designated as belonging to a particular
    compartment @em type.  The optional attribute 'compartmentType' is used
    identify the compartment type represented by the Compartment structure.
    The 'compartmentType' attribute's value must be the identifier of a
    CompartmentType instance defined in the model.  If the 'compartmentType'
    attribute is not present on a particular compartment definition, a
    unique virtual compartment type is assumed for that compartment, and no
    other compartment can belong to that compartment type.  The values of
    'compartmentType' attributes on compartments have no effect on the
    numerical interpretation of a model.  Simulators and other numerical
    analysis software may ignore 'compartmentType' attributes.  The
    'compartmentType' attribute and the CompartmentType class of objects are
    not present in SBML Level&nbsp;3 Core nor in SBML Level&nbsp;1.


    @section comp-l3 Additional considerations in SBML Level&nbsp;3

    One difference between SBML Level&nbsp;3 and lower Levels of SBML is
    that there are no restrictions on the permissible values of the
    'spatialDimensions' attribute, and there is no default value defined for
    the attribute.  The value of 'spatialDimensions' does not have to be an
    integer, either; this is to allow for the possibility of representing
    structures with fractal dimensions.

    The number of spatial dimensions possessed by a compartment cannot enter
    into mathematical formulas, and therefore cannot directly alter the
    numerical interpretation of a model.  However, the value of
    'spatialDimensions' @em does affect the interpretation of the units
    associated with a compartment's size.  Specifically, the value of
    'spatialDimensions' is used to select among the Model attributes
    'volumeUnits', 'areaUnits' and 'lengthUnits' when a Compartment object
    does not define a value for its 'units' attribute.

    The 'units' attribute may be left unspecified for a given compartment in
    a model; in that case, the compartment inherits the unit of measurement
    specified by one of the attributes on the enclosing Model object
    instance.  The applicable attribute on Model depends on the value of the
    compartment's 'spatialDimensions' attribute; the relationship is shown
    in the table below.  If the Model object does not define the relevant
    attribute ('volumeUnits', 'areaUnits' or 'lengthUnits') for a given
    'spatialDimensions' value, the unit associated with that Compartment
    object's size is undefined.  If @em both 'spatialDimensions' and 'units'
    are left unset on a given Compartment object instance, then no unit can
    be chosen from among the Model's 'volumeUnits', 'areaUnits' or
    'lengthUnits' attributes (even if the Model instance provides values for
    those attributes), because there is no basis to select between them and
    there is no default value of 'spatialDimensions'.  Leaving the units of
    compartments' sizes undefined in an SBML model does not render the model
    invalid; however, as a matter of best practice, we strongly recommend
    that all models specify the units of measurement for all compartment
    sizes.

    @htmlinclude compartment-size-recommendations.html

    The unit of measurement associated with a compartment's size, as defined
    by the 'units' attribute or (if 'units' is not set) the inherited value
    from Model according to the table above, is used in the following ways:

    <ul>

    <li> When the identifier of the compartment appears as a numerical
    quantity in a mathematical formula expressed in MathML, it represents
    the size of the compartment, and the unit associated with the size is
    the value of the 'units' attribute.

    <li> When a Species is to be treated in terms of concentrations or
    density, the unit associated with the spatial size portion of the
    concentration value (i.e., the denominator in the formula
    <em>amount</em>/<em>size</em>) is specified by the value of the 'units'
    attribute on the compartment in which the species is located.

    <li> The 'math' elements of AssignmentRule, InitialAssignment and
    EventAssignment objects setting the value of the compartment size
    should all have the same units as the unit associated with the
    compartment's size.

    <li> In a RateRule object that defines a rate of change for a
    compartment's size, the unit of the rule's 'math' element should be
    identical to the compartment's 'units' attribute divided by the
    model-wide unit of <em>time</em>.  (In other words, {<em>unit of
    compartment size</em>}/{<em>unit of time</em>}.)

    </ul>


    @section comp-other Other aspects of Compartment

    In SBML Level&nbsp;1 and Level&nbsp;2, Compartment has an optional
    attribute named 'outside', whose value can be the identifier of another
    Compartment object defined in the enclosing Model object.  Doing so
    means that the other compartment contains it or is outside of it.  This
    enables the representation of simple topological relationships between
    compartments, for those simulation systems that can make use of the
    information (e.g., for drawing simple diagrams of compartments).  It is
    worth noting that in SBML, there is no relationship between compartment
    sizes when compartment positioning is expressed using the 'outside'
    attribute.  The size of a given compartment does not in any sense
    include the sizes of other compartments having it as the value of their
    'outside' attributes.  In other words, if a compartment @em B has the
    identifier of compartment @em A as its 'outside' attribute value, the
    size of @em A does not include the size of @em B.  The compartment sizes
    are separate.

    In Level&nbsp;2, there are two restrictions on the 'outside' attribute.
    First, because a compartment with 'spatialDimensions' of @c 0 has no
    size, such a compartment cannot act as the container of any other
    compartment @em except compartments that @em also have
    'spatialDimensions' values of @c 0.  Second, the directed graph formed
    by representing Compartment structures as vertexes and the 'outside'
    attribute values as edges must be acyclic.  The latter condition is
    imposed to prevent a compartment from being contained inside itself.  In
    the absence of a value for 'outside', compartment definitions in SBML
    Level&nbsp;2 do not have any implied spatial relationships between each
    other.


    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Compartment, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Compartment, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Compartment
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Compartment
        __init__(self, SBMLNamespaces sbmlns) -> Compartment
        __init__(self, Compartment orig) -> Compartment

        This is a constructor that takes no arguments and 
        only exists because the validator code needs it.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Compartment(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Compartment

        Creates and returns a deep copy of this Compartment object.

        @return a (deep) copy of this Compartment.
          

        """
        return _libsbml.Compartment_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Compartment object to 'typical' default
        values.

        The SBML Compartment component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets attribute 'spatialDimensions' to @c 3
        <li> Sets attribute 'constant' to @c true
        <li> (Applies to Level&nbsp;1 models only) Sets attribute 'volume' to @c 1.0
        </ul>
          

        """
        return _libsbml.Compartment_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Compartment object.

        @return the id of this Compartment.
          

        """
        return _libsbml.Compartment_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Compartment object.

        @return the name of this Compartment.
          

        """
        return _libsbml.Compartment_getName(self)

    def getCompartmentType(self):
        """
        getCompartmentType(self) -> string

        Get the value of the 'compartmentType' attribute of this Compartment
        object.

        @return the value of the 'compartmentType' attribute of this
        Compartment as a string.

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Compartment_getCompartmentType(self)

    def getSpatialDimensions(self):
        """
        getSpatialDimensions(self) -> unsigned int

        Get the number of spatial dimensions of this Compartment object.

        @note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'
        attribute is @c double, whereas in Level&nbsp;2, it is @c integer.
        LibSBML provides a separate method for obtaining the value as a double,
        for models where it is relevant.

        @return the value of the 'spatialDimensions' attribute of this
        Compartment as an unsigned integer

        @see getSpatialDimensionsAsDouble()
          

        """
        return _libsbml.Compartment_getSpatialDimensions(self)

    def getSpatialDimensionsAsDouble(self):
        """
        getSpatialDimensionsAsDouble(self) -> double

        Get the number of spatial dimensions of this Compartment object
        as a double.

        @note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'
        attribute is @c double, whereas in Level&nbsp;2, it is @c integer.  To
        avoid backward compatibility issues, libSBML provides a separate
        method for obtaining the value as a double, for models where it is
        relevant.

        @return the value of the 'spatialDimensions' attribute of this
        Compartment as a double, or @c NaN if this model is not in SBML
        Level&nbsp;3 format.

        @see getSpatialDimensions()
          

        """
        return _libsbml.Compartment_getSpatialDimensionsAsDouble(self)

    def getSize(self):
        """
        getSize(self) -> double

        Get the size of this Compartment.

        This method is identical to getVolume().  In SBML Level&nbsp;1,
        compartments are always three-dimensional constructs and only have
        volumes, whereas in SBML Level&nbsp;2, compartments may be other than
        three-dimensional and therefore the 'volume' attribute is named 'size'
        in Level&nbsp;2.  LibSBML provides both getSize() and getVolume() for
        easier compatibility between SBML Levels.

        @return the value of the 'size' attribute ('volume' in Level&nbsp;1) of
        this Compartment as a float-point number.

        @see isSetSize()
        @see getVolume()
          

        """
        return _libsbml.Compartment_getSize(self)

    def getVolume(self):
        """
        getVolume(self) -> double

        Get the volume of this Compartment.

        This method is identical to getSize().  In SBML Level&nbsp;1, compartments
        are always three-dimensional constructs and only have volumes, whereas
        in SBML Level&nbsp;2, compartments may be other than three-dimensional and
        therefore the 'volume' attribute is named 'size' in Level&nbsp;2.  LibSBML
        provides both getSize() and getVolume() for easier compatibility
        between SBML Levels.

        @return the value of the 'volume' attribute ('size' in Level&nbsp;2) of
        this Compartment, as a floating-point number.

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.

        @see isSetVolume()
        @see getSize()
          

        """
        return _libsbml.Compartment_getVolume(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Get the units of this compartment's size.

        The value of an SBML compartment's 'units' attribute establishes the
        unit of measurement associated with the compartment's size.

        @return the value of the 'units' attribute of this Compartment, as a
        string.  An empty string indicates that no units have been assigned to
        the value of the size.

        @note @htmlinclude unassigned-units-are-not-a-default.html

        @see isSetUnits()
        @see setUnits()
        @see getSize()
          

        """
        return _libsbml.Compartment_getUnits(self)

    def getOutside(self):
        """
        getOutside(self) -> string

        Get the identifier, if any, of the compartment that is designated
        as being outside of this one.

        @return the value of the 'outside' attribute of this Compartment.

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.
          

        """
        return _libsbml.Compartment_getOutside(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Get the value of the 'constant' attribute of this Compartment.

        @return @c true if this Compartment's size is flagged as being
        constant, @c false otherwise.
          

        """
        return _libsbml.Compartment_getConstant(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        Compartment's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this Compartment has been
        set, @c false otherwise.
          

        """
        return _libsbml.Compartment_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        Compartment's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this Compartment has been
        set, @c false otherwise.
          

        """
        return _libsbml.Compartment_isSetName(self)

    def isSetCompartmentType(self):
        """
        isSetCompartmentType(self) -> bool

        Predicate returning @c true if this
        Compartment's 'compartmentType' attribute has been set.

        @return @c true if the 'compartmentType' attribute of this Compartment
        has been set, @c false otherwise.

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Compartment_isSetCompartmentType(self)

    def isSetSize(self):
        """
        isSetSize(self) -> bool

        Predicate returning @c true if this
        Compartment's 'size' attribute has been set.

        This method is similar but not identical to isSetVolume().  The latter
        should be used in the context of SBML Level&nbsp;1 models instead of
        isSetSize() because isSetVolume() performs extra processing to take
        into account the difference in default values between SBML Levels 1
        and 2.

        @return @c true if the 'size' attribute ('volume' in Level&nbsp;2) of
        this Compartment has been set, @c false otherwise.

        @see isSetVolume()
        @see setSize(double value)
          

        """
        return _libsbml.Compartment_isSetSize(self)

    def isSetVolume(self):
        """
        isSetVolume(self) -> bool

        Predicate returning @c true if this Compartment's
        'volume' attribute has been set.

        This method is similar but not identical to isSetSize().  The latter
        should not be used in the context of SBML Level&nbsp;1 models because this
        method (isSetVolume()) performs extra processing to take into account
        the difference in default values between SBML Levels 1 and 2.

        @return @c true if the 'volume' attribute ('size' in Level&nbsp;2 and
        above) of this Compartment has been set, @c false otherwise.

        @see isSetSize()
        @see setVolume(double value)

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.  In SBML Level&nbsp;1, a compartment's volume has a
        default value (@c 1.0) and therefore this method will always return @c
        true.  In Level 2, a compartment's size (the equivalent of SBML
        Level&nbsp;1's 'volume') is optional and has no default value, and
        therefore may or may not be set.
          

        """
        return _libsbml.Compartment_isSetVolume(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c true if this
        Compartment's 'units' attribute has been set.

        @return @c true if the 'units' attribute of this Compartment has been
        set, @c false otherwise.

        @note @htmlinclude unassigned-units-are-not-a-default.html
          

        """
        return _libsbml.Compartment_isSetUnits(self)

    def isSetOutside(self):
        """
        isSetOutside(self) -> bool

        Predicate returning @c true if this
        Compartment's 'outside' attribute has been set.

        @return @c true if the 'outside' attribute of this Compartment has
        been set, @c false otherwise.

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.
          

        """
        return _libsbml.Compartment_isSetOutside(self)

    def isSetSpatialDimensions(self):
        """
        isSetSpatialDimensions(self) -> bool

        Predicate returning @c true if this
        Compartment's 'spatialDimensions' attribute has been set.

        @return @c true if the 'spatialDimensions' attribute of this
        Compartment has been set, @c false otherwise.
          

        """
        return _libsbml.Compartment_isSetSpatialDimensions(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c true if this
        Compartment's 'constant' attribute has been set.

        @return @c true if the 'constant' attribute of this Compartment has
        been set, @c false otherwise.
          

        """
        return _libsbml.Compartment_isSetConstant(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Compartment.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this Compartment

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Compartment_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Compartment.

        The string in @p name is copied.

        @param name the new name for the Compartment

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Compartment_setName(self, *args)

    def setCompartmentType(self, *args):
        """
        setCompartmentType(self, string sid) -> int

        Sets the 'compartmentType' attribute of this Compartment.

        @param sid the identifier of a CompartmentType object defined
        elsewhere in this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Compartment_setCompartmentType(self, *args)

    def setSpatialDimensions(self, *args):
        """
        setSpatialDimensions(self, unsigned int value) -> int
        setSpatialDimensions(self, double value) -> int

        Sets the 'spatialDimensions' attribute of this Compartment as a double.

        @param value a double indicating the number of dimensions
        of this compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Compartment_setSpatialDimensions(self, *args)

    def setSize(self, *args):
        """
        setSize(self, double value) -> int

        Sets the 'size' attribute (or 'volume' in SBML Level&nbsp;1) of this
        Compartment.

        This method is identical to setVolume() and is provided for
        compatibility between SBML Level&nbsp;1 and Level&nbsp;2.

        @param value a @c double representing the size of this compartment
        instance in whatever units are in effect for the compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.
          

        """
        return _libsbml.Compartment_setSize(self, *args)

    def setVolume(self, *args):
        """
        setVolume(self, double value) -> int

        Sets the 'volume' attribute (or 'size' in SBML Level&nbsp;2) of this
        Compartment.

        This method is identical to setVolume() and is provided for
        compatibility between SBML Level&nbsp;1 and Level&nbsp;2.

        @param value a @c double representing the volume of this compartment
        instance in whatever units are in effect for the compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.
          

        """
        return _libsbml.Compartment_setVolume(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string sid) -> int

        Sets the 'units' attribute of this Compartment.

        @param sid the identifier of the defined units to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Compartment_setUnits(self, *args)

    def setOutside(self, *args):
        """
        setOutside(self, string sid) -> int

        Sets the 'outside' attribute of this Compartment.

        @param sid the identifier of a compartment that encloses this one.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.
          

        """
        return _libsbml.Compartment_setOutside(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool value) -> int

        Sets the value of the 'constant' attribute of this Compartment.

        @param value a boolean indicating whether the size/volume of this
        compartment should be considered constant (@c true) or variable (@c
        false)

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Compartment_setConstant(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Compartment_unsetName(self)

    def unsetCompartmentType(self):
        """
        unsetCompartmentType(self) -> int

        Unsets the value of the 'compartmentType'
        attribute of this Compartment.

        @see setCompartmentType(const std::string& sid)
        @see isSetCompartmentType()

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Compartment_unsetCompartmentType(self)

    def unsetSize(self):
        """
        unsetSize(self) -> int

        Unsets the value of the 'size' attribute of this Compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.
          

        """
        return _libsbml.Compartment_unsetSize(self)

    def unsetVolume(self):
        """
        unsetVolume(self) -> int

        Unsets the value of the 'volume' attribute of this
        Compartment.

        In SBML Level&nbsp;1, a Compartment volume has a default value (1.0) and
        therefore <em>should always be set</em>.  In Level&nbsp;2, 'size' is
        optional with no default value and as such may or may not be set.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.
          

        """
        return _libsbml.Compartment_unsetVolume(self)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the value of the 'units' attribute of this Compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Compartment_unsetUnits(self)

    def unsetOutside(self):
        """
        unsetOutside(self) -> int

        Unsets the value of the 'outside' attribute of this Compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.
          

        """
        return _libsbml.Compartment_unsetOutside(self)

    def unsetSpatialDimensions(self):
        """
        unsetSpatialDimensions(self) -> int

        Unsets the value of the 'spatialDimensions' attribute of this Compartment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This function is only valid for SBML Level&nbsp;3.
          

        """
        return _libsbml.Compartment_unsetSpatialDimensions(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this Compartment's designated size.

        Compartments in SBML have an attribute ('units') for declaring the
        units of measurement intended for the value of the compartment's size.
        In the absence of a value given for this attribute, the units are
        inherited from values either defined on the enclosing Model (in SBML
        Level&nbsp;3) or in defaults (in SBML Level&nbsp;2).  This method
        returns a UnitDefinition object based on how this compartment's units
        are interpreted according to the relevant SBML guidelines, or it
        returns @c NULL if no units have been declared and no defaults are
        defined by the relevant SBML specification.

        Note that unit declarations for Compartment objects are specified in
        terms of the @em identifier of a unit (e.g., using setUnits()), but
        @em this method returns a UnitDefinition object, not a unit
        identifier.  It does this by constructing an appropriate
        UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even
        when the value of the 'units' attribute is one of the special SBML
        Level&nbsp;2 unit identifiers @c 'substance', @c 'volume', @c 'area',
        @c 'length' or @c 'time'.  Callers may find this useful in conjunction
        with the helper methods provided by the UnitDefinition class for
        comparing different UnitDefinition objects.

        @return a UnitDefinition that expresses the units of this 
        Compartment, or @c NULL if one cannot be constructed.

        @note The libSBML system for unit analysis depends on the model as a
        whole.  In cases where the Compartment object has not yet been added
        to a model, or the model itself is incomplete, unit analysis is not
        possible, and consequently this method will return @c NULL.

        @see isSetUnits()
        @see getUnits()
          

        """
        return _libsbml.Compartment_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Compartment_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Compartment, is
        always @c 'compartment'.

        @return the name of this element, i.e., @c 'compartment'.
          

        """
        return _libsbml.Compartment_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this Compartment object
        have been set.

        @note The required attributes for a Compartment object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'constant' (in SBML Level&nbsp;3 only)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.Compartment_hasRequiredAttributes(self)

Compartment_swigregister = _libsbml.Compartment_swigregister
Compartment_swigregister(Compartment)

class ListOfCompartments(ListOf):
    """
    LibSBML implementation of SBML Level&nbsp;2's %ListOfCompartments construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfCompartments, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfCompartments, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfCompartments

        Creates and returns a deep copy of this ListOfCompartments instance.

        @return a (deep) copy of this ListOfCompartments.
          

        """
        return _libsbml.ListOfCompartments_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).
        @see getElementName()
          

        """
        return _libsbml.ListOfCompartments_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Compartment objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfCompartments_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfCompartments, the XML element name is @c 'listOfCompartments'.

        @return the name of this element, i.e., @c 'listOfCompartments'.
          

        """
        return _libsbml.ListOfCompartments_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Compartment
        get(self, unsigned int n) -> Compartment
        get(self, string sid) -> Compartment
        get(self, string sid) -> Compartment

        Get a Compartment from the ListOfCompartments
        based on its identifier.

        @param sid a string representing the identifier 
        of the Compartment to get.

        @return Compartment in this ListOfCompartments
        with the given id or @c NULL if no such
        Compartment exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfCompartments_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Compartment
        remove(self, string sid) -> Compartment

        Removes item in this ListOfCompartments items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        @c NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfCompartments_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfCompartments"""
        this = _libsbml.new_ListOfCompartments()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfCompartments
    __del__ = lambda self : None;
ListOfCompartments_swigregister = _libsbml.ListOfCompartments_swigregister
ListOfCompartments_swigregister(ListOfCompartments)

class Species(SBase):
    """
    LibSBML implementation of SBML's %Species construct.

    A @em species in SBML refers to a pool of entities that (a) are
    considered indistinguishable from each other for the purposes of the
    model, (b) participate in reactions, and (c) are located in a specific
    @em compartment.  The SBML Species object class is intended to represent
    these pools.

    As with other major constructs in SBML, Species has a mandatory
    attribute, 'id', used to give the species type an identifier in the
    model.  The identifier must be a text string conforming to the identifer
    syntax permitted in SBML.  Species also has an optional 'name'
    attribute, of type @c string.  The 'id' and 'name' must be used
    according to the guidelines described in the SBML specifications.

    The required attribute 'compartment' is used to identify the compartment
    in which the species is located.  The attribute's value must be the
    identifier of an existing Compartment object.  It is important to note
    that there is no default value for the 'compartment' attribute on
    Species; every species in an SBML model must be assigned a compartment
    @em explicitly.  (This also implies that every model with one or more
    Species objects must define at least one Compartment object.)


    @section species-amounts The initial amount and concentration of a species

    The optional attributes 'initialAmount' and 'initialConcentration', both
    having a data type of @c double, can be used to set the @em initial
    quantity of the species in the compartment where the species is located.
    These attributes are mutually exclusive; i.e., <em>only one</em> can
    have a value on any given instance of a Species object.  Missing
    'initialAmount' and 'initialConcentration' values implies that their
    values either are unknown, or to be obtained from an external source, or
    determined by an InitialAssignment or other SBML construct elsewhere in
    the model.

    A species' initial quantity in SBML is set by the 'initialAmount' or
    'initialConcentration' attribute exactly once.  If the 'constant'
    attribute is @c true, then the value of the species' quantity is fixed
    and cannot be changed except by an InitialAssignment.  These methods
    differ in that the 'initialAmount' and 'initialConcentration' attributes
    can only be used to set the species quantity to a literal floating-point
    number, whereas the use of an InitialAssignment object allows the value
    to be set using an arbitrary mathematical expression (which, thanks to
    MathML's expressiveness, may evaluate to a rational number).  If the
    species' 'constant' attribute is @c false, the species' quantity value
    may be overridden by an InitialAssignment or changed by AssignmentRule
    or AlgebraicRule, and in addition, for <em>t &gt; 0</em>, it may also be
    changed by a RateRule, Event objects, and as a result of being a
    reactant or product in one or more Reaction objects.  (However, some
    constructs are mutually exclusive; see the SBML specifications for the
    precise details.)  It is not an error to define 'initialAmount' or
    'initialConcentration' on a species and also redefine the value using an
    InitialAssignment, but the 'initialAmount' or 'initialConcentration'
    setting in that case is ignored.  The SBML specifications provide
    additional information about the semantics of assignments, rules and
    values for simulation time <em>t</em> <= <em>0</em>.

    SBML Level&nbsp;2 additionally stipulates that in cases where a species'
    compartment has a 'spatialDimensions' value of @c 0 (zero), the species
    cannot have a value for 'initialConcentration' because the concepts of
    concentration and density break down when a container has zero
    dimensions.

    @section species-units The units of a species' amount or concentration

    When the attribute 'initialAmount' is set, the unit of measurement
    associated with the value of 'initialAmount' is specified by the Species
    attribute 'substanceUnits'.  When the 'initialConcentration' attribute
    is set, the unit of measurement associated with this concentration value
    is {<em>unit of amount</em>} divided by {<em>unit of size</em>}, where
    the {<em>unit of amount</em>} is specified by the Species
    'substanceUnits' attribute, and the {<em>unit of size</em>} is specified
    by the 'units' attribute of the Compartment object in which the species
    is located.  Note that in either case, a unit of <em>amount</em> is
    involved and determined by the 'substanceUnits' attribute.  Note
    <strong>these two attributes alone do not determine the units of the
    species when the species identifier appears in a mathematical
    expression</strong>; <em>that</em> aspect is determined by the attribute
    'hasOnlySubstanceUnits' discussed below.

    In SBML Level&nbsp;3, if the 'substanceUnits' attribute is not set on a
    given Species object instance, then the unit of <em>amount</em> for that
    species is inherited from the 'substanceUnits' attribute on the
    enclosing Model object instance.  If that attribute on Model is not set
    either, then the unit associated with the species' quantity is
    undefined.

    In SBML Level&nbsp;2, if the 'substanceUnits' attribute is not set on a
    given Species object instance, then the unit of <em>amount</em> for that
    species is taken from the predefined SBML unit identifier @c
    'substance'.  The value assigned to 'substanceUnits' must be chosen from
    one of the following possibilities: one of the base unit identifiers
    defined in SBML, the built-in unit identifier @c 'substance', or the
    identifier of a new unit defined in the list of unit definitions in the
    enclosing Model object.  The chosen units for 'substanceUnits' must be
    be @c 'dimensionless', @c 'mole', @c 'item', @c 'kilogram', @c 'gram',
    or units derived from these.

    As noted at the beginning of this section, simply setting
    'initialAmount' or 'initialConcentration' alone does @em not determine
    whether a species identifier represents an amount or a concentration
    when it appears elsewhere in an SBML model.  The role of the attribute
    'hasOnlySubstanceUnits' is to indicate whether the units of the species,
    when the species identifier appears in mathematical formulas, are
    intended to be concentration or amount.  The attribute takes on a
    boolean value.  In SBML Level&nbsp;3, the attribute has no default value
    and must always be set in a model; in SBML Level&nbsp;2, it has a
    default value of @c false.

    The <em>units of the species</em> are used in the following ways:
    <ul>
    <li> When the species' identifier appears in a MathML formula, it
    represents the species' quantity, and the unit of measurement associated
    with the quantity is as described above.

    <li> The 'math' elements of AssignmentRule, InitialAssignment and
    EventAssignment objects referring to this species should all have the
    same units as the unit of measurement associated with the species
    quantity.

    <li> In a RateRule object that defines the rate of change of the
    species' quantity, the unit associated with the rule's 'math' element
    should be equal to the unit of the species' quantity divided by the
    model-wide unit of <em>time</em>; in other words, {<em>unit of species
    quantity</em>}/{<em>unit of time</em>}.

    </ul>


    @section species-constant The 'constant' and 'boundaryCondition' attributes

    The Species object class has two boolean attributes named 'constant' and
    'boundaryCondition', used to indicate whether and how the quantity of
    that species can vary during a simulation.  In SBML Level&nbsp;2 they
    are optional; in SBML Level&nbsp;3 they are mandatory.  The following
    table shows how to interpret the combined values of these attributes.

    @htmlinclude species-boundarycondition.html

    By default, when a species is a product or reactant of one or more
    reactions, its quantity is determined by those reactions.  In SBML, it
    is possible to indicate that a given species' quantity is <em>not</em>
    determined by the set of reactions even when that species occurs as a
    product or reactant; i.e., the species is on the <em>boundary</em> of
    the reaction system, and its quantity is not determined by the
    reactions.  The boolean attribute 'boundaryCondition' can be used to
    indicate this.  A value of @c false indicates that the species @em is
    part of the reaction system.  In SBML Level&nbsp;2, the attribute has a
    default value of @c false, while in SBML Level&nbsp;3, it has no
    default.

    The 'constant' attribute indicates whether the species' quantity can be
    changed at all, regardless of whether by reactions, rules, or constructs
    other than InitialAssignment.  A value of @c false indicates that the
    species' quantity can be changed.  (This is also a common value because
    the purpose of most simulations is precisely to calculate changes in
    species quantities.)  In SBML Level&nbsp;2, the attribute has a default
    value of @c false, while in SBML Level&nbsp;3, it has no default.  Note
    that the initial quantity of a species can be set by an
    InitialAssignment irrespective of the value of the 'constant' attribute.

    In practice, a 'boundaryCondition' value of @c true means a differential
    equation derived from the reaction definitions should not be generated
    for the species.  However, the species' quantity may still be changed by
    AssignmentRule, RateRule, AlgebraicRule, Event, and InitialAssignment
    constructs if its 'constant' attribute is @c false.  Conversely, if the
    species' 'constant' attribute is @c true, then its value cannot be
    changed by anything except InitialAssignment.

    A species having 'boundaryCondition'=@c false and 'constant'=@c false
    can appear as a product and/or reactant of one or more reactions in the
    model.  If the species is a reactant or product of a reaction, it must
    @em not also appear as the target of any AssignmentRule or RateRule
    object in the model.  If instead the species has 'boundaryCondition'=@c
    false and 'constant'=@c true, then it cannot appear as a reactant or
    product, or as the target of any AssignmentRule, RateRule or
    EventAssignment object in the model.


    @section species-l2-convfactor The conversionFactor attribute in SBML Level&nbsp;3

    In SBML Level&nbsp;3, Species has an additional optional attribute,
    'conversionFactor', that defines a conversion factor that applies to a
    particular species.  The value must be the identifier of a Parameter
    object instance defined in the model.  That Parameter object must be a
    constant, meaning its 'constant' attribute must be set to @c true.
    If a given Species object definition defines a value for its
    'conversionFactor' attribute, it takes precedence over any factor
    defined by the Model object's 'conversionFactor' attribute.

    The unit of measurement associated with a species' quantity can be
    different from the unit of extent of reactions in the model.  SBML
    Level&nbsp;3 avoids implicit unit conversions by providing an explicit
    way to indicate any unit conversion that might be required.  The use of
    a conversion factor in computing the effects of reactions on a species'
    quantity is explained in detail in the SBML Level&nbsp;3 specification
    document.  Because the value of the 'conversionFactor' attribute is the
    identifier of a Parameter object, and because parameters can have units
    attached to them, the transformation from reaction extent units to
    species units can be completely specified using this approach.

    Note that the unit conversion factor is <strong>only applied when
    calculating the effect of a reaction on a species</strong>.  It is not
    used in any rules or other SBML constructs that affect the species, and
    it is also not used when the value of the species is referenced in a
    mathematical expression.


    @section species-l2-type The speciesType attribute in SBML Level&nbsp;2 Versions&nbsp;2&ndash;4

    In SBML Level&nbsp;2 Versions&nbsp;2&ndash;4, each species in a model
    may optionally be designated as belonging to a particular species type.
    The optional attribute 'speciesType' is used to identify the species
    type of the chemical entities that make up the pool represented by the
    Species objects.  The attribute's value must be the identifier of an
    existing SpeciesType object in the model.  If the 'speciesType'
    attribute is not present on a particular species definition, it means
    the pool contains chemical entities of a type unique to that pool; in
    effect, a virtual species type is assumed for that species, and no other
    species can belong to that species type.  The value of 'speciesType'
    attributes on species have no effect on the numerical interpretation of
    a model; simulators and other numerical analysis software may ignore
    'speciesType' attributes.

    There can be only one species of a given species type in any given
    compartment of a model.  More specifically, for all Species objects
    having a value for the 'speciesType' attribute, the pair
    <center>
    ('speciesType' attribute value, 'compartment' attribute value)
    </center>

    must be unique across the set of all Species object in a model.


    @section species-other The spatialSizeUnits attribute in SBML Level&nbsp;2 Versions&nbsp;1&ndash;2

    In versions of SBML Level&nbsp;2 before Version&nbsp;3, the class
    Species included an attribute called 'spatialSizeUnits', which allowed
    explicitly setting the units of size for initial concentration.  LibSBML
    retains this attribute for compatibility with older definitions of
    Level&nbsp;2, but its use is strongly discouraged because many software
    tools do no properly interpret this unit declaration and it is
    incompatible with all SBML specifications after Level&nbsp;2
    Version&nbsp;3.


    @section species-math Additional considerations for interpreting the numerical value of a species

    Species are unique in SBML in that they have a kind of duality: a
    species identifier may stand for either substance amount (meaning, a
    count of the number of individual entities) or a concentration or
    density (meaning, amount divided by a compartment size).  The previous
    sections explain the meaning of a species identifier when it is
    referenced in a mathematical formula or in rules or other SBML
    constructs; however, it remains to specify what happens to a species
    when the compartment in which it is located changes in size.

    When a species definition has a 'hasOnlySubstanceUnits' attribute value
    of @c false and the size of the compartment in which the species is
    located changes, the default in SBML is to assume that it is the
    concentration that must be updated to account for the size change.  This
    follows from the principle that, all other things held constant, if a
    compartment simply changes in size, the size change does not in itself
    cause an increase or decrease in the number of entities of any species
    in that compartment.  In a sense, the default is that the @em amount of
    a species is preserved across compartment size changes.  Upon such size
    changes, the value of the concentration or density must be recalculated
    from the simple relationship <em>concentration = amount / size</em> if
    the value of the concentration is needed (for example, if the species
    identifier appears in a mathematical formula or is otherwise referenced
    in an SBML construct).  There is one exception: if the species' quantity
    is determined by an AssignmentRule, RateRule, AlgebraicRule, or an
    EventAssignment and the species has a 'hasOnlySubstanceUnits' attribute
    value of @c false, it means that the <em>concentration</em> is assigned
    by the rule or event; in that case, the <em>amount</em> must be
    calculated when the compartment size changes.  (Events also require
    additional care in this situation, because an event with multiple
    assignments could conceivably reassign both a species quantity and a
    compartment size simultaneously.  Please refer to the SBML
    specifications for the details.)

    Note that the above only matters if a species has a
    'hasOnlySubstanceUnits' attribute value of @c false, meaning that the
    species identifier refers to a concentration wherever the identifier
    appears in a mathematical formula.  If instead the attribute's value is
    @c true, then the identifier of the species <em>always</em> stands for
    an amount wherever it appears in a mathematical formula or is referenced
    by an SBML construct.  In that case, there is never a question about
    whether an assignment or event is meant to affect the amount or
    concentration: it is always the amount.

    A particularly confusing situation can occur when the species has
    'constant' attribute value of @c true in combination with a
    'hasOnlySubstanceUnits' attribute value of @c false.  Suppose this
    species is given a value for 'initialConcentration'.  Does a 'constant'
    value of @c true mean that the concentration is held constant if the
    compartment size changes?  No; it is still the amount that is kept
    constant across a compartment size change.  The fact that the species
    was initialized using a concentration value is irrelevant.


    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Species, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Species, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Species
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Species
        __init__(self, SBMLNamespaces sbmlns) -> Species
        __init__(self, Species orig) -> Species

        Predicate returning @c true if
        all the required attributes for this Species object
        have been set.

        @note The required attributes for a Species object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'compartment'
        @li 'initialAmount' (required in SBML Level&nbsp;1 only; optional otherwise)
        @li 'hasOnlySubstanceUnits' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)
        @li 'boundaryCondition' (required in SBML Level&nbsp;3; optional in Levels&nbsp;1 and&nbsp;2)
        @li 'constant' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Species(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Species

        Creates and returns a deep copy of this Species object.

        @return a (deep) copy of this Species.
          

        """
        return _libsbml.Species_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Species object to 'typical' defaults
        values.

        The SBML Species component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets 'boundaryCondition' to @c false
        <li> Sets 'constant' to @c false
        <li> sets 'hasOnlySubstanceUnits' to @c false
        </ul>
          

        """
        return _libsbml.Species_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Species object.

        @return the id of this Species.
          

        """
        return _libsbml.Species_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Species object.

        @return the name of this Species.
          

        """
        return _libsbml.Species_getName(self)

    def getSpeciesType(self):
        """
        getSpeciesType(self) -> string

        Get the type of this Species object object.

        @return the value of the 'speciesType' attribute of this
        Species as a string.

        @note The 'speciesType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Species_getSpeciesType(self)

    def getCompartment(self):
        """
        getCompartment(self) -> string

        Get the compartment in which this species is located.

        The compartment is designated by its identifier.

        @return the value of the 'compartment' attribute of this Species
        object, as a string.
          

        """
        return _libsbml.Species_getCompartment(self)

    def getInitialAmount(self):
        """
        getInitialAmount(self) -> double

        Get the value of the 'initialAmount' attribute.

        @return the initialAmount of this Species, as a float-point number.
          

        """
        return _libsbml.Species_getInitialAmount(self)

    def getInitialConcentration(self):
        """
        getInitialConcentration(self) -> double

        Get the value of the 'initialConcentration' attribute.

        @return the initialConcentration of this Species,, as a float-point
        number.

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.
          

        """
        return _libsbml.Species_getInitialConcentration(self)

    def getSubstanceUnits(self):
        """
        getSubstanceUnits(self) -> string

        Get the value of the 'substanceUnits' attribute.

        @return the value of the 'substanceUnits' attribute of this Species,
        as a string.  An empty string indicates that no units have been
        assigned.

        @note @htmlinclude unassigned-units-are-not-a-default.html

        @see isSetSubstanceUnits()
        @see setSubstanceUnits(const std::string& sid)
          

        """
        return _libsbml.Species_getSubstanceUnits(self)

    def getSpatialSizeUnits(self):
        """
        getSpatialSizeUnits(self) -> string

        Get the value of the 'spatialSizeUnits' attribute.

        @return the value of the 'spatialSizeUnits' attribute of this Species
        object, as a string.

        @warning In versions of SBML Level&nbsp;2 before Version&nbsp;3, the
        class Species included an attribute called 'spatialSizeUnits', which
        allowed explicitly setting the units of size for initial
        concentration.  This attribute was removed in SBML Level&nbsp;2
        Version&nbsp;3.  LibSBML retains this attribute for compatibility with
        older definitions of Level&nbsp;2, but its use is strongly discouraged
        because it is incompatible with Level&nbsp;2 Version&nbsp;3 and
        Level&nbsp;2 Version&nbsp;4.
          

        """
        return _libsbml.Species_getSpatialSizeUnits(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Get the value of the 'units' attribute.

        @return the units of this Species (L1 only).

        @note The 'units' attribute is defined only in SBML Level&nbsp;1.  In
        SBML Level&nbsp;2 and Level&nbsp;3, it has been replaced by a
        combination of 'substanceUnits' and the units of the Compartment
        object in which a species is located.  In SBML Level&nbsp;2
        Versions&nbsp;1&ndash;2, an additional attribute 'spatialSizeUnits'
        helps determine the units of the species quantity, but this attribute
        was removed in later versions of SBML Level&nbsp;2.
          

        """
        return _libsbml.Species_getUnits(self)

    def getHasOnlySubstanceUnits(self):
        """
        getHasOnlySubstanceUnits(self) -> bool

        Get the value of the 'hasOnlySubstanceUnits' attribute.

        @return @c true if this Species' 'hasOnlySubstanceUnits' attribute
        value is nonzero, @c false otherwise.

        @note The 'hasOnlySubstanceUnits' attribute does not exist in SBML
        Level&nbsp;1.
          

        """
        return _libsbml.Species_getHasOnlySubstanceUnits(self)

    def getBoundaryCondition(self):
        """
        getBoundaryCondition(self) -> bool

        Get the value of the 'boundaryCondition' attribute.

        @return @c true if this Species' 'boundaryCondition' attribute value
        is nonzero, @c false otherwise.
          

        """
        return _libsbml.Species_getBoundaryCondition(self)

    def getCharge(self):
        """
        getCharge(self) -> int

        Get the value of the 'charge' attribute.

        @return the charge of this Species.

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species is deprecated and in SBML Level&nbsp;3 it does
        not exist at all.  Its use strongly discouraged.  Its presence is
        considered a misfeature in earlier definitions of SBML because its
        implications for the mathematics of a model were never defined, and in
        any case, no known modeling system ever used it.  Instead, models take
        account of charge values directly in their definitions of species by
        (for example) having separate species identities for the charged and
        uncharged versions of the same species.  This allows the condition to
        affect model mathematics directly.  LibSBML retains this method for
        easier compatibility with SBML Level&nbsp;1.
          

        """
        return _libsbml.Species_getCharge(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Get the value of the 'constant' attribute.

        @return @c true if this Species's 'constant' attribute value is
        nonzero, @c false otherwise.

        @note The attribute 'constant' is only available in SBML Levels&nbsp;2
        and&nbsp;3.  It does not exist on Species in Level&nbsp;1.
          

        """
        return _libsbml.Species_getConstant(self)

    def getConversionFactor(self):
        """
        getConversionFactor(self) -> string

        Get the value of the 'conversionFactor' attribute.

        @return the conversionFactor of this Species, as a string.

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.
          

        """
        return _libsbml.Species_getConversionFactor(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        Species's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this Species has been
        set, @c false otherwise.
          

        """
        return _libsbml.Species_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        Species's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this Species has been
        set, @c false otherwise.
          

        """
        return _libsbml.Species_isSetName(self)

    def isSetSpeciesType(self):
        """
        isSetSpeciesType(self) -> bool

        Predicate returning @c true if this Species's
        'speciesType' attribute has been set.

        @return @c true if the 'speciesType' attribute of this Species has
        been set, @c false otherwise.

        @note The 'speciesType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Species_isSetSpeciesType(self)

    def isSetCompartment(self):
        """
        isSetCompartment(self) -> bool

        Predicate returning @c true if this
        Species's 'compartment' attribute has been set.

        @return @c true if the 'compartment' attribute of this Species has
        been set, @c false otherwise.
          

        """
        return _libsbml.Species_isSetCompartment(self)

    def isSetInitialAmount(self):
        """
        isSetInitialAmount(self) -> bool

        Predicate returning @c true if this
        Species's 'initialAmount' attribute has been set.

        @return @c true if the 'initialAmount' attribute of this Species has
        been set, @c false otherwise.

        @note In SBML Level&nbsp;1, Species' 'initialAmount' is required and
        therefore <em>should always be set</em>.  (However, in Level&nbsp;1, the
        attribute has no default value either, so this method will not return
        @c true until a value has been assigned.)  In SBML Level&nbsp;2,
        'initialAmount' is optional and as such may or may not be set.
          

        """
        return _libsbml.Species_isSetInitialAmount(self)

    def isSetInitialConcentration(self):
        """
        isSetInitialConcentration(self) -> bool

        Predicate returning @c true if this
        Species's 'initialConcentration' attribute has been set.

        @return @c true if the 'initialConcentration' attribute of this Species has
        been set, @c false otherwise.

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.
          

        """
        return _libsbml.Species_isSetInitialConcentration(self)

    def isSetSubstanceUnits(self):
        """
        isSetSubstanceUnits(self) -> bool

        Predicate returning @c true if this
        Species's 'substanceUnits' attribute has been set.

        @return @c true if the 'substanceUnits' attribute of this Species has
        been set, @c false otherwise.
          

        """
        return _libsbml.Species_isSetSubstanceUnits(self)

    def isSetSpatialSizeUnits(self):
        """
        isSetSpatialSizeUnits(self) -> bool

        Predicate returning @c true if this
        Species's 'spatialSizeUnits' attribute has been set.

        @return @c true if the 'spatialSizeUnits' attribute of this Species has
        been set, @c false otherwise.

        @warning In versions of SBML Level~2 before Version&nbsp;3, the class
        Species included an attribute called 'spatialSizeUnits', which allowed
        explicitly setting the units of size for initial concentration.  This
        attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML
        retains this attribute for compatibility with older definitions of
        Level&nbsp;2, but its use is strongly discouraged because it is
        incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.
          

        """
        return _libsbml.Species_isSetSpatialSizeUnits(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c true if
        this Species's 'units' attribute has been set.

        @return @c true if the 'units' attribute of this Species has
        been set, @c false otherwise.
          

        """
        return _libsbml.Species_isSetUnits(self)

    def isSetCharge(self):
        """
        isSetCharge(self) -> bool

        Predicate returning @c true if this
        Species's 'charge' attribute has been set.

        @return @c true if the 'charge' attribute of this Species has
        been set, @c false otherwise.

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species in SBML is deprecated and in SBML Level&nbsp;3 it
        does not exist at all.  Its use strongly discouraged.  Its presence is
        considered a misfeature in earlier definitions of SBML because its
        implications for the mathematics of a model were never defined, and in
        any case, no known modeling system ever used it.  Instead, models take
        account of charge values directly in their definitions of species by
        (for example) having separate species identities for the charged and
        uncharged versions of the same species.  This allows the condition to
        affect model mathematics directly.  LibSBML retains this method for
        easier compatibility with SBML Level&nbsp;1.
          

        """
        return _libsbml.Species_isSetCharge(self)

    def isSetConversionFactor(self):
        """
        isSetConversionFactor(self) -> bool

        Predicate returning @c true if this
        Species's 'conversionFactor' attribute has been set.

        @return @c true if the 'conversionFactor' attribute of this Species has
        been set, @c false otherwise.

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.
          

        """
        return _libsbml.Species_isSetConversionFactor(self)

    def isSetBoundaryCondition(self):
        """
        isSetBoundaryCondition(self) -> bool

        Predicate returning @c true if this
        Species's 'boundaryCondition' attribute has been set.

        @return @c true if the 'boundaryCondition' attribute of this Species has
        been set, @c false otherwise.
          

        """
        return _libsbml.Species_isSetBoundaryCondition(self)

    def isSetHasOnlySubstanceUnits(self):
        """
        isSetHasOnlySubstanceUnits(self) -> bool

        Predicate returning @c true if this
        Species's 'hasOnlySubstanceUnits' attribute has been set.

        @return @c true if the 'hasOnlySubstanceUnits' attribute of this Species has
        been set, @c false otherwise.

        @note The 'hasOnlySubstanceUnits' attribute does not exist in SBML
        Level&nbsp;1.
          

        """
        return _libsbml.Species_isSetHasOnlySubstanceUnits(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c true if this
        Species's 'constant' attribute has been set.

        @return @c true if the 'constant' attribute of this Species has
        been set, @c false otherwise.

        @note The attribute 'constant' is only available in SBML Levels&nbsp;2
        and&nbsp;3.  It does not exist on Species in Level&nbsp;1.
          

        """
        return _libsbml.Species_isSetConstant(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Species.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this Species

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Species_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Species.

        The string in @p name is copied.

        @param name the new name for the Species

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Species_setName(self, *args)

    def setSpeciesType(self, *args):
        """
        setSpeciesType(self, string sid) -> int

        Sets the 'speciesType' attribute of this Species.

        @param sid the identifier of a SpeciesType object defined elsewhere
        in this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The 'speciesType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Species_setSpeciesType(self, *args)

    def setCompartment(self, *args):
        """
        setCompartment(self, string sid) -> int

        Sets the 'compartment' attribute of this Species.

        @param sid the identifier of a Compartment object defined elsewhere
        in this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Species_setCompartment(self, *args)

    def setInitialAmount(self, *args):
        """
        setInitialAmount(self, double value) -> int

        Sets the 'initialAmount' attribute of this Species and marks the field
        as set.

        This method also unsets the 'initialConcentration' attribute.

        @param value the value to which the 'initialAmount' attribute should
        be set.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.Species_setInitialAmount(self, *args)

    def setInitialConcentration(self, *args):
        """
        setInitialConcentration(self, double value) -> int

        Sets the 'initialConcentration' attribute of this Species and marks
        the field as set.

        This method also unsets the 'initialAmount' attribute.

        @param value the value to which the 'initialConcentration' attribute
        should be set.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.
          

        """
        return _libsbml.Species_setInitialConcentration(self, *args)

    def setSubstanceUnits(self, *args):
        """
        setSubstanceUnits(self, string sid) -> int

        Sets the 'substanceUnits' attribute of this Species.

        @param sid the identifier of the unit to use.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Species_setSubstanceUnits(self, *args)

    def setSpatialSizeUnits(self, *args):
        """
        setSpatialSizeUnits(self, string sid) -> int

        (SBML Level&nbsp;2 Versions&nbsp;1&ndash;2) Sets the 'spatialSizeUnits' attribute of this Species.

        @param sid the identifier of the unit to use.

        @warning In versions of SBML Level~2 before Version&nbsp;3, the class
        Species included an attribute called 'spatialSizeUnits', which allowed
        explicitly setting the units of size for initial concentration.  This
        attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML
        retains this attribute for compatibility with older definitions of
        Level&nbsp;2, but its use is strongly discouraged because it is
        incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Species_setSpatialSizeUnits(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string sname) -> int

        (SBML Level&nbsp;1 only) Sets the units of this Species.

        @param sname the identifier of the unit to use.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
         

        """
        return _libsbml.Species_setUnits(self, *args)

    def setHasOnlySubstanceUnits(self, *args):
        """
        setHasOnlySubstanceUnits(self, bool value) -> int

        Sets the 'hasOnlySubstanceUnits' attribute of this Species.

        @param value boolean value for the 'hasOnlySubstanceUnits' attribute.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The 'hasOnlySubstanceUnits' attribute does not exist in SBML
        Level&nbsp;1.
          

        """
        return _libsbml.Species_setHasOnlySubstanceUnits(self, *args)

    def setBoundaryCondition(self, *args):
        """
        setBoundaryCondition(self, bool value) -> int

        Sets the 'boundaryCondition' attribute of this Species.

        @param value boolean value for the 'boundaryCondition' attribute.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.Species_setBoundaryCondition(self, *args)

    def setCharge(self, *args):
        """
        setCharge(self, int value) -> int

        Sets the 'charge' attribute of this Species.

        @param value an integer to which to set the 'charge' to.

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species in SBML is deprecated and its use strongly
        discouraged, and it does not exist in SBML Level&nbsp;3 at all.  Its
        presence is considered a misfeature in earlier definitions of SBML
        because its implications for the mathematics of a model were never
        defined, and in any case, no known modeling system ever used it.
        Instead, models take account of charge values directly in their
        definitions of species by (for example) having separate species
        identities for the charged and uncharged versions of the same species.
        This allows the condition to affect model mathematics directly.
        LibSBML retains this method for easier compatibility with SBML
        Level&nbsp;1.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Species_setCharge(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool value) -> int

        Sets the 'constant' attribute of this Species.

        @param value a boolean value for the 'constant' attribute

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The attribute 'constant' is only available in SBML Levels&nbsp;2
        and&nbsp;3.  It does not exist on Species in Level&nbsp;1.
          

        """
        return _libsbml.Species_setConstant(self, *args)

    def setConversionFactor(self, *args):
        """
        setConversionFactor(self, string sid) -> int

        Sets the value of the 'conversionFactor' attribute of this Species.

        The string in @p sid is copied.

        @param sid the new conversionFactor for the Species

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.
          

        """
        return _libsbml.Species_setConversionFactor(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Species_unsetName(self)

    def unsetSpeciesType(self):
        """
        unsetSpeciesType(self) -> int

        Unsets the 'speciesType' attribute value of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The attribute 'speciesType' is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.
          

        """
        return _libsbml.Species_unsetSpeciesType(self)

    def unsetInitialAmount(self):
        """
        unsetInitialAmount(self) -> int

        Unsets the 'initialAmount' attribute value of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.Species_unsetInitialAmount(self)

    def unsetInitialConcentration(self):
        """
        unsetInitialConcentration(self) -> int

        Unsets the 'initialConcentration' attribute value of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.
          

        """
        return _libsbml.Species_unsetInitialConcentration(self)

    def unsetSubstanceUnits(self):
        """
        unsetSubstanceUnits(self) -> int

        Unsets the 'substanceUnits' attribute value of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Species_unsetSubstanceUnits(self)

    def unsetSpatialSizeUnits(self):
        """
        unsetSpatialSizeUnits(self) -> int

        Unsets the 'spatialSizeUnits' attribute value of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @warning In versions of SBML Level~2 before Version&nbsp;3, the class
        Species included an attribute called 'spatialSizeUnits', which allowed
        explicitly setting the units of size for initial concentration.  This
        attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML
        retains this attribute for compatibility with older definitions of
        Level&nbsp;2, but its use is strongly discouraged because it is
        incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.
          

        """
        return _libsbml.Species_unsetSpatialSizeUnits(self)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the 'units' attribute value of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Species_unsetUnits(self)

    def unsetCharge(self):
        """
        unsetCharge(self) -> int

        Unsets the 'charge' attribute
        value of this Species.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species in SBML is deprecated and its use strongly
        discouraged, and it does not exist in SBML Level&nbsp;3 at all.  Its
        presence is considered a misfeature in earlier definitions of SBML
        because its implications for the mathematics of a model were never
        defined, and in any case, no known modeling system ever used it.
        Instead, models take account of charge values directly in their
        definitions of species by (for example) having separate species
        identities for the charged and uncharged versions of the same species.
        This allows the condition to affect model mathematics directly.
        LibSBML retains this method for easier compatibility with SBML
        Level&nbsp;1.
          

        """
        return _libsbml.Species_unsetCharge(self)

    def unsetConversionFactor(self):
        """
        unsetConversionFactor(self) -> int

        Unsets the 'conversionFactor' attribute value of this Species.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.
          

        """
        return _libsbml.Species_unsetConversionFactor(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this Species' amount or concentration.

        Species in SBML have an attribute ('substanceUnits') for declaring the
        units of measurement intended for the species' amount or concentration
        (depending on which one applies).  In the absence of a value given for
        'substanceUnits', the units are taken from the enclosing Model's
        definition of @c 'substance' or @c 'substance'/<em>(size of the
        compartment)</em> in which the species is located, or finally, if
        these are not redefined by the Model, the relevant SBML default units
        for those quantities.  Following that procedure, the method
        getDerivedUnitDefinition() returns a UnitDefinition based on the
        interpreted units of this species's amount or concentration.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c NULL.

        Note also that unit declarations for Species are in terms of the @em
        identifier of a unit, but this method returns a UnitDefinition object,
        not a unit identifier.  It does this by constructing an appropriate
        UnitDefinition.  Callers may find this particularly useful when used
        in conjunction with the helper methods on UnitDefinition for comparing
        different UnitDefinition objects.

        In SBML Level&nbsp;2 specifications prior to Version&nbsp;3, Species
        includes an additional attribute named 'spatialSizeUnits', which
        allows explicitly setting the units of size for initial concentration.
        The getDerivedUnitDefinition() takes this into account for models
        expressed in SBML Level&nbsp;2 Versions&nbsp;1 and&nbsp;2.

        @return a UnitDefinition that expresses the units of this 
        Species, or @c NULL if one cannot be constructed.

        @see getSubstanceUnits()
          

        """
        return _libsbml.Species_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Species_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Species, is
        always @c 'species'.

        @return the name of this element, i.e., @c 'species'.
          

        """
        return _libsbml.Species_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this Species object
        have been set.

        @note The required attributes for a Species object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'compartment'
        @li 'initialAmount' (required in SBML Level&nbsp;1 only; optional otherwise)
        @li 'hasOnlySubstanceUnits' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)
        @li 'boundaryCondition' (required in SBML Level&nbsp;3; optional in Levels&nbsp;1 and&nbsp;2)
        @li 'constant' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.Species_hasRequiredAttributes(self)

Species_swigregister = _libsbml.Species_swigregister
Species_swigregister(Species)

class ListOfSpecies(ListOf):
    """
    LibSBML implementation of SBML Level&nbsp;2's %ListOfSpecies construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfSpecies, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfSpecies, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfSpecies

        Creates and returns a deep copy of this ListOfSpeciess instance.

        @return a (deep) copy of this ListOfSpeciess.
          

        """
        return _libsbml.ListOfSpecies_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfSpecies_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Species objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfSpecies_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfSpeciess, the XML element name is @c 'listOfSpeciess'.

        @return the name of this element, i.e., @c 'listOfSpeciess'.
          

        """
        return _libsbml.ListOfSpecies_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Species
        get(self, unsigned int n) -> Species
        get(self, string sid) -> Species
        get(self, string sid) -> Species

        Get a Species from the ListOfSpecies
        based on its identifier.

        @param sid a string representing the identifier 
        of the Species to get.

        @return Species in this ListOfSpecies
        with the given id or @c NULL if no such
        Species exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfSpecies_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Species
        remove(self, string sid) -> Species

        Removes item in this ListOfSpeciess items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfSpecies_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfSpecies"""
        this = _libsbml.new_ListOfSpecies()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfSpecies
    __del__ = lambda self : None;
ListOfSpecies_swigregister = _libsbml.ListOfSpecies_swigregister
ListOfSpecies_swigregister(ListOfSpecies)

class Parameter(SBase):
    """
    LibSBML implementation of SBML's %Parameter construct.

    A Parameter is used in SBML to define a symbol associated with a value;
    this symbol can then be used in mathematical formulas in a model.  By
    default, parameters have constant value for the duration of a
    simulation, and for this reason are called @em parameters instead of @em
    variables in SBML, although it is crucial to understand that <em>SBML
    parameters represent both concepts</em>.  Whether a given SBML
    parameter is intended to be constant or variable is indicated by the
    value of its 'constant' attribute.

    SBML's Parameter has a required attribute, 'id', that gives the
    parameter a unique identifier by which other parts of an SBML model
    definition can refer to it.  A parameter can also have an optional
    'name' attribute of type @c string.  Identifiers and names must be used
    according to the guidelines described in the SBML specifications.

    The optional attribute 'value' determines the value (of type @c double)
    assigned to the parameter.  A missing value for 'value' implies that
    the value either is unknown, or to be obtained from an external source,
    or determined by an initial assignment.  The unit of measurement
    associated with the value of the parameter can be specified using the
    optional attribute 'units'.  Here we only mention briefly some notable
    points about the possible unit choices, but readers are urged to consult
    the SBML specification documents for more information:
    <ul>

    <li> In SBML Level&nbsp;3, there are no constraints on the units that
    can be assigned to parameters in a model; there are also no units to
    inherit from the enclosing Model object (unlike the case for, e.g.,
    Species and Compartment).

    <li> In SBML Level&nbsp;2, the value assigned to the parameter's 'units'
    attribute must be chosen from one of the following possibilities: one of
    the base unit identifiers defined in SBML; one of the built-in unit
    identifiers @c 'substance', @c 'time', @c 'volume', @c 'area' or @c
    'length'; or the identifier of a new unit defined in the list of unit
    definitions in the enclosing Model structure.  There are no constraints
    on the units that can be chosen from these sets.  There are no default
    units for parameters.
    </ul>

    The Parameter structure has another boolean attribute named 'constant'
    that is used to indicate whether the parameter's value can vary during a
    simulation.  (In SBML Level&nbsp;3, the attribute is mandatory and must
    be given a value; in SBML Levels below Level&nbsp;3, the attribute is
    optional.)  A value of @c true indicates the parameter's value cannot be
    changed by any construct except InitialAssignment.  Conversely, if the
    value of 'constant' is @c false, other constructs in SBML, such as rules
    and events, can change the value of the parameter.

    SBML Level&nbsp;3 uses a separate object class, LocalParameter, for
    parameters that are local to a Reaction's KineticLaw.  In Levels prior
    to SBML Level&nbsp;3, the Parameter class is used both for definitions
    of global parameters, as well as reaction-local parameters stored in a
    list within KineticLaw objects.  Parameter objects that are local to a
    reaction (that is, those defined within the KineticLaw structure of a
    Reaction) cannot be changed by rules and therefore are <em>implicitly
    always constant</em>; consequently, in SBML Level&nbsp;2, parameter
    definitions within Reaction structures should @em not have their
    'constant' attribute set to @c false.

    What if a global parameter has its 'constant' attribute set to @c false,
    but the model does not contain any rules, events or other constructs
    that ever change its value over time?  Although the model may be
    suspect, this situation is not strictly an error.  A value of @c false
    for 'constant' only indicates that a parameter @em can change value, not
    that it @em must.

    As with all other major SBML components, Parameter is derived from
    SBase, and the methods defined on SBase are available on Parameter.

    @see ListOfParameters

    @note The use of the term @em parameter in SBML sometimes leads to
    confusion among readers who have a particular notion of what something
    called 'parameter' should be.  It has been the source of heated debate,
    but despite this, no one has yet found an adequate replacement term that
    does not have different connotations to different people and hence leads
    to confusion among @em some subset of users.  Perhaps it would have been
    better to have two constructs, one called @em constants and the other
    called @em variables.  The current approach in SBML is simply more
    parsimonious, using a single Parameter construct with the boolean flag
    'constant' indicating which flavor it is.  In any case, readers are
    implored to look past their particular definition of a @em parameter and
    simply view SBML's Parameter as a single mechanism for defining both
    constants and (additional) variables in a model.  (We write @em
    additional because the species in a model are usually considered to be
    the central variables.)  After all, software tools are not required to
    expose to users the actual names of particular SBML constructs, and
    thus tools can present to their users whatever terms their designers
    feel best matches their target audience.

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parameter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Parameter, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Parameter
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Parameter
        __init__(self, SBMLNamespaces sbmlns) -> Parameter
        __init__(self, Parameter orig) -> Parameter

        Predicate returning @c true if
        all the required attributes for this Parameter object
        have been set.

        @note The required attributes for a Parameter object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'value' (required in Level&nbsp;1, optional otherwise)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Parameter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Parameter

        Creates and returns a deep copy of this Parameter.

        @return a (deep) copy of this Parameter.
          

        """
        return _libsbml.Parameter_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Parameter object to 'typical' defaults
        values.

        The SBML Parameter component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.  Many
        SBML object classes defined by libSBML have an initDefaults() method
        to set the values to certain common defaults, based mostly on what
        they are in SBML Level&nbsp;2.  In the case of Parameter, this method
        only sets the value of the 'constant' attribute to @c true.
          

        """
        return _libsbml.Parameter_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Parameter.

        @return the id of this Parameter.
          

        """
        return _libsbml.Parameter_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Parameter.

        @return the name of this Parameter.
          

        """
        return _libsbml.Parameter_getName(self)

    def getValue(self):
        """
        getValue(self) -> double

        Gets the numerical value of this Parameter.

        @return the value of the 'value' attribute of this Parameter, as a
        number of type @c double.

        @note <b>It is crucial</b> that callers not blindly call
        Parameter::getValue() without first using Parameter::isSetValue() to
        determine whether a value has ever been set.  Otherwise, the value
        return by Parameter::getValue() may not actually represent a value
        assigned to the parameter.  The reason is simply that the data type
        @c double in a program always has @em some value.  A separate test is
        needed to determine whether the value is a true model value, or
        uninitialized data in a computer's memory location.

        @see isSetValue()
        @see setValue(double value)
        @see getUnits()
          

        """
        return _libsbml.Parameter_getValue(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Gets the units defined for this Parameter.

        The value of an SBML parameter's 'units' attribute establishes the
        unit of measurement associated with the parameter's value.

        @return the value of the 'units' attribute of this Parameter, as a
        string.  An empty string indicates that no units have been assigned.

        @note @htmlinclude unassigned-units-are-not-a-default.html

        @see isSetUnits()
        @see setUnits()
        @see getValue()
          

        """
        return _libsbml.Parameter_getUnits(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Gets the value of the 'constant' attribute of this Parameter instance.

        @return @c true if this Parameter has been declared as being constant,
        @c false otherwise.

        @see isSetConstant()
        @see setConstant(bool flag)
          

        """
        return _libsbml.Parameter_getConstant(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        Parameter's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this Parameter has been
        set, @c false otherwise.
          

        """
        return _libsbml.Parameter_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        Parameter's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this Parameter has been
        set, @c false otherwise.
          

        """
        return _libsbml.Parameter_isSetName(self)

    def isSetValue(self):
        """
        isSetValue(self) -> bool

        Predicate returning @c true if the
        'value' attribute of this Parameter has been set.

        In SBML definitions after SBML Level&nbsp;1 Version&nbsp;1,
        parameter values are optional and have no defaults.  If a model read
        from a file does not contain a setting for the 'value' attribute of a
        parameter, its value is considered unset; it does not default to any
        particular value.  Similarly, when a Parameter object is created in
        libSBML, it has no value until given a value.  The
        Parameter::isSetValue() method allows calling applications to
        determine whether a given parameter's value has ever been set.

        In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have
        values and therefore, the value of a Parameter <b>should always be
        set</b>.  In Level&nbsp;1 Version&nbsp;2 and beyond, the value is
        optional and as such, the 'value' attribute may or may not be set.

        @return @c true if the value of this Parameter has been set,
        @c false otherwise.

        @see getValue()
        @see setValue(double value)
          

        """
        return _libsbml.Parameter_isSetValue(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c true if the
        'units' attribute of this Parameter has been set.

        @return @c true if the 'units' attribute of this Parameter has been
        set, @c false otherwise.

        @note @htmlinclude unassigned-units-are-not-a-default.html
          

        """
        return _libsbml.Parameter_isSetUnits(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c true if the
        'constant' attribute of this Parameter has been set.

        @return @c true if the 'constant' attribute of this Parameter has been
        set, @c false otherwise.
          

        """
        return _libsbml.Parameter_isSetConstant(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Parameter.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this Parameter

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Parameter_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Parameter.

        The string in @p name is copied.

        @param name the new name for the Parameter

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Parameter_setName(self, *args)

    def setValue(self, *args):
        """
        setValue(self, double value) -> int

        Sets the 'value' attribute of this Parameter to the given @c double
        value and marks the attribute as set.

        @param value a @c double, the value to assign

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.Parameter_setValue(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string units) -> int

        Sets the 'units' attribute of this Parameter to a copy of the given
        units identifier @p units.

        @param units a string, the identifier of the units to assign to this
        Parameter instance

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Parameter_setUnits(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool flag) -> int

        Sets the 'constant' attribute of this Parameter to the given boolean
        @p flag.

        @param flag a boolean, the value for the 'constant' attribute of this
        Parameter instance

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Parameter_setConstant(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Parameter.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Parameter_unsetName(self)

    def unsetValue(self):
        """
        unsetValue(self) -> int

        Unsets the 'value' attribute of this Parameter instance.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have
        values and therefore, the value of a Parameter <b>should always be
        set</b>.  In SBML Level&nbsp;1 Version&nbsp;2 and beyond, the value
        is optional and as such, the 'value' attribute may or may not be set.
          

        """
        return _libsbml.Parameter_unsetValue(self)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the 'units' attribute of this Parameter instance.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Parameter_unsetUnits(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this Parameter's value.

        Parameters in SBML have an attribute ('units') for declaring the units
        of measurement intended for the parameter's value.  <b>No defaults are
        defined</b> by SBML in the absence of a definition for 'units'.  This
        method returns a UnitDefinition object based on the units declared for
        this Parameter using its 'units' attribute, or it returns @c NULL if
        no units have been declared.

        Note that unit declarations for Parameter objects are specified in
        terms of the @em identifier of a unit (e.g., using setUnits()), but
        @em this method returns a UnitDefinition object, not a unit
        identifier.  It does this by constructing an appropriate
        UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even
        when the value of the 'units' attribute is one of the predefined SBML
        units @c 'substance', @c 'volume', @c 'area', @c 'length' or @c
        'time'.  Callers may find this useful in conjunction with the helper
        methods provided by the UnitDefinition class for comparing different
        UnitDefinition objects.

        @return a UnitDefinition that expresses the units of this 
        Parameter, or @c NULL if one cannot be constructed.

        @note The libSBML system for unit analysis depends on the model as a
        whole.  In cases where the Parameter object has not yet been added to
        a model, or the model itself is incomplete, unit analysis is not
        possible, and consequently this method will return @c NULL.

        @see isSetUnits()
          

        """
        return _libsbml.Parameter_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or
        @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Parameter_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Parameter, is
        always @c 'parameter'.

        @return the name of this element, i.e., @c 'parameter'.
          

        """
        return _libsbml.Parameter_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this Parameter object
        have been set.

        @note The required attributes for a Parameter object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'value' (required in Level&nbsp;1, optional otherwise)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.Parameter_hasRequiredAttributes(self)

Parameter_swigregister = _libsbml.Parameter_swigregister
Parameter_swigregister(Parameter)

class ListOfParameters(ListOf):
    """
    LibSBML implementation of SBML's %ListOfParameters construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfParameters, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfParameters, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfParameters

        Creates and returns a deep copy of this ListOfParameters instance.

        @return a (deep) copy of this ListOfParameters.
          

        """
        return _libsbml.ListOfParameters_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfParameters_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Parameter objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink
        (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfParameters_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfParameters, the XML element name is @c 'listOfParameters'.

        @return the name of this element, i.e., @c 'listOfParameters'.
          

        """
        return _libsbml.ListOfParameters_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Parameter
        get(self, unsigned int n) -> Parameter
        get(self, string sid) -> Parameter
        get(self, string sid) -> Parameter

        Returns the first Parameter object matching the given identifier.

        @param sid a string representing the identifier of the Parameter to
        get.

        @return the Parameter object found.  The caller owns the returned
        object and is responsible for deleting it.  If none of the items have
        an identifier matching @p sid, then @c NULL is returned.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfParameters_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Parameter
        remove(self, string sid) -> Parameter

        Removes the first Parameter object in this ListOfParameters
        matching the given identifier, and returns a pointer to it.

        @param sid the identifier of the item to remove.

        @return the item removed.  The caller owns the returned object and is
        responsible for deleting it.  If none of the items have an identifier
        matching @p sid, then @c NULL is returned.
          

        """
        return _libsbml.ListOfParameters_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfParameters"""
        this = _libsbml.new_ListOfParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfParameters
    __del__ = lambda self : None;
ListOfParameters_swigregister = _libsbml.ListOfParameters_swigregister
ListOfParameters_swigregister(ListOfParameters)

class LocalParameter(Parameter):
    """
    LibSBML implementation of SBML Level&nbsp;3's %LocalParameter construct.

    LocalParameter has been introduced in SBML Level&nbsp;3 to serve as the
    object class for parameter definitions that are intended to be local to
    a Reaction.  Objects of class LocalParameter never appear at the Model
    level; they are always contained within ListOfLocalParameters lists
    which are in turn contained within KineticLaw objects.

    Like its global Parameter counterpart, the LocalParameter object class
    is used to define a symbol associated with a value; this symbol can then
    be used in a model's mathematical formulas (and specifically, for
    LocalParameter, reaction rate formulas).  Unlike Parameter, the
    LocalParameter class does not have a 'constant' attribute: local
    parameters within reactions are @em always constant.

    LocalParameter has one required attribute, 'id', to give the
    parameter a unique identifier by which other parts of an SBML model
    definition can refer to it.  A parameter can also have an optional
    'name' attribute of type @c string.  Identifiers and names must be used
    according to the guidelines described in the SBML specifications.

    The optional attribute 'value' determines the value (of type @c double)
    assigned to the parameter.  A missing value for 'value' implies that
    the value either is unknown, or to be obtained from an external source,
    or determined by an initial assignment.  The unit of measurement
    associated with the value of the parameter can be specified using the
    optional attribute 'units'.  Here we only mention briefly some notable
    points about the possible unit choices, but readers are urged to consult
    the SBML specification documents for more information:
    <ul>

    <li> In SBML Level&nbsp;3, there are no constraints on the units that
    can be assigned to parameters in a model; there are also no units to
    inherit from the enclosing Model object.

    <li> In SBML Level&nbsp;2, the value assigned to the parameter's 'units'
    attribute must be chosen from one of the following possibilities: one of
    the base unit identifiers defined in SBML; one of the built-in unit
    identifiers @c 'substance', @c 'time', @c 'volume', @c 'area' or @c
    'length'; or the identifier of a new unit defined in the list of unit
    definitions in the enclosing Model structure.  There are no constraints
    on the units that can be chosen from these sets.  There are no default
    units for local parameters.
    </ul>

    As with all other major SBML components, LocalParameter is derived from
    SBase, and the methods defined on SBase are available on LocalParameter.

    @warning LibSBML derives LocalParameter from Parameter; however, this
    does not precisely match the object hierarchy defined by SBML
    Level&nbsp;3, where LocalParamter is derived directly from SBase and not
    Parameter.  We believe this arrangement makes it easier for libSBML
    users to program applications that work with both SBML Level&nbsp;2 and
    SBML Level&nbsp;3, but programmers should also keep in mind this
    difference exists.  A side-effect of libSBML's scheme is that certain
    methods on LocalParameter that are inherited from Parameter do not
    actually have relevance to LocalParameter objects.  An example of this
    is the methods pertaining to Parameter's attribute 'constant'
    (i.e., isSetConstant(), setConstant(), and getConstant()).

    @see ListOfLocalParameters
    @see KineticLaw

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [Parameter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalParameter, name, value)
    __swig_getmethods__ = {}
    for _s in [Parameter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalParameter, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_LocalParameter
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> LocalParameter
        __init__(self, SBMLNamespaces sbmlns) -> LocalParameter
        __init__(self, LocalParameter orig) -> LocalParameter
        __init__(self, Parameter orig) -> LocalParameter

        Predicate returning @c true if
        all the required attributes for this LocalParameter object
        have been set.

        @note The required attributes for a LocalParameter object are:
        @li 'id'
        @li 'value'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_LocalParameter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> LocalParameter

        Creates and returns a deep copy of this LocalParameter.

        @return a (deep) copy of this LocalParameter.
          

        """
        return _libsbml.LocalParameter_clone(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this LocalParameter's value.

        LocalParameters in SBML have an attribute ('units') for declaring the
        units of measurement intended for the parameter's value.  <b>No
        defaults are defined</b> by SBML in the absence of a definition for
        'units'.  This method returns a UnitDefinition object based on the
        units declared for this LocalParameter using its 'units' attribute, or
        it returns @c NULL if no units have been declared.

        Note that unit declarations for LocalParameter objects are specified
        in terms of the @em identifier of a unit (e.g., using setUnits()), but
        @em this method returns a UnitDefinition object, not a unit
        identifier.  It does this by constructing an appropriate
        UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even
        when the value of the 'units' attribute is one of the predefined SBML
        units @c 'substance', @c 'volume', @c 'area', @c 'length' or @c
        'time'.  Callers may find this useful in conjunction with the helper
        methods provided by the UnitDefinition class for comparing different
        UnitDefinition objects.

        @return a UnitDefinition that expresses the units of this 
        LocalParameter, or @c NULL if one cannot be constructed.

        @note The libSBML system for unit analysis depends on the model as a
        whole.  In cases where the LocalParameter object has not yet been
        added to a model, or the model itself is incomplete, unit analysis is
        not possible, and consequently this method will return @c NULL.

        @see isSetUnits()
          

        """
        return _libsbml.LocalParameter_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.LocalParameter_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for LocalParameter,
        is always @c 'localParameter'.

        @return the name of this element, i.e., @c 'localParameter'.
          

        """
        return _libsbml.LocalParameter_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this LocalParameter object
        have been set.

        @note The required attributes for a LocalParameter object are:
        @li 'id'
        @li 'value'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.LocalParameter_hasRequiredAttributes(self)

LocalParameter_swigregister = _libsbml.LocalParameter_swigregister
LocalParameter_swigregister(LocalParameter)

class ListOfLocalParameters(ListOfParameters):
    """
    LibSBML implementation of SBML's %ListOfLocalParameters construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    ListOfLocalParameters is a subsidiary object class used only within
    KineticLaw.  A KineticLaw object can have a single object of class
    ListOfLocalParameters containing a set of local parameters used in that
    kinetic law definition.

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOfParameters]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfLocalParameters, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOfParameters]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfLocalParameters, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfLocalParameters

        Creates and returns a deep copy of this ListOfLocalParameters object.

        @return a (deep) copy of this ListOfLocalParameters.
          

        """
        return _libsbml.ListOfLocalParameters_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfLocalParameters_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., LocalParameter objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink
        (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfLocalParameters_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfLocalParameters, the XML element name is @c 'listOfLocalParameters'.

        @return the name of this element, i.e., @c 'listOfLocalParameters'.
          

        """
        return _libsbml.ListOfLocalParameters_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> LocalParameter
        get(self, unsigned int n) -> LocalParameter
        get(self, string sid) -> LocalParameter
        get(self, string sid) -> LocalParameter

        Returns the first LocalParameter object matching the given identifier.

        @param sid a string representing the identifier of the LocalParameter
        to get.

        @return the LocalParameter object found.  The caller owns the returned
        object and is responsible for deleting it.  If none of the items have
        an identifier matching @p sid, then @c NULL is returned.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfLocalParameters_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> LocalParameter
        remove(self, string sid) -> LocalParameter

        Removes the first LocalParameter object in this ListOfLocalParameters
        matching the given identifier, and returns a pointer to it.

        @param sid the identifier of the item to remove.

        @return the item removed.  The caller owns the returned object and is
        responsible for deleting it.  If none of the items have an identifier
        matching @p sid, then @c NULL is returned.
          

        """
        return _libsbml.ListOfLocalParameters_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfLocalParameters"""
        this = _libsbml.new_ListOfLocalParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfLocalParameters
    __del__ = lambda self : None;
ListOfLocalParameters_swigregister = _libsbml.ListOfLocalParameters_swigregister
ListOfLocalParameters_swigregister(ListOfLocalParameters)

class InitialAssignment(SBase):
    """
    LibSBML implementation of %SBML's %InitialAssignment construct.

    SBML Level 2 Versions 2, 3 and 4 provide two ways of assigning initial
    values to entities in a model.  The simplest and most basic is to set
    the values of the appropriate attributes in the relevant components; for
    example, the initial value of a model parameter (whether it is a
    constant or a variable) can be assigned by setting its 'value' attribute
    directly in the model definition.  However, this approach is not
    suitable when the value must be calculated, because the initial value
    attributes on different components such as species, compartments, and
    parameters are single values and not mathematical expressions.  In those
    situations, the InitialAssignment construct can be used; it permits the
    calculation of the value of a constant or the initial value of a
    variable from the values of @em other quantities in a model.

    As explained below, the provision of InitialAssignment does not mean
    that models necessarily must use this construct when defining initial
    values of quantities in a model.  If a value can be set directly using
    the relevant attribute of a component in a model, then that
    approach may be more efficient and more portable to other software
    tools.  InitialAssignment should be used when the other mechanism is
    insufficient for the needs of a particular model.

    The InitialAssignment construct has some similarities to AssignmentRule.
    The main differences are: (a) an InitialAssignment can set the value of
    a constant whereas an AssignmentRule cannot, and (b) unlike
    AssignmentRule, an InitialAssignment definition only applies up to and
    including the beginning of simulation time, i.e., <em>t <= 0</em>,
    while an AssignmentRule applies at all times.

    InitialAssignment has a required attribute, 'symbol', whose value must
    follow the guidelines for identifiers described in the %SBML
    specification (e.g., Section 3.3 in the Level 2 Version 4
    specification).  The value of this attribute in an InitialAssignment
    object can be the identifier of a Compartment, Species or global
    Parameter elsewhere in the model.  The InitialAssignment defines the
    initial value of the constant or variable referred to by the 'symbol'
    attribute.  (The attribute's name is 'symbol' rather than 'variable'
    because it may assign values to constants as well as variables in a
    model.)  Note that an initial assignment cannot be made to reaction
    identifiers, that is, the 'symbol' attribute value of an
    InitialAssignment cannot be an identifier that is the 'id' attribute
    value of a Reaction object in the model.  This is identical to a
    restriction placed on rules.

    InitialAssignment also has a required 'math' subelement that contains a
    MathML expression used to calculate the value of the constant or the
    initial value of the variable.  The units of the value computed by the
    formula in the 'math' subelement should (in SBML Level&nbsp;2
    Version&nbsp;4) or must (in previous Versions) be identical to be the
    units associated with the identifier given in the 'symbol' attribute.
    (That is, the units are the units of the species, compartment, or
    parameter, as appropriate for the kind of object identified by the value
    of 'symbol'.)

    InitialAssignment was introduced in SBML Level 2 Version 2.  It is not
    available in earlier versions of Level 2 nor in any version of Level 1.

    @section initassign-semantics Semantics of Initial Assignments

    The value calculated by an InitialAssignment object overrides the value
    assigned to the given symbol by the object defining that symbol.  For
    example, if a compartment's 'size' attribute is set in its definition,
    and the model also contains an InitialAssignment having that
    compartment's identifier as its 'symbol' attribute value, then the
    interpretation is that the 'size' assigned in the Compartment object
    should be ignored and the value assigned based on the computation
    defined in the InitialAssignment.  Initial assignments can take place
    for Compartment, Species and global Parameter objects regardless of the
    value of their 'constant' attribute.

    The actions of all InitialAssignment objects are in general terms
    the same, but differ in the precise details depending on the type
    of variable being set:
    <ul>
    <li> <em>In the case of a species</em>, an InitialAssignment sets the
    referenced species' initial quantity (concentration or amount of
    substance) to the value determined by the formula in the 'math'
    subelement.    The overall units of the formula should (in SBML
    Level&nbsp;2 Version&nbsp;4) or must (in previous Versions) be the same
    as the units specified for the species.

    <li> <em>In the case of a compartment</em>, an InitialAssignment sets
    the referenced compartment's initial size to the size determined by the
    formula in 'math'.  The overall units of the formula should (in SBML
    Level&nbsp;2 Version&nbsp;4) or must (in previous Versions) be the same
    as the units specified for the size of the compartment.

    <li> <em>In the case of a parameter</em>, an InitialAssignment sets the
    referenced parameter's initial value to that determined by the formula
    in 'math'.  The overall units of the formula should (in SBML
    Level&nbsp;2 Version&nbsp;4) or must (in previous Versions) be the same
    as the units defined for the parameter.  </ul>

    In the context of a simulation, initial assignments establish values
    that are in effect prior to and including the start of simulation time,
    i.e., <em>t <= 0</em>.  Section 3.4.8 in the SBML Level 2
    Version 4 specification provides information about the interpretation of
    assignments, rules, and entity values for simulation time up to and
    including the start time <em>t = 0</em>; this is important for
    establishing the initial conditions of a simulation if the model
    involves expressions containing the <em>delay</em> 'csymbol'.

    There cannot be two initial assignments for the same symbol in a model;
    that is, a model must not contain two or more InitialAssignment objects
    that both have the same identifier as their 'symbol' attribute value.  A
    model must also not define initial assignments <em>and</em> assignment
    rules for the same entity.  That is, there cannot be <em>both</em> an
    InitialAssignment and an AssignmentRule for the same symbol in a model,
    because both kinds of constructs apply prior to and at the start of
    simulated time&mdash;allowing both to exist for a given symbol would
    result in indeterminism).

    The ordering of InitialAssignment objects is not significant.  The
    combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects form a set of assignment statements that must be considered as a
    whole.  The combined set of assignment statements should not contain
    algebraic loops: a chain of dependency between these statements should
    terminate.  (More formally, consider the directed graph of assignment
    statements where nodes are a model's assignment statements and directed
    arcs exist for each occurrence of a symbol in an assignment statement
    'math' attribute.  The directed arcs in this graph start from the
    statement assigning the symbol and end at the statement that contains
    the symbol in their math elements.  Such a graph must be acyclic.)

    Finally, it is worth being explicit about the expected behavior in the
    following situation.  Suppose (1) a given symbol has a value <em>x</em>
    assigned to it in its definition, and (2) there is an initial assignment
    having the identifier as its 'symbol' value and reassigning the value to
    <em>y</em>, <em>and</em> (3) the identifier is also used in the
    mathematical formula of a second initial assignment.  What value should
    the second initial assignment use?  It is <em>y</em>, the value assigned
    to the symbol by the first initial assignment, not whatever value was
    given in the symbol's definition.  This follows directly from the
    behavior described above: if an InitialAssignment object exists for a
    given symbol, then the symbol's value is overridden by that initial
    assignment.

    <!---------------------------------------------------------------------- -->


    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitialAssignment, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitialAssignment, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_InitialAssignment
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> InitialAssignment
        __init__(self, SBMLNamespaces sbmlns) -> InitialAssignment
        __init__(self, InitialAssignment orig) -> InitialAssignment

        Predicate returning @c true if
        all the required elements for this InitialAssignment object
        have been set.

        @note The required elements for a InitialAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_InitialAssignment(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> InitialAssignment

        Creates and returns a deep copy of this InitialAssignment.

        @return a (deep) copy of this InitialAssignment.
          

        """
        return _libsbml.InitialAssignment_clone(self)

    def getSymbol(self):
        """
        getSymbol(self) -> string

        Get the value of the 'symbol' attribute of this InitialAssignment.

        @return the identifier string stored as the 'symbol' attribute value
        in this InitialAssignment.
          

        """
        return _libsbml.InitialAssignment_getSymbol(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula of this InitialAssignment.

        @return an ASTNode, the value of the 'math' subelement of this
        InitialAssignment
          

        """
        return _libsbml.InitialAssignment_getMath(self)

    def isSetSymbol(self):
        """
        isSetSymbol(self) -> bool

        Predicate returning @c true if this
        InitialAssignment's 'symbol' attribute has been set.

        @return @c true if the 'symbol' attribute of this InitialAssignment
        has been set, @c false otherwise.
          

        """
        return _libsbml.InitialAssignment_isSetSymbol(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c true if this
        InitialAssignment's 'math' subelement contains a value.

        @return @c true if the 'math' for this InitialAssignment has been set,
        @c false otherwise.
          

        """
        return _libsbml.InitialAssignment_isSetMath(self)

    def setSymbol(self, *args):
        """
        setSymbol(self, string sid) -> int

        Sets the 'symbol' attribute value of this InitialAssignment.

        @param sid the identifier of a Species, Compartment or Parameter
        object defined elsewhere in this Model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.InitialAssignment_setSymbol(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this InitialAssignment.

        The AST passed in @p math is copied.

        @param math an AST containing the mathematical expression to
        be used as the formula for this InitialAssignment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.InitialAssignment_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units
        of measurement assumed for the 'math' expression of this
        InitialAssignment.

        The units are calculated based on the mathematical expression in the
        InitialAssignment and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The
        getDerivedUnitDefinition() method returns the calculated units.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c NULL.

        @warning Note that it is possible the 'math' expression in the
        InitialAssignment contains pure numbers or parameters with undeclared
        units.  In those cases, it is not possible to calculate the units of
        the overall expression without making assumptions.  LibSBML does not
        make assumptions about the units, and getDerivedUnitDefinition() only
        returns the units as far as it is able to determine them.  For
        example, in an expression <em>X + Y</em>, if <em>X</em> has
        unambiguously-defined units and <em>Y</em> does not, it will return
        the units of <em>X</em>.  <strong>It is important that callers also
        invoke the method</strong> containsUndeclaredUnits() <strong>to
        determine whether this situation holds</strong>.  Callers may wish to
        take suitable actions in those scenarios.

        @return a UnitDefinition that expresses the units of the math 
        expression of this InitialAssignment, or @c NULL if one cannot be constructed.

        @see containsUndeclaredUnits()
          

        """
        return _libsbml.InitialAssignment_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c true if 
        the math expression of this InitialAssignment contains
        parameters/numbers with undeclared units.

        @return @c true if the math expression of this InitialAssignment
        includes parameters/numbers 
        with undeclared units, @c false otherwise.

        @note A return value of @c true indicates that the UnitDefinition
        returned by getDerivedUnitDefinition() may not accurately represent
        the units of the expression.

        @see getDerivedUnitDefinition()
          

        """
        return _libsbml.InitialAssignment_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.InitialAssignment_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        InitialAssignment, is always @c 'initialAssignment'.

        @return the name of this element, i.e., @c 'initialAssignment'.
          

        """
        return _libsbml.InitialAssignment_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this InitialAssignment object
        have been set.

        @note The required attributes for an InitialAssignment object are:
        @li 'symbol'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.InitialAssignment_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this InitialAssignment object
        have been set.

        @note The required elements for a InitialAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.InitialAssignment_hasRequiredElements(self)

    def getId(self):
        """
        getId(self) -> string

        Predicate returning @c true if
        all the required elements for this InitialAssignment object
        have been set.

        @note The required elements for a InitialAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        return _libsbml.InitialAssignment_getId(self)

InitialAssignment_swigregister = _libsbml.InitialAssignment_swigregister
InitialAssignment_swigregister(InitialAssignment)

class ListOfInitialAssignments(ListOf):
    """
    LibSBML implementation of SBML's %ListOfInitialAssignments construct.

    The various ListOf___ classes in %SBML are merely containers used for
    organizing the main components of an %SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an %SBML model is
    illustrated by the following (for %SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfInitialAssignments, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfInitialAssignments, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfInitialAssignments

        Creates and returns a deep copy of this ListOfInitialAssignments instance.

        @return a (deep) copy of this ListOfInitialAssignments.
          

        """
        return _libsbml.ListOfInitialAssignments_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfInitialAssignments_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., InitialAssignment objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfInitialAssignments_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfInitialAssignments, the XML element name is @c
        'listOfInitialAssignments'.

        @return the name of this element, i.e., @c 'listOfInitialAssignments'.
          

        """
        return _libsbml.ListOfInitialAssignments_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> InitialAssignment
        get(self, unsigned int n) -> InitialAssignment
        get(self, string sid) -> InitialAssignment
        get(self, string sid) -> InitialAssignment

        Get a InitialAssignment from the ListOfInitialAssignments
        based on its identifier.

        @param sid a string representing the identifier 
        of the InitialAssignment to get.

        @return InitialAssignment in this ListOfInitialAssignments
        with the given id or @c NULL if no such
        InitialAssignment exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfInitialAssignments_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> InitialAssignment
        remove(self, string sid) -> InitialAssignment

        Removes item in this ListOfInitialAssignments items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfInitialAssignments_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfInitialAssignments"""
        this = _libsbml.new_ListOfInitialAssignments()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfInitialAssignments
    __del__ = lambda self : None;
ListOfInitialAssignments_swigregister = _libsbml.ListOfInitialAssignments_swigregister
ListOfInitialAssignments_swigregister(ListOfInitialAssignments)

RULE_TYPE_RATE = _libsbml.RULE_TYPE_RATE
RULE_TYPE_SCALAR = _libsbml.RULE_TYPE_SCALAR
RULE_TYPE_INVALID = _libsbml.RULE_TYPE_INVALID
class Rule(SBase):
    """
    LibSBML implementation of %SBML's %Rule construct.

    In SBML, @em rules provide additional ways to define the values of
    variables in a model, their relationships, and the dynamical behaviors
    of those variables.  They enable encoding relationships that cannot be
    expressed using Reaction nor InitialAssignment objects alone.

    The libSBML implementation of rules mirrors the SBML Level&nbsp;3
    Version&nbsp;1 Core definition (which is in turn is very similar to the
    Level&nbsp;2 Version&nbsp;4 definition), with Rule being the parent
    class of three subclasses as explained below.  The Rule class itself
    cannot be instantiated by user programs and has no constructor; only the
    subclasses AssignmentRule, AlgebraicRule and RateRule can be
    instantiated directly.

    @section general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into
    three subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible
    functional forms (where <em>x</em> is a variable, <em>f</em> is some
    arbitrary function returning a numerical result, <b><em>V</em></b> is a
    vector of variables that does not include <em>x</em>, and
    <b><em>W</em></b> is a vector of variables that may include <em>x</em>):

    <center>
    <table border='0' cellpadding='0' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>
    </center>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    <ul>
    <li> <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)<p>

    <li> SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.<p>

    <li> Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;<p>

    <li> Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and<p>

    <li> Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.
    </ul>

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section additional-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection no-algebraic-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops&mdash;dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection no-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in Appendix
    B of the SBML Level&nbsp;3 Version&nbsp;1 Core specification for assessing
    whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)


    @section RuleType_t RuleType_t for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level&nbsp;2 and
    Level&nbsp;3 for distinguishing rules; specifically, it uses an
    attribute whose value is drawn from an enumeration.  LibSBML supports
    this using methods that work with the #RuleType_t enumeration.

    <p>
    <center>
    <table width='90%' cellspacing='1' cellpadding='1' border='0' class='normal-font'>
     <tr style='background: lightgray' class='normal-font'>
         <td><strong>Enumerator</strong></td>
         <td><strong>Meaning</strong></td>
     </tr>
    <tr><td><em>@link RuleType_t#RULE_TYPE_RATE RULE_TYPE_RATE@endlink</em></td><td>Indicates the rule is a 'rate' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink</em></td><td>Indicates the rule is a 'scalar' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink</em></td><td>Indicates the rule type is unknown or not
    yet set.</td>
    </table>
    </center>


    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rule, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Rule, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Rule
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, Rule orig) -> Rule

        Only subclasses may create Rules.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Rule(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Rule

        Creates and returns a deep copy of this Rule.

        @return a (deep) copy of this Rule.
          

        """
        return _libsbml.Rule_clone(self)

    def getFormula(self):
        """
        getFormula(self) -> string

        Returns the mathematical expression of this Rule in text-string form.

        The text string is produced by SBML_formulaToString(); please consult
        the documentation for that function to find out more about the format
        of the text-string formula.

        @return the formula text string for this Rule.

        @see getMath()

        @note The attribute 'formula' is specific to SBML Level&nbsp;1; in
        higher Levels of SBML, it has been replaced with a subelement named
        'math'.  However, libSBML provides a unified interface to the
        underlying math expression and this method can be used for models
        of all Levels of SBML.
          

        """
        return _libsbml.Rule_getFormula(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula of this Rule as an ASTNode tree.

        @return an ASTNode, the value of the 'math' subelement of this Rule.

        @see getFormula()

        @note The subelement 'math' is present in SBML Levels&nbsp;2
        and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the
        attribute named 'formula'.  LibSBML provides a unified interface to
        the underlying math expression and this method can be used for models
        of all Levels of SBML.
          

        """
        return _libsbml.Rule_getMath(self)

    def getVariable(self):
        """
        getVariable(self) -> string

        Get the value of the 'variable' attribute of this Rule object.

        In SBML Level&nbsp;1, the different rule types each have a different
        name for the attribute holding the reference to the object
        constituting the left-hand side of the rule.  (E.g., for
        SpeciesConcentrationRule the attribute is 'species', for
        CompartmentVolumeRule it is 'compartment', etc.)  In SBML
        Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a
        left-hand side object reference are AssignmentRule and RateRule, and
        both of them use the same name for attribute: 'variable'.  In order to
        make it easier for application developers to work with all Levels of
        SBML, libSBML uses a uniform name for all of such attributes, and it
        is 'variable', regardless of whether Level&nbsp;1 rules or
        Level&nbsp;2&ndash;3 rules are being used.

        @return the identifier string stored as the 'variable' attribute value
        in this Rule, or @c NULL if this object is an AlgebraicRule object.
          

        """
        return _libsbml.Rule_getVariable(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Returns the units for the
        mathematical formula of this Rule.

        @return the identifier of the units for the expression of this Rule.

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.
          

        """
        return _libsbml.Rule_getUnits(self)

    def isSetFormula(self):
        """
        isSetFormula(self) -> bool

        Predicate returning @c true if this
        Rule's mathematical expression has been set.

        This method is equivalent to isSetMath().  This version is present for
        easier compatibility with SBML Level&nbsp;1, in which mathematical
        formulas were written in text-string form.

        @return @c true if the mathematical formula for this Rule has been
        set, @c false otherwise.

        @see isSetMath()

        @note The attribute 'formula' is specific to SBML Level&nbsp;1; in
        higher Levels of SBML, it has been replaced with a subelement named
        'math'.  However, libSBML provides a unified interface to the
        underlying math expression and this method can be used for models
        of all Levels of SBML.
          

        """
        return _libsbml.Rule_isSetFormula(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c true if this
        Rule's mathematical expression has been set.

        This method is equivalent to isSetFormula().

        @return @c true if the formula (or equivalently the math) for this
        Rule has been set, @c false otherwise.

        @note The subelement 'math' is present in SBML Levels&nbsp;2
        and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the
        attribute named 'formula'.  LibSBML provides a unified interface to
        the underlying math expression and this method can be used for models
        of all Levels of SBML.
          

        """
        return _libsbml.Rule_isSetMath(self)

    def isSetVariable(self):
        """
        isSetVariable(self) -> bool

        Predicate returning @c true if this
        Rule's 'variable' attribute has been set.

        In SBML Level&nbsp;1, the different rule types each have a different
        name for the attribute holding the reference to the object
        constituting the left-hand side of the rule.  (E.g., for
        SpeciesConcentrationRule the attribute is 'species', for
        CompartmentVolumeRule it is 'compartment', etc.)  In SBML
        Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a
        left-hand side object reference are AssignmentRule and RateRule, and
        both of them use the same name for attribute: 'variable'.  In order to
        make it easier for application developers to work with all Levels of
        SBML, libSBML uses a uniform name for all such attributes, and it is
        'variable', regardless of whether Level&nbsp;1 rules or
        Level&nbsp;2&ndash;3 rules are being used.

        @return @c true if the 'variable' attribute value of this Rule has
        been set, @c false otherwise.
          

        """
        return _libsbml.Rule_isSetVariable(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c true
        if this Rule's 'units' attribute has been set.

        @return @c true if the units for this Rule has been set, @c false
        otherwise

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.
          

        """
        return _libsbml.Rule_isSetUnits(self)

    def setFormula(self, *args):
        """
        setFormula(self, string formula) -> int

        Sets the 'math' subelement of this Rule to an expression in
        text-string form.

        This is equivalent to setMath().  The provision of using text-string
        formulas is retained for easier SBML Level&nbsp;1 compatibility.  The
        formula is converted to an ASTNode internally.

        @param formula a mathematical formula in text-string form.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink

        @note The attribute 'formula' is specific to SBML Level&nbsp;1; in
        higher Levels of SBML, it has been replaced with a subelement named
        'math'.  However, libSBML provides a unified interface to the
        underlying math expression and this method can be used for models
        of all Levels of SBML.
          

        """
        return _libsbml.Rule_setFormula(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this Rule to a copy of the given
        ASTNode.

        @param math the ASTNode structure of the mathematical formula.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink

        @note The subelement 'math' is present in SBML Levels&nbsp;2
        and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the
        attribute named 'formula'.  LibSBML provides a unified interface to
        the underlying math expression and this method can be used for models
        of all Levels of SBML.
          

        """
        return _libsbml.Rule_setMath(self, *args)

    def setVariable(self, *args):
        """
        setVariable(self, string sid) -> int

        Sets the 'variable' attribute value of this Rule object.

        In SBML Level&nbsp;1, the different rule types each have a different
        name for the attribute holding the reference to the object
        constituting the left-hand side of the rule.  (E.g., for
        SpeciesConcentrationRule the attribute is 'species', for
        CompartmentVolumeRule it is 'compartment', etc.)  In SBML
        Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a
        left-hand side object reference are AssignmentRule and RateRule, and
        both of them use the same name for attribute: 'variable'.  In order to
        make it easier for application developers to work with all Levels of
        SBML, libSBML uses a uniform name for all such attributes, and it is
        'variable', regardless of whether Level&nbsp;1 rules or
        Level&nbsp;2&ndash;3 rules are being used.

        @param sid the identifier of a Compartment, Species or Parameter
        elsewhere in the enclosing Model object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Rule_setVariable(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string sname) -> int

        Sets the units for this Rule.

        @param sname the identifier of the units

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.
          

        """
        return _libsbml.Rule_setUnits(self, *args)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the 'units' for this Rule.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.
          

        """
        return _libsbml.Rule_unsetUnits(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units of
        measurement assumed for the 'math' expression of this Rule.

        The units are calculated based on the mathematical expression in the
        Rule and the model quantities referenced by <code>&lt;ci&gt;</code>
        elements used within that expression.  The getDerivedUnitDefinition()
        method returns the calculated units.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c NULL.

        @warning Note that it is possible the 'math' expression in the Rule
        contains pure numbers or parameters with undeclared units.  In those
        cases, it is not possible to calculate the units of the overall
        expression without making assumptions.  LibSBML does not make
        assumptions about the units, and getDerivedUnitDefinition() only
        returns the units as far as it is able to determine them.  For
        example, in an expression <em>X + Y</em>, if <em>X</em> has
        unambiguously-defined units and <em>Y</em> does not, it will return
        the units of <em>X</em>.  <strong>It is important that callers also
        invoke the method</strong> containsUndeclaredUnits() <strong>to
        determine whether this situation holds</strong>.  Callers may wish to
        take suitable actions in those scenarios.

        @return a UnitDefinition that expresses the units of the math 
        expression of this Rule, or @c NULL if one cannot be constructed.

        @see containsUndeclaredUnits()
          

        """
        return _libsbml.Rule_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c true if 
        the math expression of this Rule contains
        parameters/numbers with undeclared units.

        @return @c true if the math expression of this Rule
        includes parameters/numbers 
        with undeclared units, @c false otherwise.

        @note A return value of @c true indicates that the UnitDefinition
        returned by getDerivedUnitDefinition() may not accurately represent
        the units of the expression.

        @see getDerivedUnitDefinition()
          

        """
        return _libsbml.Rule_containsUndeclaredUnits(self, *args)

    def getType(self):
        """
        getType(self) -> RuleType_t

        Get the type of rule this is.

        @return the rule type (a value drawn from the enumeration <a
        class='el' href='#RuleType_t'>RuleType_t</a>) of this Rule.  The value
        will be either @link RuleType_t#RULE_TYPE_RATE RULE_TYPE_RATE@endlink
        or @link RateRule_t#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink.

        @note The attribute 'type' on Rule objects was present only in SBML
        Level&nbsp;1.  In SBML Level&nbsp;2 and later, the type has been
        replaced by subclassing the Rule object.
          

        """
        return _libsbml.Rule_getType(self)

    def isAlgebraic(self):
        """
        isAlgebraic(self) -> bool

        Predicate returning @c true if this
        Rule is an AlgebraicRule.

        @return @c true if this Rule is an AlgebraicRule, @c false otherwise.
          

        """
        return _libsbml.Rule_isAlgebraic(self)

    def isAssignment(self):
        """
        isAssignment(self) -> bool

        Predicate returning @c true if this
        Rule is an AssignmentRule.

        @return @c true if this Rule is an AssignmentRule, @c false otherwise.
          

        """
        return _libsbml.Rule_isAssignment(self)

    def isCompartmentVolume(self):
        """
        isCompartmentVolume(self) -> bool

        Predicate returning @c true if
        this Rule is an CompartmentVolumeRule.

        @return @c true if this Rule is a CompartmentVolumeRule, @c false
        otherwise.
          

        """
        return _libsbml.Rule_isCompartmentVolume(self)

    def isParameter(self):
        """
        isParameter(self) -> bool

        Predicate returning @c true if
        this Rule is an ParameterRule.

        @return @c true if this Rule is a ParameterRule, @c false
        otherwise.
          

        """
        return _libsbml.Rule_isParameter(self)

    def isRate(self):
        """
        isRate(self) -> bool

        Predicate returning @c true if this Rule
        is a RateRule (SBML Levels&nbsp;2&ndash;3) or has a 'type' attribute
        value of @c 'rate' (SBML Level&nbsp;1).

        @return @c true if this Rule is a RateRule (Level&nbsp;2) or has
        type 'rate' (Level&nbsp;1), @c false otherwise.
          

        """
        return _libsbml.Rule_isRate(self)

    def isScalar(self):
        """
        isScalar(self) -> bool

        Predicate returning @c true if this Rule
        is an AssignmentRule (SBML Levels&nbsp;2&ndash;3) or has a 'type'
        attribute value of @c 'scalar' (SBML Level&nbsp;1).

        @return @c true if this Rule is an AssignmentRule (Level&nbsp;2) or has
        type 'scalar' (Level&nbsp;1), @c false otherwise.
          

        """
        return _libsbml.Rule_isScalar(self)

    def isSpeciesConcentration(self):
        """
        isSpeciesConcentration(self) -> bool

        Predicate returning @c true if
        this Rule is an SpeciesConcentrationRule.

        @return @c true if this Rule is a SpeciesConcentrationRule, @c false
        otherwise.
          

        """
        return _libsbml.Rule_isSpeciesConcentration(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Rule_getTypeCode(self)

    def getL1TypeCode(self):
        """
        getL1TypeCode(self) -> SBMLTypeCode_t

        Returns the SBML Level&nbsp;1 type code for this Rule object.

        This only applies to SBML Level&nbsp;1 model objects.  If this is not
        an SBML Level&nbsp;1 rule object, this method will return @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink.

        @return the SBML Level&nbsp;1 type code for this Rule (namely, @link
        SBMLTypeCode_t#SBML_COMPARTMENT_VOLUME_RULE
        SBML_COMPARTMENT_VOLUME_RULE@endlink, @link
        SBMLTypeCode_t#SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink, @link
        SBMLTypeCode_t#SBML_SPECIES_CONCENTRATION_RULE
        SBML_SPECIES_CONCENTRATION_RULE@endlink, or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink).
          

        """
        return _libsbml.Rule_getL1TypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object

        The returned value can be any of a number of different strings,
        depending on the SBML Level in use and the kind of Rule object this
        is.  The rules as of libSBML 4.1.0 are the following:
        <ul>
        <li> (Level&nbsp;2 and&nbsp;3) RateRule: returns @c 'rateRule'
        <li> (Level&nbsp;2 and&nbsp;3) AssignmentRule: returns @c 'assignmentRule' 
        <li> (Level&nbsp;2 and&nbsp;3) AlgebraicRule: returns @c 'algebraicRule'
        <li> (Level&nbsp;1 Version&nbsp;1) SpecieConcentrationRule: returns @c 'specieConcentrationRule'
        <li> (Level&nbsp;1 Version&nbsp;2) SpeciesConcentrationRule: returns @c 'speciesConcentrationRule'
        <li> (Level&nbsp;1) CompartmentVolumeRule: returns @c 'compartmentVolumeRule'
        <li> (Level&nbsp;1) ParameterRule: returns @c 'parameterRule'
        <li> Unknown rule type: returns @c 'unknownRule'
        </ul>

        Beware that the last (@c 'unknownRule') is not a valid SBML element
        name.

        @return the name of this element
          

        """
        return _libsbml.Rule_getElementName(self)

    def setL1TypeCode(self, *args):
        """
        setL1TypeCode(self, SBMLTypeCode_t type) -> int

        Sets the SBML Level&nbsp;1 type code for this Rule.

        @param type the SBML Level&nbsp;1 type code for this Rule, drawn from
        the enumeration #SBMLTypeCode_t.  The allowable values are @link
        SBMLTypeCode_t#SBML_COMPARTMENT_VOLUME_RULE
        SBML_COMPARTMENT_VOLUME_RULE@endlink, @link
        SBMLTypeCode_t#SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink, and
        @link SBMLTypeCode_t#SBML_SPECIES_CONCENTRATION_RULE
        SBML_SPECIES_CONCENTRATION_RULE@endlink.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        if given @p type value is not one of the above.

          

        """
        return _libsbml.Rule_setL1TypeCode(self, *args)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if all the
        required elements for this Rule object have been set.

        The only required element for a Rule object is the 'math' subelement.

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.Rule_hasRequiredElements(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if all the
        required attributes for this Rule object have been set.

        The required attributes for a Rule object depend on the type of Rule
        it is.  For AssignmentRule and RateRule objects (and SBML
        Level&nbsp1's SpeciesConcentrationRule, CompartmentVolumeRule, and
        ParameterRule objects), the required attribute is 'variable'; for
        AlgebraicRule objects, there is no required attribute.

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.Rule_hasRequiredAttributes(self)

    def getId(self):
        """
        getId(self) -> string

        Predicate returning @c true if all the
        required attributes for this Rule object have been set.

        The required attributes for a Rule object depend on the type of Rule
        it is.  For AssignmentRule and RateRule objects (and SBML
        Level&nbsp1's SpeciesConcentrationRule, CompartmentVolumeRule, and
        ParameterRule objects), the required attribute is 'variable'; for
        AlgebraicRule objects, there is no required attribute.

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        return _libsbml.Rule_getId(self)

Rule_swigregister = _libsbml.Rule_swigregister
Rule_swigregister(Rule)

class AlgebraicRule(Rule):
    """
    LibSBML implementation of %SBML's %AlgebraicRule construct.

    The rule type AlgebraicRule is derived from the parent class Rule.  It
    is used to express equations that are neither assignments of model
    variables nor rates of change.  AlgebraicRule does not add any
    attributes to the basic Rule; its role is simply to distinguish this
    case from the other cases.

    In the context of a simulation, algebraic rules are in effect at all
    times, <em>t</em> >= <em>0</em>.  For purposes of evaluating
    expressions that involve the delay 'csymbol' (see the SBML
    specification), algebraic rules are considered to apply also at
    <em>t</em> <= <em>0</em>.  Please consult the relevant SBML
    specification for additional information about the semantics of
    assignments, rules, and entity values for simulation time <em>t</em>
    <= <em>0</em>.

    The ability to define arbitrary algebraic expressions in an SBML model
    introduces the possibility that a model is mathematically overdetermined
    by the overall system of equations constructed from its rules and
    reactions.  An SBML model must not be overdetermined.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    Assessing whether a given continuous, deterministic, mathematical model
    is overdetermined does not require dynamic analysis; it can be done by
    analyzing the system of equations created from the model.  One approach
    is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents
    the equations.  Place edges between vertices such that variables in the
    system are linked to the equations that determine them.  For algebraic
    equations, there will be edges between the equation and each variable
    occurring in the equation.  For ordinary differential equations (such as
    those defined by rate rules or implied by the reaction rate
    definitions), there will be a single edge between the equation and the
    variable determined by that differential equation.  A mathematical model
    is overdetermined if the maximal matchings of the bipartite graph
    contain disconnected vertexes representing equations.  (If one maximal
    matching has this property, then all the maximal matchings will have
    this property; i.e., it is only necessary to find one maximal matching.)
    Appendix&nbsp;B of the SBML Level&nbsp;3 Version&nbsp;1 Core
    specification document describes a method of applying this procedure to
    specific SBML data objects.


    @section general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into
    three subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible
    functional forms (where <em>x</em> is a variable, <em>f</em> is some
    arbitrary function returning a numerical result, <b><em>V</em></b> is a
    vector of variables that does not include <em>x</em>, and
    <b><em>W</em></b> is a vector of variables that may include <em>x</em>):

    <center>
    <table border='0' cellpadding='0' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>
    </center>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    <ul>
    <li> <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)<p>

    <li> SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.<p>

    <li> Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;<p>

    <li> Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and<p>

    <li> Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.
    </ul>

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section additional-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection no-algebraic-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops&mdash;dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection no-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in Appendix
    B of the SBML Level&nbsp;3 Version&nbsp;1 Core specification for assessing
    whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)


    @section RuleType_t RuleType_t for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level&nbsp;2 and
    Level&nbsp;3 for distinguishing rules; specifically, it uses an attribute
    whose value is drawn from an enumeration.  LibSBML supports this using
    methods that work with the #RuleType_t enumeration.

    <p>
    <center>
    <table width='90%' cellspacing='1' cellpadding='1' border='0' class='normal-font'>
     <tr style='background: lightgray' class='normal-font'>
         <td><strong>Enumerator</strong></td>
         <td><strong>Meaning</strong></td>
     </tr>
    <tr><td><em>@link RuleType_t#RULE_TYPE_RATE RULE_TYPE_RATE@endlink</em></td><td>Indicates the rule is a 'rate' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink</em></td><td>Indicates the rule is a 'scalar' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink</em></td><td>Indicates the rule type is unknown or not
    yet set.</td>
    </table>
    </center>

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [Rule]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AlgebraicRule, name, value)
    __swig_getmethods__ = {}
    for _s in [Rule]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AlgebraicRule, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> AlgebraicRule
        __init__(self, SBMLNamespaces sbmlns) -> AlgebraicRule

        Predicate returning @c true if
        all the required attributes for this AlgebraicRule object
        have been set.

        @note In SBML Levels&nbsp;2&ndash;3, there is no required attribute
        for an AlgebraicRule object.  For Level&nbsp;1, the only required
        attribute is 'formula'.

        @return @c true if the required attributes have been set, @c false
        otherwise.
        @deprecated libSBML internal


        """
        this = _libsbml.new_AlgebraicRule(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_AlgebraicRule
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> AlgebraicRule

        Creates and returns a deep copy of this Rule.

        @return a (deep) copy of this Rule.
          

        """
        return _libsbml.AlgebraicRule_clone(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this AlgebraicRule object
        have been set.

        @note In SBML Levels&nbsp;2&ndash;3, there is no required attribute
        for an AlgebraicRule object.  For Level&nbsp;1, the only required
        attribute is 'formula'.

        @return @c true if the required attributes have been set, @c false
        otherwise.
          

        """
        return _libsbml.AlgebraicRule_hasRequiredAttributes(self)

AlgebraicRule_swigregister = _libsbml.AlgebraicRule_swigregister
AlgebraicRule_swigregister(AlgebraicRule)

class AssignmentRule(Rule):
    """
    LibSBML implementation of %SBML's %AssignmentRule construct.

    The rule type AssignmentRule is derived from the parent class Rule.  It
    is used to express equations that set the values of variables.  The
    left-hand side (the attribute named 'variable') of an assignment rule
    can refer to the identifier of a Species, SpeciesReference (in SBML
    Level&nbsp;3), Compartment, or Parameter object in the model (but not a
    Reaction).  The entity identified must have its 'constant' attribute set
    to @c false.  The effects of an AssignmentRule are in general terms the
    same, but differ in the precise details depending on the type of
    variable being set: <ul>
    <li> <em>In the case of a species</em>, an AssignmentRule sets the
    referenced species' quantity (whether a 'concentration' or 'amount') to
    the value determined by the formula in the MathML subelement 'math'.
    The unit associated with the value produced by the 'math' formula @em
    should (in SBML Level&nbsp;2 Version&nbsp;4 and later) or @em must (in
    SBML releases prior to Level&nbsp;2 version&nbsp;4) be equal to the unit
    associated with the species' quantity.  <em>Restrictions</em>: There
    must not be both an AssignmentRule 'variable' attribute and a
    SpeciesReference 'species' attribute having the same value, unless the
    referenced Species object has its 'boundaryCondition' attribute set to
    @c true.  In other words, an assignment rule cannot be defined for a
    species that is created or destroyed in a reaction unless that species
    is defined as a boundary condition in the model.

    <li> (For SBML Level&nbsp;3 only) <em>In the case of a species
    reference</em>, an AssignmentRule sets the stoichiometry of the
    referenced reactant or product to the value determined by the formula in
    'math'.  The unit associated with the value produced by the 'math'
    formula should be consistent with the unit 'dimensionless', because
    reactant and product stoichiometries in reactions are dimensionless
    quantities.

    <li> <em>In the case of a compartment</em>, an AssignmentRule sets the
    referenced compartment's size to the value determined by the formula in
    the 'math' subelement of the AssignmentRule object.  The overall units
    of the formula in 'math' @em should (in SBML Level&nbsp;2 Version&nbsp;4
    and later) or @em must (in SBML releases prior to Level&nbsp;2
    version&nbsp;4) be the same as the units of the size of the compartment.

    <li> <em>In the case of a parameter</em>, an AssignmentRule sets the
    referenced parameter's value to that determined by the formula in the
    'math' subelement of the AssignmentRule object.  The overall units of
    the formula in the 'math' subelement @em should (in SBML Level&nbsp;2
    Version&nbsp;4 and later) or @em must (in SBML releases prior to
    Level&nbsp;2 version&nbsp;4) be the same as the units defined for the
    parameter.  </ul>

    In the context of a simulation, assignment rules are in effect at all
    times, <em>t</em> >= <em>0</em>.  For purposes of evaluating
    expressions that involve the <em>delay</em> 'csymbol' (see the SBML
    Level&nbsp;2 specification), assignment rules are considered to apply
    also at <em>t</em> <= <em>0</em>.  Please consult the relevant
    SBML specification for additional information about the semantics of
    assignments, rules, and entity values for simulation time <em>t</em>
    <= <em>0</em>.

    A model must not contain more than one AssignmentRule or RateRule
    object having the same value of 'variable'; in other words, in the set
    of all assignment rules and rate rules in an SBML model, each variable
    appearing in the left-hand sides can only appear once.  This simply
    follows from the fact that an indeterminate system would result if a
    model contained more than one assignment rule for the same variable or
    both an assignment rule and a rate rule for the same variable.

    Similarly, a model must also not contain <em>both</em> an AssignmentRule
    and an InitialAssignment for the same variable, because both kinds of
    constructs apply prior to and at the start of simulation time, i.e.,
    <em>t</em> <= <em>0</em>.  If a model contained both an initial
    assignment and an assignment rule for the same variable, an
    indeterminate system would result.

    The value calculated by an AssignmentRule object overrides the value
    assigned to the given symbol by the object defining that symbol.  For
    example, if a Compartment object's 'size' attribute value is set in its
    definition, and the model also contains an AssignmentRule object having
    that compartment's 'id' as its 'variable' value, then the 'size'
    assigned in the Compartment object definition is ignored and the value
    assigned based on the computation defined in the AssignmentRule.  This
    does <em>not</em> mean that a definition for a given symbol can be
    omitted if there is an AssignmentRule object for it.  For example, there
    must be a Parameter definition for a given parameter if there is an
    AssignmentRule for that parameter.  It is only a question of which value
    definition takes precedence.

    @section general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into three
    subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible functional
    forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary
    function returning a numerical result, <b><em>V</em></b> is a vector of
    variables that does not include <em>x</em>, and <b><em>W</em></b> is a
    vector of variables that may include <em>x</em>):

    <center>
    <table border='0' cellpadding='0' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>
    </center>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    <ul>
    <li> <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)<p>

    <li> SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.<p>

    <li> Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;<p>

    <li> Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and<p>

    <li> Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.
    </ul>

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section additional-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection no-algebraic-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops&mdash;dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection no-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in Appendix
    B of the SBML Level&nbsp;3 Version&nbsp;1 Core specification for assessing
    whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)


    @section RuleType_t RuleType_t for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level&nbsp;2 and
    Level&nbsp;3 for distinguishing rules; specifically, it uses an attribute
    whose value is drawn from an enumeration.  LibSBML supports this using
    methods that work with the #RuleType_t enumeration.

    <p>
    <center>
    <table width='90%' cellspacing='1' cellpadding='1' border='0' class='normal-font'>
     <tr style='background: lightgray' class='normal-font'>
         <td><strong>Enumerator</strong></td>
         <td><strong>Meaning</strong></td>
     </tr>
    <tr><td><em>@link RuleType_t#RULE_TYPE_RATE RULE_TYPE_RATE@endlink</em></td><td>Indicates the rule is a 'rate' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink</em></td><td>Indicates the rule is a 'scalar' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink</em></td><td>Indicates the rule type is unknown or not
    yet set.</td>
    </table>
    </center>

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [Rule]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AssignmentRule, name, value)
    __swig_getmethods__ = {}
    for _s in [Rule]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AssignmentRule, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> AssignmentRule
        __init__(self, SBMLNamespaces sbmlns) -> AssignmentRule

        Predicate returning @c true if
        all the required attributes for this AssignmentRule object
        have been set.

        @note In SBML Levels&nbsp;2&ndash;3, the only required attribute for
        an AssignmentRule object is 'variable'.  For Level&nbsp;1, where the
        equivalent attribute is known by different names ('compartment',
        'species', or 'name', depending on the type of object), there is an
        additional required attribute called 'formula'.

        @return @c true if the required attributes have been set, @c false
        otherwise.
        @deprecated libSBML internal


        """
        this = _libsbml.new_AssignmentRule(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_AssignmentRule
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> AssignmentRule

        Creates and returns a deep copy of this Rule.

        @return a (deep) copy of this Rule.
          

        """
        return _libsbml.AssignmentRule_clone(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this AssignmentRule object
        have been set.

        @note In SBML Levels&nbsp;2&ndash;3, the only required attribute for
        an AssignmentRule object is 'variable'.  For Level&nbsp;1, where the
        equivalent attribute is known by different names ('compartment',
        'species', or 'name', depending on the type of object), there is an
        additional required attribute called 'formula'.

        @return @c true if the required attributes have been set, @c false
        otherwise.
          

        """
        return _libsbml.AssignmentRule_hasRequiredAttributes(self)

AssignmentRule_swigregister = _libsbml.AssignmentRule_swigregister
AssignmentRule_swigregister(AssignmentRule)

class RateRule(Rule):
    """
    LibSBML implementation of %SBML's %RateRule construct.

    The rule type RateRule is derived from the parent class Rule.  It is
    used to express equations that determine the rates of change of
    variables.  The left-hand side (the 'variable' attribute) can refer to
    the identifier of a species, compartment, or parameter (but not a
    reaction).  The entity identified must have its 'constant' attribute set
    to @c false.  The effects of a RateRule are in general terms the same,
    but differ in the precise details depending on which variable is being
    set:

    <ul> <li> <em>In the case of a species</em>, a RateRule sets the rate of
    change of the species' quantity (<em>concentration</em> or <em>amount of
    substance</em>) to the value determined by the formula in the 'math'
    subelement of the RateRule object.  The overall units of the formula in
    'math' @em should (in SBML Level&nbsp;2 Version&nbsp;4 and later) or @em
    must (in SBML releases prior to Level&nbsp;2 version&nbsp;4) be equal to
    the unit of <em>species quantity</em> divided by the model-wide unit of
    <em>time</em>.  <em>Restrictions</em>: There must not be both a RateRule
    'variable' attribute and a SpeciesReference 'species' attribute having
    the same value, unless that species has its 'boundaryCondition'
    attribute is set to @c true.  This means a rate rule cannot be defined
    for a species that is created or destroyed in a reaction, unless that
    species is defined as a boundary condition in the model.

    <li> (For SBML Level&nbsp;3 only) <em>In the case of a species
    reference</em>, a RateRule sets the rate of change of the stoichiometry
    of the referenced reactant or product to the value determined by the
    formula in 'math'.  The unit associated with the value produced by the
    'math' formula should be consistent with the unit 'dimensionless'
    divided by the model-wide unit of <em>time</em>.

    <li> <em>In the case of a compartment</em>, a RateRule sets the rate of
    change of the compartment's size to the value determined by the formula
    in the 'math' subelement of the RateRule object.  The overall units of
    the formula @em should (in SBML Level&nbsp;2 Version&nbsp;4 and
    later) or @em must (in SBML releases prior to Level&nbsp;2
    version&nbsp;4) be the units of the compartment's <em>size</em> divided
    by the model-wide unit of <em>time</em>.

    <li> <em>In the case of a parameter</em>, a RateRule sets the rate of
    change of the parameter's value to that determined by the formula in the
    'math' subelement of the RateRule object.  The overall units of the
    formula @em should (in SBML Level&nbsp;2 Version&nbsp;4 and
    later) or @em must (in SBML releases prior to Level&nbsp;2
    version&nbsp;4) be the Parameter object's 'unit' attribute value divided
    by the model-wide unit of <em>time</em>.
    </ul>

    In the context of a simulation, rate rules are in effect for simulation
    time <em>t</em> &lt; <em>0</em>.  Please consult the relevant SBML
    specification for additional information about the semantics of
    assignments, rules, and entity values for simulation time <em>t</em>
    <= <em>0</em>.

    As mentioned in the description of AssignmentRule, a model must not
    contain more than one RateRule or AssignmentRule object having the same
    value of 'variable'; in other words, in the set of all assignment rules
    and rate rules in an SBML model, each variable appearing in the
    left-hand sides can only appear once.  This simply follows from the fact
    that an indeterminate system would result if a model contained more than
    one assignment rule for the same variable or both an assignment rule and
    a rate rule for the same variable.

    @section general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into
    three subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible
    functional forms (where <em>x</em> is a variable, <em>f</em> is some
    arbitrary function returning a numerical result, <b><em>V</em></b> is a
    vector of variables that does not include <em>x</em>, and
    <b><em>W</em></b> is a vector of variables that may include <em>x</em>):

    <center>
    <table border='0' cellpadding='0' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>
    </center>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    <ul>
    <li> <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)<p>

    <li> SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.<p>

    <li> Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;<p>

    <li> Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and<p>

    <li> Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.
    </ul>

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section additional-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection no-algebraic-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops&mdash;dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection no-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in Appendix
    B of the SBML Level&nbsp;3 Version&nbsp;1 Core specification for assessing
    whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)


    @section RuleType_t RuleType_t for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level&nbsp;2 and
    Level&nbsp;3 for distinguishing rules; specifically, it uses an attribute
    whose value is drawn from an enumeration.  LibSBML supports this using
    methods that work with the #RuleType_t enumeration.

    <p>
    <center>
    <table width='90%' cellspacing='1' cellpadding='1' border='0' class='normal-font'>
     <tr style='background: lightgray' class='normal-font'>
         <td><strong>Enumerator</strong></td>
         <td><strong>Meaning</strong></td>
     </tr>
    <tr><td><em>@link RuleType_t#RULE_TYPE_RATE RULE_TYPE_RATE@endlink</em></td><td>Indicates the rule is a 'rate' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink</em></td><td>Indicates the rule is a 'scalar' rule.</td>
    <tr><td><em>@link RuleType_t#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink</em></td><td>Indicates the rule type is unknown or not
    yet set.</td>
    </table>
    </center>

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [Rule]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RateRule, name, value)
    __swig_getmethods__ = {}
    for _s in [Rule]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RateRule, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> RateRule
        __init__(self, SBMLNamespaces sbmlns) -> RateRule

        Predicate returning @c true if
        all the required attributes for this RateRule object
        have been set.

        @note In SBML Levels&nbsp;2&ndash;3, the only required attribute for a
        RateRule object is 'variable'.  For Level&nbsp;1, where the equivalent
        attribute is known by different names ('compartment', 'species', or
        'name', depending on the type of object), there is an additional
        required attribute called 'formula'.

        @return @c true if the required attributes have been set, @c false
        otherwise.
        @deprecated libSBML internal


        """
        this = _libsbml.new_RateRule(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_RateRule
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> RateRule

        Creates and returns a deep copy of this Rule.

        @return a (deep) copy of this Rule.
          

        """
        return _libsbml.RateRule_clone(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this RateRule object
        have been set.

        @note In SBML Levels&nbsp;2&ndash;3, the only required attribute for a
        RateRule object is 'variable'.  For Level&nbsp;1, where the equivalent
        attribute is known by different names ('compartment', 'species', or
        'name', depending on the type of object), there is an additional
        required attribute called 'formula'.

        @return @c true if the required attributes have been set, @c false
        otherwise.
          

        """
        return _libsbml.RateRule_hasRequiredAttributes(self)

RateRule_swigregister = _libsbml.RateRule_swigregister
RateRule_swigregister(RateRule)

class ListOfRules(ListOf):
    """
    LibSBML implementation of SBML's %ListOfRules construct.

    The various ListOf___ classes in %SBML are merely containers used for
    organizing the main components of an %SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an %SBML model is
    illustrated by the following (for SBML Level&nbsp;3 and later versions
    of SBML Level&nbsp;2 as well):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfRules, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfRules, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfRules

        Creates and returns a deep copy of this ListOfRules instance.

        @return a (deep) copy of this ListOfRules.
          

        """
        return _libsbml.ListOfRules_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfRules_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Rule objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfRules_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfRules, the XML element name is @c 'listOfRules'.

        @return the name of this element, i.e., @c 'listOfRules'.
          

        """
        return _libsbml.ListOfRules_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Rule
        get(self, unsigned int n) -> Rule
        get(self, string sid) -> Rule
        get(self, string sid) -> Rule

        Get a Rule from the ListOfRules
        based on its identifier.

        @param sid a string representing the identifier 
        of the Rule to get.

        @return Rule in this ListOfRules
        with the given id or @c NULL if no such
        Rule exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfRules_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Rule
        remove(self, string sid) -> Rule

        Removes item in this ListOfRules items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfRules_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfRules"""
        this = _libsbml.new_ListOfRules()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfRules
    __del__ = lambda self : None;
ListOfRules_swigregister = _libsbml.ListOfRules_swigregister
ListOfRules_swigregister(ListOfRules)

class Constraint(SBase):
    """
    LibSBML implementation of SBML's %Constraint construct.

    The Constraint object class was introduced in SBML Level&nbsp;2 Version&nbsp;2 as
    a mechanism for stating the assumptions under which a model is designed
    to operate.  The <em>constraints</em> are statements about permissible
    values of different quantities in a model.  Constraints are not used to
    compute dynamical values for simulation or analysis, but rather, they
    serve an advisory role for simulation/analysis tools.

    SBML's Constraint object class has one required attribute, 'id', to
    give the parameter a unique identifier by which other parts of an SBML
    model definition can refer to it.  A Constraint object can also have an
    optional 'name' attribute of type @c string.  Identifiers and names must
    be used according to the guidelines described in the SBML specification
    (e.g., Section 3.3 in the Level&nbsp;2 Version 4 specification).  

    Constraint has one required subelement, 'math', containing a MathML
    formula defining the condition of the constraint.  This formula must
    return a boolean value of @c true when the model is a <em>valid</em>
    state.  The formula can be an arbitrary expression referencing the
    variables and other entities in an SBML model.  The evaluation of 'math'
    and behavior of constraints are described in more detail below.

    A Constraint structure also has an optional subelement called 'message'.
    This can contain a message in XHTML format that may be displayed to the
    user when the condition of the formula in the 'math' subelement
    evaluates to a value of @c false.  Software tools are not required to
    display the message, but it is recommended that they do so as a matter
    of best practice.  The XHTML content within a 'message' subelement must
    follow the same restrictions as for the 'notes' element on SBase
    described in in the SBML Level&nbsp;2 specification.  For example, 'message'
    must not contain an XML declaration or a DOCTYPE declaration, and the
    permitted content can only take one of the following general forms: (1)
    a complete XHTML document beginning with the element
    <code>&lt;html&gt;</code> and ending with <code>&lt;/xhtml&gt;</code>; 
    (2) the body portion of a document beginning with the element
    <code>&lt;body&gt;</code> and ending with <code>&lt;/body&gt;</code>; or
    (3) XHTML content that is permitted within a <code>&lt;body&gt;</code> ...
    <code>&lt;/body&gt;</code> elements.  The appendix of the SBML Level&nbsp;2
    Version 4 specification document describes one approach to reading the
    'message' subelement content.

    Constraint was introduced in SBML Level&nbsp;2 Version&nbsp;2.  It is not
    available in earlier versions of Level&nbsp;2 nor in any version of Level&nbsp;1.

    @section constraint-semantics Semantics of Constraints

    In the context of a simulation, a Constraint has effect at all times
    <em>t >= 0</em>.  Each Constraint's 'math' subelement is first
    evaluated after any InitialAssignment definitions in a model at <em>t =
    0</em> and can conceivably trigger at that point.  (In other words, a
    simulation could fail a constraint immediately.)

    Constraint structures <em>cannot and should not</em> be used to compute
    the dynamical behavior of a model as part of, for example, simulation.
    Constraints may be used as input to non-dynamical analysis, for instance
    by expressing flux constraints for flux balance analysis.

    The results of a simulation of a model containing a constraint are
    invalid from any simulation time at and after a point when the function
    given by the 'math' subelement returns a value of @c false.  Invalid
    simulation results do not make a prediction of the behavior of the
    biochemical reaction network represented by the model.  The precise
    behavior of simulation tools is left undefined with respect to
    constraints.  If invalid results are detected with respect to a given
    constraint, the 'message' subelement may optionally be displayed to the
    user.  The simulation tool may also halt the simulation or clearly
    delimit in output data the simulation time point at which the simulation
    results become invalid.

    SBML does not impose restrictions on duplicate Constraint definitions or
    the order of evaluation of Constraint objects in a model.  It is
    possible for a model to define multiple constraints all with the same
    mathematical expression.  Since the failure of any constraint indicates
    that the model simulation has entered an invalid state, a system is not
    required to attempt to detect whether other constraints in the model
    have failed once any one constraint has failed.

    <!---------------------------------------------------------------------- -->


    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constraint, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Constraint, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Constraint
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Constraint
        __init__(self, SBMLNamespaces sbmlns) -> Constraint
        __init__(self, Constraint orig) -> Constraint

        Predicate returning @c true if
        all the required elements for this Constraint object
        have been set.

        @note The required elements for a Constraint object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Constraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Constraint

        Creates and returns a deep copy of this Constraint.

        @return a (deep) copy of this Constraint.
          

        """
        return _libsbml.Constraint_clone(self)

    def getMessage(self):
        """
        getMessage(self) -> XMLNode

        Get the message, if any, associated with this Constraint

        @return the message for this Constraint, as an XMLNode.
          

        """
        return _libsbml.Constraint_getMessage(self)

    def getMessageString(self):
        """
        getMessageString(self) -> string

        Get the message string, if any, associated with this Constraint

        @return the message for this Constraint, as a string.
          

        """
        return _libsbml.Constraint_getMessageString(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical expression of this Constraint

        @return the math for this Constraint, as an ASTNode.
          

        """
        return _libsbml.Constraint_getMath(self)

    def isSetMessage(self):
        """
        isSetMessage(self) -> bool

        Predicate returning @c true if a
        message has been defined for this Constraint.

        @return @c true if the message of this Constraint has been set,
        @c false otherwise.
          

        """
        return _libsbml.Constraint_isSetMessage(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c true if a
        mathematical formula has been defined for this Constraint.

        @return @c true if the 'math' subelement for this Constraint has been
        set, @c false otherwise.
          

        """
        return _libsbml.Constraint_isSetMath(self)

    def setMessage(self, *args):
        """
        setMessage(self, XMLNode xhtml) -> int

        Sets the message of this Constraint.

        The XMLNode tree passed in @p xhtml is copied.

        @param xhtml an XML tree containing XHTML content.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.Constraint_setMessage(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the mathematical expression of this Constraint to a copy of the
        AST given as @p math.

        @param math an ASTNode expression to be assigned as the 'math'
        subelement of this Constraint

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.Constraint_setMath(self, *args)

    def unsetMessage(self):
        """
        unsetMessage(self) -> int

        Unsets the 'message' subelement of this Constraint.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Constraint_unsetMessage(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Constraint_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Constraint, is
        always @c 'constraint'.

        @return the name of this element, i.e., @c 'constraint'.
          

        """
        return _libsbml.Constraint_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this Constraint object
        have been set.

        @note The required elements for a Constraint object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.Constraint_hasRequiredElements(self)

Constraint_swigregister = _libsbml.Constraint_swigregister
Constraint_swigregister(Constraint)

class ListOfConstraints(ListOf):
    """
    LibSBML implementation of SBML's %ListOfConstraints construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfConstraints, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfConstraints, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfConstraints

        Creates and returns a deep copy of this ListOfConstraints instance.

        @return a (deep) copy of this ListOfConstraints.
          

        """
        return _libsbml.ListOfConstraints_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfConstraints_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Constraint objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfConstraints_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfConstraints, the XML element name is @c 'listOfConstraints'.

        @return the name of this element, i.e., @c 'listOfConstraints'.
          

        """
        return _libsbml.ListOfConstraints_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Constraint
        get(self, unsigned int n) -> Constraint

        Get a Constraint from the ListOfConstraints.

        @param n the index number of the Constraint to get.

        @return the nth Constraint in this ListOfConstraints.

        @see size()
          

        """
        return _libsbml.ListOfConstraints_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Constraint

        Removes the nth item from this ListOfConstraints items and returns a
        pointer to it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
          

        """
        return _libsbml.ListOfConstraints_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfConstraints"""
        this = _libsbml.new_ListOfConstraints()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfConstraints
    __del__ = lambda self : None;
ListOfConstraints_swigregister = _libsbml.ListOfConstraints_swigregister
ListOfConstraints_swigregister(ListOfConstraints)

class Reaction(SBase):
    """
    LibSBML implementation of SBML's %Reaction construct.

    A @em reaction represents any transformation, transport or binding
    process, typically a chemical reaction, that can change the quantity of
    one or more species.  In SBML, a reaction is defined primarily in terms
    of the participating reactants and products (and their corresponding
    stoichiometries), along with optional modifier species, an optional rate
    at which the reaction takes place, and optional parameters.  

    As with other major object in SBML, Reaction has a mandatory attribute,
    'id', used to give the compartment type an identifier.  The identifier
    must be a text string conforming to the identifer syntax permitted in
    SBML.  In SBML Level&nbsp;2 and Level&nbsp;3, the reaction 'id'
    identifier can be used in mathematical formulas elsewhere in an SBML
    model to represent the rate of that reaction; this usage is explained
    below.  Reaction also has an optional 'name' attribute, of type @c
    string.  The 'id' and 'name' must be used according to the guidelines
    described in the SBML specification.

    The species participating as reactants, products, and/or modifiers in a
    reaction are declared using lists of SpeciesReference and/or
    ModifierSpeciesReference instances stored in subelements
    'listOfReactants', 'listOfProducts' and 'listOfModifiers'.  Certain
    restrictions are placed on the appearance of species in reaction
    definitions:
    <ul>
    <li> The ability of a species to appear as a reactant or product of any
    reaction in a model is governed by certain flags in that species'
    definition; see the definition of Species for more information.

    <li> Any species appearing in the mathematical formula of the subelement
    'kineticLaw' (described below) of a Reaction must be declared in at
    least one of that Reaction's lists of reactants, products, and/or
    modifiers.  Put another way, it is an error for a reaction's kinetic law
    formula to refer to species that have not been declared for that
    reaction.

    <li> A reaction definition can contain an empty list of reactants
    <em>or</em> an empty list of products, but it must have at least one
    reactant or product; in other words, a reaction without any reactant or
    product species is not permitted.  (This restriction does not apply to
    modifier species, which remain optional in all cases.)
    </ul>

    A reaction can contain up to one KineticLaw object in a subelement named
    'kineticLaw'.  It defines the speed at which the process defined by the
    reaction takes place.  The description of KineticLaw provides more
    details about its use.  Note that although the inclusion of a KineticLaw
    object in an instance of a Reaction component is optional, there is no
    useful default that can be substituted in place of a missing rate
    expression in a reaction.  Moreover, a reaction's rate cannot be defined
    in any other way in SBML&mdash;InitialAssignment, AssignmentRule,
    RateRule, AlgebraicRule, Event, and other constructs in SBML cannot be
    used to set the reaction rate separately.  Nevertheless, for some
    modeling applications, reactions without any defined rate can be
    perfectly acceptable.

    Reaction also has a boolean attribute named 'reversible' for indicating
    whether the reaction is reversible.  This attribute is optional in SBML
    Level&nbsp;2, with a default of @c true; it is mandatory in SBML
    Level&nbsp;3 (with no default value).  To say that a reaction is @em
    reversible is to say it can proceed in either the forward or the reverse
    direction.  Although the reversibility of a reaction can sometimes be
    deduced by inspecting its rate expression, this is not always the case,
    especially for complicated expressions.  Moreover, the need in SBML to
    allow rate expressions (i.e., KineticLaw) to be optional leads to the
    need for a separate flag indicating reversibility.  Note that labeling a
    reaction as irreversible is an assertion that the reaction always
    proceeds in the given forward direction.  (Why else would it be flagged
    as irreversible?)  This implies the rate expression in the KineticLaw
    always has a non-negative value during simulations.  Software tools
    could provide a means of optionally testing that this condition holds.
    The presence of reversibility information in two places (i.e., the rate
    expression and the 'reversible' attribute on Reaction) leaves open the
    possibility that a model could contain contradictory information, but
    the creation of such a model would be an error on the part of the
    software generating it.

    The Reaction object class has another boolean attribute called 'fast'.
    This attribute is optional in SBML Level&nbsp;2, with a default of @c
    false; it is mandatory in SBML Level&nbsp;3 (with no default value).  It
    is used to indicate that a reaction occurs on a vastly faster time scale
    than others in a system.  Readers are directed to the SBML Level&nbsp;2
    Version&nbsp;4 specification, which provides more detail about the
    conditions under which a reaction can be considered to be fast in this
    sense.  The attribute's default value is @c false.  SBML Level&nbsp;1
    and Level&nbsp;2 Version&nbsp;1 incorrectly claimed that software tools
    could ignore this attribute if they did not implement support for the
    corresponding concept; however, further research in SBML has revealed
    that this is not true, and 'fast' <em>cannot be ignored</em> if it is
    set to @c true.  SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 therefore
    stipulate that if a model has any reactions with 'fast' set to @c true,
    a software tool must be able to respect the attribute or else indicate
    to the user that it does not have the capacity to do so.  Analysis
    software cannot ignore the value of the 'fast' attribute because doing
    so may lead to different results as compared to a software system that
    <em>does</em> make use of 'fast'.

    In SBML Level&nbsp;3 Version&nbsp;1, the Reaction object has an
    additional optional attribute named 'compartment', whose value must be
    the identifier of a compartment defined in the enclosing Model object.
    The 'compartment' attribute can be used to indicate the compartment in
    which the reaction is assumed to take place.  If the attribute is
    present, its value must be the identifier of a Compartment object
    defined in the enclosing Model object.  Similar to the 'reversible'
    attribute, the value of the 'compartment' attribute has no direct impact
    on the construction of mathematical equations for the SBML model.  When
    a kinetic law is given for a reaction, the compartment location may
    already be implicit in the kinetic law (although this cannot always be
    guaranteed).  Nevertheless, software tools may find the 'compartment'
    attribute value useful for such purposes as analyzing the structure of
    the model, guiding the modeler in constructing correct rate formulas,
    and visualization purposes.

    Readers are urged to read the SBML specification for more details about
    the proper use of Reaction.



    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Reaction, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Reaction, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Reaction
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Reaction
        __init__(self, SBMLNamespaces sbmlns) -> Reaction
        __init__(self, Reaction orig) -> Reaction

        Predicate returning @c true if all the required attributes for this
        Reaction object have been set.

        @note The required attributes for a Reaction object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'fast' (in Level&nbsp;3 only, where it is defined as a required attribute)
        @li 'reversible' (in Level&nbsp;3 only, where it is defined as a required attribute)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Reaction(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Reaction

        Creates and returns a deep copy of this Reaction.

        @return a (deep) copy of this Reaction.
          

        """
        return _libsbml.Reaction_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Reaction object to 'typical' default
        values.

        The SBML Reaction component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets the 'reversible' attribute to @c true
        <li> Sets the 'fast' attribute to @c false
        <li> Marks the 'fast' attribute as @em not having been set
        </ul>

        @warning The 'fast' attribute must be used with care.  SBML
        definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly
        indicated that software tools could ignore this attribute if they did
        not implement support for the corresponding concept; however, further
        research in SBML has revealed that this is not true, and 'fast'
        <em>cannot be ignored</em> if it is set to @c true.  Beginning with
        SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications therefore
        stipulate that if a model has any reactions with 'fast' set to @c
        true, a software tool must be able to respect the attribute or else
        indicate to the user that it does not have the capacity to do so.
        Readers are directed to the SBML specifications, which provides more
        detail about the conditions under which a reaction can be considered
        to be fast in this sense.
          

        """
        return _libsbml.Reaction_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Reaction.

        @return the id of this Reaction.
          

        """
        return _libsbml.Reaction_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Reaction.

        @return the name of this Reaction.
          

        """
        return _libsbml.Reaction_getName(self)

    def getKineticLaw(self, *args):
        """
        getKineticLaw(self) -> KineticLaw
        getKineticLaw(self) -> KineticLaw

        Returns the KineticLaw object contained in this Reaction.

        @return the KineticLaw instance.
          

        """
        return _libsbml.Reaction_getKineticLaw(self, *args)

    def getReversible(self):
        """
        getReversible(self) -> bool

        Returns the value of the 'reversible' attribute on the Reaction as a
        boolean value.

        @return the reversibility status of this Reaction.
          

        """
        return _libsbml.Reaction_getReversible(self)

    def getFast(self):
        """
        getFast(self) -> bool

        Returns the value of the 'fast' attribute of this Reaction.

        @return the 'fast' status of this Reaction.

        @warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly
        indicated that software tools could ignore this attribute if they did
        not implement support for the corresponding concept; however, further
        research in SBML has revealed that this is not true, and 'fast'
        <em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2
        Versions 2, 3 and 4 therefore stipulate that if a model has any reactions
        with 'fast' set to @c true, a software tool must be able to respect
        the attribute or else indicate to the user that it does not have the
        capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version
        4 specification, which provides more detail about the conditions under
        which a reaction can be considered to be fast in this sense.
          

        """
        return _libsbml.Reaction_getFast(self)

    def getCompartment(self):
        """
        getCompartment(self) -> string

        (SBML Level&nbsp;3 only) Returns the value of the 'compartment'
        attribute on the Reaction.

        @return the compartment of this Reaction.

        @note The 'compartment' attribute has been introduced in SBML
        Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in
        lower Levels of SBML.
          

        """
        return _libsbml.Reaction_getCompartment(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        Reaction's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this Reaction has been
        set, @c false otherwise.
          

        """
        return _libsbml.Reaction_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        Reaction's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this Reaction has been
        set, @c false otherwise.
          

        """
        return _libsbml.Reaction_isSetName(self)

    def isSetKineticLaw(self):
        """
        isSetKineticLaw(self) -> bool

        Predicate returning @c true if this
        Reaction contains a kinetic law object.

        @return @c true if a KineticLaw is present in this Reaction,, @c false
        otherwise.
          

        """
        return _libsbml.Reaction_isSetKineticLaw(self)

    def isSetFast(self):
        """
        isSetFast(self) -> bool

        Predicate returning @c true if the value of
        the 'fast' attribute on this Reaction.

        @return @c true if the 'fast' attribute is true, @c false otherwise.

        @warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly
        indicated that software tools could ignore this attribute if they did
        not implement support for the corresponding concept; however, further
        research in SBML has revealed that this is not true, and 'fast'
        <em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2
        Versions 2, 3 and 4 therefore stipulate that if a model has any reactions
        with 'fast' set to @c true, a software tool must be able to respect
        the attribute or else indicate to the user that it does not have the
        capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version
        4 specification, which provides more detail about the conditions under
        which a reaction can be considered to be fast in this sense.  Note
        also that in SBML Level&nbsp;1, 'fast' is defined as optional with a
        default of @c false, which means it is effectively always set.
          

        """
        return _libsbml.Reaction_isSetFast(self)

    def isSetCompartment(self):
        """
        isSetCompartment(self) -> bool

        Predicate returning @c true if this
        Reaction's 'compartment' attribute has been set.

        @return @c true if the 'compartment' attribute of this Reaction has been
        set, @c false otherwise.

        @note The 'compartment' attribute has been introduced in SBML
        Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in
        lower Levels of SBML.
          

        """
        return _libsbml.Reaction_isSetCompartment(self)

    def isSetReversible(self):
        """
        isSetReversible(self) -> bool

        Predicate returning @c true if this
        Reaction's 'reversible' attribute has been set.

        @return @c true if the 'reversible' attribute of this Reaction has been
        set, @c false otherwise.
          

        """
        return _libsbml.Reaction_isSetReversible(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Reaction.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this Reaction

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Reaction_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Reaction.

        The string in @p name is copied.

        @param name the new name for the Reaction

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Reaction_setName(self, *args)

    def setKineticLaw(self, *args):
        """
        setKineticLaw(self, KineticLaw kl) -> int

        Sets the 'kineticLaw' subelement of this Reaction to a copy of the
        given KineticLaw object.

        @param kl the KineticLaw object to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
         

        """
        return _libsbml.Reaction_setKineticLaw(self, *args)

    def setReversible(self, *args):
        """
        setReversible(self, bool value) -> int

        Sets the value of the 'reversible' attribute of this Reaction.

        @param value the value of the 'reversible' attribute.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.Reaction_setReversible(self, *args)

    def setFast(self, *args):
        """
        setFast(self, bool value) -> int

        Sets the value of the 'fast' attribute of this Reaction.

        @param value the value of the 'fast' attribute.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly
        indicated that software tools could ignore this attribute if they did
        not implement support for the corresponding concept; however, further
        research in SBML has revealed that this is not true, and 'fast'
        <em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2
        Versions 2, 3 and 4 therefore stipulate that if a model has any reactions
        with 'fast' set to @c true, a software tool must be able to respect
        the attribute or else indicate to the user that it does not have the
        capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version
        4 specification, which provides more detail about the conditions under
        which a reaction can be considered to be fast in this sense.
          

        """
        return _libsbml.Reaction_setFast(self, *args)

    def setCompartment(self, *args):
        """
        setCompartment(self, string sid) -> int

        Sets the value of the 'compartment' attribute of this Reaction.

        The string @p sid is copied.  

        @param sid the string to use as the compartment of this Reaction

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note The 'compartment' attribute has been introduced in SBML
        Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in
        lower Levels of SBML.
          

        """
        return _libsbml.Reaction_setCompartment(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Reaction_unsetName(self)

    def unsetKineticLaw(self):
        """
        unsetKineticLaw(self) -> int

        Unsets the 'kineticLaw' subelement of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Reaction_unsetKineticLaw(self)

    def unsetFast(self):
        """
        unsetFast(self) -> int

        Unsets the value of the 'fast' attribute of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @warning In SBML Level&nbsp;1, 'fast' is optional with a default of @c
        false, which means it is effectively always set (and reset to @c false
        if this method is called).  Further, SBML definitions before SBML
        Level&nbsp;2 Version&nbsp;2 incorrectly indicated that software tools could
        ignore this attribute if they did not implement support for the
        corresponding concept; however, further research in SBML has revealed
        that this is not true, and 'fast' <em>cannot be ignored</em> if it is
        set to @c true.  SBML Level&nbsp;2 Versions 2, 3 and 4 therefore stipulate
        that if a model has any reactions with 'fast' set to @c true, a
        software tool must be able to respect the attribute or else indicate
        to the user that it does not have the capacity to do so.  Readers are
        directed to the SBML Level&nbsp;2 Version&nbsp;4 specification, which provides
        more detail about the conditions under which a reaction can be
        considered to be fast in this sense.
          

        """
        return _libsbml.Reaction_unsetFast(self)

    def unsetCompartment(self):
        """
        unsetCompartment(self) -> int

        Unsets the value of the 'compartment' attribute of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The 'compartment' attribute has been introduced in SBML
        Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in
        lower Levels of SBML.
          

        """
        return _libsbml.Reaction_unsetCompartment(self)

    def addReactant(self, *args):
        """
        addReactant(self, SpeciesReference sr) -> int

        Adds a given SpeciesReference object as a reactant in this Reaction.

        The SpeciesReference instance in @p sr is copied.

        @param sr a SpeciesReference object referring to a Species in the
        enclosing Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Reaction.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Reaction</em>.  In addition, the caller should make
        sure to free the original object if it is no longer being used, or
        else a memory leak will result.  Please see Reaction::createReactant()
        for a method that does not lead to these issues.

        @see createReactant()
          

        """
        return _libsbml.Reaction_addReactant(self, *args)

    def addProduct(self, *args):
        """
        addProduct(self, SpeciesReference sr) -> int

        Adds a given SpeciesReference object as a product in this Reaction.

        The SpeciesReference instance in @p sr is copied.

        @param sr a SpeciesReference object referring to a Species in the
        enclosing Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Reaction.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Reaction</em>.  In addition, the caller should make
        sure to free the original object if it is no longer being used, or
        else a memory leak will result.  Please see Reaction::createProduct()
        for a method that does not lead to these issues.

        @see createProduct()
          

        """
        return _libsbml.Reaction_addProduct(self, *args)

    def addModifier(self, *args):
        """
        addModifier(self, ModifierSpeciesReference msr) -> int

        Adds a given ModifierSpeciesReference object as a product in this
        Reaction.

        The ModifierSpeciesReference instance in @p msr is copied.

        @param msr a ModifierSpeciesReference object referring to a Species in
        the enclosing Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Reaction.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Reaction</em>.  In addition, the caller should make
        sure to free the original object if it is no longer being used, or
        else a memory leak will result.  Please see Reaction::createModifier()
        for a method that does not lead to these issues.

        @see createModifier()
          

        """
        return _libsbml.Reaction_addModifier(self, *args)

    def createReactant(self):
        """
        createReactant(self) -> SpeciesReference

        Creates a new SpeciesReference, adds it to this Reaction's list of
        reactants, and returns it.

        @return a new SpeciesReference object.
          

        """
        return _libsbml.Reaction_createReactant(self)

    def createProduct(self):
        """
        createProduct(self) -> SpeciesReference

        Creates a new SpeciesReference, adds it to this Reaction's list of
        products, and returns it.

        @return a new SpeciesReference object.
          

        """
        return _libsbml.Reaction_createProduct(self)

    def createModifier(self):
        """
        createModifier(self) -> ModifierSpeciesReference

        Creates a new ModifierSpeciesReference, adds it to this Reaction's
        list of modifiers and returns it.

        @return a new ModifierSpeciesReference object.
          

        """
        return _libsbml.Reaction_createModifier(self)

    def createKineticLaw(self):
        """
        createKineticLaw(self) -> KineticLaw

        Creates a new KineticLaw object, installs it as this Reaction's
        'kineticLaw' subelement, and returns it.

        If this Reaction had a previous KineticLaw, it will be destroyed.

        @return the new KineticLaw object
          

        """
        return _libsbml.Reaction_createKineticLaw(self)

    def getListOfReactants(self, *args):
        """
        getListOfReactants(self) -> ListOfSpeciesReferences
        getListOfReactants(self) -> ListOfSpeciesReferences

        Returns the list of reactants in this Reaction object.

        @return the ListOfSpeciesReferences containing the references to the
        species acting as reactants in this reaction
          

        """
        return _libsbml.Reaction_getListOfReactants(self, *args)

    def getListOfProducts(self, *args):
        """
        getListOfProducts(self) -> ListOfSpeciesReferences
        getListOfProducts(self) -> ListOfSpeciesReferences

        Returns the list of products in this Reaction object.

        @return the ListOfSpeciesReferences containing the references to the
        species acting as products in this reaction
          

        """
        return _libsbml.Reaction_getListOfProducts(self, *args)

    def getListOfModifiers(self, *args):
        """
        getListOfModifiers(self) -> ListOfSpeciesReferences
        getListOfModifiers(self) -> ListOfSpeciesReferences

        Returns the list of modifiers in this Reaction object.

        @return the ListOfSpeciesReferences containing the references to the
        species acting as modifiers in this reaction
          

        """
        return _libsbml.Reaction_getListOfModifiers(self, *args)

    def getReactant(self, *args):
        """
        getReactant(self, unsigned int n) -> SpeciesReference
        getReactant(self, unsigned int n) -> SpeciesReference
        getReactant(self, string species) -> SpeciesReference
        getReactant(self, string species) -> SpeciesReference

        Returns the reactant species (as a SpeciesReference object) having 
        a specific identifier in this Reaction.

        @param species the identifier of the reactant Species ('species' 
        attribute of the reactant SpeciesReference object)

        @return a SpeciesReference object, or @c NULL if no species with the
        given identifier @p species appears as a reactant in this Reaction.
          

        """
        return _libsbml.Reaction_getReactant(self, *args)

    def getProduct(self, *args):
        """
        getProduct(self, unsigned int n) -> SpeciesReference
        getProduct(self, unsigned int n) -> SpeciesReference
        getProduct(self, string species) -> SpeciesReference
        getProduct(self, string species) -> SpeciesReference

        Returns the product species (as a SpeciesReference object) having 
        a specific identifier in this Reaction.

        @param species the identifier of the product Species ('species'
        attribute of the product SpeciesReference object)

        @return a SpeciesReference object, or @c NULL if no species with the
        given identifier @p species appears as a product in this Reaction.
          

        """
        return _libsbml.Reaction_getProduct(self, *args)

    def getModifier(self, *args):
        """
        getModifier(self, unsigned int n) -> ModifierSpeciesReference
        getModifier(self, unsigned int n) -> ModifierSpeciesReference
        getModifier(self, string species) -> ModifierSpeciesReference
        getModifier(self, string species) -> ModifierSpeciesReference

        Returns the modifier species (as a ModifierSpeciesReference object) 
        having a specific identifier in this Reaction.

        @param species the identifier of the modifier Species ('species' 
        attribute of the ModifierSpeciesReference object)

        @return a ModifierSpeciesReference object, or @c NULL if no species with
        the given identifier @p species appears as a modifier in this
        Reaction.
          

        """
        return _libsbml.Reaction_getModifier(self, *args)

    def getNumReactants(self):
        """
        getNumReactants(self) -> unsigned int

        Returns the number of reactant species in this Reaction.

        @return the number of reactants in this Reaction.
          

        """
        return _libsbml.Reaction_getNumReactants(self)

    def getNumProducts(self):
        """
        getNumProducts(self) -> unsigned int

        Returns the number of product species in this Reaction.

        @return the number of products in this Reaction.
          

        """
        return _libsbml.Reaction_getNumProducts(self)

    def getNumModifiers(self):
        """
        getNumModifiers(self) -> unsigned int

        Returns the number of modifier species in this Reaction.

        @return the number of modifiers in this Reaction.
          

        """
        return _libsbml.Reaction_getNumModifiers(self)

    def removeReactant(self, *args):
        """
        removeReactant(self, unsigned int n) -> SpeciesReference
        removeReactant(self, string species) -> SpeciesReference

        Removes the reactant species (SpeciesReference object) having the given  
        'species' attribute in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param species the 'species' attribute of the reactant SpeciesReference 
        object

        @return the removed reactant SpeciesReference object, or @c NULL if no 
        reactant SpeciesReference object with the given 'species' attribute 
        @p species exists in this Reaction.
          

        """
        return _libsbml.Reaction_removeReactant(self, *args)

    def removeProduct(self, *args):
        """
        removeProduct(self, unsigned int n) -> SpeciesReference
        removeProduct(self, string species) -> SpeciesReference

        Removes the product species (SpeciesReference object) having the given  
        'species' attribute in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param species the 'species' attribute of the product SpeciesReference 
        object

        @return the removed product SpeciesReference object, or @c NULL if no 
        product SpeciesReference object with the given 'species' attribute 
        @p species exists in this Reaction.
          

        """
        return _libsbml.Reaction_removeProduct(self, *args)

    def removeModifier(self, *args):
        """
        removeModifier(self, unsigned int n) -> ModifierSpeciesReference
        removeModifier(self, string species) -> ModifierSpeciesReference

        Removes the modifier species (ModifierSpeciesReference object) having 
        the given 'species' attribute in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param species the 'species' attribute of the ModifierSpeciesReference 
        object

        @return the removed ModifierSpeciesReference object, or @c NULL if no 
        ModifierSpeciesReference object with the given 'species' attribute @p 
        species exists in this Reaction.
          

        """
        return _libsbml.Reaction_removeModifier(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Reaction_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Reaction, is
        always @c 'reaction'.

        @return the name of this element, i.e., @c 'reaction'.
          

        """
        return _libsbml.Reaction_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if all the required attributes for this
        Reaction object have been set.

        @note The required attributes for a Reaction object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'fast' (in Level&nbsp;3 only, where it is defined as a required attribute)
        @li 'reversible' (in Level&nbsp;3 only, where it is defined as a required attribute)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.Reaction_hasRequiredAttributes(self)

Reaction_swigregister = _libsbml.Reaction_swigregister
Reaction_swigregister(Reaction)

class ListOfReactions(ListOf):
    """
    LibSBML implementation of SBML's %ListOfReactions construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfReactions, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfReactions, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfReactions

        Creates and returns a deep copy of this ListOfReactions instance.

        @return a (deep) copy of this ListOfReactions.
          

        """
        return _libsbml.ListOfReactions_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfReactions_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Reaction objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfReactions_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object

        For ListOfReactions, the XML element name is @c 'listOfReactions'.

        @return the name of this element, i.e., @c 'listOfReactions'.
          

        """
        return _libsbml.ListOfReactions_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Reaction
        get(self, unsigned int n) -> Reaction
        get(self, string sid) -> Reaction
        get(self, string sid) -> Reaction

        Get a Reaction from the ListOfReactions
        based on its identifier.

        @param sid a string representing the identifier 
        of the Reaction to get.

        @return Reaction in this ListOfReactions
        with the given id or @c NULL if no such
        Reaction exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfReactions_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Reaction
        remove(self, string sid) -> Reaction

        Removes item in this ListOfReactions items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        @c NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfReactions_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfReactions"""
        this = _libsbml.new_ListOfReactions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfReactions
    __del__ = lambda self : None;
ListOfReactions_swigregister = _libsbml.ListOfReactions_swigregister
ListOfReactions_swigregister(ListOfReactions)

class KineticLaw(SBase):
    """
    LibSBML implementation of %SBML's %KineticLaw construct.

    An object of class KineticLaw is used to describe the rate at which the
    process defined by a given Reaction takes place.  KineticLaw has
    subelements called 'math' (for MathML content) and 'listOfParameters'
    (of class ListOfParameters), in addition to the attributes and
    subelements it inherits from SBase.

    KineticLaw's 'math' subelement for holding a MathML formula defines the
    rate of the reaction.  The formula may refer to other entities in a
    model (Compartment, Species, Parameter, FunctionDefinition, Reaction),
    but the only Species identifiers that can be used in this formula are
    those declared in the lists of reactants, products and modifiers in the
    Reaction structure.  Parameter identifiers may be taken from either the
    KineticLaw's list of local parameters (discussed below) or the
    parameters defined globally on the Model instance.

    KineticLaw also provides a way to define @em local parameters whose
    identifiers can be used in the 'math' formula of that KineticLaw
    instance.  Prior to SBML Level&nbsp;3, these parameter definitions are
    stored inside a 'listOfParameters' subelement containing Parameter
    objects; in SBML Level&nbsp;3, this is achieved using a specialized
    object class called LocalParameter and the containing subelement is
    called 'listOfLocalParameters'.  In both cases, the parameters so
    defined are only visible within the KineticLaw; they cannot be accessed
    outside.  A local parameter within one reaction is not visible from
    within another, nor is it visible to any other construct outside of the
    KineticLaw in which it is defined.  In addition, another important
    feature is that if such a Parameter (or in Level&nbsp;3, LocalParameter)
    object has the same identifier as another object in the scope of the
    enclosing Model, the definition inside the KineticLaw takes precedence.
    In other words, within the KineticLaw's 'math' formula, references to
    local parameter identifiers <strong>shadow any identical global
    identifiers</strong>.

    The values of local parameters defined within KineticLaw objects cannot
    change.  In SBML Level&nbsp;3, this quality is built into the
    LocalParameter construct.  In Level&nbsp;2, where the same kind of
    Parameter object class is used as for global parameters, the Parameter
    objects' 'constant' attribute must always have a value of @c true
    (either explicitly or left to its default value).


    @note Before SBML Level&nbsp;2 Version&nbsp;2, the SBML specification
    included two additional attributes on KineticLaw called 'substanceUnits'
    and 'timeUnits'.  They were removed beginning with SBML Level&nbsp;2
    Version&nbsp;2 because further research determined they introduced many
    problems.  The most significant problem was that their use could easily
    lead to the creation of valid models whose reactions nevertheless could
    not be integrated into a system of equations without outside knowledge
    for converting the quantities used.  Examination of real-life models
    revealed that a common reason for using 'substanceUnits' on KineticLaw
    was to set the units of all reactions to the same set of substance
    units, something that is better achieved by using UnitDefinition to
    redefine @c 'substance' for the whole Model.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KineticLaw, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KineticLaw, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_KineticLaw
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> KineticLaw
        __init__(self, SBMLNamespaces sbmlns) -> KineticLaw
        __init__(self, KineticLaw orig) -> KineticLaw

        Predicate returning @c true if
        all the required elements for this KineticLaw object
        have been set.

        @note The required elements for a KineticLaw object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_KineticLaw(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> KineticLaw

        Creates and returns a deep copy of this KineticLaw object.

        @return a (deep) copy of this KineticLaw.
          

        """
        return _libsbml.KineticLaw_clone(self)

    def getFormula(self):
        """
        getFormula(self) -> string

        Returns the mathematical formula for this KineticLaw object and return
        it as as a text string.

        This is fundamentally equivalent to getMath().  This variant is
        provided principally for compatibility compatibility with SBML Level
        1.

        @return a string representing the formula of this KineticLaw.

        @see getMath()

        @note SBML Level&nbsp;1 uses a text-string format for mathematical
        formulas.  SBML Level&nbsp;2 uses MathML, an XML format for
        representing mathematical expressions.  LibSBML provides an Abstract
        Syntax Tree API for working with mathematical expressions; this API is
        more powerful than working with formulas directly in text form, and
        ASTs can be translated into either MathML or the text-string syntax.
        The libSBML methods that accept text-string formulas directly (such as
        this constructor) are provided for SBML Level&nbsp;1 compatibility,
        but developers are encouraged to use the AST mechanisms.
          

        """
        return _libsbml.KineticLaw_getFormula(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Returns the mathematical formula for this KineticLaw object and return
        it as as an AST.

        This is fundamentally equivalent to getFormula().  The latter is
        provided principally for compatibility compatibility with SBML Level
        1, which represented mathematical formulas in text-string form.

        @return the ASTNode representation of the mathematical formula.

        @see getFormula()
          

        """
        return _libsbml.KineticLaw_getMath(self)

    def getTimeUnits(self):
        """
        getTimeUnits(self) -> string

        Returns the value of the 'timeUnits' attribute of this KineticLaw
        object.

        @return the 'timeUnits' attribute value

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_getTimeUnits(self)

    def getSubstanceUnits(self):
        """
        getSubstanceUnits(self) -> string

        Returns the value of the
        'substanceUnits' attribute of this KineticLaw object.

        @return the 'substanceUnits' attribute value

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_getSubstanceUnits(self)

    def isSetFormula(self):
        """
        isSetFormula(self) -> bool

        Predicate returning @c true if this
        KineticLaw's 'formula' attribute has been set

        This is functionally identical to the method isSetMath().  It is
        provided in order to mirror the parallel between getFormula() and
        getMath().

        @return @c true if the formula (meaning the @c math subelement) of
        this KineticLaw has been set, @c false otherwise.

        @note SBML Level&nbsp;1 uses a text-string format for mathematical
        formulas.  SBML Level&nbsp;2 uses MathML, an XML format for
        representing mathematical expressions.  LibSBML provides an Abstract
        Syntax Tree API for working with mathematical expressions; this API is
        more powerful than working with formulas directly in text form, and
        ASTs can be translated into either MathML or the text-string syntax.
        The libSBML methods that accept text-string formulas directly (such as
        this constructor) are provided for SBML Level&nbsp;1 compatibility,
        but developers are encouraged to use the AST mechanisms.
            

        """
        return _libsbml.KineticLaw_isSetFormula(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c true if this
        Kinetic's 'math' subelement has been set

        This is identical to the method isSetFormula().  It is provided
        in order to mirror the parallel between getFormula() and getMath().

        @return @c true if the formula (meaning the @c math subelement) of
        this KineticLaw has been set, @c false otherwise.
          

        """
        return _libsbml.KineticLaw_isSetMath(self)

    def isSetTimeUnits(self):
        """
        isSetTimeUnits(self) -> bool

        Predicate returning @c true if
        this SpeciesReference's 'timeUnits' attribute has been set

        @return @c true if the 'timeUnits' attribute of this KineticLaw object
        has been set, @c false otherwise.

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_isSetTimeUnits(self)

    def isSetSubstanceUnits(self):
        """
        isSetSubstanceUnits(self) -> bool

        Predicate returning @c true if
        this SpeciesReference's 'substanceUnits' attribute has been set

        @return @c true if the 'substanceUnits' attribute of this KineticLaw
        object has been set, @c false otherwise.

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_isSetSubstanceUnits(self)

    def setFormula(self, *args):
        """
        setFormula(self, string formula) -> int

        Sets the mathematical expression of this KineticLaw instance to the
        given @p formula.

        The given @p formula string is copied.  Internally, libSBML stores the
        mathematical expression as an ASTNode.

        @param formula the mathematical expression to use, represented in
        text-string form.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink

        @note SBML Level&nbsp;1 uses a text-string format for mathematical
        formulas.  SBML Level&nbsp;2 uses MathML, an XML format for representing
        mathematical expressions.  LibSBML provides an Abstract Syntax Tree
        API for working with mathematical expressions; this API is more
        powerful than working with formulas directly in text form, and ASTs
        can be translated into either MathML or the text-string syntax.  The
        libSBML methods that accept text-string formulas directly (such as
        this constructor) are provided for SBML Level&nbsp;1 compatibility, but
        developers are encouraged to use the AST mechanisms.
          

        """
        return _libsbml.KineticLaw_setFormula(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the mathematical expression of this KineticLaw instance to a copy
        of the given ASTNode.

        This is fundamentally identical to setFormula().  The latter is
        provided principally for compatibility compatibility with SBML Level
        1, which represented mathematical formulas in text-string form.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
         

        """
        return _libsbml.KineticLaw_setMath(self, *args)

    def setTimeUnits(self, *args):
        """
        setTimeUnits(self, string sid) -> int

        Sets the 'timeUnits' attribute
        of this KineticLaw object to a copy of the identifier in @p sid.

        @param sid the identifier of the units to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_setTimeUnits(self, *args)

    def setSubstanceUnits(self, *args):
        """
        setSubstanceUnits(self, string sid) -> int

        Sets the 'substanceUnits'
        attribute of this KineticLaw object to a copy of the identifier given
        in @p sid.

        @param sid the identifier of the units to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_setSubstanceUnits(self, *args)

    def unsetTimeUnits(self):
        """
        unsetTimeUnits(self) -> int

        Unsets the 'timeUnits'
        attribugte of this KineticLaw object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_unsetTimeUnits(self)

    def unsetSubstanceUnits(self):
        """
        unsetSubstanceUnits(self) -> int

        Unsets the 'substanceUnits'
        attribute of this KineticLaw object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.
          

        """
        return _libsbml.KineticLaw_unsetSubstanceUnits(self)

    def addParameter(self, *args):
        """
        addParameter(self, Parameter p) -> int

        Adds a copy of the given Parameter object to the list of local
        parameters in this KineticLaw.

        @param p the Parameter to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this KineticLaw.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the KineticLaw</em>.  In addition, the caller should make
        sure to free the original object if it is no longer being used, or
        else a memory leak will result.  Please see
        KineticLaw::createParameter() for ab method that does not lead to
        these issues.

        @see createParameter()
          

        """
        return _libsbml.KineticLaw_addParameter(self, *args)

    def addLocalParameter(self, *args):
        """
        addLocalParameter(self, LocalParameter p) -> int

        Adds a copy of the given LocalParameter object to the list of local
        parameters in this KineticLaw.

        @param p the LocalParameter to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this KineticLaw.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the KineticLaw</em>.  In addition, the caller should make
        sure to free the original object if it is no longer being used, or
        else a memory leak will result.  Please see
        KineticLaw::createParameter() for ab method that does not lead to
        these issues.

        @see createLocalParameter()
          

        """
        return _libsbml.KineticLaw_addLocalParameter(self, *args)

    def createParameter(self):
        """
        createParameter(self) -> Parameter

        Creates a new Parameter object, adds it to this KineticLaw's list of
        local parameters, and returns the Parameter object created.

        @return a new Parameter object instance

        @see addParameter(const Parameter* p)
          

        """
        return _libsbml.KineticLaw_createParameter(self)

    def createLocalParameter(self):
        """
        createLocalParameter(self) -> LocalParameter

        Creates a new LocalParameter object, adds it to this KineticLaw's list of
        local parameters, and returns the LocalParameter object created.

        @return a new LocalParameter object instance

        @see addLocalParameter(const LocalParameter* p)
          

        """
        return _libsbml.KineticLaw_createLocalParameter(self)

    def getListOfParameters(self, *args):
        """
        getListOfParameters(self) -> ListOfParameters
        getListOfParameters(self) -> ListOfParameters

        Returns the list of local parameters in this KineticLaw object.

        @return the list of Parameters for this KineticLaw.
          

        """
        return _libsbml.KineticLaw_getListOfParameters(self, *args)

    def getListOfLocalParameters(self, *args):
        """
        getListOfLocalParameters(self) -> ListOfLocalParameters
        getListOfLocalParameters(self) -> ListOfLocalParameters

        Returns the list of local parameters in this KineticLaw object.

        @return the list of LocalParameters for this KineticLaw.
          

        """
        return _libsbml.KineticLaw_getListOfLocalParameters(self, *args)

    def getParameter(self, *args):
        """
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, string sid) -> Parameter
        getParameter(self, string sid) -> Parameter

        Returns a local parameter based on its identifier.

        @param sid the identifier of the Parameter being sought.

        @return the Parameter object in this KineticLaw instace having the
        given 'id', or @c NULL if no such Parameter exists.
          

        """
        return _libsbml.KineticLaw_getParameter(self, *args)

    def getLocalParameter(self, *args):
        """
        getLocalParameter(self, unsigned int n) -> LocalParameter
        getLocalParameter(self, unsigned int n) -> LocalParameter
        getLocalParameter(self, string sid) -> LocalParameter
        getLocalParameter(self, string sid) -> LocalParameter

        Returns a local parameter based on its identifier.

        @param sid the identifier of the LocalParameter being sought.

        @return the LocalParameter object in this KineticLaw instace having the
        given 'id', or @c NULL if no such LocalParameter exists.
          

        """
        return _libsbml.KineticLaw_getLocalParameter(self, *args)

    def getNumParameters(self):
        """
        getNumParameters(self) -> unsigned int

        Returns the number of local parameters in this KineticLaw instance.

        @return the number of Parameters in this KineticLaw.
          

        """
        return _libsbml.KineticLaw_getNumParameters(self)

    def getNumLocalParameters(self):
        """
        getNumLocalParameters(self) -> unsigned int

        Returns the number of local parameters in this KineticLaw instance.

        @return the number of LocalParameters in this KineticLaw.
          

        """
        return _libsbml.KineticLaw_getNumLocalParameters(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units
        of measurement assumed for the 'math' expression of this
        KineticLaw.

        The units are calculated based on the mathematical expression in the
        KineticLaw and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The
        getDerivedUnitDefinition() method returns the calculated units.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c NULL.

        @warning Note that it is possible the 'math' expression in the
        KineticLaw contains pure numbers or parameters with undeclared
        units.  In those cases, it is not possible to calculate the units of
        the overall expression without making assumptions.  LibSBML does not
        make assumptions about the units, and getDerivedUnitDefinition() only
        returns the units as far as it is able to determine them.  For
        example, in an expression <em>X + Y</em>, if <em>X</em> has
        unambiguously-defined units and <em>Y</em> does not, it will return
        the units of <em>X</em>.  <strong>It is important that callers also
        invoke the method</strong> containsUndeclaredUnits() <strong>to
        determine whether this situation holds</strong>.  Callers may wish to
        take suitable actions in those scenarios.

        @return a UnitDefinition that expresses the units of the math 
        expression of this KineticLaw, or @c NULL if one cannot be constructed.

        @see containsUndeclaredUnits()
          

        """
        return _libsbml.KineticLaw_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c true if 
        the math expression of this KineticLaw contains
        parameters/numbers with undeclared units.

        @return @c true if the math expression of this KineticLaw
        includes parameters/numbers 
        with undeclared units, @c false otherwise.

        @note A return value of @c true indicates that the UnitDefinition
        returned by getDerivedUnitDefinition() may not accurately represent
        the units of the expression.

        @see getDerivedUnitDefinition()
          

        """
        return _libsbml.KineticLaw_containsUndeclaredUnits(self, *args)

    def removeParameter(self, *args):
        """
        removeParameter(self, unsigned int n) -> Parameter
        removeParameter(self, string sid) -> Parameter

        Removes a Parameter object with the given identifier in the list of
        local parameters in this KineticLaw instance and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the Parameter to remove

        @return the Parameter object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no Parameter
        object with the identifier exists in this KineticLaw instance.
          

        """
        return _libsbml.KineticLaw_removeParameter(self, *args)

    def removeLocalParameter(self, *args):
        """
        removeLocalParameter(self, unsigned int n) -> LocalParameter
        removeLocalParameter(self, string sid) -> LocalParameter

        Removes a LocalParameter object with the given identifier in the list of
        local parameters in this KineticLaw instance and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the LocalParameter to remove

        @return the LocalParameter object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no LocalParameter
        object with the identifier exists in this KineticLaw instance.
          

        """
        return _libsbml.KineticLaw_removeLocalParameter(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link
        SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.KineticLaw_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Species, is
        always @c 'kineticLaw'.

        @return the name of this element, i.e., @c 'kineticLaw'.
          

        """
        return _libsbml.KineticLaw_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this KineticLaw object
        have been set.

        @note The required attributes for a KineticLaw object are:
        @li 'formula' (SBML Level&nbsp;1 only)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.KineticLaw_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this KineticLaw object
        have been set.

        @note The required elements for a KineticLaw object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.KineticLaw_hasRequiredElements(self)

KineticLaw_swigregister = _libsbml.KineticLaw_swigregister
KineticLaw_swigregister(KineticLaw)

class SimpleSpeciesReference(SBase):
    """
    LibSBML implementation of %SBML's %SimpleSpeciesReference construct.

    As mentioned in the description of Reaction, every species that enters
    into a given reaction must appear in that reaction's lists of reactants,
    products and/or modifiers.  In an SBML model, all species that may
    participate in any reaction are listed in the 'listOfSpecies' element of
    the top-level Model object.  Lists of products, reactants and modifiers
    in Reaction objects do not introduce new species, but rather, they refer
    back to those listed in the model's top-level 'listOfSpecies'.  For
    reactants and products, the connection is made using SpeciesReference
    objects; for modifiers, it is made using ModifierSpeciesReference
    objects.  SimpleSpeciesReference is an abstract type that serves as the
    parent class of both SpeciesReference and ModifierSpeciesReference.  It
    is used simply to hold the attributes and elements that are common to
    the latter two structures.

    The SimpleSpeciesReference structure has a mandatory attribute,
    'species', which must be a text string conforming to the identifer
    syntax permitted in %SBML.  This attribute is inherited by the
    SpeciesReference and ModifierSpeciesReference subclasses derived from
    SimpleSpeciesReference.  The value of the 'species' attribute must be
    the identifier of a species defined in the enclosing Model.  The species
    is thereby declared as participating in the reaction being defined.  The
    precise role of that species as a reactant, product, or modifier in the
    reaction is determined by the subclass of SimpleSpeciesReference (i.e.,
    either SpeciesReference or ModifierSpeciesReference) in which the
    identifier appears.

    SimpleSpeciesReference also contains an optional attribute, 'id',
    allowing instances to be referenced from other structures.  No SBML
    structures currently do this; however, such structures are anticipated
    in future SBML Levels.


    <!---------------------------------------------------------------------- -->


    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleSpeciesReference, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleSpeciesReference, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SimpleSpeciesReference
    __del__ = lambda self : None;
    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this SimpleSpeciesReference.

        @return the id of this SimpleSpeciesReference.
          

        """
        return _libsbml.SimpleSpeciesReference_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this SimpleSpeciesReference.

        @return the name of this SimpleSpeciesReference.
          

        """
        return _libsbml.SimpleSpeciesReference_getName(self)

    def getSpecies(self):
        """
        getSpecies(self) -> string

        Get the value of the 'species' attribute.

        @return the value of the attribute 'species' for this
        SimpleSpeciesReference.
          

        """
        return _libsbml.SimpleSpeciesReference_getSpecies(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        SimpleSpeciesReference's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this SimpleSpeciesReference has been
        set, @c false otherwise.
          

        """
        return _libsbml.SimpleSpeciesReference_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        SimpleSpeciesReference's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this SimpleSpeciesReference has been
        set, @c false otherwise.
          

        """
        return _libsbml.SimpleSpeciesReference_isSetName(self)

    def isSetSpecies(self):
        """
        isSetSpecies(self) -> bool

        Predicate returning @c true if this
        SimpleSpeciesReference's 'species' attribute has been set.

        @return @c true if the 'species' attribute of this
        SimpleSpeciesReference has been set, @c false otherwise.
          

        """
        return _libsbml.SimpleSpeciesReference_isSetSpecies(self)

    def setSpecies(self, *args):
        """
        setSpecies(self, string sid) -> int

        Sets the 'species' attribute of this SimpleSpeciesReference.

        The identifier string passed in @p sid is copied.

        @param sid the identifier of a species defined in the enclosing
        Model's ListOfSpecies.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.SimpleSpeciesReference_setSpecies(self, *args)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this SimpleSpeciesReference.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this SimpleSpeciesReference

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.SimpleSpeciesReference_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this SimpleSpeciesReference.

        The string in @p name is copied.

        @param name the new name for the SimpleSpeciesReference

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.SimpleSpeciesReference_setName(self, *args)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the value of the 'id' attribute of this SimpleSpeciesReference.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.SimpleSpeciesReference_unsetId(self)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this SimpleSpeciesReference.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.SimpleSpeciesReference_unsetName(self)

    def isModifier(self):
        """
        isModifier(self) -> bool

        Predicate returning @c true if this
        is a ModifierSpeciesReference.

        @return @c true if this SimpleSpeciesReference's subclass is
        ModiferSpeciesReference, @c false if it is a plain SpeciesReference.
          

        """
        return _libsbml.SimpleSpeciesReference_isModifier(self)

SimpleSpeciesReference_swigregister = _libsbml.SimpleSpeciesReference_swigregister
SimpleSpeciesReference_swigregister(SimpleSpeciesReference)

class SpeciesReference(SimpleSpeciesReference):
    """
    LibSBML implementation of %SBML's %SpeciesReference construct.

    The Reaction structure provides a way to express which species act as
    reactants and which species act as products in a reaction.  In a given
    reaction, references to those species acting as reactants and/or
    products are made using instances of SpeciesReference structures in a
    Reaction object's lists of reactants and products.

    A species can occur more than once in the lists of reactants and
    products of a given Reaction instance.  The effective stoichiometry for
    a species in a reaction is the sum of the stoichiometry values given on
    the SpeciesReference object in the list of products minus the sum of
    stoichiometry values given on the SpeciesReference objects in the list
    of reactants.  A positive value indicates the species is effectively a
    product and a negative value indicates the species is effectively a
    reactant.  SBML places no restrictions on the effective stoichiometry of
    a species in a reaction; for example, it can be zero.  In the following
    SBML fragment, the two reactions have the same effective stoichiometry
    for all their species:
    @code
    <reaction id='x'>
        <listOfReactants>
            <speciesReference species='a'/>
            <speciesReference species='a'/>
            <speciesReference species='b'/>
        </listOfReactants>
        <listOfProducts>
            <speciesReference species='c'/>
            <speciesReference species='b'/>
        </listProducts>
    </reaction>
    <reaction id='y'>
        <listOfReactants>
            <speciesReference species='a' stoichiometry='2'/>
        </listOfReactants>
        <listOfProducts>
            <speciesReference species='c'/>
        </listProducts>
    </reaction>
    @endcode

    The precise structure of SpeciesReference differs between SBML
    Level&nbsp;2 and Level&nbsp;3.  We discuss the two variants in separate
    sections below.

    @section spr-l2 SpeciesReference in SBML Level 2

    The mandatory 'species' attribute of SpeciesReference must have as its
    value the identifier of an existing species defined in the enclosing
    Model.  The species is thereby designated as a reactant or product in
    the reaction.  Which one it is (i.e., reactant or product) is indicated
    by whether the SpeciesReference appears in the Reaction's 'reactant' or
    'product' lists.

    Product and reactant stoichiometries can be specified using
    <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
    SpeciesReference object.  The 'stoichiometry' attribute is of type
    double and should contain values greater than zero (0).  The
    'stoichiometryMath' element is implemented as an element containing a
    MathML expression.  These two are mutually exclusive; only one of
    'stoichiometry' or 'stoichiometryMath' should be defined in a given
    SpeciesReference instance.  When neither the attribute nor the element
    is present, the value of 'stoichiometry' in the SpeciesReference
    instance defaults to @c 1.

    For maximum interoperability, the 'stoichiometry' attribute should be
    used in preference to 'stoichiometryMath' when a species' stoichiometry
    is a simple scalar number (integer or decimal).  When the stoichiometry
    is a rational number, or when it is a more complicated formula,
    'stoichiometryMath' must be used.  The MathML expression in
    'stoichiometryMath' may also refer to identifiers of entities in a model
    (except reaction identifiers).  However, the only species identifiers
    that can be used in 'stoichiometryMath' are those referenced in the
    Reaction list of reactants, products and modifiers.

    The following is a simple example of a species reference for species @c
    X0, with stoichiometry @c 2, in a list of reactants within a reaction
    having the identifier @c J1:
    @code
    <model>
        ...
        <listOfReactions>
            <reaction id='J1'>
                <listOfReactants>
                    <speciesReference species='X0' stoichiometry='2'>
                </listOfReactants>
                ...
            </reaction>
            ...
        </listOfReactions>
        ...
    </model>
    @endcode

    The following is a more complex example of a species reference for
    species X0, with a stoichiometry formula consisting of the parameter
    @c x:
    @code
    <model>
        ...
        <listOfReactions>
            <reaction id='J1'>
                <listOfReactants>
                    <speciesReference species='X0'>
                        <stoichiometryMath>
                            <math xmlns='http://www.w3.org/1998/Math/MathML'>
                                <ci>x</ci>
                            </math>
                        </stoichiometryMath>
                    </speciesReference>
                </listOfReactants>
                ...
            </reaction>
            ...
        </listOfReactions>
        ...
    </model>
    @endcode


    @section spr-l3 SpeciesReference in SBML Level 3

    In Level 2's definition of a reaction, the stoichiometry attribute of a
    SpeciesReference is actually a combination of two factors, the standard
    biochemical stoichiometry and a conversion factor that may be needed to
    translate the units of the species quantity to the units of the reaction
    rate. Unfortunately, Level&nbsp;2 offers no direct way of decoupling
    these two factors, or for explicitly indicating the units. The only way
    to do it in Level&nbsp;2 is to use the StoichiometryMath object
    associated with SpeciesReferences, and to reference SBML Parameter
    objects from within the StoichiometryMath formula. This works because
    Parameter offers a way to attach units to a numerical value, but the
    solution is indirect and awkward for something that should be a simple
    matter.  Moreover, the question of how to properly encode
    stoichiometries in SBML reactions has caused much confusion among
    implementors of SBML software.

    SBML Level&nbsp;3 approaches this problem differently.  It (1) extends
    the the use of the SpeciesReference identifier to represent the value of
    the 'stoichiometry' attribute, (2) makes the 'stoichiometry' attribute
    optional, (3) removes StoichiometryMath, and (4) adds a new 'constant'
    boolean attribute on SpeciesReference.

    As in Level&nbsp;2, the 'stoichiometry' attribute is of type
    @c double and should contain values greater than zero (@c 0).  A
    missing 'stoichiometry' implies that the stoichiometry is either
    unknown, or to be obtained from an external source, or determined by an
    InitialAssignment object or other SBML construct elsewhere in the model.

    A species reference's stoichiometry is set by its 'stoichiometry'
    attribute exactly once.  If the SpeciesReference object's 'constant'
    attribute has the value @c true, then the stoichiometry is fixed and
    cannot be changed except by an InitialAssignment object.  These two
    methods of setting the stoichiometry (i.e., using 'stoichiometry'
    directly, or using InitialAssignment) differ in that the 'stoichiometry'
    attribute can only be set to a literal floating-point number, whereas
    InitialAssignment allows the value to be set using an arbitrary
    mathematical expression.  (As an example, the approach could be used to
    set the stoichiometry to a rational number of the form @em p/@em q,
    where @em p and @em q are integers, something that is occasionally
    useful in the context of biochemical reaction networks.)  If the species
    reference's 'constant' attribute has the value @c false, the species
    reference's value may be overridden by an InitialAssignment or changed
    by AssignmentRule or AlgebraicRule, and in addition, for simulation time
    <em>t &gt; 0</em>, it may also be changed by a RateRule or Event
    objects.  (However, some of these constructs are mutually exclusive; see
    the SBML Level&nbsp;3 Version&nbsp;1 Core specifiation for more
    details.)  It is not an error to define 'stoichiometry' on a species
    reference and also redefine the stoichiometry using an
    InitialAssignment, but the 'stoichiometry' attribute in that case is
    ignored.

    The value of the 'id' attribute of a SpeciesReference can be used as the
    content of a <code>&lt;ci&gt;</code> element in MathML formulas
    elsewhere in the model.  When the identifier appears in a MathML
    <code>&lt;ci&gt;</code> element, it represents the stoichiometry of the
    corresponding species in the reaction where the SpeciesReference object
    instance appears.  More specifically, it represents the value of the
    'stoichiometry' attribute on the SpeciesReference object.

    In SBML Level 3, the unit of measurement associated with the value of a
    species' stoichiometry is always considered to be @c dimensionless.
    This has the following implications:
    <ul>

    <li> When a species reference's identifier appears in mathematical
    formulas elsewhere in the model, the unit associated with that value is
    @c dimensionless.

    <li> The units of the 'math' elements of AssignmentRule,
    InitialAssignment and EventAssignment objects setting the stoichiometry
    of the species reference should be @c dimensionless.

    <li> If a species reference's identifier is the subject of a RateRule,
    the unit associated with the RateRule object's value should be
    <code>dimensionless</code>/<em>time</em>, where <em>time</em> is the
    model-wide unit of time set on the Model object.

    </ul>

    <!---------------------------------------------------------------------- -->


    """
    __swig_setmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeciesReference, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeciesReference, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SpeciesReference
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> SpeciesReference
        __init__(self, SBMLNamespaces sbmlns) -> SpeciesReference
        __init__(self, SpeciesReference orig) -> SpeciesReference

        Predicate returning @c true if
        all the required attributes for this SpeciesReference object
        have been set.

        @note The required attributes for a SpeciesReference object are:
        @li 'species'
        @li 'constant' (only available SBML Level&nbsp;3)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_SpeciesReference(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SpeciesReference

        Creates and returns a deep copy of this SpeciesReference instance.

        @return a (deep) copy of this SpeciesReference.
          

        """
        return _libsbml.SpeciesReference_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this SpeciesReference object to 'typical'
        default values.

        The SBML SpeciesReference component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets attribute 'stoichiometry' to @c 1.0
        <li> (Applies to Level&nbsp;1 models only) Sets attribute 'denominator' to @c 1
        </ul>

        @see getDenominator()
        @see setDenominator(int value)
        @see getStoichiometry()
        @see setStoichiometry(double value)
        @see getStoichiometryMath()
        @see setStoichiometryMath(const StoichiometryMath* math)
          

        """
        return _libsbml.SpeciesReference_initDefaults(self)

    def getStoichiometry(self):
        """
        getStoichiometry(self) -> double

        Get the value of the 'stoichiometry' attribute.

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c double and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @return the value of the (scalar) 'stoichiometry' attribute of this
        SpeciesReference.

        @see getStoichiometryMath()
          

        """
        return _libsbml.SpeciesReference_getStoichiometry(self)

    def getStoichiometryMath(self, *args):
        """
        getStoichiometryMath(self) -> StoichiometryMath
        getStoichiometryMath(self) -> StoichiometryMath

        Get the content of the 'stoichiometryMath' subelement as an ASTNode
        tree.

        The 'stoichiometryMath' element exists only in SBML Level 2.  There,
        product and reactant stoichiometries can be specified using
        <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c double and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or decimal).

        @return the content of the 'stoichiometryMath' subelement of this
        SpeciesReference.

        @see getStoichiometry()
          

        """
        return _libsbml.SpeciesReference_getStoichiometryMath(self, *args)

    def getDenominator(self):
        """
        getDenominator(self) -> int

        Get the value of the 'denominator' attribute, for the case of a
        rational-numbered stoichiometry or a model in SBML Level&nbsp;1.

        The 'denominator' attribute is only actually written out in the case
        of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number
        stoichiometries are written as MathML elements in the
        'stoichiometryMath' subelement.  However, as a convenience to users,
        libSBML allows the creation and manipulation of rational-number
        stoichiometries by supplying the numerator and denominator directly
        rather than having to manually create an ASTNode structure.  LibSBML
        will write out the appropriate constructs (either a combination of
        'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or a
        'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).

        @return the value of the 'denominator' attribute of this
        SpeciesReference.
          

        """
        return _libsbml.SpeciesReference_getDenominator(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Get the value of the 'constant' attribute.

        @return the value of the 'constant' attribute of this
        SpeciesReference.
          

        """
        return _libsbml.SpeciesReference_getConstant(self)

    def isSetStoichiometryMath(self):
        """
        isSetStoichiometryMath(self) -> bool

        Predicate returning @c true if this
        SpeciesReference's 'stoichiometryMath' subelement has been set

        @return @c true if the 'stoichiometryMath' subelement of this
        SpeciesReference has been set, @c false otherwise.
          

        """
        return _libsbml.SpeciesReference_isSetStoichiometryMath(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c true if this
        SpeciesReference's 'constant' attribute has been set

        @return @c true if the 'constant' attribute of this
        SpeciesReference has been set, @c false otherwise.
          

        """
        return _libsbml.SpeciesReference_isSetConstant(self)

    def isSetStoichiometry(self):
        """
        isSetStoichiometry(self) -> bool

        Predicate returning @c true if this
        SpeciesReference's 'stoichiometry' attribute has been set.

        @return @c true if the 'stoichiometry' attribute of this
        SpeciesReference has been set, @c false otherwise.
          

        """
        return _libsbml.SpeciesReference_isSetStoichiometry(self)

    def setStoichiometry(self, *args):
        """
        setStoichiometry(self, double value) -> int

        Sets the value of the 'stoichiometry' attribute of this
        SpeciesReference.

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c double and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @param value the new value of the 'stoichiometry' attribute

        @note In SBML Level&nbsp;2, the 'stoichiometryMath' subelement of this
        SpeciesReference object will be unset because the 'stoichiometry'
        attribute and the stoichiometryMath' subelement are mutually
        exclusive.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.SpeciesReference_setStoichiometry(self, *args)

    def setStoichiometryMath(self, *args):
        """
        setStoichiometryMath(self, StoichiometryMath math) -> int

        Sets the 'stoichiometryMath' subelement of this SpeciesReference.

        The Abstract Syntax Tree in @p math is copied.

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c double and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @param math the StoichiometryMath expression that is to be copied as the
        content of the 'stoichiometryMath' subelement.

        @note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this
        SpeciesReference object will be unset (isSetStoichiometry() will
        return @c false although getStoichiometry() will return @c 1.0) if the
        given math is not null because the 'stoichiometry' attribute and the
        stoichiometryMath' subelement are mutually exclusive.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
          

        """
        return _libsbml.SpeciesReference_setStoichiometryMath(self, *args)

    def setDenominator(self, *args):
        """
        setDenominator(self, int value) -> int

        Set the value of the 'denominator' attribute, for the case of a
        rational-numbered stoichiometry or a model in SBML Level&nbsp;1.

        The 'denominator' attribute is only actually written out in the case
        of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number
        stoichiometries are written as MathML elements in the
        'stoichiometryMath' subelement.  However, as a convenience to users,
        libSBML allows the creation and manipulation of rational-number
        stoichiometries by supplying the numerator and denominator directly
        rather than having to manually create an ASTNode structure.  LibSBML
        will write out the appropriate constructs (either a combination of
        'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or
        a 'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).

        @param value the scalar value 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.SpeciesReference_setDenominator(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool flag) -> int

        Sets the 'constant' attribute of this SpeciesReference to the given boolean
        @p flag.

        @param flag a boolean, the value for the 'constant' attribute of this
        SpeciesReference instance

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.SpeciesReference_setConstant(self, *args)

    def unsetStoichiometryMath(self):
        """
        unsetStoichiometryMath(self) -> int

        Unsets the 'stoichiometryMath' subelement of this SpeciesReference.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c double and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this
        SpeciesReference object will be reset to a default value (@c 1.0) if
        the 'stoichiometry' attribute has not been set.
          

        """
        return _libsbml.SpeciesReference_unsetStoichiometryMath(self)

    def unsetStoichiometry(self):
        """
        unsetStoichiometry(self) -> int

        Unsets the 'stoichiometry' attribute of this SpeciesReference.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note In SBML Level&nbsp;1, the 'stoichiometry' attribute of this
        SpeciesReference object will be just reset to a default value (@c 1.0)
        and isSetStoichiometry() will still return @c true.  In SBML
        Level&nbsp;2, the 'stoichiometry' attribute of this object will be
        unset (which will result in isSetStoichiometry() returning @c false,
        although getStoichiometry() will return @c 1.0) if the
        'stoichiometryMath' subelement has been set, otherwise the attribute
        will be just reset to the default value (@c 1.0) (and
        isSetStoichiometry() will still return @c true).  In SBML
        Level&nbsp;3, the 'stoichiometry' attribute of this object will be set
        to @c NaN and isSetStoichiometry() will return @c false.
          

        """
        return _libsbml.SpeciesReference_unsetStoichiometry(self)

    def createStoichiometryMath(self):
        """
        createStoichiometryMath(self) -> StoichiometryMath

        Creates a new, empty StoichiometryMath object, adds it to this
        SpeciesReference, and returns it.

        @return the newly created StoichiometryMath object instance

        @see Reaction::addReactant(const SpeciesReference* sr)
        @see Reaction::addProduct(const SpeciesReference* sr)
          

        """
        return _libsbml.SpeciesReference_createStoichiometryMath(self)

    def setAnnotation(self, *args):
        """
        setAnnotation(self, XMLNode annotation) -> int
        setAnnotation(self, string annotation) -> int

        Sets the value of the 'annotation' subelement of this SBML object to a
        copy of @p annotation.

        Any existing content of the 'annotation' subelement is discarded.
        Unless you have taken steps to first copy and reconstitute any
        existing annotations into the @p annotation that is about to be
        assigned, it is likely that performing such wholesale replacement is
        unfriendly towards other software applications whose annotations are
        discarded.  An alternative may be to use appendAnnotation().

        @param annotation an XML string that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see appendAnnotation(const XMLNode* annotation)
        @see appendAnnotation(const std::string& annotation)
          

        """
        return _libsbml.SpeciesReference_setAnnotation(self, *args)

    def appendAnnotation(self, *args):
        """
        appendAnnotation(self, XMLNode annotation) -> int
        appendAnnotation(self, string annotation) -> int

        Appends annotation content to any existing content in the 'annotation'
        subelement of this object.

        The content in @p annotation is copied.  Unlike setAnnotation(), this
        method allows other annotations to be preserved when an application
        adds its own data.

        @param annotation an XML string that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see setAnnotation(const std::string& annotation)
        @see setAnnotation(const XMLNode* annotation)
          

        """
        return _libsbml.SpeciesReference_appendAnnotation(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.SpeciesReference_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        SpeciesReference, is always @c 'speciesReference'.

        @return the name of this element, i.e., @c 'speciesReference'.
          

        """
        return _libsbml.SpeciesReference_getElementName(self)

    def initL2Stoichiometry(self):
        """
        initL2Stoichiometry(self)

        Subclasses should override this method to write out their contained
        SBML objects as XML elements.  Be sure to call your parents
        implementation of this method as well.
        @deprecated libSBML internal


        """
        return _libsbml.SpeciesReference_initL2Stoichiometry(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this SpeciesReference object
        have been set.

        @note The required attributes for a SpeciesReference object are:
        @li 'species'
        @li 'constant' (only available SBML Level&nbsp;3)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.SpeciesReference_hasRequiredAttributes(self)

SpeciesReference_swigregister = _libsbml.SpeciesReference_swigregister
SpeciesReference_swigregister(SpeciesReference)

class ModifierSpeciesReference(SimpleSpeciesReference):
    """
    LibSBML implementation of %SBML's %ModifierSpeciesReference construct.

    Sometimes a species appears in the kinetic rate formula of a reaction
    but is itself neither created nor destroyed in that reaction (for
    example, because it acts as a catalyst or inhibitor).  In SBML, all such
    species are simply called @em modifiers without regard to the detailed
    role of those species in the model.  The Reaction structure provides a
    way to express which species act as modifiers in a given reaction.  This
    is the purpose of the list of modifiers available in Reaction.  The list
    contains instances of ModifierSpeciesReference structures.

    The ModifierSpeciesReference structure inherits the mandatory attribute
    'species' and optional attributes 'id' and 'name' from the parent class
    SimpleSpeciesReference.  See the description of SimpleSpeciesReference
    for more information about these.

    The value of the 'species' attribute must be the identifier of a species
    defined in the enclosing Model; this species is designated as a modifier
    for the current reaction.  A reaction may have any number of modifiers.
    It is permissible for a modifier species to appear simultaneously in the
    list of reactants and products of the same reaction where it is
    designated as a modifier, as well as to appear in the list of reactants,
    products and modifiers of other reactions in the model.


    <!---------------------------------------------------------------------- -->


    """
    __swig_setmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModifierSpeciesReference, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModifierSpeciesReference, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ModifierSpeciesReference
        __init__(self, SBMLNamespaces sbmlns) -> ModifierSpeciesReference

        Creates a new ModifierSpeciesReference using the given SBMLNamespaces object
        @p sbmlns.

        @param sbmlns an SBMLNamespaces object.

        @note Upon the addition of a ModifierSpeciesReference object to an
        SBMLDocument (e.g., using Model::addModifierSpeciesReference()), the
        SBML XML namespace of the document @em overrides the value used when
        creating the ModifierSpeciesReference object via this constructor.
        This is necessary to ensure that an SBML document is a consistent
        structure.  Nevertheless, the ability to supply the values at the time
        of creation of a ModifierSpeciesReference is an important aid to
        producing valid SBML.  Knowledge of the intented SBML Level and
        Version determine whether it is valid to assign a particular value to
        an attribute, or whether it is valid to add an object to an existing
        SBMLDocument.
          

        """
        this = _libsbml.new_ModifierSpeciesReference(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ModifierSpeciesReference
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> ModifierSpeciesReference

        Creates and returns a deep copy of this ModifierSpeciesReference
        instance.

        @return a (deep) copy of this ModifierSpeciesReference.
          

        """
        return _libsbml.ModifierSpeciesReference_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ModifierSpeciesReference_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Species, is
        always @c 'modifierSpeciesReference'.

        @return the name of this element, i.e., @c 'modifierSpeciesReference'.
          

        """
        return _libsbml.ModifierSpeciesReference_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this ModifierSpeciesReference object
        have been set.

        @note The required attributes for a ModifierSpeciesReference object are:
        species
          

        """
        return _libsbml.ModifierSpeciesReference_hasRequiredAttributes(self)

ModifierSpeciesReference_swigregister = _libsbml.ModifierSpeciesReference_swigregister
ModifierSpeciesReference_swigregister(ModifierSpeciesReference)

class ListOfSpeciesReferences(ListOf):
    """
    LibSBML implementation of SBML's %ListOfSpeciesReferences construct.

    The ListOfSpeciesReferences class is used to store lists of reactants
    and products in a Reaction object.

    As with the various other ListOf___ classes in %SBML, the
    ListOfSpeciesReferences is merely a container used for organizing
    instances of other objects, in this case SpeciesReference objects.
    ListOfSpeciesReferences is derived from the abstract class SBase, and
    inherit the various attributes and subelements of SBase, such as
    'metaid' as and 'annotation'.  The ListOf___ classes do not add any
    attributes of their own.

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfSpeciesReferences, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfSpeciesReferences, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> ListOfSpeciesReferences

        Creates a new, empty ListOfSpeciesReferences.
          

        """
        this = _libsbml.new_ListOfSpeciesReferences()
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfSpeciesReferences

        Creates and returns a deep copy of this ListOfSpeciesReferences
        instance.

        @return a (deep) copy of this ListOfSpeciesReferences.
          

        """
        return _libsbml.ListOfSpeciesReferences_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfSpeciesReferences_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., SpeciesReference objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfSpeciesReferences_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfSpeciesReferences, the XML element name is @c
        'listOfSpeciesReferences'.

        @return the name of this element, i.e., @c 'listOfSpeciesReferences'.
          

        """
        return _libsbml.ListOfSpeciesReferences_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> SimpleSpeciesReference
        get(self, unsigned int n) -> SimpleSpeciesReference
        get(self, string sid) -> SimpleSpeciesReference
        get(self, string sid) -> SimpleSpeciesReference

        Get a SpeciesReference from the ListOfSpeciesReferences
        based on its identifier.

        @param sid a string representing the identifier 
        of the SpeciesReference to get.

        @return SpeciesReference in this ListOfSpeciesReferences
        with the given id or @c NULL if no such
        SpeciesReference exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfSpeciesReferences_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> SimpleSpeciesReference
        remove(self, string sid) -> SimpleSpeciesReference

        Removes item in this ListOfSpeciesReferences items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfSpeciesReferences_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfSpeciesReferences
    __del__ = lambda self : None;
ListOfSpeciesReferences_swigregister = _libsbml.ListOfSpeciesReferences_swigregister
ListOfSpeciesReferences_swigregister(ListOfSpeciesReferences)

class Event(SBase):
    """
    LibSBML implementation of SBML's %Event construct.

    An Event object defines when the event can occur, the variables that are
    affected by the event, and how the variables are affected.

    An Event definition has several parts: an optional identifier (defined
    by the attribute 'id'), an optional name (defined by the attribute
    'name'), a required trigger condition (defined by an object of class
    Trigger), and at least one EventAssignment.  In addition, an event can
    include an optional delay (defined by an object of class Delay).

    The operation of Event is divided into two phases (even when the event
    is not delayed): one when the event is @em fired, and the other when the
    event is @em executed.  Trigger objects define the conditions for firing
    an event, Delay objects define when the event is actually executed, and
    EventAssignment objects define the effects of executing the event.
    Please consult the descriptions of Trigger, Delay and EventAssignment
    for more information.

    The optional Delay on Event means there are two times to consider when
    computing the results of an event: the time at which the event
    <em>fires</em>, and the time at which assignments are <em>executed</em>.
    It is also possible to distinguish between the time at which the
    EventAssignment's expression is calculated, and the time at which the
    assignment is made: the expression could be evaluated at the same time
    the assignments are performed, i.e., when the event is
    <em>executed</em>, but it could also be defined to be evaluated at the
    time the event <em>fired</em>.

    In SBML Level&nbsp;2 versions before Version&nbsp;4, the semantics of
    Event time delays were defined such that the expressions in the event's
    assignments were always evaluated at the time the event was
    <em>fired</em>.  This definition made it difficult to define an event
    whose assignment formulas were meant to be evaluated at the time the
    event was <em>executed</em> (i.e., after the time period defined by the
    value of the Delay element).  In SBML Level&nbsp;2 Version&nbsp;4 and in
    Level&nbsp;3, the attribute 'useValuesFromTriggerTime' on Event allows a
    model to indicate the time at which the event's assignments are intended
    the values of the assignment formulas are computed at the moment the
    event fired, not after the delay.  If 'useValuesFromTriggerTime'=@c
    false, it means that the formulas in the event's assignments are to be
    computed @em after the delay, at the time the event is executed.

    @section version-diffs SBML version differences

    The definition of Event in SBML Level&nbsp;2 Versions 1 and 2 includes
    an additional attribute called 'timeUnits', which allowed the time units
    of the Delay to be set explicitly.  Later Versions of SBML Level&nbsp;2
    as well as SBML Level&nbsp;3 do not define this attribute.  LibSBML
    supports this attribute for compatibility with previous versions of SBML
    Level&nbsp;2; however, if a model in SBML Level&nbsp;3 or Level&nbsp;2
    Versions&nbsp;3&ndash;4 format sets the attribute, the
    consistency-checking method SBMLDocument::checkConsistency() will report
    an error.

    The attribute 'useValuesFromTriggerTime' was introduced in SBML
    Level&nbsp;2 Version&nbsp;4.  Models defined in prior Versions of SBML
    Level&nbsp;2 cannot use this attribute, and
    SBMLDocument::checkConsistency() will report an error if they do.

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Event, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Event, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Event
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Event
        __init__(self, SBMLNamespaces sbmlns) -> Event
        __init__(self, Event orig) -> Event

        Predicate returning @c true if
        all the required elements for this Event object
        have been set.

        @note The required elements for a Event object are:
        @li 'trigger'
        @li 'listOfEventAssignments' (required in SBML Level&nbsp;2, optional in Level&nbsp;3)
        @deprecated libSBML internal


        """
        this = _libsbml.new_Event(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Event

        Creates and returns a deep copy of this Event.

        @return a (deep) copy of this Event.
          

        """
        return _libsbml.Event_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Event.

        @return the id of this Event.
          

        """
        return _libsbml.Event_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Event.

        @return the name of this Event.
          

        """
        return _libsbml.Event_getName(self)

    def getTrigger(self, *args):
        """
        getTrigger(self) -> Trigger
        getTrigger(self) -> Trigger

        Get the event trigger portion of this Event.

        @return the Trigger object of this Event.
          

        """
        return _libsbml.Event_getTrigger(self, *args)

    def getDelay(self, *args):
        """
        getDelay(self) -> Delay
        getDelay(self) -> Delay

        Get the assignment delay portion of this Event, if there is one.

        @return the delay of this Event if one is defined, or @c NULL if none
        is defined.
          

        """
        return _libsbml.Event_getDelay(self, *args)

    def getTimeUnits(self):
        """
        getTimeUnits(self) -> string

        Get the value of the 'timeUnits' attribute of this Event, if it has one.

        @return the value of the attribute 'timeUnits' as a string.

        @warning Definitions of Event in SBML Level 2 Versions&nbsp;1
        and&nbsp;2 included the additional attribute called 'timeUnits', but
        it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports
        this attribute for compatibility with previous versions of SBML
        Level&nbsp;2, but its use is discouraged since models in Level 2
        Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3
        or&nbsp;4 model sets the attribute, the consistency-checking method
        SBMLDocument::checkConsistency() will report an error.
          

        """
        return _libsbml.Event_getTimeUnits(self)

    def getUseValuesFromTriggerTime(self):
        """
        getUseValuesFromTriggerTime(self) -> bool

        Get the value of the 'useValuesFromTriggerTime' attribute of this Event.

        The optional Delay on Event means there are two times to consider when
        computing the results of an event: the time at which the event
        <em>fires</em>, and the time at which assignments are <em>executed</em>.
        It is also possible to distinguish between the time at which the
        EventAssignment's expression is calculated, and the time at which the
        assignment is made: the expression could be evaluated at the same time
        the assignments are performed, i.e., when the event is
        <em>executed</em>, but it could also be defined to be evaluated at the
        time the event <em>fired</em>.

        In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics of
        Event time delays were defined such that the expressions in the event's
        assignments were always evaluated at the time the event was
        <em>fired</em>.  This definition made it difficult to define an event
        whose assignment formulas were meant to be evaluated at the time the
        event was <em>executed</em> (i.e., after the time period defined by the
        value of the Delay element).  In SBML Level&nbsp;2 Version&nbsp;4, the
        attribute 'useValuesFromTriggerTime' on Event allows a model to indicate
        the time at which the event's assignments are intended to be evaluated.
        The default value is @c true, which corresponds to the interpretation of
        event assignments prior to Version&nbsp;4: the values of the assignment
        formulas are computed at the moment the event fired, not after the
        delay.  If 'useValuesFromTriggerTime'=@c false, it means that the
        formulas in the event's assignments are to be computed after the delay,
        at the time the event is executed.

        @return the value of the attribute 'useValuesFromTriggerTime' as a boolean.

        @warning The attribute 'useValuesFromTriggerTime' was introduced in
        SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in models defined
        using SBML Level&nbsp;2 versions prior to Version&nbsp;4.  If a
        Version&nbsp;1&ndash;&nbsp;3 model sets the attribute, the
        consistency-checking method SBMLDocument::checkConsistency() will
        report an error.
          

        """
        return _libsbml.Event_getUseValuesFromTriggerTime(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c true if this
        Event's 'id' attribute has been set.

        @return @c true if the 'id' attribute of this Event has been
        set, @c false otherwise.
          

        """
        return _libsbml.Event_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c true if this
        Event's 'name' attribute has been set.

        @return @c true if the 'name' attribute of this Event has been
        set, @c false otherwise.
          

        """
        return _libsbml.Event_isSetName(self)

    def isSetTrigger(self):
        """
        isSetTrigger(self) -> bool

        Predicate for testing whether the trigger for this Event has been set.

        @return @c true if the trigger of this Event has been set, @c false
        otherwise.
          

        """
        return _libsbml.Event_isSetTrigger(self)

    def isSetDelay(self):
        """
        isSetDelay(self) -> bool

        Predicate for testing whether the delay for this Event has been set.

        @return @c true if the delay of this Event has been set, @c false
        otherwise.
          

        """
        return _libsbml.Event_isSetDelay(self)

    def isSetTimeUnits(self):
        """
        isSetTimeUnits(self) -> bool

        Predicate for testing whether the 'timeUnits' attribute of this Event
        has been set.

        @return @c true if the 'timeUnits' attribute of this Event has been
        set, @c false otherwise.

        @warning Definitions of Event in SBML Level 2 Versions&nbsp;1
        and&nbsp;2 included the additional attribute called 'timeUnits', but
        it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports
        this attribute for compatibility with previous versions of SBML
        Level&nbsp;2, but its use is discouraged since models in Level 2
        Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3
        or&nbsp;4 model sets the attribute, the consistency-checking method
        SBMLDocument::checkConsistency() will report an error.
          

        """
        return _libsbml.Event_isSetTimeUnits(self)

    def isSetUseValuesFromTriggerTime(self):
        """
        isSetUseValuesFromTriggerTime(self) -> bool

        Predicate for testing whether the 'useValuesFromTriggerTime' attribute of this Event
        has been set.

        @return @c true if the 'useValuesFromTriggerTime' attribute of this Event has been
        set, @c false otherwise.

        @warning Definitions of Event in SBML Level 2 Versions&nbsp;1
        and&nbsp;2 included the additional attribute called 'timeUnits', but
        it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports
        this attribute for compatibility with previous versions of SBML
        Level&nbsp;2, but its use is discouraged since models in Level 2
        Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3
        or&nbsp;4 model sets the attribute, the consistency-checking method
        SBMLDocument::checkConsistency() will report an error.
          

        """
        return _libsbml.Event_isSetUseValuesFromTriggerTime(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Event.

        The string @p sid is copied.  Note that SBML has strict requirements
        for the syntax of identifiers.  @htmlinclude id-syntax.html

        @param sid the string to use as the identifier of this Event

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Event_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Event.

        The string in @p name is copied.

        @param name the new name for the Event

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Event_setName(self, *args)

    def setTrigger(self, *args):
        """
        setTrigger(self, Trigger trigger) -> int

        Sets the trigger definition of this Event to a copy of the given
        Trigger object instance.

        @param trigger the Trigger object instance to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
          

        """
        return _libsbml.Event_setTrigger(self, *args)

    def setDelay(self, *args):
        """
        setDelay(self, Delay delay) -> int

        Sets the delay definition of this Event to a copy of the given Delay
        object instance.

        @param delay the Delay object instance to use

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
          

        """
        return _libsbml.Event_setDelay(self, *args)

    def setTimeUnits(self, *args):
        """
        setTimeUnits(self, string sid) -> int

        Sets the 'timeUnits' attribute of this Event to a copy of @p sid.

        @param sid the identifier of the time units to use.

        @warning Definitions of Event in SBML Level 2 Versions&nbsp;1
        and&nbsp;2 included the additional attribute called 'timeUnits', but
        it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports
        this attribute for compatibility with previous versions of SBML
        Level&nbsp;2, but its use is discouraged since models in Level 2
        Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3
        or&nbsp;4 model sets the attribute, the consistency-checking method
        SBMLDocument::checkConsistency() will report an error.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.Event_setTimeUnits(self, *args)

    def setUseValuesFromTriggerTime(self, *args):
        """
        setUseValuesFromTriggerTime(self, bool value) -> int

        Sets the 'useValuesFromTriggerTime' attribute of this Event to a @p value.

        The optional Delay on Event means there are two times to consider when
        computing the results of an event: the time at which the event
        <em>fires</em>, and the time at which assignments are <em>executed</em>.
        It is also possible to distinguish between the time at which the
        EventAssignment's expression is calculated, and the time at which the
        assignment is made: the expression could be evaluated at the same time
        the assignments are performed, i.e., when the event is
        <em>executed</em>, but it could also be defined to be evaluated at the
        time the event <em>fired</em>.

        In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics of
        Event time delays were defined such that the expressions in the event's
        assignments were always evaluated at the time the event was
        <em>fired</em>.  This definition made it difficult to define an event
        whose assignment formulas were meant to be evaluated at the time the
        event was <em>executed</em> (i.e., after the time period defined by the
        value of the Delay element).  In SBML Level&nbsp;2 Version&nbsp;4, the
        attribute 'useValuesFromTriggerTime' on Event allows a model to indicate
        the time at which the event's assignments are intended to be evaluated.
        The default value is @c true, which corresponds to the interpretation of
        event assignments prior to Version&nbsp;4: the values of the assignment
        formulas are computed at the moment the event fired, not after the
        delay.  If 'useValuesFromTriggerTime'=@c false, it means that the
        formulas in the event's assignments are to be computed after the delay,
        at the time the event is executed.

        @param value the value of useValuesFromTriggerTime to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink

        @warning The attribute 'useValuesFromTriggerTime' was introduced in
        SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in models defined
        using SBML Level&nbsp;2 versions prior to Version&nbsp;4.  If a
        Version&nbsp;1&ndash;&nbsp;3 model sets the attribute, the
        consistency-checking method SBMLDocument::checkConsistency() will
        report an error.
          

        """
        return _libsbml.Event_setUseValuesFromTriggerTime(self, *args)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the value of the 'id' attribute of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Event_unsetId(self)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Event_unsetName(self)

    def unsetDelay(self):
        """
        unsetDelay(self) -> int

        Unsets the Delay of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.Event_unsetDelay(self)

    def unsetTimeUnits(self):
        """
        unsetTimeUnits(self) -> int

        Unsets the 'timeUnits' attribute of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @warning Definitions of Event in SBML Level&nbsp;2 Versions 1 and 2
        included the attribute called 'timeUnits', but it was removed in SBML
        Level&nbsp;2 Version&nbsp;3.  LibSBML supports this attribute for
        compatibility with previous versions of SBML Level&nbsp;2, but its use
        is discouraged since models in Level&nbsp;2 Version&nbsp;3 and
        Version&nbsp;4 cannot contain it.  If a Version&nbsp;3 or&nbsp;4 model
        sets this attribute, the consistency-checking method
        SBMLDocument::checkConsistency() will report an error.
          

        """
        return _libsbml.Event_unsetTimeUnits(self)

    def addEventAssignment(self, *args):
        """
        addEventAssignment(self, EventAssignment ea) -> int

        Appends a copy of the given EventAssignment to this Event.

        @param ea the EventAssignment object to add.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink
        @li @link OperationReturnValues_t#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note This method should be used with some caution.  The fact that
        this method @em copies the object passed to it means that the caller
        will be left holding a physically different object instance than the
        one contained in this Event.  Changes made to the original object
        instance (such as resetting attribute values) will <em>not affect the
        instance in the Event</em>.  In addition, the caller should make sure
        to free the original object if it is no longer being used, or else a
        memory leak will result.  Please see Event::createEventAssignment()
        for a method that does not lead to these issues.

        @see createEventAssignment()
          

        """
        return _libsbml.Event_addEventAssignment(self, *args)

    def createEventAssignment(self):
        """
        createEventAssignment(self) -> EventAssignment

        Creates a new, empty EventAssignment, adds it to this Event's list of
        event assignments and returns the EventAssignment.

        @return the newly created EventAssignment object instance

        @see addEventAssignment(const EventAssignment* ea)
          

        """
        return _libsbml.Event_createEventAssignment(self)

    def createTrigger(self):
        """
        createTrigger(self) -> Trigger

        Creates a new, empty Trigger, adds it to this Event and 
        returns the Trigger.

        @return the newly created Trigger object instance
          

        """
        return _libsbml.Event_createTrigger(self)

    def createDelay(self):
        """
        createDelay(self) -> Delay

        Creates a new, empty Delay, adds it to this Event and 
        returns the Delay.

        @return the newly created Delay object instance
          

        """
        return _libsbml.Event_createDelay(self)

    def getListOfEventAssignments(self, *args):
        """
        getListOfEventAssignments(self) -> ListOfEventAssignments
        getListOfEventAssignments(self) -> ListOfEventAssignments

        Returns the list of event assignments for this Event.

        @return the list of EventAssignments for this Event.
          

        """
        return _libsbml.Event_getListOfEventAssignments(self, *args)

    def getEventAssignment(self, *args):
        """
        getEventAssignment(self, unsigned int n) -> EventAssignment
        getEventAssignment(self, unsigned int n) -> EventAssignment
        getEventAssignment(self, string variable) -> EventAssignment
        getEventAssignment(self, string variable) -> EventAssignment

        Return the event assignment indicated by the given @p variable.

        @param variable a string, the identifier of the variable whose
        EventAssignment is being sought.

        @return the EventAssignment for the given @p variable, or @c NULL if
        no such EventAssignment exits.
          

        """
        return _libsbml.Event_getEventAssignment(self, *args)

    def getNumEventAssignments(self):
        """
        getNumEventAssignments(self) -> unsigned int

        Returns the number of EventAssignment objects attached to this
        Event.

        @return the number of EventAssignments in this Event.
          

        """
        return _libsbml.Event_getNumEventAssignments(self)

    def removeEventAssignment(self, *args):
        """
        removeEventAssignment(self, unsigned int n) -> EventAssignment
        removeEventAssignment(self, string variable) -> EventAssignment

        Removes the EventAssignment object with the given 'variable' attribute 
        from this Event object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the EventAssignment objects in this Event object have the 
        'variable' attribute @p variable, then @c NULL is returned.

        @param variable the 'variable' attribute of the EventAssignment object 
        to remove

        @return the EventAssignment object removed.  As mentioned above, the 
        caller owns the returned object. @c NULL is returned if no EventAssignment
        object with the 'variable' attribute exists in this Event object.
          

        """
        return _libsbml.Event_removeEventAssignment(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code of this object instance.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Event_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Event, is
        always @c 'event'.

        @return the name of this element, i.e., @c 'event'. 
          

        """
        return _libsbml.Event_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this Event object
        have been set.

        @note The required attributes for a Event object are:
        @li 'useValuesfromTriggerTime' (required in SBML Level&nbsp;3)
          

        """
        return _libsbml.Event_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this Event object
        have been set.

        @note The required elements for a Event object are:
        @li 'trigger'
        @li 'listOfEventAssignments' (required in SBML Level&nbsp;2, optional in Level&nbsp;3)
          

        """
        return _libsbml.Event_hasRequiredElements(self)

Event_swigregister = _libsbml.Event_swigregister
Event_swigregister(Event)

class ListOfEvents(ListOf):
    """
    LibSBML implementation of SBML's %ListOfEvents construct.

    The various ListOf___ classes in SBML are merely containers used for
    organizing the main components of an SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @image html listof-illustration.jpg 'ListOf___ elements in an SBML Model'
    @image latex listof-illustration.jpg 'ListOf___ elements in an SBML Model'

    Readers may wonder about the motivations for using the ListOf___
    containers.  A simpler approach in XML might be to place the components
    all directly at the top level of the model definition.  We chose instead
    to group them within XML elements named after ListOf<em>Classname</em>,
    in part because we believe this helps organize the components and makes
    visual reading of models in XML easier.  More importantly, the fact that
    the container classes are derived from SBase means that software tools
    can add information about the lists themselves into each list
    container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfEvents, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfEvents, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfEvents

        Creates and returns a deep copy of this ListOfEvents.

        @return a (deep) copy of this ListOfEvents.
          

        """
        return _libsbml.ListOfEvents_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfEvents_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Event objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfEvents_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfEvents, the XML element name is @c 'listOfEvents'.

        @return the name of this element, i.e., @c 'listOfEvents'.
          

        """
        return _libsbml.ListOfEvents_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Event
        get(self, unsigned int n) -> Event
        get(self, string sid) -> Event
        get(self, string sid) -> Event

        Get a Event from the ListOfEvents
        based on its identifier.

        @param sid a string representing the identifier 
        of the Event to get.

        @return Event in this ListOfEvents
        with the given id or @c NULL if no such
        Event exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfEvents_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Event
        remove(self, string sid) -> Event

        Removes item in this ListOfEvents items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfEvents_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfEvents"""
        this = _libsbml.new_ListOfEvents()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfEvents
    __del__ = lambda self : None;
ListOfEvents_swigregister = _libsbml.ListOfEvents_swigregister
ListOfEvents_swigregister(ListOfEvents)

class EventAssignment(SBase):
    """
    LibSBML implementation of %SBML's %EventAssignment construct for %Event

    An Event object defines when the event can occur, the variables that are
    affected by the event, and how the variables are affected.  The purpose
    of the EventAssignment object class is to define how variables are
    affected by an Event.  In every instance of an Event definition in a
    model, the object's ListOfEventAssignments must have a non-empty list of
    one or more elements of class EventAssignment.

    The operation of an Event is divided into two phases (regardless of
    whether a delay is involved): one phase when the event is @em fired, and
    the other when the event is @em executed.  EventAssignment objects are
    interpreted when an event is executed.  The effects are described below.

    EventAssignment is derived from SBase and adds one attribute
    ('variable') and one subelement ('math', containing MathML content).
    The attribute 'variable' is required to have a value.  Its type is the
    SBML type @c SId and can contain the identifier of an existing
    Compartment, Species or (global) Parameter instance defined in the
    model.

    @section event-variable Effects of event assignments

    An SBML event assignment has effect when the event is @em executed; that
    is, at the end of any given delay period (if defined) following the
    moment that the Event is triggered.  When the event fires, the effect is
    to change the value of the model component identified by the 'variable'
    attribute.

    Certain restrictions are placed on what can appear in 'variable':
    <ul>
    <li> The object identified by the value of the EventAssignment attribute
    'variable' must not have its 'constant' attribute set to or default to
    @c true.  (Constants cannot be affected by events.)

    <li> The 'variable' attribute must not contain the identifier of a
    reaction; only species, compartment and parameter values may be set by
    an Event.

    <li> The value of every 'variable' attribute must be unique among the set
    of EventAssignment structures within a given Event structure.  In other
    words, a single event cannot have multiple EventAssignment objects
    assigning the same variable.  (All of them would be performed at the
    same time when that particular Event triggers, resulting in
    indeterminacy.)  However, @em separate Event instances can refer to the
    same variable.
     
    <li> A variable cannot be assigned a value in an EventAssignment object
    instance and also be assigned a value by an AssignmentRule; i.e., the
    value of an EventAssignment's 'variable' attribute cannot be the same as
    the value of a AssignmentRule' 'variable' attribute.  (Assignment rules
    hold at all times, therefore it would be inconsistent to also define an
    event that reassigns the value of the same variable.)
    </ul>

    Note that the time of assignment of the object identified by the
    value of the 'variable' attribute is always the time at which the Event
    is <em>executed</em>, not when it is <em>fired</em>.  The timing is
    controlled by the optional Delay in an Event.  The time of
    assignment is not affected by the 'useValuesFromTriggerTime'
    attribute on Event&mdash;that attribute affects the time at which the
    EventAssignment's 'math' expression is @em evaluated.  In other
    words, SBML allows decoupling the time at which the
    'variable' is assigned from the time at which its value
    expression is calculated.

    @section event-math The 'math' subelement in an EventAssignment

    The MathML expression contained in an EventAssignment defines the new
    value of the variable being assigned by the Event.  The order of the
    EventAssignment structures is not significant; the effect of one
    assignment cannot affect the result of another assignment.

    The time at which this expression is evaluated is determined by Event's
    'useValuesFromTriggerTime' attribute.  If the attribute value is @c true
    (the default), the expression must be evaluated when the event is
    <em>fired</em>; more precisely, the values of identifiers occurring in
    MathML @c ci attributes in the EventAssignment's 'math' expression are
    the values they have at the point when the event <em>fired</em>.  If,
    instead, 'useValuesFromTriggerTime''s value is @c false, it means the
    values at <em>execution</em> time should be used; that is, the values of
    identifiers occurring in MathML @c ci attributes in the
    EventAssignment's 'math' expression are the values they have at the
    point when the event <em>executed</em>.

    Between Version&nbsp;4 and previous versions of SBML Level&nbsp;2, the
    requirements regarding the matching of units between an
    EvengAssignment's formula and the units of the object identified by the
    'variable' attribute changed.  Previous versions required consistency,
    but in Version&nbsp;4, unit consistency is only recommended.  More
    precisely: <ul> <li> In the case of a species, an EventAssignment sets
    the referenced species' quantity (concentration or amount of substance)
    to the value determined by the formula in the EventAssignment's 'math'
    subelement.  The units of the 'math' formula should (in SBML
    Level&nbsp;2 Version&nbsp;4) or must (in previous Versions) be identical
    to the units of the species.

    <li> In the case of a compartment, an EventAssignment sets the
    referenced compartment's size to the size determined by the formula in
    the 'math' subelement of the EventAssignment.  The overall units of the
    formula should (in SBML Level&nbsp;2 Version&nbsp;4) or must (in
    previous Versions) be identical to the units specified for the size of
    the compartment identified by the EventAssignment's 'variable'
    attribute.

    <li> In the case of a parameter, an EventAssignment sets the referenced
    parameter's value to that determined by the formula in 'math'.  The
    overall units of the formula should (in SBML Level&nbsp;2
    Version&nbsp;4) or must (in previous Versions) be identical to the units
    defined for the parameter.
    </ul>

    Note that the formula placed in the 'math' element <em>has no assumed
    units</em>.  The consistency of the units of the formula, and the units
    of the entity which the assignment affects, must be explicitly
    established just as in the case of the value of the Delay subelement.
    An approach similar to the one discussed in the context of Delay may be
    used for the formula of an EventAssignment.

    @section event-semantics Semantics of Event and EventAssignment

    Readers are urged to consult the SBML specification for important
    information about the interpretation of Event and EventAssignment.



    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventAssignment, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventAssignment, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_EventAssignment
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> EventAssignment
        __init__(self, SBMLNamespaces sbmlns) -> EventAssignment
        __init__(self, EventAssignment orig) -> EventAssignment

        Predicate returning @c true if
        all the required elements for this EventAssignment object
        have been set.

        @note The required elements for a EventAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_EventAssignment(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> EventAssignment

        Creates and returns a deep copy of this EventAssignment.

        @return a (deep) copy of this EventAssignment.
          

        """
        return _libsbml.EventAssignment_clone(self)

    def getVariable(self):
        """
        getVariable(self) -> string

        Get the value of this EventAssignment's 'variable' attribute.

        @return the identifier stored in the 'variable' attribute of this
        EventAssignment.
          

        """
        return _libsbml.EventAssignment_getVariable(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical expression in this EventAssignment's 'math'
        subelement.

        @return the top ASTNode of an abstract syntax tree representing the
        mathematical formula in this EventAssignment.
          

        """
        return _libsbml.EventAssignment_getMath(self)

    def isSetVariable(self):
        """
        isSetVariable(self) -> bool

        Predicate for testing whether the attribute 'variable' of this
        EventAssignment has been set.

        @return @c true if the 'variable' attribute of this EventAssignment
        has been set, @c false otherwise.
          

        """
        return _libsbml.EventAssignment_isSetVariable(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate for testing whether the 'math' subelement of this
        EventAssignment has been set.

        @return @c true if this EventAssignment has a 'math' subelement,
        @c false otherwise.
          

        """
        return _libsbml.EventAssignment_isSetMath(self)

    def setVariable(self, *args):
        """
        setVariable(self, string sid) -> int

        Sets the attribute 'variable' of this EventAssignment to a copy of
        the given identifier string.

        @param sid the identifier of a Compartment, Species or (global)
        Parameter defined in this model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.EventAssignment_setVariable(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this EventAssignment to a copy of the
        given ASTNode.

        @param math an ASTNode that will be copied and stored as the
        mathematical formula for this EventAssignment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.EventAssignment_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units
        of measurement assumed for the 'math' expression of this
        EventAssignment.

        The units are calculated based on the mathematical expression in the
        EventAssignment and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The
        EventAssignment::getDerivedUnitDefinition() method returns the
        calculated units.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c NULL.

        @warning Note that it is possible the 'math' expression in the
        EventAssignment contains literal numbers or parameters with undeclared
        units.  In those cases, it is not possible to calculate the units of
        the overall expression without making assumptions.  LibSBML does not
        make assumptions about the units, and
        EventAssignment::getDerivedUnitDefinition() only returns the units as
        far as it is able to determine them.  For example, in an expression
        <em>X + Y</em>, if <em>X</em> has unambiguously-defined units and
        <em>Y</em> does not, it will return the units of <em>X</em>.  When
        using this method, <strong>it is critical that callers also invoke the
        method</strong> EventAssignment::containsUndeclaredUnits() <strong>to
        determine whether this situation holds</strong>.  Callers should take
        suitable action in those situations.

        @return a UnitDefinition that expresses the units of the math 
        expression of this EventAssignment, or @c NULL if one cannot be constructed.

        @see containsUndeclaredUnits()
          

        """
        return _libsbml.EventAssignment_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c true if the math
        expression of this EventAssignment contains literal numbers or
        parameters with undeclared units.

        The EventAssignment::getDerivedUnitDefinition() method returns what
        libSBML computes to be the units of the 'math', to the extent that
        libSBML can compute them.  However, if the expression contains literal
        numbers or parameters with undeclared units, libSBML may not be able
        to compute the full units of the expression and will only return what
        it can compute.  Callers should always use
        EventAssignment::containsUndeclaredUnits() when using
        EventAssignment::getDerivedUnitDefinition() to decide whether the
        returned units may be incomplete.

        @return @c true if the math expression of this EventAssignment
        includes parameters/numbers 
        with undeclared units, @c false otherwise.

        @note A return value of @c true indicates that the UnitDefinition
        returned by EventAssignment::getDerivedUnitDefinition() may not
        accurately represent the units of the expression.

        @see getDerivedUnitDefinition()
          

        """
        return _libsbml.EventAssignment_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code of this object instance.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.EventAssignment_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        EventAssignment, is always @c 'eventAssignment'.

        @return the name of this element, i.e., @c 'eventAssignment'. 
          

        """
        return _libsbml.EventAssignment_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c true if
        all the required attributes for this EventAssignment object
        have been set.

        @note The required attributes for a EventAssignment object are:
        @li 'variable'

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.
          

        """
        return _libsbml.EventAssignment_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this EventAssignment object
        have been set.

        @note The required elements for a EventAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.EventAssignment_hasRequiredElements(self)

    def getId(self):
        """
        getId(self) -> string

        Predicate returning @c true if
        all the required elements for this EventAssignment object
        have been set.

        @note The required elements for a EventAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        return _libsbml.EventAssignment_getId(self)

EventAssignment_swigregister = _libsbml.EventAssignment_swigregister
EventAssignment_swigregister(EventAssignment)

class ListOfEventAssignments(ListOf):
    """
    LibSBML implementation of SBML's %ListOfEventAssignments construct.

    The various ListOf___ classes in %SBML are merely containers used for
    organizing the main components of an %SBML model.  All are derived from
    the abstract class SBase, and inherit the various attributes and
    subelements of SBase, such as 'metaid' as and 'annotation'.  The
    ListOf___ classes do not add any attributes of their own.

    ListOfEventAssignments is entirely contained within Event.

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfEventAssignments, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfEventAssignments, name)
    __repr__ = _swig_repr
    def clone(self):
        """
        clone(self) -> ListOfEventAssignments

        Creates and returns a deep copy of this ListOfEventAssignments.

        @return a (deep) copy of this ListOfEventAssignments.
          

        """
        return _libsbml.ListOfEventAssignments_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for this %SBML object.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfEventAssignments_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., EventAssignment objects, if the list is non-empty).

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for the objects contained in this ListOf
        instance, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.ListOfEventAssignments_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfEventAssignments, the XML element name is @c
        'listOfEventAssignments'.

        @return the name of this element, i.e., @c 'listOfEventAssignments'.
          

        """
        return _libsbml.ListOfEventAssignments_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> EventAssignment
        get(self, unsigned int n) -> EventAssignment
        get(self, string sid) -> EventAssignment
        get(self, string sid) -> EventAssignment

        Get a EventAssignment from the ListOfEventAssignments
        based on its identifier.

        @param sid a string representing the identifier 
        of the EventAssignment to get.

        @return EventAssignment in this ListOfEventAssignments
        with the given id or @c NULL if no such
        EventAssignment exists.

        @see get(unsigned int n)
        @see size()
          

        """
        return _libsbml.ListOfEventAssignments_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> EventAssignment
        remove(self, string sid) -> EventAssignment

        Removes item in this ListOfEventAssignments items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        NULL is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.
          

        """
        return _libsbml.ListOfEventAssignments_remove(self, *args)

    def __init__(self): 
        """__init__(self) -> ListOfEventAssignments"""
        this = _libsbml.new_ListOfEventAssignments()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ListOfEventAssignments
    __del__ = lambda self : None;
ListOfEventAssignments_swigregister = _libsbml.ListOfEventAssignments_swigregister
ListOfEventAssignments_swigregister(ListOfEventAssignments)

class Trigger(SBase):
    """
    LibSBML implementation of %SBML's %Trigger construct for %Event.

    An Event object defines when the event can occur, the variables that
    are affected by the event, and how the variables are affected.  The
    Trigger construct in SBML is used to define a mathematical expression
    that determines when an Event @em fires.

    A Trigger contains one subelement named 'math' containing a MathML
    expression.  The expression must evaluate to a value of type @c boolean.
    The exact moment at which the expression evaluates to @c true is the
    time point when the Event is @em fired.

    An event only fires when its Trigger expression makes the transition in
    value from @c false to @c true.  The event will also fire at any future
    time points when the trigger expression makes this transition; in other
    words, an event can fire multiple times during a simulation if its
    trigger condition makes the transition from @c false to @c true more
    than once.

    An important question is whether an event can fire prior to, or at,
    initial simulation time, that is <em>t &lt; 0</em>.  The answer is no:
    an event can only be triggered immediately after initial simulation time
    i.e., <em>t &gt; 0</em>.

    @see Event
    @see Delay
    @see EventAssignment

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trigger, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Trigger, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Trigger
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Trigger
        __init__(self, SBMLNamespaces sbmlns) -> Trigger
        __init__(self, Trigger orig) -> Trigger

        Predicate returning @c true if
        all the required elements for this Trigger object
        have been set.

        @note The required elements for a Trigger object are:
        math

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Trigger(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Trigger

        Creates and returns a deep copy of this Trigger.

        @return a (deep) copy of this Trigger.
          

        """
        return _libsbml.Trigger_clone(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula for the trigger and return it
        as an AST.

        @return the math of this Trigger.
          

        """
        return _libsbml.Trigger_getMath(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate to test whether the math for this trigger has been set.

        @return @c true if the formula (meaning the 'math' subelement) of
        this Trigger has been set, @c false otherwise.
          

        """
        return _libsbml.Trigger_isSetMath(self)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the trigger expression of this Trigger instance to a copy of the given
        ASTNode.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink!
          

        """
        return _libsbml.Trigger_setMath(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code of this object instance.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Trigger_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Trigger, is
        always @c 'trigger'.

        @return the name of this element, i.e., @c 'trigger'. 
          

        """
        return _libsbml.Trigger_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this Trigger object
        have been set.

        @note The required elements for a Trigger object are:
        math

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.Trigger_hasRequiredElements(self)

Trigger_swigregister = _libsbml.Trigger_swigregister
Trigger_swigregister(Trigger)

class Delay(SBase):
    """
    LibSBML implementation of %SBML's %Delay construct for %Event.

    An Event object defines when the event can occur, the variables that
    are affected by the event, and how the variables are affected.  The
    effect of the event can optionally be delayed after the occurrence of
    the condition which invokes it.  An event delay is defined using an
    object of class Delay.

    The object class Delay is derived from SBase and adds a single
    subelement called 'math'.  This subelement is used to hold MathML
    content.  The mathematical formula represented by 'math' must evaluate
    to a numerical value.  It is used as the length of time between when the
    event has @em fired and when the event's assignments are actually @em
    executed.  If no delay is present on a given Event, a time delay of zero
    is assumed.

    The expression in 'math' must be evaluated at the time the rule is @em
    fired.  The expression must always evaluate to a positive number
    (otherwise, a nonsensical situation could arise where an event is
    defined to fire before it is triggered!).

    @section delay-units The units of the mathematical expression in a Delay

    In SBML Level&nbsp;2 versions before Version&nbsp;4, the units of the
    numerical value computed by the Delay's 'math' expression were @em
    required to be in units of time or the model is considered to have a
    unit consistency error.  In Version&nbsp;4, this requirement is relaxed.
    The Version&nbsp;4 specification only stipulates that the units of the
    numerical value computed by a Delay instance's 'math' expression @em
    should match the model's units of time (meaning the definition of the @c
    time units in the model).  Depending on which Version of SBML
    Level&nbsp;2 is in use, libSBML may or may not flag unit inconsistencies
    as errors or just warnings. 

    Note that <em>units are not predefined or assumed</em> for the contents
    of 'math' in a Delay object; rather, they must be defined explicitly for
    each instance of a Delay object in a model.  This is an important point
    to bear in mind when literal numbers are used in delay expressions.  For
    example, the following Event instance would result in a warning logged
    by SBMLDocument::checkConsistency() about the fact that libSBML cannot
    verify the consistency of the units of the expression.  The reason is
    that the formula inside the 'math' element does not have any declared
    units, whereas what is expected in this context is units of time:
    @code
    <model>
        ...
        <listOfEvents>
            <event>
                ...
                <delay>
                    <math xmlns='http://www.w3.org/1998/Math/MathML'>
                        <cn> 1 </cn>
                    </math>
                </delay>
                ...
            </event>
        </listOfEvents>
        ...
    </model>
    @endcode

    The <code>&lt;cn&gt; 1 &lt;/cn&gt;</code> within the mathematical formula
    of the @c delay above has <em>no units declared</em>.  To make the
    expression have the needed units of time, literal numbers should be
    avoided in favor of defining Parameter objects for each quantity, and
    declaring units for the Parameter values.  The following fragment of
    SBML illustrates this approach:
    @code
    <model>
        ...
        <listOfParameters>
            <parameter id='transcriptionDelay' value='10' units='time'/>
        </listOfParameters>
        ...
        <listOfEvents>
            <event>
                ...
                <delay>
                    <math xmlns='http://www.w3.org/1998/Math/MathML'>
                        <ci> transcriptionDelay </ci>
                    </math>
                </delay>
                ...
            </event>
        </listOfEvents>
        ...
    </model>
    @endcode

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Delay, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Delay, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Delay
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Delay
        __init__(self, SBMLNamespaces sbmlns) -> Delay
        __init__(self, Delay orig) -> Delay

        Predicate returning @c true if
        all the required elements for this Delay object
        have been set.

        @note The required elements for a Delay object are:
        math

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_Delay(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Delay

        Creates and returns a deep copy of this Delay.

        @return a (deep) copy of this Delay.
          

        """
        return _libsbml.Delay_clone(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula for the delay and return it
        as an AST.

        @return the math of this Delay.
          

        """
        return _libsbml.Delay_getMath(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate to test whether the formula for this delay has been set.

        @return @c true if the formula (meaning the @c math subelement) of
        this Delay has been set, @c false otherwise.
          

        """
        return _libsbml.Delay_isSetMath(self)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the delay expression of this Delay instance to a copy of the given
        ASTNode.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t.  @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.Delay_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units
        of measurement assumed for the 'math' expression of this Delay.

        Delay elements in SBML express a time delay for an Event.  Beginning
        with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are
        calculated based on the mathematical expression and the model
        quantities referenced by <code>&lt;ci&gt;</code> elements used within
        that expression.  The Delay::getDerivedUnitDefinition() method returns
        what libSBML computes the units to be, to the extent that libSBML can
        compute them.

        (Prior to SBML Level&nbsp;2 Version&nbsp;2, there existed an attribute
        on Event called 'timeUnits'.  This attribute could be used to set the
        intended units of the delay expression.  For such models, this will
        return a UnitDefinition object that corresponds to the declared
        'timeUnits' units.)

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c NULL.

        @warning Note that it is possible the 'math' expression in the Delay
        contains literal numbers or parameters with undeclared units.  In
        those cases, it is not possible to calculate the units of the overall
        expression without making assumptions.  LibSBML does not make
        assumptions about the units, and Delay::getDerivedUnitDefinition()
        only returns the units as far as it is able to determine them.  For
        example, in an expression <em>X + Y</em>, if <em>X</em> has
        unambiguously-defined units and <em>Y</em> does not, it will return
        the units of <em>X</em>.  When using this method, <strong>it is
        critical that callers also invoke the method</strong>
        Delay::containsUndeclaredUnits() <strong>to determine whether this
        situation holds</strong>.  Callers should take suitable action in
        those situations.

        @return a UnitDefinition that expresses the units of the math 
        expression of this Delay, or @c NULL if one cannot be constructed.

        @see containsUndeclaredUnits()
          

        """
        return _libsbml.Delay_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c true if 
        the 'math' expression in this Delay instance contains
        parameters with undeclared units or literal numbers.

        Delay elements in SBML express a time delay for an Event.  Beginning
        with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are
        calculated based on the mathematical expression and the model
        quantities referenced by <code>&lt;ci&gt;</code> elements used within
        that expression.  The Delay::getDerivedUnitDefinition() method returns
        what libSBML computes the units to be, to the extent that libSBML can
        compute them.  However, if the expression contains literal numbers or
        parameters with undeclared units, libSBML may not be able to compute
        the full units of the expression and will only return what it can
        compute.  Callers should always use Delay::containsUndeclaredUnits()
        when using Delay::getDerivedUnitDefinition() to decide whether the
        returned units may be incomplete.

        @return @c true if the math expression of this Delay includes
        numbers/parameters with undeclared units, @c false otherwise.

        @note A return value of @c true indicates that the UnitDefinition
        returned by Delay::getDerivedUnitDefinition() may not accurately
        represent the units of the expression.

        @see getDerivedUnitDefinition()
          

        """
        return _libsbml.Delay_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code of this object instance.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.Delay_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Delay, is
        always @c 'delay'.

        @return the name of this element, i.e., @c 'delay'.

        @see getTypeCode()
          

        """
        return _libsbml.Delay_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this Delay object
        have been set.

        @note The required elements for a Delay object are:
        math

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.Delay_hasRequiredElements(self)

Delay_swigregister = _libsbml.Delay_swigregister
Delay_swigregister(Delay)

class SBO(_object):
    """
    Methods for interacting with Systems Biology Ontology (%SBO) terms.

    @htmlinclude not-sbml-warning.html


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBO, name)
    __repr__ = _swig_repr
    def isQuantitativeParameter(*args):
        """
        isQuantitativeParameter(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a QuantitativeParameter, false otherwise
          

        """
        return _libsbml.SBO_isQuantitativeParameter(*args)

    if _newclass:isQuantitativeParameter = staticmethod(isQuantitativeParameter)
    __swig_getmethods__["isQuantitativeParameter"] = lambda x: isQuantitativeParameter
    def isParticipantRole(*args):
        """
        isParticipantRole(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a ParticipantRole, false otherwise
          

        """
        return _libsbml.SBO_isParticipantRole(*args)

    if _newclass:isParticipantRole = staticmethod(isParticipantRole)
    __swig_getmethods__["isParticipantRole"] = lambda x: isParticipantRole
    def isModellingFramework(*args):
        """
        isModellingFramework(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a ModellingFramework, false otherwise
          

        """
        return _libsbml.SBO_isModellingFramework(*args)

    if _newclass:isModellingFramework = staticmethod(isModellingFramework)
    __swig_getmethods__["isModellingFramework"] = lambda x: isModellingFramework
    def isMathematicalExpression(*args):
        """
        isMathematicalExpression(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a MathematicalExpression, false otherwise
          

        """
        return _libsbml.SBO_isMathematicalExpression(*args)

    if _newclass:isMathematicalExpression = staticmethod(isMathematicalExpression)
    __swig_getmethods__["isMathematicalExpression"] = lambda x: isMathematicalExpression
    def isKineticConstant(*args):
        """
        isKineticConstant(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a KineticConstant, false otherwise
          

        """
        return _libsbml.SBO_isKineticConstant(*args)

    if _newclass:isKineticConstant = staticmethod(isKineticConstant)
    __swig_getmethods__["isKineticConstant"] = lambda x: isKineticConstant
    def isReactant(*args):
        """
        isReactant(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a Reactant, false otherwise
          

        """
        return _libsbml.SBO_isReactant(*args)

    if _newclass:isReactant = staticmethod(isReactant)
    __swig_getmethods__["isReactant"] = lambda x: isReactant
    def isProduct(*args):
        """
        isProduct(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a Product, false otherwise
          

        """
        return _libsbml.SBO_isProduct(*args)

    if _newclass:isProduct = staticmethod(isProduct)
    __swig_getmethods__["isProduct"] = lambda x: isProduct
    def isModifier(*args):
        """
        isModifier(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a Modifier, false otherwise
          

        """
        return _libsbml.SBO_isModifier(*args)

    if _newclass:isModifier = staticmethod(isModifier)
    __swig_getmethods__["isModifier"] = lambda x: isModifier
    def isRateLaw(*args):
        """
        isRateLaw(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a RateLaw, false otherwise
          

        """
        return _libsbml.SBO_isRateLaw(*args)

    if _newclass:isRateLaw = staticmethod(isRateLaw)
    __swig_getmethods__["isRateLaw"] = lambda x: isRateLaw
    def isEvent(*args):
        """
        isEvent(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a Event, false otherwise
          

        """
        return _libsbml.SBO_isEvent(*args)

    if _newclass:isEvent = staticmethod(isEvent)
    __swig_getmethods__["isEvent"] = lambda x: isEvent
    def isPhysicalParticipant(*args):
        """
        isPhysicalParticipant(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a PhysicalParticipant, false otherwise
           

        """
        return _libsbml.SBO_isPhysicalParticipant(*args)

    if _newclass:isPhysicalParticipant = staticmethod(isPhysicalParticipant)
    __swig_getmethods__["isPhysicalParticipant"] = lambda x: isPhysicalParticipant
    def isParticipant(*args):
        """
        isParticipant(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a Participant, false otherwise
           

        """
        return _libsbml.SBO_isParticipant(*args)

    if _newclass:isParticipant = staticmethod(isParticipant)
    __swig_getmethods__["isParticipant"] = lambda x: isParticipant
    def isInteraction(*args):
        """
        isInteraction(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a Interaction, false otherwise
          

        """
        return _libsbml.SBO_isInteraction(*args)

    if _newclass:isInteraction = staticmethod(isInteraction)
    __swig_getmethods__["isInteraction"] = lambda x: isInteraction
    def isEntity(*args):
        """
        isEntity(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a Entity, false otherwise
          

        """
        return _libsbml.SBO_isEntity(*args)

    if _newclass:isEntity = staticmethod(isEntity)
    __swig_getmethods__["isEntity"] = lambda x: isEntity
    def isFunctionalEntity(*args):
        """
        isFunctionalEntity(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a FunctionalEntity, false otherwise
          

        """
        return _libsbml.SBO_isFunctionalEntity(*args)

    if _newclass:isFunctionalEntity = staticmethod(isFunctionalEntity)
    __swig_getmethods__["isFunctionalEntity"] = lambda x: isFunctionalEntity
    def isMaterialEntity(*args):
        """
        isMaterialEntity(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a MaterialEntity, false otherwise
          

        """
        return _libsbml.SBO_isMaterialEntity(*args)

    if _newclass:isMaterialEntity = staticmethod(isMaterialEntity)
    __swig_getmethods__["isMaterialEntity"] = lambda x: isMaterialEntity
    def isConservationLaw(*args):
        """
        isConservationLaw(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a ConservationLaw, false otherwise
          

        """
        return _libsbml.SBO_isConservationLaw(*args)

    if _newclass:isConservationLaw = staticmethod(isConservationLaw)
    __swig_getmethods__["isConservationLaw"] = lambda x: isConservationLaw
    def isSteadyStateExpression(*args):
        """
        isSteadyStateExpression(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a SteadyStateExpression, false otherwise
          

        """
        return _libsbml.SBO_isSteadyStateExpression(*args)

    if _newclass:isSteadyStateExpression = staticmethod(isSteadyStateExpression)
    __swig_getmethods__["isSteadyStateExpression"] = lambda x: isSteadyStateExpression
    def isFunctionalCompartment(*args):
        """
        isFunctionalCompartment(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a FunctionalCompartment, false otherwise
          

        """
        return _libsbml.SBO_isFunctionalCompartment(*args)

    if _newclass:isFunctionalCompartment = staticmethod(isFunctionalCompartment)
    __swig_getmethods__["isFunctionalCompartment"] = lambda x: isFunctionalCompartment
    def isContinuousFramework(*args):
        """
        isContinuousFramework(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a ContinuousFramework, false otherwise
          

        """
        return _libsbml.SBO_isContinuousFramework(*args)

    if _newclass:isContinuousFramework = staticmethod(isContinuousFramework)
    __swig_getmethods__["isContinuousFramework"] = lambda x: isContinuousFramework
    def isDiscreteFramework(*args):
        """
        isDiscreteFramework(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a DiscreteFramework, false otherwise
          

        """
        return _libsbml.SBO_isDiscreteFramework(*args)

    if _newclass:isDiscreteFramework = staticmethod(isDiscreteFramework)
    __swig_getmethods__["isDiscreteFramework"] = lambda x: isDiscreteFramework
    def isLogicalFramework(*args):
        """
        isLogicalFramework(unsigned int term) -> bool

        Function for checking the SBO term is from correct part of SBO.

        @return true if the term is-a LogicalFramework, false otherwise
          

        """
        return _libsbml.SBO_isLogicalFramework(*args)

    if _newclass:isLogicalFramework = staticmethod(isLogicalFramework)
    __swig_getmethods__["isLogicalFramework"] = lambda x: isLogicalFramework
    def isObselete(*args):
        """
        isObselete(unsigned int term) -> bool

        Function for checking whether the SBO term is obselete.

        @return true if the term is-a Obsolete, false otherwise
          

        """
        return _libsbml.SBO_isObselete(*args)

    if _newclass:isObselete = staticmethod(isObselete)
    __swig_getmethods__["isObselete"] = lambda x: isObselete
    def intToString(*args):
        """
        intToString(int sboTerm) -> string

        Returns the integer as a correctly formatted SBO string.

        @return the given integer sboTerm as a zero-padded seven digit string.

        @note If the sboTerm is not in the correct range ([0 -- 9999999]), an empty
        string is returned.
          

        """
        return _libsbml.SBO_intToString(*args)

    if _newclass:intToString = staticmethod(intToString)
    __swig_getmethods__["intToString"] = lambda x: intToString
    def stringToInt(*args):
        """
        stringToInt(string sboTerm) -> int

        Returns the string as a correctly formatted SBO integer portion.

        @return the given string sboTerm as an integer.  If the sboTerm is not
        in the correct format (a zero-padded, seven digit string), -1 is
        returned.
          

        """
        return _libsbml.SBO_stringToInt(*args)

    if _newclass:stringToInt = staticmethod(stringToInt)
    __swig_getmethods__["stringToInt"] = lambda x: stringToInt
    def checkTerm(*args):
        """
        checkTerm(string sboTerm) -> bool
        checkTerm(int sboTerm) -> bool

        Checks the format of the given SBO integer portion.

        @return true if sboTerm is in the range [0 -- 9999999], false
        otherwise.
          

        """
        return _libsbml.SBO_checkTerm(*args)

    if _newclass:checkTerm = staticmethod(checkTerm)
    __swig_getmethods__["checkTerm"] = lambda x: checkTerm
    def __init__(self): 
        """__init__(self) -> SBO"""
        this = _libsbml.new_SBO()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBO
    __del__ = lambda self : None;
SBO_swigregister = _libsbml.SBO_swigregister
SBO_swigregister(SBO)

def SBO_isQuantitativeParameter(*args):
  """
    SBO_isQuantitativeParameter(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a QuantitativeParameter, false otherwise
      

    """
  return _libsbml.SBO_isQuantitativeParameter(*args)

def SBO_isParticipantRole(*args):
  """
    SBO_isParticipantRole(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a ParticipantRole, false otherwise
      

    """
  return _libsbml.SBO_isParticipantRole(*args)

def SBO_isModellingFramework(*args):
  """
    SBO_isModellingFramework(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a ModellingFramework, false otherwise
      

    """
  return _libsbml.SBO_isModellingFramework(*args)

def SBO_isMathematicalExpression(*args):
  """
    SBO_isMathematicalExpression(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a MathematicalExpression, false otherwise
      

    """
  return _libsbml.SBO_isMathematicalExpression(*args)

def SBO_isKineticConstant(*args):
  """
    SBO_isKineticConstant(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a KineticConstant, false otherwise
      

    """
  return _libsbml.SBO_isKineticConstant(*args)

def SBO_isReactant(*args):
  """
    SBO_isReactant(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a Reactant, false otherwise
      

    """
  return _libsbml.SBO_isReactant(*args)

def SBO_isProduct(*args):
  """
    SBO_isProduct(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a Product, false otherwise
      

    """
  return _libsbml.SBO_isProduct(*args)

def SBO_isModifier(*args):
  """
    SBO_isModifier(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a Modifier, false otherwise
      

    """
  return _libsbml.SBO_isModifier(*args)

def SBO_isRateLaw(*args):
  """
    SBO_isRateLaw(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a RateLaw, false otherwise
      

    """
  return _libsbml.SBO_isRateLaw(*args)

def SBO_isEvent(*args):
  """
    SBO_isEvent(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a Event, false otherwise
      

    """
  return _libsbml.SBO_isEvent(*args)

def SBO_isPhysicalParticipant(*args):
  """
    SBO_isPhysicalParticipant(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a PhysicalParticipant, false otherwise
       

    """
  return _libsbml.SBO_isPhysicalParticipant(*args)

def SBO_isParticipant(*args):
  """
    SBO_isParticipant(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a Participant, false otherwise
       

    """
  return _libsbml.SBO_isParticipant(*args)

def SBO_isInteraction(*args):
  """
    SBO_isInteraction(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a Interaction, false otherwise
      

    """
  return _libsbml.SBO_isInteraction(*args)

def SBO_isEntity(*args):
  """
    SBO_isEntity(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a Entity, false otherwise
      

    """
  return _libsbml.SBO_isEntity(*args)

def SBO_isFunctionalEntity(*args):
  """
    SBO_isFunctionalEntity(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a FunctionalEntity, false otherwise
      

    """
  return _libsbml.SBO_isFunctionalEntity(*args)

def SBO_isMaterialEntity(*args):
  """
    SBO_isMaterialEntity(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a MaterialEntity, false otherwise
      

    """
  return _libsbml.SBO_isMaterialEntity(*args)

def SBO_isConservationLaw(*args):
  """
    SBO_isConservationLaw(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a ConservationLaw, false otherwise
      

    """
  return _libsbml.SBO_isConservationLaw(*args)

def SBO_isSteadyStateExpression(*args):
  """
    SBO_isSteadyStateExpression(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a SteadyStateExpression, false otherwise
      

    """
  return _libsbml.SBO_isSteadyStateExpression(*args)

def SBO_isFunctionalCompartment(*args):
  """
    SBO_isFunctionalCompartment(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a FunctionalCompartment, false otherwise
      

    """
  return _libsbml.SBO_isFunctionalCompartment(*args)

def SBO_isContinuousFramework(*args):
  """
    SBO_isContinuousFramework(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a ContinuousFramework, false otherwise
      

    """
  return _libsbml.SBO_isContinuousFramework(*args)

def SBO_isDiscreteFramework(*args):
  """
    SBO_isDiscreteFramework(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a DiscreteFramework, false otherwise
      

    """
  return _libsbml.SBO_isDiscreteFramework(*args)

def SBO_isLogicalFramework(*args):
  """
    SBO_isLogicalFramework(unsigned int term) -> bool

    Function for checking the SBO term is from correct part of SBO.

    @return true if the term is-a LogicalFramework, false otherwise
      

    """
  return _libsbml.SBO_isLogicalFramework(*args)

def SBO_isObselete(*args):
  """
    SBO_isObselete(unsigned int term) -> bool

    Function for checking whether the SBO term is obselete.

    @return true if the term is-a Obsolete, false otherwise
      

    """
  return _libsbml.SBO_isObselete(*args)

def SBO_intToString(*args):
  """
    SBO_intToString(int sboTerm) -> string

    Returns the integer as a correctly formatted SBO string.

    @return the given integer sboTerm as a zero-padded seven digit string.

    @note If the sboTerm is not in the correct range ([0 -- 9999999]), an empty
    string is returned.
      

    """
  return _libsbml.SBO_intToString(*args)

def SBO_stringToInt(*args):
  """
    SBO_stringToInt(string sboTerm) -> int

    Returns the string as a correctly formatted SBO integer portion.

    @return the given string sboTerm as an integer.  If the sboTerm is not
    in the correct format (a zero-padded, seven digit string), -1 is
    returned.
      

    """
  return _libsbml.SBO_stringToInt(*args)

def SBO_checkTerm(*args):
  """
    checkTerm(string sboTerm) -> bool
    SBO_checkTerm(int sboTerm) -> bool

    Checks the format of the given SBO integer portion.

    @return true if sboTerm is in the range [0 -- 9999999], false
    otherwise.
      

    """
  return _libsbml.SBO_checkTerm(*args)

class SyntaxChecker(_object):
    """
    Methods for checking syntax of SBML identifiers and other strings.

    @htmlinclude not-sbml-warning.html

    This utility class provides static methods for checking the syntax of
    identifiers and other text used in an SBML model.  The methods allow
    callers to verify that strings such as SBML identifiers and XHTML notes
    text conform to the SBML specifications.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SyntaxChecker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SyntaxChecker, name)
    __repr__ = _swig_repr
    def isValidSBMLSId(*args):
        """
        isValidSBMLSId(string sid) -> bool

        Returns true @c true or @c false depending on whether the argument
        string conforms to the syntax of SBML identifiers.

        In SBML, identifiers that are the values of <code>id</code> attributes
        on objects must conform to a data type called <code>SId</code> in the
        SBML specifications.  LibSBML does not provide an explicit
        <code>SId</code> data type; instead, it tests for identifier validity
        at various times, such as when reading in models from files and data
        streams.  To enable calling programs to test that the identifiers they
        generate also conform to the SBML identifier syntax, libSBML provides
        this method.

        @param sid string to be checked for conformance to SBML identifier
        syntax.

        @return @c true if the string conforms to type SBML data type
        <code>SId</code>, @c false otherwise.

        @note @htmlinclude id-syntax.html

        @see isValidUnitSId(std::string sid)
        @see isValidXMLID(std::string sid)
            

        """
        return _libsbml.SyntaxChecker_isValidSBMLSId(*args)

    if _newclass:isValidSBMLSId = staticmethod(isValidSBMLSId)
    __swig_getmethods__["isValidSBMLSId"] = lambda x: isValidSBMLSId
    def isValidXMLID(*args):
        """
        isValidXMLID(string id) -> bool

        Returns @c true or @c false depending on whether the argument string
        conforms to the XML data type <code>ID</code>.

        In SBML, identifiers that are the values of <code>metaid</code>
        attributes on objects must conform to the <a target='_blank' 
        href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a> data type.  LibSBML
        does not provide an explicit XML <code>ID</code> data type; instead,
        it tests for identifier validity at various times, such as when
        reading in models from files and data streams.  To enable calling
        programs to test that the identifiers they generate also conform to
        the SBML identifier syntax, libSBML provides this method.

        @param id string to be checked for conformance to the syntax of
        <a target='_blank' href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.

        @return @c true if the string is a syntactically-valid value for the
        XML type <a target='_blank'
        href='http://www.w3.org/TR/REC-xml/#id'>ID</a>, @c false otherwise.

        @note @htmlinclude xmlid-syntax.html

        @see isValidSBMLSId(std::string sid)
        @see isValidUnitSId(std::string sid)
            

        """
        return _libsbml.SyntaxChecker_isValidXMLID(*args)

    if _newclass:isValidXMLID = staticmethod(isValidXMLID)
    __swig_getmethods__["isValidXMLID"] = lambda x: isValidXMLID
    def isValidUnitSId(*args):
        """
        isValidUnitSId(string units) -> bool

        Returns @c true or @c false depending on whether the argument string
        conforms to the syntax of SBML unit identifiers.

        In SBML, the identifiers of units (of both the predefined units and
        user-defined units) must conform to a data type called
        <code>UnitSId</code> in the SBML specifications.  LibSBML does not
        provide an explicit <code>UnitSId</code> data type; instead, it tests
        for identifier validity at various times, such as when reading in
        models from files and data streams.  To enable calling programs to
        test that the unit identifiers they generate also conform to the SBML
        identifier syntax, libSBML provides this method.

        @param units string to be checked for conformance to SBML unit
        identifier syntax.

        @return @c true if the string conforms to type SBML data type
        <code>UnitSId</code>, @c false otherwise.

        @note @htmlinclude unitid-syntax.html

        @see isValidSBMLSId(std::string sid)
        @see isValidXMLID(std::string sid)
          

        """
        return _libsbml.SyntaxChecker_isValidUnitSId(*args)

    if _newclass:isValidUnitSId = staticmethod(isValidUnitSId)
    __swig_getmethods__["isValidUnitSId"] = lambda x: isValidUnitSId
    def hasExpectedXHTMLSyntax(*args):
        """
        hasExpectedXHTMLSyntax(XMLNode xhtml, SBMLNamespaces sbmlns = None) -> bool
        hasExpectedXHTMLSyntax(XMLNode xhtml) -> bool

        Returns @c true or @c false depending on whether the given XMLNode
        object contains valid XHTML content.

        In SBML, the content of the 'notes' subelement available on SBase, as
        well as the 'message' subelement available on Constraint, must conform
        to <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a> (which is
        simply an XML-ized version of HTML).  However, the content cannot be
        @em entirely free-form; it must satisfy certain requirements defined in
        the <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML
        specifications</a> for specific SBML Levels.  This method implements a
        verification process that lets callers check whether the content of a
        given XMLNode object conforms to the SBML requirements for 'notes' and
        'message' structure.

        An aspect of XHTML validity is that the content is declared to be in
        the XML namespace for XHTML&nbsp;1.0.  There is more than one way in
        which this can be done in XML.  In particular, a model might not
        contain the declaration within the 'notes' or 'message' subelement
        itself, but might instead place the declaration on an enclosing
        element and use an XML namespace prefix within the 'notes' element to
        refer to it.  In other words, the following is valid:
          @verbatim
         <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'
               xmlns:xhtml='http://www.w3.org/1999/xhtml'>
           <model>
             <notes>
               <xhtml:body>
                 <xhtml:center><xhtml:h2>A Simple Mitotic Oscillator</xhtml:h2></xhtml:center>
                 <xhtml:p>A minimal cascade model for the mitotic oscillator.</xhtml:p>
               </xhtml:body>
             </notes>
           ... rest of model ...
         </sbml>
         @endverbatim
        Contrast the above with the following, self-contained version, which
        places the XML namespace declaration within the <code>&lt;notes&gt;</code>
        element itself:
          @verbatim
         <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'>
           <model>
             <notes>
               <html xmlns='http://www.w3.org/1999/xhtml'>
                 <head>
                   <title/>
                 </head>
                 <body>
                   <center><h2>A Simple Mitotic Oscillator</h2></center>
                   <p>A minimal cascade model for the mitotic oscillator.</p>
                 </body>
               </html>
             </notes>
           ... rest of model ...
         </sbml>
         @endverbatim

        Both of the above are valid XML.  The purpose of the @p sbmlns
        argument to this method is to allow callers to check the validity of
        'notes' and 'message' subelements whose XML namespace declarations
        have been put elsewhere in the manner illustrated above.  Callers can
        can pass in the SBMLNamespaces object of a higher-level model
        component if the XMLNode object does not itself have the XML namespace
        declaration for XHTML&nbsp;1.0.

        @param xhtml the XMLNode to be checked for conformance.
        @param sbmlns the SBMLNamespaces associated with the object.

        @return @c true if the XMLNode content conforms, @c false otherwise.

        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
          

        """
        return _libsbml.SyntaxChecker_hasExpectedXHTMLSyntax(*args)

    if _newclass:hasExpectedXHTMLSyntax = staticmethod(hasExpectedXHTMLSyntax)
    __swig_getmethods__["hasExpectedXHTMLSyntax"] = lambda x: hasExpectedXHTMLSyntax
    def __init__(self): 
        """__init__(self) -> SyntaxChecker"""
        this = _libsbml.new_SyntaxChecker()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SyntaxChecker
    __del__ = lambda self : None;
SyntaxChecker_swigregister = _libsbml.SyntaxChecker_swigregister
SyntaxChecker_swigregister(SyntaxChecker)

def SyntaxChecker_isValidSBMLSId(*args):
  """
    SyntaxChecker_isValidSBMLSId(string sid) -> bool

    Returns true @c true or @c false depending on whether the argument
    string conforms to the syntax of SBML identifiers.

    In SBML, identifiers that are the values of <code>id</code> attributes
    on objects must conform to a data type called <code>SId</code> in the
    SBML specifications.  LibSBML does not provide an explicit
    <code>SId</code> data type; instead, it tests for identifier validity
    at various times, such as when reading in models from files and data
    streams.  To enable calling programs to test that the identifiers they
    generate also conform to the SBML identifier syntax, libSBML provides
    this method.

    @param sid string to be checked for conformance to SBML identifier
    syntax.

    @return @c true if the string conforms to type SBML data type
    <code>SId</code>, @c false otherwise.

    @note @htmlinclude id-syntax.html

    @see isValidUnitSId(std::string sid)
    @see isValidXMLID(std::string sid)
        

    """
  return _libsbml.SyntaxChecker_isValidSBMLSId(*args)

def SyntaxChecker_isValidXMLID(*args):
  """
    SyntaxChecker_isValidXMLID(string id) -> bool

    Returns @c true or @c false depending on whether the argument string
    conforms to the XML data type <code>ID</code>.

    In SBML, identifiers that are the values of <code>metaid</code>
    attributes on objects must conform to the <a target='_blank' 
    href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a> data type.  LibSBML
    does not provide an explicit XML <code>ID</code> data type; instead,
    it tests for identifier validity at various times, such as when
    reading in models from files and data streams.  To enable calling
    programs to test that the identifiers they generate also conform to
    the SBML identifier syntax, libSBML provides this method.

    @param id string to be checked for conformance to the syntax of
    <a target='_blank' href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.

    @return @c true if the string is a syntactically-valid value for the
    XML type <a target='_blank'
    href='http://www.w3.org/TR/REC-xml/#id'>ID</a>, @c false otherwise.

    @note @htmlinclude xmlid-syntax.html

    @see isValidSBMLSId(std::string sid)
    @see isValidUnitSId(std::string sid)
        

    """
  return _libsbml.SyntaxChecker_isValidXMLID(*args)

def SyntaxChecker_isValidUnitSId(*args):
  """
    SyntaxChecker_isValidUnitSId(string units) -> bool

    Returns @c true or @c false depending on whether the argument string
    conforms to the syntax of SBML unit identifiers.

    In SBML, the identifiers of units (of both the predefined units and
    user-defined units) must conform to a data type called
    <code>UnitSId</code> in the SBML specifications.  LibSBML does not
    provide an explicit <code>UnitSId</code> data type; instead, it tests
    for identifier validity at various times, such as when reading in
    models from files and data streams.  To enable calling programs to
    test that the unit identifiers they generate also conform to the SBML
    identifier syntax, libSBML provides this method.

    @param units string to be checked for conformance to SBML unit
    identifier syntax.

    @return @c true if the string conforms to type SBML data type
    <code>UnitSId</code>, @c false otherwise.

    @note @htmlinclude unitid-syntax.html

    @see isValidSBMLSId(std::string sid)
    @see isValidXMLID(std::string sid)
      

    """
  return _libsbml.SyntaxChecker_isValidUnitSId(*args)

def SyntaxChecker_hasExpectedXHTMLSyntax(*args):
  """
    hasExpectedXHTMLSyntax(XMLNode xhtml, SBMLNamespaces sbmlns = None) -> bool
    SyntaxChecker_hasExpectedXHTMLSyntax(XMLNode xhtml) -> bool

    Returns @c true or @c false depending on whether the given XMLNode
    object contains valid XHTML content.

    In SBML, the content of the 'notes' subelement available on SBase, as
    well as the 'message' subelement available on Constraint, must conform
    to <a target='_blank'
    href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a> (which is
    simply an XML-ized version of HTML).  However, the content cannot be
    @em entirely free-form; it must satisfy certain requirements defined in
    the <a target='_blank'
    href='http://sbml.org/Documents/Specifications'>SBML
    specifications</a> for specific SBML Levels.  This method implements a
    verification process that lets callers check whether the content of a
    given XMLNode object conforms to the SBML requirements for 'notes' and
    'message' structure.

    An aspect of XHTML validity is that the content is declared to be in
    the XML namespace for XHTML&nbsp;1.0.  There is more than one way in
    which this can be done in XML.  In particular, a model might not
    contain the declaration within the 'notes' or 'message' subelement
    itself, but might instead place the declaration on an enclosing
    element and use an XML namespace prefix within the 'notes' element to
    refer to it.  In other words, the following is valid:
      @verbatim
     <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'
           xmlns:xhtml='http://www.w3.org/1999/xhtml'>
       <model>
         <notes>
           <xhtml:body>
             <xhtml:center><xhtml:h2>A Simple Mitotic Oscillator</xhtml:h2></xhtml:center>
             <xhtml:p>A minimal cascade model for the mitotic oscillator.</xhtml:p>
           </xhtml:body>
         </notes>
       ... rest of model ...
     </sbml>
     @endverbatim
    Contrast the above with the following, self-contained version, which
    places the XML namespace declaration within the <code>&lt;notes&gt;</code>
    element itself:
      @verbatim
     <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'>
       <model>
         <notes>
           <html xmlns='http://www.w3.org/1999/xhtml'>
             <head>
               <title/>
             </head>
             <body>
               <center><h2>A Simple Mitotic Oscillator</h2></center>
               <p>A minimal cascade model for the mitotic oscillator.</p>
             </body>
           </html>
         </notes>
       ... rest of model ...
     </sbml>
     @endverbatim

    Both of the above are valid XML.  The purpose of the @p sbmlns
    argument to this method is to allow callers to check the validity of
    'notes' and 'message' subelements whose XML namespace declarations
    have been put elsewhere in the manner illustrated above.  Callers can
    can pass in the SBMLNamespaces object of a higher-level model
    component if the XMLNode object does not itself have the XML namespace
    declaration for XHTML&nbsp;1.0.

    @param xhtml the XMLNode to be checked for conformance.
    @param sbmlns the SBMLNamespaces associated with the object.

    @return @c true if the XMLNode content conforms, @c false otherwise.

    @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
      

    """
  return _libsbml.SyntaxChecker_hasExpectedXHTMLSyntax(*args)

class StoichiometryMath(SBase):
    """
    LibSBML implementation of SBML Level&nbsp;2's %StoichiometryMath construct.

    @section l2-stoichiometries Stoichiometries in SBML Level 2

    In SBML Level 2, product and reactant stoichiometries can be specified
    using @em either the 'stoichiometry' attribute or a 'stoichiometryMath'
    element in a SpeciesReference object.  The 'stoichiometry' attribute is
    of type @c double and should contain values greater than zero (0).  The
    'stoichiometryMath' element is implemented as an element containing a
    MathML expression.  These two are mutually exclusive; only one of
    'stoichiometry' or 'stoichiometryMath' should be defined in a given
    SpeciesReference instance.  When neither the attribute nor the element
    is present, the value of 'stoichiometry' in the enclosing
    SpeciesReference instance defaults to @c 1.

    For maximum interoperability, SpeciesReference's 'stoichiometry'
    attribute should be used in preference to 'stoichiometryMath' when a
    species' stoichiometry is a simple scalar number (integer or decimal).
    When the stoichiometry is a rational number, or when it is a more
    complicated formula, 'stoichiometryMath' must be used.  The MathML
    expression in 'stoichiometryMath' may also refer to identifiers of
    entities in a model (except reaction identifiers).  However, the only
    species identifiers that can be used in 'stoichiometryMath' are those
    referenced in the enclosing Reaction's list of reactants, products and
    modifiers.

    The 'stoichiometry' attribute and the 'stoichiometryMath' element, when
    either is used, is each interpreted as a factor applied to the reaction
    rate to produce the rate of change of the species identified by the
    'species' attribute in the enclosing SpeciesReference.  This is the
    normal interpretation of a stoichiometry, but in SBML, one additional
    consideration has to be taken into account.  The reaction rate, which is
    the result of the KineticLaw's 'math' element, is always in the model's
    @em substance per @em time units.  However, the rate of change of the
    species will involve the species' @em substance units (i.e., the units
    identified by the Species object's 'substanceUnits' attribute), and
    these units may be different from the model's default @em substance
    units.  If the units @em are different, the stoichiometry must
    incorporate a conversion factor for converting the model's @em substance
    units to the species' @em substance units.  The conversion factor is
    assumed to be included in the scalar value of the 'stoichiometry'
    attribute if 'stoichiometry' is used.  If instead 'stoichiometryMath' is
    used, then the product of the model's 'substance' units times the
    'stoichiometryMath' units must match the @em substance units of the
    species.  Note that in either case, if the species' units and the
    model's default @em substance units are the same, the stoichiometry ends
    up being a dimensionless number and equivalent to the standard chemical
    stoichiometry found in textbooks.  Examples and more explanations of
    this are given in the SBML specification.

    The following is a simple example of a species reference for species @c
    'X0', with stoichiometry @c 2, in a list of reactants within a reaction
    having the identifier @c 'J1':
    @code
    <model>
        ...
        <listOfReactions>
            <reaction id='J1'>
                <listOfReactants>
                    <speciesReference species='X0' stoichiometry='2'>
                </listOfReactants>
                ...
            </reaction>
            ...
        </listOfReactions>
        ...
    </model>
    @endcode

    The following is a more complex example of a species reference for
    species @c 'X0', with a stoichiometry formula consisting of
    a rational number:
    @code
    <model>
        ...
        <listOfReactions>
            <reaction id='J1'>
                <listOfReactants>
                    <speciesReference species='X0'>
                        <stoichiometryMath>
                            <math xmlns='http://www.w3.org/1998/Math/MathML'> 
                                <cn type='rational'> 3 <sep/> 2 </cn>
                            </math>
                        </stoichiometryMath>
                    </speciesReference>
                </listOfReactants>
                ...
            </reaction>
            ...
        </listOfReactions>
        ...
    </model>
    @endcode

    Additional discussions of stoichiometries and implications for species
    and reactions are included in the documentation of SpeciesReference
    class.

    @section l3-stoichiometries Stoichiometries in SBML Level 3

    The StoichiometryMath construct is not defined in SBML Level&nbsp;3
    Version&nbsp;1 Core.  Instead, Level&nbsp;3 defines the identifier of
    SpeciesReference objects as a stand-in for the stoichiometry of the
    reactant or product being referenced, and allows that identifier to be
    used elsewhere in SBML models, including (for example) InitialAssignment
    objects.  This makes it possible to achieve the same effect as
    StoichiometryMath, but with other SBML objects.  For instance, to
    produce a stoichiometry value that is a rational number, a model can use
    InitialAssignment to assign the identifier of a SpeciesReference object
    to a MathML expression evaluating to a rational number.  This is
    analogous to the same way that, in Level&nbsp;2, the model would use
    StoichiometryMath with a MathML expression evaluating to a rational
    number.

    In SBML Level 2, the stoichiometry of a reactant or product is a
    combination of both a <em>biochemical stoichiometry</em> (meaning, the
    standard stoichiometry of a species in a reaction) and any necessary
    unit conversion factors. The introduction of an explicit attribute on
    the Species object for a conversion factor allows Level&nbsp;3 to avoid
    having to overload the meaning of stoichiometry.  In Level&nbsp;3, the
    stoichiometry given by a SpeciesReference object in a reaction is a
    'proper' biochemical stoichiometry, meaning a dimensionless number free
    of unit conversions.

    @see SpeciesReference
    @see Reaction

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StoichiometryMath, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StoichiometryMath, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_StoichiometryMath
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> StoichiometryMath
        __init__(self, SBMLNamespaces sbmlns) -> StoichiometryMath
        __init__(self, StoichiometryMath orig) -> StoichiometryMath

        Predicate returning @c true if
        all the required elements for this StoichiometryMath object
        have been set.

        @note The required elements for a StoichiometryMath object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
        @deprecated libSBML internal


        """
        this = _libsbml.new_StoichiometryMath(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> StoichiometryMath

        Creates and returns a deep copy of this StoichiometryMath object.

        @return a (deep) copy of this StoichiometryMath.
          

        """
        return _libsbml.StoichiometryMath_clone(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Retrieves the mathematical formula within this StoichiometryMath and
        return it as an AST.

        @return the math of this StoichiometryMath.
          

        """
        return _libsbml.StoichiometryMath_getMath(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate to test whether the math for this StoichiometryMath object
        has been set.

        @return @c true if the formula (meaning the @c math subelement) of
        this StoichiometryMath has been set, @c false otherwise.
          

        """
        return _libsbml.StoichiometryMath_isSetMath(self)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' expression of this StoichiometryMath instance to a
        copy of the given ASTNode.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.StoichiometryMath_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition object that expresses the
        units returned by the math expression in this StoichiometryMath
        object.

        The units are calculated based on the mathematical expression in the
        StoichiometryMath and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The
        StoichiometryMath::getDerivedUnitDefinition() method returns the
        calculated units.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c NULL.

        @warning Note that it is possible the 'math' expression in the
        StoichiometryMath instance contains literal numbers or parameters with
        undeclared units.  In those cases, it is not possible to calculate the
        units of the overall expression without making assumptions.  LibSBML
        does not make assumptions about the units, and
        StoichiometryMath::getDerivedUnitDefinition() only returns the units
        as far as it is able to determine them.  For example, in an expression
        <em>X + Y</em>, if <em>X</em> has unambiguously-defined units and
        <em>Y</em> does not, it will return the units of <em>X</em>.  When
        using this method, <strong>it is critical that callers also invoke the
        method</strong> StoichiometryMath::containsUndeclaredUnits()
        <strong>to determine whether this situation holds</strong>.  Callers
        should take suitable action in those situations.

        @return a UnitDefinition that expresses the units of the math,
        or @c NULL if one cannot be constructed.

        @see containsUndeclaredUnits()
          

        """
        return _libsbml.StoichiometryMath_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c true if the math
        expression of this StoichiometryMath object contains literal numbers
        or parameters with undeclared units.

        The StoichiometryMath::getDerivedUnitDefinition() method returns what
        libSBML computes the units of the Stoichiometry to be, to the extent
        that libSBML can compute them.  However, if the expression contains
        literal numbers or parameters with undeclared units, libSBML may not
        be able to compute the full units of the expression and will only
        return what it can compute.  Callers should always use
        StoichiometryMath::containsUndeclaredUnits() when using
        StoichiometryMath::getDerivedUnitDefinition() to decide whether the
        returned units may be incomplete.

        @return @c true if the math expression of this StoichiometryMath
        includes numbers/parameters with undeclared units, @c false otherwise.

        @note A return value of @c true indicates that the UnitDefinition
        returned by StoichiometryMath::getDerivedUnitDefinition() may not
        accurately represent the units of the expression.

        @see getDerivedUnitDefinition()
          

        """
        return _libsbml.StoichiometryMath_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> SBMLTypeCode_t

        Returns the libSBML type code of this object instance.

        @if clike LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.
        The set of possible type codes is defined in the enumeration
        #SBMLTypeCode_t.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if java LibSBML attaches an
        identifying code to every kind of SBML object.  These are known as
        <em>SBML type codes</em>.  In other languages, the set of type codes
        is stored in an enumeration; in the Java language interface for
        libSBML, the type codes are defined as static integer constants in
        interface class {@link libsbmlConstants}.  The names of the type codes
        all begin with the characters @c SBML_. @endif

        @return the SBML type code for this object, or @link SBMLTypeCode_t#SBML_UNKNOWN SBML_UNKNOWN@endlink (default).

        @see getElementName()
          

        """
        return _libsbml.StoichiometryMath_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for StoichiometryMath, is
        always @c 'stoichiometryMath'.

        @return the name of this element, i.e., @c 'stoichiometryMath'. 
          

        """
        return _libsbml.StoichiometryMath_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c true if
        all the required elements for this StoichiometryMath object
        have been set.

        @note The required elements for a StoichiometryMath object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.
          

        """
        return _libsbml.StoichiometryMath_hasRequiredElements(self)

StoichiometryMath_swigregister = _libsbml.StoichiometryMath_swigregister
StoichiometryMath_swigregister(StoichiometryMath)

SBML_DEFAULT_LEVEL = _libsbml.SBML_DEFAULT_LEVEL
SBML_DEFAULT_VERSION = _libsbml.SBML_DEFAULT_VERSION
SBML_XMLNS_L1 = _libsbml.SBML_XMLNS_L1
SBML_XMLNS_L2V1 = _libsbml.SBML_XMLNS_L2V1
SBML_XMLNS_L2V2 = _libsbml.SBML_XMLNS_L2V2
SBML_XMLNS_L2V3 = _libsbml.SBML_XMLNS_L2V3
SBML_XMLNS_L2V4 = _libsbml.SBML_XMLNS_L2V4
SBML_XMLNS_L3V1 = _libsbml.SBML_XMLNS_L3V1
class SBMLNamespaces(_object):
    """
    Class to store SBML level, version and namespace information.

    @htmlinclude not-sbml-warning.html

    There are differences in the definitions of components between different
    SBML Levels, as well as Versions within Levels.  For example, the
    'sboTerm' attribute was not introduced until Level&nbsp;2
    Version&nbsp;2, and then only on certain component classes; the SBML
    Level&nbsp;2 Version&nbsp;3 specification moved the 'sboTerm' attribute
    to the SBase class, thereby allowing nearly all components to have SBO
    annotations.  As a result of differences such as those, libSBML needs to
    track the SBML Level and Version of every object created.

    The purpose of the SBMLNamespaces object class is to make it easier to
    communicate SBML Level and Version data between libSBML constructors and
    other methods.  The SBMLNamespaces object class tracks 3-tuples
    (triples) consisting of SBML Level, Version, and the corresponding SBML
    XML namespace.  (The plural name is not a mistake, because in SBML
    Level&nbsp;3, objects may have extensions added by Level&nbsp;3 packages
    used by a given model; however, until the introduction of SBML
    Level&nbsp;3, the SBMLNamespaces object only records one SBML
    Level/Version/namespace combination at a time.)  Most constructors for
    SBML objects in libSBML take a SBMLNamespaces object as an argument,
    thereby allowing the constructor to produce the proper combination of
    attributes and other internal data structures for the given SBML
    Level and Version.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLNamespaces, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLNamespaces, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SBMLNamespaces
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level = 3, unsigned int version = 1) -> SBMLNamespaces
        __init__(self, unsigned int level = 3) -> SBMLNamespaces
        __init__(self) -> SBMLNamespaces
        __init__(self, SBMLNamespaces orig) -> SBMLNamespaces

        Copy constructor; creates a copy of a SBMLNamespaces.

        @param orig the SBMLNamespaces instance to copy.
          

        """
        this = _libsbml.new_SBMLNamespaces(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLNamespaces

        Creates and returns a deep copy of this SBMLNamespaces.

        @return a (deep) copy of this SBMLNamespaces.
          

        """
        return _libsbml.SBMLNamespaces_clone(self)

    def getSBMLNamespaceURI(*args):
        """
        getSBMLNamespaceURI(unsigned int level, unsigned int version) -> string

        Returns a string representing the SBML XML namespace for the 
        given @p level and @p version of SBML.

        @param level the SBML level
        @param version the SBML version

        @return a string representing the SBML namespace that reflects the
        SBML Level and Version specified.
          

        """
        return _libsbml.SBMLNamespaces_getSBMLNamespaceURI(*args)

    if _newclass:getSBMLNamespaceURI = staticmethod(getSBMLNamespaceURI)
    __swig_getmethods__["getSBMLNamespaceURI"] = lambda x: getSBMLNamespaceURI
    def getLevel(self, *args):
        """
        getLevel(self) -> unsigned int
        getLevel(self) -> unsigned int

        Get the SBML Level of this SBMLNamespaces object.

        @return the SBML Level of this SBMLNamespaces object.
          

        """
        return _libsbml.SBMLNamespaces_getLevel(self, *args)

    def getVersion(self, *args):
        """
        getVersion(self) -> unsigned int
        getVersion(self) -> unsigned int

        Get the SBML Version of this SBMLNamespaces object.

        @return the SBML Version of this SBMLNamespaces object.
          

        """
        return _libsbml.SBMLNamespaces_getVersion(self, *args)

    def getNamespaces(self, *args):
        """
        getNamespaces(self) -> XMLNamespaces
        getNamespaces(self) -> XMLNamespaces

        Get the XML namespaces list for this SBMLNamespaces object.

        The plural is not a mistake, because in SBML Level&nbsp;3, objects may
        have extensions added by Level&nbsp;3 packages used by a given model,
        and therefore there may be multiple XML namespaces involved too.
        However, until the introduction of SBML Level&nbsp;3, the
        SBMLNamespaces object only records one SBML Level/Version/namespace
        combination at a time, and so this method will also only return
        a list of one item.

        @return the XML namespaces of this SBMLNamespaces object.
          

        """
        return _libsbml.SBMLNamespaces_getNamespaces(self, *args)

    def addNamespaces(self, *args):
        """
        addNamespaces(self, XMLNamespaces xmlns)

        Add the XML namespaces list to the set of namespaces
        within this SBMLNamespaces object.

        @param xmlns the XML namespaces to be added.
          

        """
        return _libsbml.SBMLNamespaces_addNamespaces(self, *args)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBMLNamespaces_swigregister = _libsbml.SBMLNamespaces_swigregister
SBMLNamespaces_swigregister(SBMLNamespaces)

def SBMLNamespaces_getSBMLNamespaceURI(*args):
  """
    SBMLNamespaces_getSBMLNamespaceURI(unsigned int level, unsigned int version) -> string

    Returns a string representing the SBML XML namespace for the 
    given @p level and @p version of SBML.

    @param level the SBML level
    @param version the SBML version

    @return a string representing the SBML namespace that reflects the
    SBML Level and Version specified.
      

    """
  return _libsbml.SBMLNamespaces_getSBMLNamespaceURI(*args)

class SBMLTransforms(_object):
    """
    Methods for transform elements of SBML


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLTransforms, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLTransforms, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> SBMLTransforms"""
        this = _libsbml.new_SBMLTransforms()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLTransforms
    __del__ = lambda self : None;
SBMLTransforms_swigregister = _libsbml.SBMLTransforms_swigregister
SBMLTransforms_swigregister(SBMLTransforms)


def readMathMLFromString(*args):
  """
    readMathMLFromString(char xml) -> ASTNode_t

    Reads the MathML from the given XML string, constructs a corresponding
    abstract syntax tree, and returns a pointer to the root of the tree.

    @param xml a string containing a full MathML expression

    @return the root of an AST corresponding to the given mathematical
    expression, otherwise @c NULL is returned if the given string is @c NULL
    or invalid.


    """
  return _libsbml.readMathMLFromString(*args)

def writeMathMLToString(*args):
  """
    writeMathMLToString(ASTNode_t node) -> char

    Writes the given ASTNode (and its children) to a string as MathML, and
    returns the string.

    @param node the root of an AST to write out to the stream.

    @return a string containing the written-out MathML representation
    of the given AST.

    @note The string is owned by the caller and should be freed (with
    free()) when no longer needed.  @c NULL is returned if the given
    argument is @c NULL.


    """
  return _libsbml.writeMathMLToString(*args)
AST_PLUS = _libsbml.AST_PLUS
AST_MINUS = _libsbml.AST_MINUS
AST_TIMES = _libsbml.AST_TIMES
AST_DIVIDE = _libsbml.AST_DIVIDE
AST_POWER = _libsbml.AST_POWER
AST_INTEGER = _libsbml.AST_INTEGER
AST_REAL = _libsbml.AST_REAL
AST_REAL_E = _libsbml.AST_REAL_E
AST_RATIONAL = _libsbml.AST_RATIONAL
AST_NAME = _libsbml.AST_NAME
AST_NAME_AVOGADRO = _libsbml.AST_NAME_AVOGADRO
AST_NAME_TIME = _libsbml.AST_NAME_TIME
AST_CONSTANT_E = _libsbml.AST_CONSTANT_E
AST_CONSTANT_FALSE = _libsbml.AST_CONSTANT_FALSE
AST_CONSTANT_PI = _libsbml.AST_CONSTANT_PI
AST_CONSTANT_TRUE = _libsbml.AST_CONSTANT_TRUE
AST_LAMBDA = _libsbml.AST_LAMBDA
AST_FUNCTION = _libsbml.AST_FUNCTION
AST_FUNCTION_ABS = _libsbml.AST_FUNCTION_ABS
AST_FUNCTION_ARCCOS = _libsbml.AST_FUNCTION_ARCCOS
AST_FUNCTION_ARCCOSH = _libsbml.AST_FUNCTION_ARCCOSH
AST_FUNCTION_ARCCOT = _libsbml.AST_FUNCTION_ARCCOT
AST_FUNCTION_ARCCOTH = _libsbml.AST_FUNCTION_ARCCOTH
AST_FUNCTION_ARCCSC = _libsbml.AST_FUNCTION_ARCCSC
AST_FUNCTION_ARCCSCH = _libsbml.AST_FUNCTION_ARCCSCH
AST_FUNCTION_ARCSEC = _libsbml.AST_FUNCTION_ARCSEC
AST_FUNCTION_ARCSECH = _libsbml.AST_FUNCTION_ARCSECH
AST_FUNCTION_ARCSIN = _libsbml.AST_FUNCTION_ARCSIN
AST_FUNCTION_ARCSINH = _libsbml.AST_FUNCTION_ARCSINH
AST_FUNCTION_ARCTAN = _libsbml.AST_FUNCTION_ARCTAN
AST_FUNCTION_ARCTANH = _libsbml.AST_FUNCTION_ARCTANH
AST_FUNCTION_CEILING = _libsbml.AST_FUNCTION_CEILING
AST_FUNCTION_COS = _libsbml.AST_FUNCTION_COS
AST_FUNCTION_COSH = _libsbml.AST_FUNCTION_COSH
AST_FUNCTION_COT = _libsbml.AST_FUNCTION_COT
AST_FUNCTION_COTH = _libsbml.AST_FUNCTION_COTH
AST_FUNCTION_CSC = _libsbml.AST_FUNCTION_CSC
AST_FUNCTION_CSCH = _libsbml.AST_FUNCTION_CSCH
AST_FUNCTION_DELAY = _libsbml.AST_FUNCTION_DELAY
AST_FUNCTION_EXP = _libsbml.AST_FUNCTION_EXP
AST_FUNCTION_FACTORIAL = _libsbml.AST_FUNCTION_FACTORIAL
AST_FUNCTION_FLOOR = _libsbml.AST_FUNCTION_FLOOR
AST_FUNCTION_LN = _libsbml.AST_FUNCTION_LN
AST_FUNCTION_LOG = _libsbml.AST_FUNCTION_LOG
AST_FUNCTION_PIECEWISE = _libsbml.AST_FUNCTION_PIECEWISE
AST_FUNCTION_POWER = _libsbml.AST_FUNCTION_POWER
AST_FUNCTION_ROOT = _libsbml.AST_FUNCTION_ROOT
AST_FUNCTION_SEC = _libsbml.AST_FUNCTION_SEC
AST_FUNCTION_SECH = _libsbml.AST_FUNCTION_SECH
AST_FUNCTION_SIN = _libsbml.AST_FUNCTION_SIN
AST_FUNCTION_SINH = _libsbml.AST_FUNCTION_SINH
AST_FUNCTION_TAN = _libsbml.AST_FUNCTION_TAN
AST_FUNCTION_TANH = _libsbml.AST_FUNCTION_TANH
AST_LOGICAL_AND = _libsbml.AST_LOGICAL_AND
AST_LOGICAL_NOT = _libsbml.AST_LOGICAL_NOT
AST_LOGICAL_OR = _libsbml.AST_LOGICAL_OR
AST_LOGICAL_XOR = _libsbml.AST_LOGICAL_XOR
AST_RELATIONAL_EQ = _libsbml.AST_RELATIONAL_EQ
AST_RELATIONAL_GEQ = _libsbml.AST_RELATIONAL_GEQ
AST_RELATIONAL_GT = _libsbml.AST_RELATIONAL_GT
AST_RELATIONAL_LEQ = _libsbml.AST_RELATIONAL_LEQ
AST_RELATIONAL_LT = _libsbml.AST_RELATIONAL_LT
AST_RELATIONAL_NEQ = _libsbml.AST_RELATIONAL_NEQ
AST_UNKNOWN = _libsbml.AST_UNKNOWN
class ASTNode(_object):
    """
    Abstract Syntax Tree (AST) representation of a
    mathematical expression.

    @htmlinclude not-sbml-warning.html

    Abstract Syntax Trees (ASTs) are a simple kind of data structure used in
    libSBML for storing mathematical expressions.  The ASTNode is the
    cornerstone of libSBML's AST representation.  ASTNodes represent the
    most basic, indivisible part of a mathematical formula and come in many
    types.  For instance, there are node types to represent numbers (with
    subtypes to distinguish integer, real, and rational numbers), names
    (e.g., constants or variables), simple mathematical operators, logical
    or relational operators and functions. LibSBML ASTs provide a canonical,
    in-memory representation for all mathematical formulas regardless of
    their original format (which might be MathML or might be text strings).

    An AST @em node in libSBML is a recursive structure containing a pointer
    to the node's value (which might be, for example, a number or a symbol)
    and a list of children nodes.  Each ASTNode node may have none, one,
    two, or more child depending on its type. The following diagram
    illustrates an example of how the mathematical expression <code>'1 +
    2'</code> is represented as an AST with one @em plus node having two @em
    integer children nodes for the numbers <code>1</code> and
    <code>2</code>.  The figure also shows the corresponding MathML
    representation:

    @image html astnode-illustration.jpg 'Example AST representation of a mathematical expression.'
    @image latex astnode-illustration.jpg 'Example AST representation of a mathematical expression.'

    The following are other noteworthy points about the AST representation
    in libSBML:
    <ul>
    <li> A numerical value represented in MathML as a real number with an
    exponent is preserved as such in the AST node representation, even if
    the number could be stored in a @c double data type.  This is done
    so that when an SBML model is read in and then written out again, the
    amount of change introduced by libSBML to the SBML during the round-trip
    activity is minimized.
     
    <li> Rational numbers are represented in an AST node using separate
    numerator and denominator values.  These can be retrieved using the
    methods ASTNode::getNumerator() and ASTNode::getDenominator().

    <li> The children of an ASTNode are other ASTNode objects.  The list of
    children is empty for nodes that are leaf elements, such as numbers.
    For nodes that are actually roots of expression subtrees, the list of
    children points to the parsed objects that make up the rest of the
    expression.
    </ul>


    @if clike <h3><a class='anchor' name='ASTNodeType_t'>
    ASTNodeType_t</a></h3> @endif@if java <h3><a class='anchor'
    name='ASTNodeType_t'>The set of possible %ASTNode types</a></h3> @endif

    @if clike Every ASTNode has an associated type code to indicate,
    for example, whether it holds a number or stands for an arithmetic
    operator.  The type is recorded as a value drawn from the enumeration 
    @link ASTNode.h::ASTNodeType_t ASTNodeType_t@endlink.  The list of
    possible types is quite long, because it covers all the mathematical
    functions that are permitted in SBML.  The values are shown in the
    following table: @endif@if java Every ASTNode has an associated
    type code to indicate, for example, whether it holds a number or stands for
    an arithmetic operator.  The type is recorded as a value drawn from a
    set of static integer constants defined in the class {@link
    libsbmlConstants}.  Their names begin with the characters @c AST_.  The
    list of possible types is quite long, because it covers all the
    mathematical functions that are permitted in SBML.  The values are shown
    in the following table: @endif

    @htmlinclude astnode-types.html

    The types have the following meanings:
    <ul>
    <li> If the node is basic mathematical operator (e.g., @c '+'), then the
    node's type will be @c AST_PLUS, @c AST_MINUS, @c AST_TIMES, @c AST_DIVIDE,
    or @c AST_POWER, as appropriate.

    <li> If the node is a predefined function or operator from %SBML Level 1
    (in the string-based formula syntax used in Level 1) or %SBML Level 2
    (in the subset of MathML used in SBML Level 2), then the node's type
    will be either <code>AST_FUNCTION_</code><em><span
    class='placeholder'>X</span></em>, <code>AST_LOGICAL_</code><em><span
    class='placeholder'>X</span></em>, or
    <code>AST_RELATIONAL_</code><em><span class='placeholder'>X</span></em>,
    as appropriate.  (Examples: @c AST_FUNCTION_LOG, @c AST_RELATIONAL_LEQ.)

    <li> If the node refers to a user-defined function, the node's type will
    be @c AST_NAME (because it holds the name of the function).

    <li> If the node is a lambda expression, its type will be @c AST_LAMBDA.

    <li> If the node is a predefined constant (@c 'ExponentialE', @c 'Pi', 
    @c 'True' or @c 'False'), then the node's type will be @c AST_CONSTANT_E,
    @c AST_CONSTANT_PI, @c AST_CONSTANT_TRUE, or @c AST_CONSTANT_FALSE.

    <li> (Level 2 only) If the node is the special MathML csymbol @c time,
    the value of the node will be @c AST_NAME_TIME.  (Note, however, that the
    MathML csymbol @c delay is translated into a node of type
    @c AST_FUNCTION_DELAY.  The difference is due to the fact that @c time is a
    single variable, whereas @c delay is actually a function taking
    arguments.)

    <li> If the node contains a numerical value, its type will be
    @c AST_INTEGER, @c AST_REAL, @c AST_REAL_E, or @c AST_RATIONAL,
    as appropriate.
    </ul>


    <h3><a class='anchor' name='math-convert'>Converting between ASTs and text strings</a></h3>

    @if clike The text-string form of mathematical formulas
    produced by SBML_formulaToString() and read by SBML_parseFormula() are
    simple C-inspired infix notation taken from SBML Level&nbsp;1.  A
    formula in this text-string form can be handed to a program that
    understands SBML Level&nbsp;1 mathematical expressions, or used as part
    of a translation system.  The libSBML distribution comes with an example
    program in the @c 'examples' subdirectory called @c translateMath that
    implements an interactive command-line demonstration of translating
    infix formulas into MathML and
    vice-versa. @endif@if java
    The text-string form of mathematical formulas produced by <code><a
    href='libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)'>
    libsbml.formulaToString()</a></code> and read by <code><a
    href='libsbml.html#parseFormula(java.lang.String)'>
    libsbml.parseFormula()</a></code> are simple C-inspired
    infix notation taken from SBML Level&nbsp;1.  A formula in this
    text-string form can be handed to a program that understands SBML
    Level&nbsp;1 mathematical expressions, or used as part of a translation
    system.  The libSBML distribution comes with an example program in the
    @c 'examples' subdirectory called @c translateMath that implements an
    interactive command-line demonstration of translating infix formulas
    into MathML and vice-versa.@endif

    The formula strings may contain operators, function calls, symbols, and
    white space characters.  The allowable white space characters are tab
    and space.  The following are illustrative examples of formulas
    expressed in the syntax:

      @verbatim
     0.10 * k4^2
     @endverbatim
      @verbatim
     (vm * s1)/(km + s1)
     @endverbatim

    The following table shows the precedence rules in this syntax.  In the
    Class column, @em operand implies the construct is an operand, @em
    prefix implies the operation is applied to the following arguments, @em
    unary implies there is one argument, and @em binary implies there are
    two arguments.  The values in the Precedence column show how the order
    of different types of operation are determined.  For example, the
    expression <em>a * b + c</em> is evaluated as <em>(a * b) + c</em>
    because the <code>*</code> operator has higher precedence.  The
    Associates column shows how the order of similar precedence operations
    is determined; for example, <em>a - b + c</em> is evaluated as <em>(a -
    b) + c</em> because the <code>+</code> and <code>-</code> operators are
    left-associative.  The precedence and associativity rules are taken from
    the C programming language, except for the symbol <code>^</code>, which
    is used in C for a different purpose.  (Exponentiation can be invoked
    using either <code>^</code> or the function @c power.)

    @htmlinclude math-precedence-table.html 

    A program parsing a formula in an SBML model should assume that names
    appearing in the formula are the identifiers of Species, Parameter,
    Compartment, FunctionDefinition, or Reaction objects defined in a model.
    When a function call is involved, the syntax consists of a function
    identifier, followed by optional white space, followed by an opening
    parenthesis, followed by a sequence of zero or more arguments separated
    by commas (with each comma optionally preceded and/or followed by zero
    or more white space characters), followed by a closing parenthesis.
    There is an almost one-to-one mapping between the list of predefined
    functions available, and those defined in MathML.  All of the MathML
    functions are recognized; this set is larger than the functions defined
    in SBML Level&nbsp;1.  In the subset of functions that overlap between
    MathML and SBML Level&nbsp;1, there exist a few differences.  The
    following table summarizes the differences between the predefined
    functions in SBML Level&nbsp;1 and the MathML equivalents in SBML
    Level&nbsp;2:

    @htmlinclude math-functions.html

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ASTNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ASTNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ASTNodeType_t type = AST_UNKNOWN) -> ASTNode
        __init__(self) -> ASTNode
        __init__(self, ASTNode orig) -> ASTNode

        Copy constructor; creates a deep copy of the given ASTNode.

        @param orig the ASTNode to be copied.
          

        """
        this = _libsbml.new_ASTNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ASTNode
    __del__ = lambda self : None;
    def freeName(self):
        """
        freeName(self) -> int

        Frees the name of this ASTNode and sets it to @c NULL.

        This operation is only applicable to ASTNodes corresponding to
        operators, numbers, or @link ASTNodeType_t#AST_UNKNOWN
        AST_UNKNOWN@endlink.  This method has no effect on other types of
        nodes.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
          

        """
        return _libsbml.ASTNode_freeName(self)

    def canonicalize(self):
        """
        canonicalize(self) -> bool

        Converts this ASTNode to a canonical form and returns @c true if
        successful, @c false otherwise.

        The rules determining the canonical form conversion are as follows:
        <ul>

        <li> If the node type is @link ASTNodeType_t#AST_NAME AST_NAME@endlink
        and the node name matches @c 'ExponentialE', @c 'Pi', @c 'True' or @c
        'False' the node type is converted to the corresponding @c
        AST_CONSTANT_<em><span class='placeholder'>X</span></em> type.

        <li> If the node type is an @link ASTNodeType_t#AST_FUNCTION
        AST_FUNCTION@endlink and the node name matches an SBML Level&nbsp;1 or
        Level&nbsp;2 (MathML) function name, logical operator name, or
        relational operator name, the node is converted to the corresponding
        <code>AST_FUNCTION_</code><em><span class='placeholder'>X</span></em> or
        <code>AST_LOGICAL_</code><em><span class='placeholder'>X</span></em> type.

        </ul>

        SBML Level&nbsp;1 function names are searched first; thus, for
        example, canonicalizing @c log will result in a node type of @link
        ASTNodeType_t#AST_FUNCTION_LN AST_FUNCTION_LN@endlink.  (See the SBML
        Level&nbsp;1 Version&nbsp;2 Specification, Appendix C.)

        Sometimes, canonicalization of a node results in a structural
        conversion of the node as a result of adding a child.  For example, a
        node with the SBML Level&nbsp;1 function name @c sqr and a single
        child node (the argument) will be transformed to a node of type
        @link ASTNodeType_t#AST_FUNCTION_POWER AST_FUNCTION_POWER@endlink with
        two children.  The first child will remain unchanged, but the second
        child will be an ASTNode of type @link ASTNodeType_t#AST_INTEGER
        AST_INTEGER@endlink and a value of 2.  The function names that result
        in structural changes are: @c log10, @c sqr, and @c sqrt.
          

        """
        return _libsbml.ASTNode_canonicalize(self)

    def addChild(self, *args):
        """
        addChild(self, ASTNode child) -> int

        Adds the given node as a child of this ASTNode.  Child nodes are added
        in-order, from left to right.

        @param child the ASTNode instance to add

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note Adding a child to an ASTNode may change the structure of
        the mathematical formula being represented by the tree structure,
        and may render the representation invalid.

        @see prependChild(ASTNode* child)
        @see replaceChild(unsigned int n, ASTNode* child)
        @see insertChild(unsigned int n, ASTNode* child)
        @see removeChild(unsigned int n)
          

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ASTNode_addChild(self, *args)

    def prependChild(self, *args):
        """
        prependChild(self, ASTNode child) -> int

        Adds the given node as a child of this ASTNode.  This method adds
        child nodes from right to left.

        @param child the ASTNode instance to add

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @note Prepending a child to an ASTNode may change the structure of the
        mathematical formula being represented by the tree structure, and may
        render the representation invalid.

        @see addChild(ASTNode* child)
        @see replaceChild(unsigned int n, ASTNode* child)
        @see insertChild(unsigned int n, ASTNode* child)
        @see removeChild(unsigned int n)
          

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ASTNode_prependChild(self, *args)

    def removeChild(self, *args):
        """
        removeChild(self, unsigned int n) -> int

        Removes the nth child of this ASTNode object.

        @param n unsigned int the index of the child to remove

        @return integer value indicating success/failure of the
        function. The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink

        @note Removing a child from an ASTNode may change the structure of the
        mathematical formula being represented by the tree structure, and may
        render the representation invalid.

        @see addChild(ASTNode* child)
        @see prependChild(ASTNode* child)
        @see replaceChild(unsigned int n, ASTNode* child)
        @see insertChild(unsigned int n, ASTNode* child)
          

        """
        return _libsbml.ASTNode_removeChild(self, *args)

    def replaceChild(self, *args):
        """
        replaceChild(self, unsigned int n, ASTNode newChild) -> int

        Replaces the nth child of this ASTNode with the given ASTNode.

        @param n unsigned int the index of the child to replace
        @param newChild ASTNode to replace the nth child

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink

        @note Replacing a child from an ASTNode may change the structure of the
        mathematical formula being represented by the tree structure, and may
        render the representation invalid.

        @see addChild(ASTNode* child)
        @see prependChild(ASTNode* child)
        @see insertChild(unsigned int n, ASTNode* child)
        @see removeChild(unsigned int n)
          

        """
        if args[1] is not None: args[1].thisown = 0


        return _libsbml.ASTNode_replaceChild(self, *args)

    def insertChild(self, *args):
        """
        insertChild(self, unsigned int n, ASTNode newChild) -> int

        Insert the given ASTNode at point n in the list of children
        of this ASTNode.

        @param n unsigned int the index of the ASTNode being added
        @param newChild ASTNode to insert as the nth child

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink

        @note Inserting a child into an ASTNode may change the structure of the
        mathematical formula being represented by the tree structure, and may
        render the representation invalid.

        @see addChild(ASTNode* child)
        @see prependChild(ASTNode* child)
        @see replaceChild(unsigned int n, ASTNode* child)
        @see removeChild(unsigned int n)
          

        """
        if args[1] is not None: args[1].thisown = 0


        return _libsbml.ASTNode_insertChild(self, *args)

    def deepCopy(self):
        """
        deepCopy(self) -> ASTNode

        Creates a recursive copy of this node and all its children.

        @return a copy of this ASTNode and all its children.  The caller owns
        the returned ASTNode and is reponsible for deleting it.
          

        """
        return _libsbml.ASTNode_deepCopy(self)

    def getChild(self, *args):
        """
        getChild(self, unsigned int n) -> ASTNode

        Get a child of this node according to an index number.

        @param n the index of the child to get

        @return the nth child of this ASTNode or @c NULL if this node has no nth
        child (<code>n &gt; getNumChildren() - 1</code>).
          

        """
        return _libsbml.ASTNode_getChild(self, *args)

    def getLeftChild(self):
        """
        getLeftChild(self) -> ASTNode

        Get the left child of this node.

        @return the left child of this ASTNode.  This is equivalent to
        <code>getChild(0)</code>;
          

        """
        return _libsbml.ASTNode_getLeftChild(self)

    def getRightChild(self):
        """
        getRightChild(self) -> ASTNode

        Get the right child of this node.

        @return the right child of this ASTNode, or @c NULL if this node has no
        right child.  If <code>getNumChildren() &gt; 1</code>, then
        this is equivalent to:
        @code
        getChild( getNumChildren() - 1 );
        @endcode
          

        """
        return _libsbml.ASTNode_getRightChild(self)

    def getNumChildren(self):
        """
        getNumChildren(self) -> unsigned int

        Get the number of children that this node has.

        @return the number of children of this ASTNode, or 0 is this node has
        no children.
          

        """
        return _libsbml.ASTNode_getNumChildren(self)

    def addSemanticsAnnotation(self, *args):
        """
        addSemanticsAnnotation(self, XMLNode sAnnotation) -> int

        Adds the given XMLNode as a semantic annotation of this ASTNode.

        @param sAnnotation the annotation to add.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ASTNode_addSemanticsAnnotation(self, *args)

    def getNumSemanticsAnnotations(self):
        """
        getNumSemanticsAnnotations(self) -> unsigned int

        Get the number of semantic annotation elements inside this node.

        @return the number of annotations of this ASTNode.  
          

        """
        return _libsbml.ASTNode_getNumSemanticsAnnotations(self)

    def getSemanticsAnnotation(self, *args):
        """
        getSemanticsAnnotation(self, unsigned int n) -> XMLNode

        Get the nth semantic annotation of this node.

        @return the nth annotation of this ASTNode, or @c NULL if this node has
        no nth annotation (<code>n &gt; getNumChildren() - 1</code>).
          

        """
        return _libsbml.ASTNode_getSemanticsAnnotation(self, *args)

    def getCharacter(self):
        """
        getCharacter(self) -> char

        Get the value of this node as a single character.  This function
        should be called only when getType() is one of @link
        ASTNodeType_t#AST_PLUS AST_PLUS@endlink, @link ASTNodeType_t#AST_MINUS
        AST_MINUS@endlink, @link ASTNodeType_t#AST_TIMES AST_TIMES@endlink,
        @link ASTNodeType_t#AST_DIVIDE AST_DIVIDE@endlink or @link
        ASTNodeType_t#AST_POWER AST_POWER@endlink.

        @return the value of this ASTNode as a single character
          

        """
        return _libsbml.ASTNode_getCharacter(self)

    def getInteger(self):
        """
        getInteger(self) -> long

        Get the value of this node as an integer. This function should be
        called only when <code>getType() == @link ASTNodeType_t#AST_INTEGER
        AST_INTEGER@endlink</code>.

        @return the value of this ASTNode as a (<code>long</code>) integer. 
          

        """
        return _libsbml.ASTNode_getInteger(self)

    def getName(self):
        """
        getName(self) -> char

        Get the value of this node as a string.  This function may be called
        on nodes that are not operators (<code>isOperator() == false</code>)
        or numbers (<code>isNumber() == false</code>).

        @return the value of this ASTNode as a string.
          

        """
        return _libsbml.ASTNode_getName(self)

    def getNumerator(self):
        """
        getNumerator(self) -> long

        Get the value of the numerator of this node.  This function should be
        called only when <code>getType() == @link ASTNodeType_t#AST_RATIONAL
        AST_RATIONAL@endlink</code>.

        @return the value of the numerator of this ASTNode.  
          

        """
        return _libsbml.ASTNode_getNumerator(self)

    def getDenominator(self):
        """
        getDenominator(self) -> long

        Get the value of the denominator of this node.  This function should
        be called only when <code>getType() == @link
        ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink</code>.

        @return the value of the denominator of this ASTNode.
          

        """
        return _libsbml.ASTNode_getDenominator(self)

    def getReal(self):
        """
        getReal(self) -> double

        Get the real-numbered value of this node.  This function
        should be called only when <code>isReal() == true</code>.

        This function performs the necessary arithmetic if the node type is
        @link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink (<em>mantissa *
        10<sup> exponent</sup></em>) or @link ASTNodeType_t#AST_RATIONAL
        AST_RATIONAL@endlink (<em>numerator / denominator</em>).

        @return the value of this ASTNode as a real (double).
          

        """
        return _libsbml.ASTNode_getReal(self)

    def getMantissa(self):
        """
        getMantissa(self) -> double

        Get the mantissa value of this node.  This function should be called
        only when getType() returns @link ASTNodeType_t#AST_REAL_E
        AST_REAL_E@endlink or @link ASTNodeType_t#AST_REAL AST_REAL@endlink.
        If getType() returns @link ASTNodeType_t#AST_REAL AST_REAL@endlink,
        this method is identical to getReal().

        @return the value of the mantissa of this ASTNode. 
          

        """
        return _libsbml.ASTNode_getMantissa(self)

    def getExponent(self):
        """
        getExponent(self) -> long

        Get the exponent value of this ASTNode.  This function should be
        called only when getType() returns @link ASTNodeType_t#AST_REAL_E
        AST_REAL_E@endlink or @link ASTNodeType_t#AST_REAL AST_REAL@endlink.

        @return the value of the exponent of this ASTNode.
          

        """
        return _libsbml.ASTNode_getExponent(self)

    def getPrecedence(self):
        """
        getPrecedence(self) -> int

        Get the precedence of this node in the infix math syntax of SBML
        Level&nbsp;1.  For more information about the infix syntax, see the
        discussion about <a href='#math-convert'>text string formulas</a> at
        the top of the documentation for ASTNode.

        @return an integer indicating the precedence of this ASTNode
          

        """
        return _libsbml.ASTNode_getPrecedence(self)

    def getType(self):
        """
        getType(self) -> ASTNodeType_t

        Get the type of this ASTNode.  The value returned is one of the
        enumeration values such as @link ASTNodeType_t#AST_LAMBDA
        AST_LAMBDA@endlink, @link ASTNodeType_t#AST_PLUS AST_PLUS@endlink,
        etc.

        @return the type of this ASTNode.
          

        """
        return _libsbml.ASTNode_getType(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Get the units of this ASTNode.  

        This operation only applies to MathML <code>&lt;cn&gt;</code> elements.

        @return the units of this ASTNode.
          

        """
        return _libsbml.ASTNode_getUnits(self)

    def isBoolean(self):
        """
        isBoolean(self) -> bool

        Predicate returning @c true (non-zero) if this node has a boolean type
        (a logical operator, a relational operator, or the constants @c true
        or @c false).

        @return true if this ASTNode is a boolean, false otherwise.
          

        """
        return _libsbml.ASTNode_isBoolean(self)

    def isConstant(self):
        """
        isConstant(self) -> bool

        Predicate returning @c true (non-zero) if this node represents a MathML
        constant (e.g., @c true, @c Pi).

        @return true if this ASTNode is a MathML constant, false otherwise.
          

        """
        return _libsbml.ASTNode_isConstant(self)

    def isFunction(self):
        """
        isFunction(self) -> bool

        Predicate returning @c true (non-zero) if this node represents a
        MathML function (e.g., <code>abs()</code>), or an SBML Level&nbsp;1
        function, or a user-defined function.

        @return true if this ASTNode is a function, false otherwise.
          

        """
        return _libsbml.ASTNode_isFunction(self)

    def isInfinity(self):
        """
        isInfinity(self) -> bool

        Predicate returning @c true (non-zero) if this node represents
        the special IEEE 754 value infinity, @c false (zero) otherwise.

        @return true if this ASTNode is the special IEEE 754 value infinity,
        false otherwise.
          

        """
        return _libsbml.ASTNode_isInfinity(self)

    def isInteger(self):
        """
        isInteger(self) -> bool

        Predicate returning @c true (non-zero) if this node contains an
        integer value, @c false (zero) otherwise.

        @return true if this ASTNode is of type @link
        ASTNodeType_t#AST_INTEGER AST_INTEGER@endlink, false otherwise.
          

        """
        return _libsbml.ASTNode_isInteger(self)

    def isLambda(self):
        """
        isLambda(self) -> bool

        Predicate returning @c true (non-zero) if this node is a MathML
        <code>&lt;lambda&gt;</code>, @c false (zero) otherwise.

        @return true if this ASTNode is of type @link ASTNodeType_t#AST_LAMBDA
        AST_LAMBDA@endlink, false otherwise.
          

        """
        return _libsbml.ASTNode_isLambda(self)

    def isLog10(self):
        """
        isLog10(self) -> bool

        Predicate returning @c true (non-zero) if this node represents a @c
        log10() function, @c false (zero) otherwise.  More precisely, this
        predicate returns @c true if the node type is @link
        ASTNodeType_t#AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink with two
        children, the first of which is an @link ASTNodeType_t#AST_INTEGER
        AST_INTEGER@endlink equal to 10.

        @return true if the given ASTNode represents a log10() function, false
        otherwise.
          

        """
        return _libsbml.ASTNode_isLog10(self)

    def isLogical(self):
        """
        isLogical(self) -> bool

        Predicate returning @c true (non-zero) if this node is a MathML
        logical operator (i.e., @c and, @c or, @c not, @c xor).

        @return true if this ASTNode is a MathML logical operator
          

        """
        return _libsbml.ASTNode_isLogical(self)

    def isName(self):
        """
        isName(self) -> bool

        Predicate returning @c true (non-zero) if this node is a user-defined
        variable name in SBML L1, L2 (MathML), or the special symbols @c delay
        or @c time.  The predicate returns @c false (zero) otherwise.

        @return true if this ASTNode is a user-defined variable name in SBML
        L1, L2 (MathML) or the special symbols delay or time.
          

        """
        return _libsbml.ASTNode_isName(self)

    def isNaN(self):
        """
        isNaN(self) -> bool

        Predicate returning @c true (non-zero) if this node represents the
        special IEEE 754 value 'not a number' (NaN), @c false (zero)
        otherwise.

        @return true if this ASTNode is the special IEEE 754 NaN
          

        """
        return _libsbml.ASTNode_isNaN(self)

    def isNegInfinity(self):
        """
        isNegInfinity(self) -> bool

        Predicate returning @c true (non-zero) if this node represents the
        special IEEE 754 value 'negative infinity', @c false (zero) otherwise.

        @return true if this ASTNode is the special IEEE 754 value negative
        infinity, false otherwise.
          

        """
        return _libsbml.ASTNode_isNegInfinity(self)

    def isNumber(self):
        """
        isNumber(self) -> bool

        Predicate returning @c true (non-zero) if this node contains a number,
        @c false (zero) otherwise.  This is functionally equivalent to the
        following code:
        @code
          isInteger() || isReal()
        @endcode

        @return true if this ASTNode is a number, false otherwise.
          

        """
        return _libsbml.ASTNode_isNumber(self)

    def isOperator(self):
        """
        isOperator(self) -> bool

        Predicate returning @c true (non-zero) if this node is a mathematical
        operator, meaning, <code>+</code>, <code>-</code>, <code>*</code>, 
        <code>/</code> or <code>^</code> (power).

        @return true if this ASTNode is an operator.
          

        """
        return _libsbml.ASTNode_isOperator(self)

    def isPiecewise(self):
        """
        isPiecewise(self) -> bool

        Predicate returning @c true (non-zero) if this node is the MathML
        <code>&lt;piecewise&gt;</code> construct, @c false (zero) otherwise.

        @return true if this ASTNode is a MathML @c piecewise function
          

        """
        return _libsbml.ASTNode_isPiecewise(self)

    def isRational(self):
        """
        isRational(self) -> bool

        Predicate returning @c true (non-zero) if this node represents a rational
        number, @c false (zero) otherwise.

        @return true if this ASTNode is of type @link
        ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink.
          

        """
        return _libsbml.ASTNode_isRational(self)

    def isReal(self):
        """
        isReal(self) -> bool

        Predicate returning @c true (non-zero) if this node can represent a
        real number, @c false (zero) otherwise.  More precisely, this node
        must be of one of the following types: @link ASTNodeType_t#AST_REAL
        AST_REAL@endlink, @link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink or
        @link ASTNodeType_t#AST_RATIONAL AST_RATIONAL@endlink.

        @return true if the value of this ASTNode can represented as a real
        number, @c false otherwise.
          

        """
        return _libsbml.ASTNode_isReal(self)

    def isRelational(self):
        """
        isRelational(self) -> bool

        Predicate returning @c true (non-zero) if this node is a MathML
        relational operator, meaning <code>==</code>, <code>&gt;=</code>, 
        <code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>.

        @return true if this ASTNode is a MathML relational operator, false
        otherwise
          

        """
        return _libsbml.ASTNode_isRelational(self)

    def isSqrt(self):
        """
        isSqrt(self) -> bool

        Predicate returning @c true (non-zero) if this node represents a
        square root function, @c false (zero) otherwise.  More precisely, the
        node type must be @link ASTNodeType_t#AST_FUNCTION_ROOT
        AST_FUNCTION_ROOT@endlink with two children, the first of which is an
        @link ASTNodeType_t#AST_INTEGER AST_INTEGER@endlink node having value
        equal to 2.

        @return true if the given ASTNode represents a sqrt() function, false
        otherwise.
          

        """
        return _libsbml.ASTNode_isSqrt(self)

    def isUMinus(self):
        """
        isUMinus(self) -> bool

        Predicate returning @c true (non-zero) if this node is a unary minus
        operator, @c false (zero) otherwise.  A node is defined as a unary
        minus node if it is of type @link ASTNodeType_t#AST_MINUS
        AST_MINUS@endlink and has exactly one child.

        For numbers, unary minus nodes can be 'collapsed' by negating the
        number.  In fact, SBML_parseFormula() does this during its parse.
        However, unary minus nodes for symbols (@link ASTNodeType_t#AST_NAME
        AST_NAME@endlink) cannot be 'collapsed', so this predicate function
        is necessary.

        @return true if this ASTNode is a unary minus, false otherwise.
          

        """
        return _libsbml.ASTNode_isUMinus(self)

    def isUnknown(self):
        """
        isUnknown(self) -> bool

        Predicate returning @c true (non-zero) if this node has an unknown type.

        'Unknown' nodes have the type @link ASTNodeType_t#AST_UNKNOWN
        AST_UNKNOWN@endlink.  Nodes with unknown types will not appear in an
        ASTNode tree returned by libSBML based upon valid SBML input; the only
        situation in which a node with type @link ASTNodeType_t#AST_UNKNOWN
        AST_UNKNOWN@endlink may appear is immediately after having create a
        new, untyped node using the ASTNode constructor.  Callers creating
        nodes should endeavor to set the type to a valid node type as soon as
        possible after creating new nodes.

        @return true if this ASTNode is of type @link
        ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink, false otherwise.
          

        """
        return _libsbml.ASTNode_isUnknown(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c true (non-zero) if this node has the attribute
        <code>sbml:units</code>.

        Only applies to MathML <code>&lt;cn&gt;</code> elements.

        @return true if this ASTNode has units, false otherwise.
          

        """
        return _libsbml.ASTNode_isSetUnits(self)

    def hasUnits(self):
        """
        hasUnits(self) -> bool

        Predicate returning @c true (non-zero) if this node or any of its
        children nodes have the attribute <code>sbml:units</code>.

        @return true if this ASTNode or its children has units, 
        false otherwise.
          

        """
        return _libsbml.ASTNode_hasUnits(self)

    def setCharacter(self, *args):
        """
        setCharacter(self, char value) -> int

        Sets the value of this ASTNode to the given character.  If character
        is one of @c +, @c -, @c *, @c / or @c ^, the node type will be set
        accordingly.  For all other characters, the node type will be set to
        @link ASTNodeType_t#AST_UNKNOWN AST_UNKNOWN@endlink.

        @param value the character value to which the node's value should be
        set.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.ASTNode_setCharacter(self, *args)

    def setName(self, *args):
        """
        setName(self, char name) -> int

        Sets the value of this ASTNode to the given name.

        As a side-effect, this ASTNode object's type will be reset to
        @link ASTNodeType_t#AST_NAME AST_NAME@endlink if (and <em>only
        if</em>) the ASTNode was previously an operator (<code>isOperator() ==
        true</code>), number (<code>isNumber() == true</code>), or unknown.
        This allows names to be set for @link ASTNodeType_t#AST_FUNCTION
        AST_FUNCTION@endlink nodes and the like.

        @param name the string containing the name to which this node's value
        should be set

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.ASTNode_setName(self, *args)

    def setValue(self, *args):
        """
        setValue(self, long value) -> int
        setValue(self, long numerator, long denominator) -> int
        setValue(self, double value) -> int
        setValue(self, double mantissa, long exponent) -> int

        Sets the value of this ASTNode to the given real (@c double) in two
        parts: the mantissa and the exponent.  The node type is set to
        @link ASTNodeType_t#AST_REAL_E AST_REAL_E@endlink.

        @param mantissa the mantissa of this node's real-numbered value
        @param exponent the exponent of this node's real-numbered value

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.ASTNode_setValue(self, *args)

    def setType(self, *args):
        """
        setType(self, ASTNodeType_t type) -> int

        Sets the type of this ASTNode to the given <a class='el'
        href='#ASTNodeType_t'>ASTNodeType_t</a>.  A side-effect of doing this
        is that any numerical values previously stored in this node are reset
        to zero.

        @param type the type to which this node should be set

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.ASTNode_setType(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string units) -> int

        Sets the units of this ASTNode to units.

        The units will be set <em>only if</em> the ASTNode represents a MathML
        <code>&lt;cn&gt;</code> element, i.e., represents a number.  Callers
        may use isNumber() to inquire whether the node is of that type.

        @param units @c string representing the unit identifier.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.ASTNode_setUnits(self, *args)

    def swapChildren(self, *args):
        """
        swapChildren(self, ASTNode that) -> int

        Swap the children of this ASTNode object with the children of the
        given ASTNode object.

        @param that the other node whose children should be used to replace
        <em>this</em> node's children

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.ASTNode_swapChildren(self, *args)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the units of this ASTNode.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.ASTNode_unsetUnits(self)

    def getDefinitionURL(self):
        """
        getDefinitionURL(self) -> XMLAttributes

        Gets the MathML @c definitionURL attribute value.
          

        """
        return _libsbml.ASTNode_getDefinitionURL(self)

    def replaceArgument(self, *args):
        """
        replaceArgument(self, string bvar, ASTNode arg)

        Replaces occurences of a given name within this ASTNode with the
        name/value/formula represented by @p arg.

        For example, if the formula in this ASTNode is <code>x + y</code>,
        then the <code>&lt;bvar&gt;</code> is @c x and @c arg is an ASTNode
        representing the real value @c 3.  This method substitutes @c 3 for @c
        x within this ASTNode object.

        @param bvar a string representing the variable name to be substituted
        @param arg an ASTNode representing the name/value/formula to substitute
          

        """
        return _libsbml.ASTNode_replaceArgument(self, *args)

    def getParentSBMLObject(self):
        """
        getParentSBMLObject(self) -> SBase

        Returns the parent SBML object.

        @return the parent SBML object of this ASTNode.
          

        """
        return _libsbml.ASTNode_getParentSBMLObject(self)

    def reduceToBinary(self):
        """
        reduceToBinary(self)

        Reduces this ASTNode to a binary tree.

        Example: if this ASTNode is <code>and(x, y, z)</code>, then the 
        formula of the reduced node is <code>and(and(x, y), z)</code>.  The
        operation replaces the formula stored in the current ASTNode object.
          

        """
        return _libsbml.ASTNode_reduceToBinary(self)

    def isWellFormedASTNode(self):
        """
        isWellFormedASTNode(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ASTNode is well-formed.

        @note An ASTNode may be well-formed, with each node and its children
        having the appropriate number of children for the given type, but may
        still be invalid in the context of its use within an SBML model.

        @see hasCorrectNumberArguments()

        @return @c true if this ASTNode is well-formed, @c false otherwise.
         

        """
        return _libsbml.ASTNode_isWellFormedASTNode(self)

    def hasCorrectNumberArguments(self):
        """
        hasCorrectNumberArguments(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ASTNode has the correct number of children for it's type.

        For example, an ASTNode with type @link ASTNodeType_t#AST_PLUS
        AST_PLUS@endlink expects 2 child nodes.

        @note This function performs a check on the toplevel node only.
        Child nodes are not checked.

        @see isWellFormedASTNode()

        @return @c true if this ASTNode is has appropriate number of children
        for it's type, @c false otherwise.
         

        """
        return _libsbml.ASTNode_hasCorrectNumberArguments(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

    def getListOfNodes(self):
        """
        getListOfNodes(self) -> ASTNodeList

        Performs a depth-first search of the tree rooted at this ASTNode
        object, and returns a List of nodes where the given function
        <code>predicate(node)</code> returns @c true (non-zero).

        For portability between different programming languages, the predicate
        is passed in as a pointer to a function.  The function definition must
        have the type @link ASTNode.h::ASTNodePredicate ASTNodePredicate
        @endlink, which is defined as
        @code
        int (*ASTNodePredicate) (const ASTNode_t *node);
        @endcode
        where a return value of non-zero represents @c true and zero
        represents @c false.

        @param predicate the predicate to use

        @return the list of nodes for which the predicate returned @c true
        (non-zero).  The List returned is owned by the caller and should be
        deleted after the caller is done using it.  The ASTNode objects in the
        list; however, are not owned by the caller (as they still belong to
        the tree itself), and therefore should not be deleted.
          

        """
        return _libsbml.ASTNode_getListOfNodes(self)

ASTNode_swigregister = _libsbml.ASTNode_swigregister
ASTNode_swigregister(ASTNode)


def parseFormula(*args):
  """
    parseFormula(char formula) -> ASTNode_t

    Parses a text-string mathematical formula and returns a representation
    as an Abstract Syntax Tree.

    @if clike The text-string form of mathematical formulas produced by
    SBML_formulaToString() and read by SBML_parseFormula() are simple
    C-inspired infix notation taken from SBML Level&nbsp;1.  A formula in
    this text-string form therefore can be handed to a program that
    understands SBML Level&nbsp;1 mathematical expressions, or used as part
    of a formula translation system.  The syntax is described in detail in
    the documentation for ASTNode. @endif@if java The text-string form of
    mathematical formulas produced by <code><a
    href='libsbml.html'>libsbml.formulaToString()</a></code> and read by
    <code><a href='libsbml.html'>libsbml.parseFormula()</a></code> are
    simple C-inspired infix notation taken from SBML Level&nbsp;1.  A
    formula in this text-string form therefore can be handed to a program
    that understands SBML Level&nbsp;1 mathematical expressions, or used as
    part of a formula translation system.  The syntax is described in detail
    in the documentation for ASTNode.   @endif

    @param formula the string containing the mathematical formula.

    @return an ASTNode (the root of the expression tree).  If the formula
    contains a grammatical error, @c NULL is returned.


    """
  return _libsbml.parseFormula(*args)

def formulaToString(*args):
  """
    formulaToString(ASTNode_t tree) -> char

    Converts an ASTNode formula to a text string using a specific
    syntax for mathematical formulas.

    @if clike The text-string form of mathematical formulas produced by
    SBML_formulaToString() and read by SBML_parseFormula() are simple
    C-inspired infix notation taken from SBML Level&nbsp;1.  A formula in
    this text-string form therefore can be handed to a program that
    understands SBML Level&nbsp;1 mathematical expressions, or used as part
    of a formula translation system.  The syntax is described in detail in
    the documentation for ASTNode. @endif@if java The text-string form of
    mathematical formulas produced by <code><a
    href='libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)'>
    libsbml.formulaToString()</a></code> and read by
    <code><a href='libsbml.html#parseFormula(java.lang.String)'>
    libsbml.parseFormula()</a></code> are
    simple C-inspired infix notation taken from SBML Level&nbsp;1.  A
    formula in this text-string form therefore can be handed to a program
    that understands SBML Level&nbsp;1 mathematical expressions, or used as
    part of a formula translation system.  The syntax is described in detail
    in the documentation for ASTNode.   @endif

    @param tree the root of the ASTNode formula expression tree

    @return the formula from the given AST as an SBML Level 1 text-string
    mathematical formula.  The caller owns the returned string and is
    responsible for freeing it when it is no longer needed.
    @c NULL is returned if the given argument is @c NULL. 



    """
  return _libsbml.formulaToString(*args)
class XMLAttributes(_object):
    """
    Representation of attributes on an XML node.

    @htmlinclude not-sbml-warning.html


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLAttributes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLAttributes, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLAttributes
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLAttributes
        __init__(self, XMLAttributes orig) -> XMLAttributes

        Copy constructor; creates a copy of this XMLAttributes set.
          

        """
        this = _libsbml.new_XMLAttributes(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLAttributes

        Creates and returns a deep copy of this XMLAttributes set.

        @return a (deep) copy of this XMLAttributes set.
          

        """
        return _libsbml.XMLAttributes_clone(self)

    def add(self, *args):
        """
        add(self, string name, string value, string namespaceURI = "", 
            string prefix = "") -> int
        add(self, string name, string value, string namespaceURI = "") -> int
        add(self, string name, string value) -> int
        add(self, XMLTriple triple, string value) -> int

        Adds an attribute with the given XMLTriple/value pair to this XMLAttributes set.

        @note if local name with the same namespace URI already exists in this attribute set, 
        its value and prefix will be replaced.

        @param triple an XMLTriple, the XML triple of the attribute.
        @param value a string, the value of the attribute.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.XMLAttributes_add(self, *args)

    def removeResource(self, *args):
        """
        removeResource(self, int n) -> int

        Removes an attribute with the given index from this XMLAttributes set.  

        @param n an integer the index of the resource to be deleted
        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink
          

        """
        return _libsbml.XMLAttributes_removeResource(self, *args)

    def remove(self, *args):
        """
        remove(self, int n) -> int
        remove(self, string name, string uri = "") -> int
        remove(self, string name) -> int
        remove(self, XMLTriple triple) -> int

        Removes an attribute with the given XMLTriple from this XMLAttributes set.  

        @param triple an XMLTriple, the XML triple of the attribute.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink
          

        """
        return _libsbml.XMLAttributes_remove(self, *args)

    def clear(self):
        """
        clear(self) -> int

        Clears (deletes) all attributes in this XMLAttributes object.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.XMLAttributes_clear(self)

    def getIndex(self, *args):
        """
        getIndex(self, string name) -> int
        getIndex(self, string name, string uri) -> int
        getIndex(self, XMLTriple triple) -> int

        Return the index of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute for which 
               the index is required.

        @return the index of an attribute with the given XMLTriple, or -1 if not present.
          

        """
        return _libsbml.XMLAttributes_getIndex(self, *args)

    def getLength(self):
        """
        getLength(self) -> int

        Return the number of attributes in the set.

        @return the number of attributes in this XMLAttributes set.
          

        """
        return _libsbml.XMLAttributes_getLength(self)

    def getName(self, *args):
        """
        getName(self, int index) -> string

        Return the local name of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose local name is 
        required.

        @return the local name of an attribute in this list (by position).  

        @note If index is out of range, an empty string will be returned.  Use
        XMLAttributes::hasAttribute(int index) to test for the attribute
        existence.
          

        """
        return _libsbml.XMLAttributes_getName(self, *args)

    def getPrefix(self, *args):
        """
        getPrefix(self, int index) -> string

        Return the prefix of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose prefix is 
        required.

        @return the namespace prefix of an attribute in this list (by
        position).  

        @note If index is out of range, an empty string will be returned. Use
        XMLAttributes::hasAttribute(int index) to test for the attribute
        existence.
          

        """
        return _libsbml.XMLAttributes_getPrefix(self, *args)

    def getPrefixedName(self, *args):
        """
        getPrefixedName(self, int index) -> string

        Return the prefixed name of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose prefixed 
        name is required.

        @return the prefixed name of an attribute in this list (by
        position).  

        @note If index is out of range, an empty string will be returned.  Use
        XMLAttributes::hasAttribute(int index) to test for attribute existence.
          

        """
        return _libsbml.XMLAttributes_getPrefixedName(self, *args)

    def getURI(self, *args):
        """
        getURI(self, int index) -> string

        Return the namespace URI of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose namespace URI is 
        required.

        @return the namespace URI of an attribute in this list (by position).

        @note If index is out of range, an empty string will be returned.  Use
        XMLAttributes::hasAttribute(int index) to test for attribute existence.
          

        """
        return _libsbml.XMLAttributes_getURI(self, *args)

    def getValue(self, *args):
        """
        getValue(self, int index) -> string
        getValue(self, string name) -> string
        getValue(self, string name, string uri) -> string
        getValue(self, XMLTriple triple) -> string

        Return a value of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute whose 
               value is required.

        @return The attribute value as a string.  

        @note If an attribute with the given XMLTriple does not exist, an
        empty string will be returned.  Use
        XMLAttributes::hasAttribute(const XMLTriple& triple) to test for attribute existence.
          

        """
        return _libsbml.XMLAttributes_getValue(self, *args)

    def hasAttribute(self, *args):
        """
        hasAttribute(self, int index) -> bool
        hasAttribute(self, string name, string uri = "") -> bool
        hasAttribute(self, string name) -> bool
        hasAttribute(self, XMLTriple triple) -> bool

        Predicate returning @c true or @c false depending on whether
        an attribute with the given XML triple exists in this XMLAttributes.

        @param triple an XMLTriple, the XML triple of the attribute 

        @return @c true if an attribute with the given XML triple exists in this
        XMLAttributes, @c false otherwise.

          

        """
        return _libsbml.XMLAttributes_hasAttribute(self, *args)

    def isEmpty(self):
        """
        isEmpty(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLAttributes set is empty.

        @return @c true if this XMLAttributes set is empty, @c false otherwise.
          

        """
        return _libsbml.XMLAttributes_isEmpty(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLAttributes_swigregister = _libsbml.XMLAttributes_swigregister
XMLAttributes_swigregister(XMLAttributes)

class XMLNamespaces(_object):
    """
    Representation of XML Namespaces.

    @htmlinclude not-sbml-warning.html

    This class serves to organize functionality for tracking XML namespaces
    in a document or data stream.  The namespace declarations are stored as
    a list of pairs of XML namespace URIs and prefix strings.  These
    correspond to the parts of a namespace declaration on an XML element.
    For example, in the following XML fragment,
      @verbatim
     <annotation>
         <mysim:nodecolors xmlns:mysim='urn:lsid:mysim.org'
              mysim:bgcolor='green' mysim:fgcolor='white'/>
     </annotation>
     @endverbatim
    there is one namespace declaration.  Its URI is
    <code>urn:lsid:mysim.org</code> and its prefix is <code>mysim</code>.
    This pair could be stored as one item in an XMLNamespaces list.

    XMLNamespaces provides various methods for manipulating the list of
    prefix-URI pairs.  Individual namespaces stored in a given XMLNamespace
    object instance can be retrieved based on their index using
    XMLNamespaces::getPrefix(int index), or by their characteristics such as
    their URI or position in the list.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLNamespaces, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLNamespaces, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLNamespaces
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLNamespaces
        __init__(self, XMLNamespaces orig) -> XMLNamespaces

        Copy constructor; creates a copy of this XMLNamespaces list.

        @param orig the XMLNamespaces object to copy
          

        """
        this = _libsbml.new_XMLNamespaces(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLNamespaces

        Creates and returns a deep copy of this XMLNamespaces list.

        @return a (deep) copy of this XMLNamespaces list.
          

        """
        return _libsbml.XMLNamespaces_clone(self)

    def add(self, *args):
        """
        add(self, string uri, string prefix = "") -> int
        add(self, string uri) -> int

        Appends an XML namespace prefix and URI pair to this list of namespace
        declarations.

        An XMLNamespace object stores a list of pairs of namespaces and their
        prefixes.  If there is an XML namespace with the given @p uri prefix
        in this list, then its corresponding URI will be overwritten by the
        new @p uri.  Calling programs could use one of the other XMLNamespaces
        methods, such as
        @if clike XMLNamespaces::hasPrefix() @endif@if java XMLNamespaces::hasPrefix(String) @endif and 
        @if clike XMLNamespaces::hasURI() @endif@if java XMLNamespaces::hasURI(String) @endif to
        inquire whether a given prefix and/or URI
        is already present in this XMLNamespaces object.

        @param uri a string, the uri for the namespace
        @param prefix a string, the prefix for the namespace

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
          

        """
        return _libsbml.XMLNamespaces_add(self, *args)

    def remove(self, *args):
        """
        remove(self, int index) -> int
        remove(self, string prefix) -> int

        Removes an XML Namespace with the given prefix.

        @param prefix a string, prefix of the required namespace.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink

        @see remove(int index)
          

        """
        return _libsbml.XMLNamespaces_remove(self, *args)

    def clear(self):
        """
        clear(self) -> int

        Clears (deletes) all XML namespace declarations in this XMLNamespaces
        object.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see remove(int index)
          

        """
        return _libsbml.XMLNamespaces_clear(self)

    def getIndex(self, *args):
        """
        getIndex(self, string uri) -> int

        Look up the index of an XML namespace declaration by URI.

        An XMLNamespace object stores a list of pairs of namespaces and their
        prefixes.  If this XMLNamespaces object contains a pair with the given
        URI @p uri, this method returns its index in the list.

        @param uri a string, the URI of the sought-after namespace.

        @return the index of the given declaration, or <code>-1</code> if not
        present.
          

        """
        return _libsbml.XMLNamespaces_getIndex(self, *args)

    def getIndexByPrefix(self, *args):
        """
        getIndexByPrefix(self, string prefix) -> int

        Look up the index of an XML namespace declaration by prefix.

        An XMLNamespace object stores a list of pairs of namespaces and their
        prefixes.  If this XMLNamespaces object contains a pair with the given
        prefix @p prefix, this method returns its index in the list.

        @param prefix a string, the prefix string of the sought-after
        namespace

        @return the index of the given declaration, or <code>-1</code> if not
        present.
          

        """
        return _libsbml.XMLNamespaces_getIndexByPrefix(self, *args)

    def getLength(self):
        """
        getLength(self) -> int

        Returns the total number of URI-and-prefix pairs stored in this
        particular XMLNamespaces instance.

        @return the number of namespaces in this list.
          

        """
        return _libsbml.XMLNamespaces_getLength(self)

    def getPrefix(self, *args):
        """
        getPrefix(self, int index) -> string
        getPrefix(self, string uri) -> string

        Look up the prefix of an XML namespace declaration by its URI.

        An XMLNamespace object stores a list of pairs of namespaces and their
        prefixes.  This method returns the prefix for a pair that has the
        given @p uri.

        @param uri a string, the URI of the prefix being sought

        @return the prefix of an XML namespace declaration given its URI, or
        an empty string if no such @p uri exists in this XMLNamespaces object
          

        """
        return _libsbml.XMLNamespaces_getPrefix(self, *args)

    def getURI(self, *args):
        """
        getURI(self, int index) -> string
        getURI(self, string prefix = "") -> string
        getURI(self) -> string

        Look up the URI of an XML namespace declaration by its prefix.

        An XMLNamespace object stores a list of pairs of namespaces and their
        prefixes.  This method returns the namespace URI for a pair that has
        the given @p prefix.

        @param prefix a string, the prefix of the required URI

        @return the URI of an XML namespace declaration having the given @p
        prefix, or an empty string if no such prefix-and-URI pair exists
        in this XMLNamespaces object

        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif

        @see getURI()
          

        """
        return _libsbml.XMLNamespaces_getURI(self, *args)

    def isEmpty(self):
        """
        isEmpty(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        XMLNamespaces list is empty.

        @return @c true if this XMLNamespaces list is empty, @c false otherwise.
          

        """
        return _libsbml.XMLNamespaces_isEmpty(self)

    def hasURI(self, *args):
        """
        hasURI(self, string uri) -> bool

        Predicate returning @c true or @c false depending on whether an XML
        Namespace with the given URI is contained in this XMLNamespaces list.

        @param uri a string, the uri for the namespace

        @return @c true if an XML Namespace with the given URI is contained in
        this XMLNamespaces list, @c false otherwise.
          

        """
        return _libsbml.XMLNamespaces_hasURI(self, *args)

    def hasPrefix(self, *args):
        """
        hasPrefix(self, string prefix) -> bool

        Predicate returning @c true or @c false depending on whether an XML
        Namespace with the given prefix is contained in this XMLNamespaces
        list.

        @param prefix a string, the prefix for the namespace

        @return @c true if an XML Namespace with the given URI is contained in
        this XMLNamespaces list, @c false otherwise.
          

        """
        return _libsbml.XMLNamespaces_hasPrefix(self, *args)

    def hasNS(self, *args):
        """
        hasNS(self, string uri, string prefix) -> bool

        Predicate returning @c true or @c false depending on whether an XML
        Namespace with the given URI and prefix pair is contained in this
        XMLNamespaces list.

        @param uri a string, the URI for the namespace
        @param prefix a string, the prefix for the namespace

        @return @c true if an XML Namespace with the given uri/prefix pair is
        contained in this XMLNamespaces list, @c false otherwise.
          

        """
        return _libsbml.XMLNamespaces_hasNS(self, *args)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLNamespaces_swigregister = _libsbml.XMLNamespaces_swigregister
XMLNamespaces_swigregister(XMLNamespaces)

class XMLToken(_object):
    """
    Representation of a token in an XML stream.

    @htmlinclude not-sbml-warning.html


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLToken, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLToken, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLToken
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0, unsigned int column = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, 
            unsigned int column = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes) -> XMLToken
        __init__(self, XMLTriple triple, unsigned int line = 0, unsigned int column = 0) -> XMLToken
        __init__(self, XMLTriple triple, unsigned int line = 0) -> XMLToken
        __init__(self, XMLTriple triple) -> XMLToken
        __init__(self, string chars, unsigned int line = 0, unsigned int column = 0) -> XMLToken
        __init__(self, string chars, unsigned int line = 0) -> XMLToken
        __init__(self, string chars) -> XMLToken
        __init__(self, XMLToken orig) -> XMLToken

        Copy constructor; creates a copy of this XMLToken.
          

        """
        this = _libsbml.new_XMLToken(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLToken

        Creates and returns a deep copy of this XMLToken.

        @return a (deep) copy of this XMLToken set.
          

        """
        return _libsbml.XMLToken_clone(self)

    def getAttributes(self):
        """
        getAttributes(self) -> XMLAttributes

        Returns the attributes of this element.

        @return the XMLAttributes of this XML element.
          

        """
        return _libsbml.XMLToken_getAttributes(self)

    def setAttributes(self, *args):
        """
        setAttributes(self, XMLAttributes attributes) -> int

        Sets an XMLAttributes to this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @param attributes XMLAttributes to be set to this XMLToken.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink

        @note This function replaces the existing XMLAttributes with the new one.
          

        """
        return _libsbml.XMLToken_setAttributes(self, *args)

    def addAttr(self, *args):
        """
        addAttr(self, string name, string value, string namespaceURI = "", 
            string prefix = "") -> int
        addAttr(self, string name, string value, string namespaceURI = "") -> int
        addAttr(self, string name, string value) -> int
        addAttr(self, XMLTriple triple, string value) -> int

        Adds an attribute with the given XMLTriple/value pair to the attribute set
        in this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @note if local name with the same namespace URI already exists in the 
        attribute set, its value and prefix will be replaced.

        @param triple an XMLTriple, the XML triple of the attribute.
        @param value a string, the value of the attribute.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink
          

        """
        return _libsbml.XMLToken_addAttr(self, *args)

    def removeAttr(self, *args):
        """
        removeAttr(self, int n) -> int
        removeAttr(self, string name, string uri = "") -> int
        removeAttr(self, string name) -> int
        removeAttr(self, XMLTriple triple) -> int

        Removes an attribute with the given XMLTriple from the attribute set 
        in this XMLToken.  
        Nothing will be done if this XMLToken is not a start element.

        @param triple an XMLTriple, the XML triple of the attribute.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink
          

        """
        return _libsbml.XMLToken_removeAttr(self, *args)

    def clearAttributes(self):
        """
        clearAttributes(self) -> int

        Clears (deletes) all attributes in this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink
          

        """
        return _libsbml.XMLToken_clearAttributes(self)

    def getAttrIndex(self, *args):
        """
        getAttrIndex(self, string name, string uri = "") -> int
        getAttrIndex(self, string name) -> int
        getAttrIndex(self, XMLTriple triple) -> int

        Return the index of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute for which 
               the index is required.

        @return the index of an attribute with the given XMLTriple, or -1 if not present.
          

        """
        return _libsbml.XMLToken_getAttrIndex(self, *args)

    def getAttributesLength(self):
        """
        getAttributesLength(self) -> int

        Return the number of attributes in the attributes set.

        @return the number of attributes in the attributes set in this XMLToken.
          

        """
        return _libsbml.XMLToken_getAttributesLength(self)

    def getAttrName(self, *args):
        """
        getAttrName(self, int index) -> string

        Return the local name of an attribute in the attributes set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose local name 
        is required.

        @return the local name of an attribute in this list (by position).  

        @note If index
        is out of range, an empty string will be returned.  Use hasAttr(index) 
        to test for the attribute existence.
          

        """
        return _libsbml.XMLToken_getAttrName(self, *args)

    def getAttrPrefix(self, *args):
        """
        getAttrPrefix(self, int index) -> string

        Return the prefix of an attribute in the attribute set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose prefix is 
        required.

        @return the namespace prefix of an attribute in the attribute set
        (by position).  

        @note If index is out of range, an empty string will be
        returned. Use hasAttr(index) to test for the attribute existence.
          

        """
        return _libsbml.XMLToken_getAttrPrefix(self, *args)

    def getAttrPrefixedName(self, *args):
        """
        getAttrPrefixedName(self, int index) -> string

        Return the prefixed name of an attribute in the attribute set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose prefixed 
        name is required.

        @return the prefixed name of an attribute in the attribute set 
        (by position).  

        @note If index is out of range, an empty string will be
        returned.  Use hasAttr(index) to test for attribute existence.
          

        """
        return _libsbml.XMLToken_getAttrPrefixedName(self, *args)

    def getAttrURI(self, *args):
        """
        getAttrURI(self, int index) -> string

        Return the namespace URI of an attribute in the attribute set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose namespace 
        URI is required.

        @return the namespace URI of an attribute in the attribute set (by position).

        @note If index is out of range, an empty string will be returned.  Use
        hasAttr(index) to test for attribute existence.
          

        """
        return _libsbml.XMLToken_getAttrURI(self, *args)

    def getAttrValue(self, *args):
        """
        getAttrValue(self, int index) -> string
        getAttrValue(self, string name, string uri = "") -> string
        getAttrValue(self, string name) -> string
        getAttrValue(self, XMLTriple triple) -> string

        Return a value of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute whose 
               value is required.

        @return The attribute value as a string.  

        @note If an attribute with the
        given XMLTriple does not exist, an empty string will be returned.  
        Use hasAttr(triple) to test for attribute existence.
          

        """
        return _libsbml.XMLToken_getAttrValue(self, *args)

    def hasAttr(self, *args):
        """
        hasAttr(self, int index) -> bool
        hasAttr(self, string name, string uri = "") -> bool
        hasAttr(self, string name) -> bool
        hasAttr(self, XMLTriple triple) -> bool

        Predicate returning @c true or @c false depending on whether
        an attribute with the given XML triple exists in the attribute set in 
        this XMLToken 

        @param triple an XMLTriple, the XML triple of the attribute 

        @return @c true if an attribute with the given XML triple exists
        in the attribute set in this XMLToken, @c false otherwise.

          

        """
        return _libsbml.XMLToken_hasAttr(self, *args)

    def isAttributesEmpty(self):
        """
        isAttributesEmpty(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        the attribute set in this XMLToken set is empty.

        @return @c true if the attribute set in this XMLToken is empty, 
        @c false otherwise.
          

        """
        return _libsbml.XMLToken_isAttributesEmpty(self)

    def getNamespaces(self):
        """
        getNamespaces(self) -> XMLNamespaces

        Returns the XML namespace declarations for this XML element.

        @return the XML namespace declarations for this XML element.
          

        """
        return _libsbml.XMLToken_getNamespaces(self)

    def setNamespaces(self, *args):
        """
        setNamespaces(self, XMLNamespaces namespaces) -> int

        Sets an XMLnamespaces to this XML element.
        Nothing will be done if this XMLToken is not a start element.

        @param namespaces XMLNamespaces to be set to this XMLToken.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink

        @note This function replaces the existing XMLNamespaces with the new one.
          

        """
        return _libsbml.XMLToken_setNamespaces(self, *args)

    def addNamespace(self, *args):
        """
        addNamespace(self, string uri, string prefix = "") -> int
        addNamespace(self, string uri) -> int

        Appends an XML namespace prefix and URI pair to this XMLToken.
        If there is an XML namespace with the given prefix in this XMLToken, 
        then the existing XML namespace will be overwritten by the new one.

        Nothing will be done if this XMLToken is not a start element.

        @param uri a string, the uri for the namespace
        @param prefix a string, the prefix for the namespace

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink

        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
          

        """
        return _libsbml.XMLToken_addNamespace(self, *args)

    def removeNamespace(self, *args):
        """
        removeNamespace(self, int index) -> int
        removeNamespace(self, string prefix) -> int

        Removes an XML Namespace with the given prefix.
        Nothing will be done if this XMLToken is not a start element.

        @param prefix a string, prefix of the required namespace.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink
        @li @link OperationReturnValues_t#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink
          

        """
        return _libsbml.XMLToken_removeNamespace(self, *args)

    def clearNamespaces(self):
        """
        clearNamespaces(self) -> int

        Clears (deletes) all XML namespace declarations in the XMLNamespaces of
        this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink
          

        """
        return _libsbml.XMLToken_clearNamespaces(self)

    def getNamespaceIndex(self, *args):
        """
        getNamespaceIndex(self, string uri) -> int

        Look up the index of an XML namespace declaration by URI.

        @param uri a string, uri of the required namespace.

        @return the index of the given declaration, or -1 if not present.
          

        """
        return _libsbml.XMLToken_getNamespaceIndex(self, *args)

    def getNamespaceIndexByPrefix(self, *args):
        """
        getNamespaceIndexByPrefix(self, string prefix) -> int

        Look up the index of an XML namespace declaration by prefix.

        @param prefix a string, prefix of the required namespace.

        @return the index of the given declaration, or -1 if not present.
          

        """
        return _libsbml.XMLToken_getNamespaceIndexByPrefix(self, *args)

    def getNamespacesLength(self):
        """
        getNamespacesLength(self) -> int

        Returns the number of XML namespaces stored in the XMLNamespaces 
        of this XMLToken.

        @return the number of namespaces in this list.
          

        """
        return _libsbml.XMLToken_getNamespacesLength(self)

    def getNamespacePrefix(self, *args):
        """
        getNamespacePrefix(self, int index) -> string
        getNamespacePrefix(self, string uri) -> string

        Look up the prefix of an XML namespace declaration by its URI.

        @param uri a string, the URI of the prefix being sought

        @return the prefix of an XML namespace declaration given its URI.  

        @note If @p uri does not exist, an empty string will be returned.
          

        """
        return _libsbml.XMLToken_getNamespacePrefix(self, *args)

    def getNamespaceURI(self, *args):
        """
        getNamespaceURI(self, int index) -> string
        getNamespaceURI(self, string prefix = "") -> string
        getNamespaceURI(self) -> string

        Look up the URI of an XML namespace declaration by its prefix.

        @param prefix a string, the prefix of the required URI

        @return the URI of an XML namespace declaration given its prefix.  

        @note If @p prefix does not exist, an empty string will be returned.

        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
          

        """
        return _libsbml.XMLToken_getNamespaceURI(self, *args)

    def isNamespacesEmpty(self):
        """
        isNamespacesEmpty(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        the XMLNamespaces of this XMLToken is empty.

        @return @c true if the XMLNamespaces of this XMLToken is empty, 
        @c false otherwise.
          

        """
        return _libsbml.XMLToken_isNamespacesEmpty(self)

    def hasNamespaceURI(self, *args):
        """
        hasNamespaceURI(self, string uri) -> bool

        Predicate returning @c true or @c false depending on whether 
        an XML Namespace with the given URI is contained in the XMLNamespaces of
        this XMLToken.

        @param uri a string, the uri for the namespace

        @return @c true if an XML Namespace with the given URI is contained in the
        XMLNamespaces of this XMLToken,  @c false otherwise.
          

        """
        return _libsbml.XMLToken_hasNamespaceURI(self, *args)

    def hasNamespacePrefix(self, *args):
        """
        hasNamespacePrefix(self, string prefix) -> bool

        Predicate returning @c true or @c false depending on whether 
        an XML Namespace with the given prefix is contained in the XMLNamespaces of
        this XMLToken.

        @param prefix a string, the prefix for the namespace

        @return @c true if an XML Namespace with the given URI is contained in the
        XMLNamespaces of this XMLToken, @c false otherwise.
          

        """
        return _libsbml.XMLToken_hasNamespacePrefix(self, *args)

    def hasNamespaceNS(self, *args):
        """
        hasNamespaceNS(self, string uri, string prefix) -> bool

        Predicate returning @c true or @c false depending on whether 
        an XML Namespace with the given uri/prefix pair is contained in the 
        XMLNamespaces ofthis XMLToken.

        @param uri a string, the uri for the namespace
        @param prefix a string, the prefix for the namespace

        @return @c true if an XML Namespace with the given uri/prefix pair is 
        contained in the XMLNamespaces of this XMLToken,  @c false otherwise.
          

        """
        return _libsbml.XMLToken_hasNamespaceNS(self, *args)

    def setTriple(self, *args):
        """
        setTriple(self, XMLTriple triple) -> int

        Sets the XMLTripe (name, uri and prefix) of this XML element.
        Nothing will be done if this XML element is a text node.

        @param triple XMLTriple to be added to this XML element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink
          

        """
        return _libsbml.XMLToken_setTriple(self, *args)

    def getName(self):
        """
        getName(self) -> string

        Returns the (unqualified) name of this XML element.

        @return the (unqualified) name of this XML element.
          

        """
        return _libsbml.XMLToken_getName(self)

    def getPrefix(self):
        """
        getPrefix(self) -> string

        Returns the namespace prefix of this XML element.

        @return the namespace prefix of this XML element.  

        @note If no prefix
        exists, an empty string will be return.
          

        """
        return _libsbml.XMLToken_getPrefix(self)

    def getURI(self):
        """
        getURI(self) -> string

        Returns the namespace URI of this XML element.

        @return the namespace URI of this XML element.
          

        """
        return _libsbml.XMLToken_getURI(self)

    def getCharacters(self):
        """
        getCharacters(self) -> string

        Returns the text of this element.

        @return the characters of this XML text.
          

        """
        return _libsbml.XMLToken_getCharacters(self)

    def append(self, *args):
        """
        append(self, string chars) -> int

        Appends characters to this XML text content.

        @param chars string, characters to append

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
          

        """
        return _libsbml.XMLToken_append(self, *args)

    def getColumn(self):
        """
        getColumn(self) -> unsigned int

        Returns the column at which this XMLToken occurred in the input
        document or data stream.

        @return the column at which this XMLToken occurred.
          

        """
        return _libsbml.XMLToken_getColumn(self)

    def getLine(self):
        """
        getLine(self) -> unsigned int

        Returns the line at which this XMLToken occurred in the input document
        or data stream.

        @return the line at which this XMLToken occurred.
          

        """
        return _libsbml.XMLToken_getLine(self)

    def isElement(self):
        """
        isElement(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLToken is an XML element.

        @return @c true if this XMLToken is an XML element, @c false otherwise.
          

        """
        return _libsbml.XMLToken_isElement(self)

    def isEnd(self):
        """
        isEnd(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLToken is an XML end element.

        @return @c true if this XMLToken is an XML end element, @c false otherwise.
          

        """
        return _libsbml.XMLToken_isEnd(self)

    def isEndFor(self, *args):
        """
        isEndFor(self, XMLToken element) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLToken is an XML end element for the given start element.

        @param element XMLToken, element for which query is made.

        @return @c true if this XMLToken is an XML end element for the given
        XMLToken start element, @c false otherwise.
          

        """
        return _libsbml.XMLToken_isEndFor(self, *args)

    def isEOF(self):
        """
        isEOF(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLToken is an end of file marker.

        @return @c true if this XMLToken is an end of file (input) marker, @c false
        otherwise.
          

        """
        return _libsbml.XMLToken_isEOF(self)

    def isStart(self):
        """
        isStart(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLToken is an XML start element.

        @return @c true if this XMLToken is an XML start element, @c false otherwise.
          

        """
        return _libsbml.XMLToken_isStart(self)

    def isText(self):
        """
        isText(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLToken is an XML text element.

        @return @c true if this XMLToken is an XML text element, @c false otherwise.
          

        """
        return _libsbml.XMLToken_isText(self)

    def setEnd(self):
        """
        setEnd(self) -> int

        Declares this XML start element is also an end element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
          

        """
        return _libsbml.XMLToken_setEnd(self)

    def setEOF(self):
        """
        setEOF(self) -> int

        Declares this XMLToken is an end-of-file (input) marker.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
          

        """
        return _libsbml.XMLToken_setEOF(self)

    def unsetEnd(self):
        """
        unsetEnd(self) -> int

        Declares this XML start/end element is no longer an end element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
          

        """
        return _libsbml.XMLToken_unsetEnd(self)

    def toString(self):
        """
        toString(self) -> string

        Prints a string representation of the underlying token stream, for
        debugging purposes.
          

        """
        return _libsbml.XMLToken_toString(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLToken_swigregister = _libsbml.XMLToken_swigregister
XMLToken_swigregister(XMLToken)

class XMLNode(XMLToken):
    """
    Representation of a node in an XML document tree.

    Beginning with version 3.0.0, libSBML implements an XML abstraction
    layer.  This layer presents a uniform XML interface to calling programs
    regardless of which underlying XML parser libSBML has actually been
    configured to use.  The basic data object in the XML abstraction is a
    @em node, represented by XMLNode.

    An XMLNode can contain any number of children.  Each child is another
    XMLNode, thereby forming a tree.  The methods XMLNode::getNumChildren()
    and @if clike XMLNode::getChild() can be used to access the
    tree structure starting from a given node. @endif@if java XMLNode::getChild(long n)
    can be used to access the tree structure starting from a given node.
    @endif

    Each XMLNode is subclassed from XMLToken, and thus has the same methods
    available as XMLToken.  These methods include XMLToken::getNamespaces(),
    XMLToken::getPrefix(), XMLToken::getName(), XMLToken::getURI(), and
    XMLToken::getAttributes().

    @section xmlnode-str2xmlnode Conversion between an XML string and an XMLNode

    LibSBML provides the following utility functions for converting an XML string 
    (e.g., &lt;annotation&gt;...&lt;/annotation&gt;) to/from an XMLNode object.
    <ul>
    <li> XMLNode::toXMLString() returns a string representation of the XMLNode object. 

    <li> XMLNode::convertXMLNodeToString() (static function) returns a string representation 
    of the given XMLNode object.

    <li> XMLNode::convertStringToXMLNode() (static function) returns an XMLNode object converted 
    from the given XML string.
    </ul>

    The returned XMLNode object by XMLNode::convertStringToXMLNode() is a dummy root 
    (container) XMLNode if the given XML string has two or more top-level elements 
    (e.g., '&lt;p&gt;...&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;'). In the dummy root node, each top-level element in 
    the given XML string is contained as a child XMLNode. XMLToken::isEOF() can be used 
    to identify if the returned XMLNode object is a dummy node or not. 
    Here is an example:
    @if clike   @verbatim
     // Checks if the returned XMLNode object by XMLNode::convertStringToXMLNode() is a dummy root node:
                                                                                              
     std::string str = '...'; 
     XMLNode* xn = XMLNode::convertStringToXMLNode(str);                                      
     if (!xn)
     {                                                                                      
       // returned value is null (error)                                                    
       ...
     }                                                                                      
     else if ( xn->isEOF() )                                                                 
     {                                                                                      
       // root node is a dummy node                                                         
       for (int i=0; i < xn->getNumChildren(); i++)                                          
       {                                                                                    
         // access to each child node of the dummy node.                                    
         XMLNode& xnChild = xn->getChild(i);                                                  
         ...                                                                                
       }                                                                                    
     }                                                                                      
     else                                                                                   
     {                                                                                      
       // root node is NOT a dummy node                                                     
       ...                                                                                  
     }
     @endverbatim @endif@if java   @verbatim
     // Checks if the returned XMLNode object by XMLNode::convertStringToXMLNode() is a dummy root node:

     String str = '...';
     XMLNode xn = XMLNode.convertStringToXMLNode(str);
     if (xn == null)
     {
       // returned value is null (error)
       ...
     }
     else if ( xn.isEOF() )
     {
       // root node is a dummy node
       for (int i=0; i < xn.getNumChildren(); i++)
       {
         // access to each child node of the dummy node.
         XMLNode xnChild = xn.getChild(i);
         ...
       }
     }
     else
     {
       // root node is NOT a dummy node
       ...
     }
     @endverbatim @endif


    """
    __swig_setmethods__ = {}
    for _s in [XMLToken]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLNode, name, value)
    __swig_getmethods__ = {}
    for _s in [XMLToken]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, XMLNode, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLNode
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLNode
        __init__(self, XMLToken token) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0, unsigned int column = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, 
            unsigned int column = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes) -> XMLNode
        __init__(self, XMLTriple triple, unsigned int line = 0, unsigned int column = 0) -> XMLNode
        __init__(self, XMLTriple triple, unsigned int line = 0) -> XMLNode
        __init__(self, XMLTriple triple) -> XMLNode
        __init__(self, string chars, unsigned int line = 0, unsigned int column = 0) -> XMLNode
        __init__(self, string chars, unsigned int line = 0) -> XMLNode
        __init__(self, string chars) -> XMLNode
        __init__(self, XMLNode orig) -> XMLNode

        Copy constructor; creates a copy of this XMLNode.

        @param orig the XMLNode instance to copy.
          

        """
        this = _libsbml.new_XMLNode(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLNode

        Creates and returns a deep copy of this XMLNode.

        @return a (deep) copy of this XMLNode.
          

        """
        return _libsbml.XMLNode_clone(self)

    def addChild(self, *args):
        """
        addChild(self, XMLNode node) -> int

        Adds a copy of @p node as a child of this XMLNode.

        The given @p node is added at the end of the list of children.

        @param node the XMLNode to be added as child.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink

        @note The given node is added at the end of the children list.
          

        """
        return _libsbml.XMLNode_addChild(self, *args)

    def insertChild(self, *args):
        """
        insertChild(self, unsigned int n, XMLNode node) -> XMLNode

        Inserts a copy of the given node as the <code>n</code>th child of this
        XMLNode.

        If the given index @p n is out of range for this XMLNode instance,
        the @p node is added at the end of the list of children.  Even in
        that situation, this method does not throw an error.

        @param n an integer, the index at which the given node is inserted
        @param node an XMLNode to be inserted as <code>n</code>th child.

        @return a reference to the newly-inserted child @p node
          

        """
        return _libsbml.XMLNode_insertChild(self, *args)

    def removeChild(self, *args):
        """
        removeChild(self, unsigned int n) -> XMLNode

        Removes the <code>n</code>th child of this XMLNode and returns the
        removed node.

        It is important to keep in mind that a given XMLNode may have more
        than one child.  Calling this method erases all existing references to
        child nodes @em after the given position @p n.  If the index @p n is
        greater than the number of child nodes in this XMLNode, this method
        takes no action (and returns @c NULL).

        @param n an integer, the index of the node to be removed

        @return the removed child, or @c NULL if @p n is greater than the number
        of children in this node

        @note The caller owns the returned node and is responsible for deleting it.
          

        """
        return _libsbml.XMLNode_removeChild(self, *args)

    def removeChildren(self):
        """
        removeChildren(self) -> int

        Removes all children from this node.
        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.XMLNode_removeChildren(self)

    def getChild(self, *args):
        """
        getChild(self, unsigned int n) -> XMLNode
        getChild(self, unsigned int n) -> XMLNode

        Returns the  <code>n</code>th child of this XMLNode.

        If the index @p n is greater than the number of child nodes, or it is
        0 or less, this method returns an empty node.

        @param n an integer, the index of the node to return

        @return the  <code>n</code>th child of this XMLNode.
          

        """
        return _libsbml.XMLNode_getChild(self, *args)

    def getNumChildren(self):
        """
        getNumChildren(self) -> unsigned int

        Returns the number of children for this XMLNode.

        @return the number of children for this XMLNode.
          

        """
        return _libsbml.XMLNode_getNumChildren(self)

    def toXMLString(self):
        """
        toXMLString(self) -> string

        Returns a string representation of this XMLNode. 

        @return a string derived from this XMLNode.
          

        """
        return _libsbml.XMLNode_toXMLString(self)

    def convertXMLNodeToString(*args):
        """
        convertXMLNodeToString(XMLNode node) -> string

        Returns a string representation of a given XMLNode. 

        @param node the XMLNode to be represented as a string

        @return a string-form representation of @p node
          

        """
        return _libsbml.XMLNode_convertXMLNodeToString(*args)

    if _newclass:convertXMLNodeToString = staticmethod(convertXMLNodeToString)
    __swig_getmethods__["convertXMLNodeToString"] = lambda x: convertXMLNodeToString
    def convertStringToXMLNode(*args):
        """
        convertStringToXMLNode(string xmlstr, XMLNamespaces xmlns = None) -> XMLNode
        convertStringToXMLNode(string xmlstr) -> XMLNode

        Returns an XMLNode which is derived from a string containing XML
        content.

        The XML namespace must be defined using argument @p xmlns if the
        corresponding XML namespace attribute is not part of the string of the
        first argument.

        @param xmlstr string to be converted to a XML node.
        @param xmlns XMLNamespaces the namespaces to set (default value is @c NULL).

        @note The caller owns the returned XMLNode and is reponsible for deleting it.
        The returned XMLNode object is a dummy root (container) XMLNode if the top-level 
        element in the given XML string is NOT @p html, @p body, @p annotation, @p notes.
        In the dummy root node, each top-level element in the given XML string is contained
        as a child XMLNode. XMLToken::isEOF() can be used to identify if the returned XMLNode 
        object is a dummy node.

        @return a XMLNode which is converted from string @p xmlstr. @c NULL is returned
        if the conversion failed. 


        @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
          

        """
        return _libsbml.XMLNode_convertStringToXMLNode(*args)

    if _newclass:convertStringToXMLNode = staticmethod(convertStringToXMLNode)
    __swig_getmethods__["convertStringToXMLNode"] = lambda x: convertStringToXMLNode
XMLNode_swigregister = _libsbml.XMLNode_swigregister
XMLNode_swigregister(XMLNode)

def XMLNode_convertXMLNodeToString(*args):
  """
    XMLNode_convertXMLNodeToString(XMLNode node) -> string

    Returns a string representation of a given XMLNode. 

    @param node the XMLNode to be represented as a string

    @return a string-form representation of @p node
      

    """
  return _libsbml.XMLNode_convertXMLNodeToString(*args)

def XMLNode_convertStringToXMLNode(*args):
  """
    convertStringToXMLNode(string xmlstr, XMLNamespaces xmlns = None) -> XMLNode
    XMLNode_convertStringToXMLNode(string xmlstr) -> XMLNode

    Returns an XMLNode which is derived from a string containing XML
    content.

    The XML namespace must be defined using argument @p xmlns if the
    corresponding XML namespace attribute is not part of the string of the
    first argument.

    @param xmlstr string to be converted to a XML node.
    @param xmlns XMLNamespaces the namespaces to set (default value is @c NULL).

    @note The caller owns the returned XMLNode and is reponsible for deleting it.
    The returned XMLNode object is a dummy root (container) XMLNode if the top-level 
    element in the given XML string is NOT @p html, @p body, @p annotation, @p notes.
    In the dummy root node, each top-level element in the given XML string is contained
    as a child XMLNode. XMLToken::isEOF() can be used to identify if the returned XMLNode 
    object is a dummy node.

    @return a XMLNode which is converted from string @p xmlstr. @c NULL is returned
    if the conversion failed. 


    @if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif
      

    """
  return _libsbml.XMLNode_convertStringToXMLNode(*args)

class XMLTriple(_object):
    """
    Representation of a qualified XML name.

    @htmlinclude not-sbml-warning.html

    A 'triple' in the libSBML XML layer encapsulates the notion of qualified
    name, meaning an element name or an attribute name with an optional
    namespace qualifier.  An XMLTriple instance carries up to three data items:

    <ul>

    <li> The name of the attribute or element; that is, the attribute name
    as it appears in an XML document or data stream;

    <li> The XML namespace prefix (if any) of the attribute.  For example,
    in the following fragment of XML, the namespace prefix is the string
    <code>mysim</code> and it appears on both the element
    <code>someelement</code> and the attribute <code>attribA</code>.  When
    both the element and the attribute are stored as XMLTriple objects,
    their <i>prefix</i> is <code>mysim</code>.
      @verbatim
     <mysim:someelement mysim:attribA='value' />
     @endverbatim

    <li> The XML namespace URI with which the prefix is associated.  In
    XML, every namespace used must be declared and mapped to a URI.

    </ul>

    XMLTriple objects are the lowest-level data item in the XML layer
    of libSBML.  Other objects such as XMLToken make use of XMLTriple
    objects.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLTriple, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLTriple, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> XMLTriple
        __init__(self, string name, string uri, string prefix) -> XMLTriple
        __init__(self, string triplet, char sepchar = ' ') -> XMLTriple
        __init__(self, string triplet) -> XMLTriple
        __init__(self, XMLTriple orig) -> XMLTriple

        Copy constructor; creates a copy of this XMLTriple set.
          

        """
        this = _libsbml.new_XMLTriple(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLTriple

        Creates and returns a deep copy of this XMLTriple set.

        @return a (deep) copy of this XMLTriple set.
          

        """
        return _libsbml.XMLTriple_clone(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the @em name portion of this XMLTriple.

        @return a string, the name from this XMLTriple.
          

        """
        return _libsbml.XMLTriple_getName(self)

    def getPrefix(self):
        """
        getPrefix(self) -> string

        Returns the @em prefix portion of this XMLTriple.

        @return a string, the @em prefix portion of this XMLTriple.
          

        """
        return _libsbml.XMLTriple_getPrefix(self)

    def getURI(self):
        """
        getURI(self) -> string

        Returns the @em URI portion of this XMLTriple.

        @return URI a string, the @em prefix portion of this XMLTriple.
          

        """
        return _libsbml.XMLTriple_getURI(self)

    def getPrefixedName(self):
        """
        getPrefixedName(self) -> string

        Returns the prefixed name from this XMLTriple.

        @return a string, the prefixed name from this XMLTriple.
          

        """
        return _libsbml.XMLTriple_getPrefixedName(self)

    def isEmpty(self):
        """
        isEmpty(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this XMLTriple is empty.

        @return @c true if this XMLTriple is empty, @c false otherwise.
        @deprecated libSBML internal


        """
        return _libsbml.XMLTriple_isEmpty(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

    __swig_destroy__ = _libsbml.delete_XMLTriple
    __del__ = lambda self : None;
XMLTriple_swigregister = _libsbml.XMLTriple_swigregister
XMLTriple_swigregister(XMLTriple)

class XMLOutputStream(_object):
    """
    @if java @deprecated libSBML internal @endif

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLOutputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLOutputStream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ostream stream, string encoding = "UTF-8", bool writeXMLDecl = True, 
            string programName = "", string programVersion = "") -> XMLOutputStream
        __init__(self, ostream stream, string encoding = "UTF-8", bool writeXMLDecl = True, 
            string programName = "") -> XMLOutputStream
        __init__(self, ostream stream, string encoding = "UTF-8", bool writeXMLDecl = True) -> XMLOutputStream
        __init__(self, ostream stream, string encoding = "UTF-8") -> XMLOutputStream
        __init__(self, ostream stream) -> XMLOutputStream

        Unitialized XMLOutputStreams may only be created by subclasses.
        @deprecated libSBML internal


        """
        this = _libsbml.new_XMLOutputStream(*args)
        try: self.this.append(this)
        except: self.this = this
    def endElement(self, *args):
        """
        endElement(self, string name)
        endElement(self, XMLTriple triple)

        Writes the given XML end element 'prefix:name' to this
        XMLOutputStream.
          

        """
        return _libsbml.XMLOutputStream_endElement(self, *args)

    def setAutoIndent(self, *args):
        """
        setAutoIndent(self, bool indent)

        Turns automatic indentation on or off for this XMLOutputStream.
          

        """
        return _libsbml.XMLOutputStream_setAutoIndent(self, *args)

    def startElement(self, *args):
        """
        startElement(self, string name)
        startElement(self, XMLTriple triple)

        Writes the given XML start element 'prefix:name' to this
        XMLOutputStream.
          

        """
        return _libsbml.XMLOutputStream_startElement(self, *args)

    def startEndElement(self, *args):
        """
        startEndElement(self, string name)
        startEndElement(self, XMLTriple triple)

        Writes the given XML start and end element 'prefix:name' to this
        XMLOutputStream.
          

        """
        return _libsbml.XMLOutputStream_startEndElement(self, *args)

    def writeAttribute(self, *args):
        """
        writeAttribute(self, string name, string value)
        writeAttribute(self, XMLTriple triple, string value)
        writeAttribute(self, string name, bool value)
        writeAttribute(self, XMLTriple triple, bool value)
        writeAttribute(self, string name, double value)
        writeAttribute(self, XMLTriple triple, double value)
        writeAttribute(self, string name, long value)
        writeAttribute(self, XMLTriple triple, long value)
        writeAttribute(self, string name, int value)
        writeAttribute(self, XMLTriple triple, int value)

        Writes the given attribute, prefix:name='value' to this
        XMLOutputStream.
          

        """
        if type(args[1]) == type(True): return _libsbml.XMLOutputStream_writeAttributeBool(self, *args)


        return _libsbml.XMLOutputStream_writeAttribute(self, *args)

    def writeXMLDecl(self):
        """
        writeXMLDecl(self)

        Writes the XML declaration:
        <?xml version='1.0' encoding='...'?>
          

        """
        return _libsbml.XMLOutputStream_writeXMLDecl(self)

    def writeComment(self, *args):
        """
        writeComment(self, string programName, string programVersion)

        Writes an XML comment:
        <?xml version='1.0' encoding='...'?>
          

        """
        return _libsbml.XMLOutputStream_writeComment(self, *args)

    def downIndent(self):
        """
        downIndent(self)

        Decreases the indentation level for this XMLOutputStream.
          

        """
        return _libsbml.XMLOutputStream_downIndent(self)

    def upIndent(self):
        """
        upIndent(self)

        Increases the indentation level for this XMLOutputStream.
          

        """
        return _libsbml.XMLOutputStream_upIndent(self)

    def writeAttributeBool(self, *args):
        """
        writeAttributeBool(self, string name, bool value)
        writeAttributeBool(self, XMLTriple name, bool value)
        """
        return _libsbml.XMLOutputStream_writeAttributeBool(self, *args)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

    __swig_destroy__ = _libsbml.delete_XMLOutputStream
    __del__ = lambda self : None;
XMLOutputStream_swigregister = _libsbml.XMLOutputStream_swigregister
XMLOutputStream_swigregister(XMLOutputStream)

XMLUnknownError = _libsbml.XMLUnknownError
XMLOutOfMemory = _libsbml.XMLOutOfMemory
XMLFileUnreadable = _libsbml.XMLFileUnreadable
XMLFileUnwritable = _libsbml.XMLFileUnwritable
XMLFileOperationError = _libsbml.XMLFileOperationError
XMLNetworkAccessError = _libsbml.XMLNetworkAccessError
InternalXMLParserError = _libsbml.InternalXMLParserError
UnrecognizedXMLParserCode = _libsbml.UnrecognizedXMLParserCode
XMLTranscoderError = _libsbml.XMLTranscoderError
MissingXMLDecl = _libsbml.MissingXMLDecl
MissingXMLEncoding = _libsbml.MissingXMLEncoding
BadXMLDecl = _libsbml.BadXMLDecl
BadXMLDOCTYPE = _libsbml.BadXMLDOCTYPE
InvalidCharInXML = _libsbml.InvalidCharInXML
BadlyFormedXML = _libsbml.BadlyFormedXML
UnclosedXMLToken = _libsbml.UnclosedXMLToken
InvalidXMLConstruct = _libsbml.InvalidXMLConstruct
XMLTagMismatch = _libsbml.XMLTagMismatch
DuplicateXMLAttribute = _libsbml.DuplicateXMLAttribute
UndefinedXMLEntity = _libsbml.UndefinedXMLEntity
BadProcessingInstruction = _libsbml.BadProcessingInstruction
BadXMLPrefix = _libsbml.BadXMLPrefix
BadXMLPrefixValue = _libsbml.BadXMLPrefixValue
MissingXMLRequiredAttribute = _libsbml.MissingXMLRequiredAttribute
XMLAttributeTypeMismatch = _libsbml.XMLAttributeTypeMismatch
XMLBadUTF8Content = _libsbml.XMLBadUTF8Content
MissingXMLAttributeValue = _libsbml.MissingXMLAttributeValue
BadXMLAttributeValue = _libsbml.BadXMLAttributeValue
BadXMLAttribute = _libsbml.BadXMLAttribute
UnrecognizedXMLElement = _libsbml.UnrecognizedXMLElement
BadXMLComment = _libsbml.BadXMLComment
BadXMLDeclLocation = _libsbml.BadXMLDeclLocation
XMLUnexpectedEOF = _libsbml.XMLUnexpectedEOF
BadXMLIDValue = _libsbml.BadXMLIDValue
BadXMLIDRef = _libsbml.BadXMLIDRef
UninterpretableXMLContent = _libsbml.UninterpretableXMLContent
BadXMLDocumentStructure = _libsbml.BadXMLDocumentStructure
InvalidAfterXMLContent = _libsbml.InvalidAfterXMLContent
XMLExpectedQuotedString = _libsbml.XMLExpectedQuotedString
XMLEmptyValueNotPermitted = _libsbml.XMLEmptyValueNotPermitted
XMLBadNumber = _libsbml.XMLBadNumber
XMLBadColon = _libsbml.XMLBadColon
MissingXMLElements = _libsbml.MissingXMLElements
XMLContentEmpty = _libsbml.XMLContentEmpty
XMLErrorCodesUpperBound = _libsbml.XMLErrorCodesUpperBound
LIBSBML_CAT_INTERNAL = _libsbml.LIBSBML_CAT_INTERNAL
LIBSBML_CAT_SYSTEM = _libsbml.LIBSBML_CAT_SYSTEM
LIBSBML_CAT_XML = _libsbml.LIBSBML_CAT_XML
LIBSBML_SEV_INFO = _libsbml.LIBSBML_SEV_INFO
LIBSBML_SEV_WARNING = _libsbml.LIBSBML_SEV_WARNING
LIBSBML_SEV_ERROR = _libsbml.LIBSBML_SEV_ERROR
LIBSBML_SEV_FATAL = _libsbml.LIBSBML_SEV_FATAL
class XMLError(_object):
    """
    Representation of errors, warnings and other diagnostics

    @htmlinclude not-sbml-warning.html

    LibSBML can be configured to use any of a number of XML parsers; at the
    time of this writing, libSBML supports Xerces versions 2.4 through 3.0,
    Expat version 1.95.x and higher, and libxml2 version 2.6.16 and higher.
    These parsers each report different status codes for the various
    exceptions that can occur during XML processing.  The XMLError object
    class abstracts away from the particular diagnostics reported by the
    different parsers and presents a single uniform interface and set of
    status codes, along with operations for manipulating the error objects.

    When the libSBML XML parser layer encounters an error in the XML content
    being processed, or when there is something else wrong (such as an
    out-of-memory condition), the problems are reported as XMLError objects.
    Each XMLError object instance has an identification number that
    identifies the nature of the problem.
    @if clike This error identifier will be up to five digits 
    long and drawn from the enumeration <a class='el'
    href='#XMLErrorCode_t'>XMLErrorCode_t</a>.  Applications can use the
    error identifiers as a means of recognizing the error encountered and
    changing their behavior if desired. @endif@if java This
    error identifier is one of the constants listed in the next section below.
    Applications can use the error identifiers as a means of recognizing the
    error encountered and changing their behavior if desired.  @endif

    Integer error codes are useful for software, but not so much for telling
    humans what happened.  For this reason, XMLError also provides two text
    messages describing the nature of the error.  These messages are
    accessible by means of the methods XMLError::getShortMessage() and
    XMLError::getMessage().  The method XMLError::getShortMessage() returns
    a very brief synopsis of the warning or error condition, whereas
    XMLError::getMessage() returns a longer explanation.  These text strings
    are suitable for displaying to human users.

    Each XMLError object also contains a category code; its value may be
    retrieved using the method XMLError::getCategory().  Category values
    are @if clike drawn from the enumeration
    <a class='el' href='#XMLErrorCategory_t'>XMLErrorCategory_t</a> 
    described below.  Categories are used by libSBML to provide more
    information to calling programs about the nature of a given
    error. @endif@if java drawn from a set of constants whose
    names begin with the characters @c LIBSBML_CAT_.  The list of possible
    codes is described in a separate section below. Categories are used by
    libSBML to provide more information to calling programs about the nature
    of a given error.  @endif

    In addition to category codes, each XMLError object also has a severity
    code; its value may be retrieved using the method
    XMLError::getSeverity().  Severity code values are 
    @if clike drawn from the enumeration 
    <a class='el' href='#XMLErrorSeverity_t'>XMLErrorSeverity_t</a> described
    in a separate section below.  Severity levels range from informational
    (@c LIBSBML_SEV_INFO) to fatal errors (@c LIBSBML_SEV_FATAL).
    @endif@if java drawn from a
    set of constants whose names begin with the characters @c LIBSBML_SEV_.
    The list of possible severity codes is described in a separate section
    below.  Severity levels range from informational (@c LIBSBML_SEV_INFO)
    to fatal errors (@c LIBSBML_SEV_FATAL). @endif

    Finally, XMLError objects record the line and column near where the
    problem occurred in the XML content.  The values can be retrieved using
    the methods XMLError::getLine() and XMLError::getColumn().  We say 'near
    where the problem occurred', because many factors affect how accurate
    the line/column information ultimately is.  For example, different XML
    parsers have different conventions for which line and column number they
    report for a particular problem (which in turn makes a difference when a
    problem involves an opening XML tag on one line and a closing tag on
    another line).  In some situations, some parsers report invalid line
    and/or column numbers altogether.  If this occurs, libSBML sets the line
    and/or column number in the XMLError object to the the value of the
    maximum unsigned long integer representable on the platform where
    libSBML is running.  (This is equal to the constant named
    <code>ULONG_MAX</code> in C and C++.)  The probability that a true line
    or column number in an SBML model would equal this value is vanishingly
    small; thus, if an application encounters these values in an XMLError
    object, it can assume no valid line/column number could be provided by
    libSBML in that situation.


    @if clike
    <h3><a class='anchor' name='XMLErrorCode_t'>XMLErrorCode_t</a></h3>

    This is an enumeration of all the error and warning codes returned by
    the XML layer in libSBML.  Each code is an integer with a 4-digit value
    less than 10000.  The following table lists each possible value and a
    brief description of its meaning.
    @endif@if java <h3><a class='anchor' 
    name='XMLErrorCode_t'>Error codes associated with XMLError objects</a></h3>

    The error and warning codes returned by the XML layer in libSBML are
    listed in the table below.  In the libSBML Java language interface,
    these error identifiers are currently (in libSBML 3.3.x) implemented as
    static integer constants defined in the interface class <code><a
    href='libsbmlConstants.html'>libsbmlConstants</a></code>.  This is admittedly
    not an ideal approach from the standpoint of modern Java programming,
    but it was necessary to work around the lack of enumerations in Java
    prior to JDK 1.5.  Future versions of libSBML may use a proper Java
    enumeration type to define the error identifiers. @endif

    <center>
    <table cellspacing='1' cellpadding='1' border='0' class='text-table width80 normal-font alt-row-colors'>
    <caption>Possible XMLError error codes.  Depending on the programming
    language in use, the <em>Enumerator</em> values will be defined either
    as a value from the enumeration XMLErrorCode_t or as integer constants.
    To make this table more compact, we have shortened the identifiers for
    the category and severity codes to their essential parts.  To get the
    actual names of the constants, prepend <code>LIBSBML_CAT_</code> to the
    category names and <code>LIBSBML_SEV_</code> to the severity names
    shown in the two right-hand columns.
    </caption>
     <tr style='background: lightgray' class='normal-font'>
         <th>Enumerator</th>
         <th>Meaning</th>
         <th width='90'>Category</th>
         <th width='90'>Severity</th>
     </tr>
    <tr><td><code>XMLUnknownError</code></td><td>Unrecognized error encountered internally</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td><code>XMLOutOfMemory</code></td> <td>Out of memory</td><td>SYSTEM</td><td>FATAL</td></tr>
    <tr><td><code>XMLFileUnreadable</code></td> <td>File unreadable</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td><code>XMLFileUnwritable</code></td> <td>File unwritable</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td><code>XMLFileOperationError</code></td><td>Error encountered while attempting file operation</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td><code>XMLNetworkAccessError</code></td><td>Network access error</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td><code>InternalXMLParserError</code></td><td>Internal XML parser state error</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td><code>UnrecognizedXMLParserCode</code></td><td>XML parser returned an unrecognized error code</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td><code>XMLTranscoderError</code></td><td>Character transcoder error</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td><code>MissingXMLDecl</code></td><td>Missing XML declaration at beginning of XML input</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>MissingXMLEncoding</code></td><td>Missing encoding attribute in XML declaration</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLDecl</code></td><td>Invalid or unrecognized XML declaration or XML encoding</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLDOCTYPE</code></td><td>Invalid, malformed or unrecognized XML DOCTYPE declaration</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>InvalidCharInXML</code></td><td>Invalid character in XML content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadlyFormedXML</code></td><td>XML content is not well-formed</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>UnclosedXMLToken</code></td><td>Unclosed XML token</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>InvalidXMLConstruct</code></td><td>XML construct is invalid or not permitted</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLTagMismatch</code></td><td>Element tag mismatch or missing tag</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>DuplicateXMLAttribute</code></td><td>Duplicate XML attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>UndefinedXMLEntity</code></td><td>Undefined XML entity</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadProcessingInstruction</code></td><td>Invalid, malformed or unrecognized XML processing instruction</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLPrefix</code></td><td>Invalid or undefined XML namespace prefix</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLPrefixValue</code></td><td>Invalid XML namespace prefix value</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>MissingXMLRequiredAttribute</code></td><td>Missing a required XML attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLAttributeTypeMismatch</code></td><td>Data type mismatch for the value of an attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLBadUTF8Content</code></td><td>Invalid UTF8 content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>MissingXMLAttributeValue</code></td><td>Missing or improperly formed attribute value</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLAttributeValue</code></td><td>Invalid or unrecognizable attribute value</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLAttribute</code></td><td>Invalid, unrecognized or malformed attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>UnrecognizedXMLElement</code></td><td>Element either not recognized or not permitted</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLComment</code></td><td>Badly formed XML comment</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLDeclLocation</code></td><td>XML declaration not permitted in this location</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLUnexpectedEOF</code></td><td>Reached end of input unexpectedly</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLIDValue</code></td><td>Value is invalid for XML ID, or has already been used</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLIDRef</code></td><td>XML ID value was never declared</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>UninterpretableXMLContent</code></td><td>Unable to interpret content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>BadXMLDocumentStructure</code></td><td>Bad XML document structure</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>InvalidAfterXMLContent</code></td><td>Encountered invalid content after expected content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLExpectedQuotedString</code></td><td>Expected to find a quoted string</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLEmptyValueNotPermitted</code></td><td>An empty value is not permitted in this context</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLBadNumber</code></td><td>Invalid or unrecognized number</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLBadColon</code></td><td>Colon characters are invalid in this context</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>MissingXMLElements</code></td><td>One or more expected elements are missing</td><td>XML</td><td>ERROR</td></tr>
    <tr><td><code>XMLContentEmpty</code></td><td>Main XML content is empty</td><td>XML</td><td>ERROR</td></tr>
    </table>
    </center>


    @if clike
    <h3><a class='anchor' name='XMLErrorCategory_t'>XMLErrorCategory_t</a></h3>

    As discussed above, each XMLError object contains a value for a category
    identifier, describing the type of issue that the XMLError object
    represents.  The category can be retrieved from an XMLError object using
    the method XMLError::getCategory().  The value is chosen from the
    enumeration of category codes <a class='el' href='#XMLErrorCategory_t'>
    XMLErrorCategory_t</a>.  The following table
    lists each possible value and a brief description of its meaning.
    @endif@if java <h3><a class='anchor'
    name='XMLErrorCategory_t'>Category codes associated with XMLError objects</a></h3>

    As discussed above, each XMLError object contains a value for a category
    identifier, describing the type of issue that the XMLError object represents.
    The category can be retrieved from an XMLError object using the method
    XMLError::getCategory(). The following table lists each possible value
    and a brief description of its meaning.

    As is the case with the error codes, in the libSBML Java language
    interface, the category identifiers are currently implemented as static
    integer constants defined in the interface class
    <code>libsbmlConstants</code> in the file '<a
    href='libsbmlConstants.html'>libsbmlConstants.java</a>'.
    @endif

    <center>
    <table width='90%' cellspacing='1' cellpadding='1' border='0' class='text-table width80 normal-font alt-row-colors'>
     <tr style='background: lightgray' class='normal-font'>
         <th>Enumerator</th>
         <th>Meaning</th>
     </tr>
    <tr><td><em>LIBSBML_CAT_INTERNAL</em></td><td>A problem involving the libSBML
    software itself or the underlying XML parser.  This almost certainly
    indicates a software defect (i.e., bug) in libSBML.  Please report
    instances of this to the libSBML developers.</td></tr>
    <tr><td><em>LIBSBML_CAT_SYSTEM</em></td><td>A problem reported by the operating
    system, such as an inability to read or write a file.  This indicates
    something that is not a program error but is outside of the control of
    libSBML.</td></tr>
    <tr><td><em>LIBSBML_CAT_XML</em></td><td>A problem in the XML content itself.  This
    usually arises from malformed XML or the use of
    constructs not permitted in SBML.</td></tr>
    </table>
    </center>


    @if clike
    <h3><a class='anchor' name='XMLErrorSeverity_t'>XMLErrorSeverity_t</a></h3>

    As described above, each XMLError object contains a value for a severity
    code, describing how critical is the issue that the XMLError object
    represents.  The severity can be retrieved from an XMLError object using
    the method XMLError::getSeverity().  The value is chosen from the
    enumeration of category codes <a class='el' href='#XMLErrorSeverity_t'>
    XMLErrorSeverity_t</a>.  The following table
    lists each possible value and a brief description of its meaning.
    @endif@if java <h3><a class='anchor'
    name='XMLErrorSeverity_t'>Severity codes associated with XMLError objects</a></h3>

    As described above, each XMLError object contains a value for a severity
    code, describing how severe is the issue that the XMLError object
    represents.  The severity be retrieved from an XMLError object using the
    method XMLError::getSeverity(). The following table lists each possible
    value and a brief description of its meaning.

    As is the case with the category codes, in the libSBML Java language
    interface, these severity codes are currently (in libSBML 3.3.x)
    implemented as static integer constants defined in the interface class
    <code>libsbmlConstants</code> in the file 'libsbmlConstants.java'.  This
    is admittedly not an ideal approach from the standpoint of modern Java
    programming, but it was necessary to work around the lack of
    enumerations in Java prior to JDK 1.5.  Future versions of libSBML may
    use a proper Java enumeration type to define the severity codes. @endif

    <center>
    <table width='90%' cellspacing='1' cellpadding='1' border='0' class='text-table width80 normal-font alt-row-colors'>
     <tr style='background: lightgray' class='normal-font'>
         <th>Enumerator</th>
         <th>Meaning</th>
     </tr>
    <tr><td><em>LIBSBML_SEV_INFO</em></td><td>The error is actually informational and
    not necessarily a serious problem.</td></tr>
    <tr><td><em>LIBSBML_SEV_WARNING</em></td><td>The error object represents a problem
    that is not serious enough to necessarily stop the problem, but
    applications should take note of the problem and evaluate what its
    implications may be.</td></tr>
    <tr><td><em>LIBSBML_SEV_ERROR</em></td><td>The error object represents a serious
    error.  The application may continue running but it is unlikely to be
    able to continue processing the same XML file or data stream.</td></tr>
    <tr><td><em>LIBSBML_SEV_FATAL</em></td><td>A serious error occurred, such as an
    out-of-memory condition, and the software should terminate
    immediately.</td></tr>
    </table>
    </center>

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL, 
            unsigned int category = LIBSBML_CAT_INTERNAL) -> XMLError
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL) -> XMLError
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0, 
            unsigned int column = 0) -> XMLError
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0) -> XMLError
        __init__(self, int errorId = 0, string details = "") -> XMLError
        __init__(self, int errorId = 0) -> XMLError
        __init__(self) -> XMLError
        __init__(self, XMLError orig) -> XMLError

        Copy constructor; creates a copy of this XMLError.
          

        """
        this = _libsbml.new_XMLError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_XMLError
    __del__ = lambda self : None;
    def getErrorId(self):
        """
        getErrorId(self) -> unsigned int

        Returns the identifier of this error.

        @return the id of this XMLError.

        @see getMessage()
        @see getShortMessage()
        @see getCategory()
        @see getSeverity()
          

        """
        return _libsbml.XMLError_getErrorId(self)

    def getMessage(self):
        """
        getMessage(self) -> string

        Returns the message text of this error.

        The message associated with an error object describes the nature of
        the problem.  The message returned by this method is generally longer
        and clearer than the message returned by XMLError::getShortMessage(),
        but not in all cases.

        Callers may use XMLError::getCategory() and XMLError::getSeverity() to
        obtain additional information about the nature and severity of the
        problem.

        @return the message text

        @see getErrorId()
        @see getShortMessage()
        @see getCategory()
        @see getSeverity()
          

        """
        return _libsbml.XMLError_getMessage(self)

    def getShortMessage(self):
        """
        getShortMessage(self) -> string

        Returns a brief message for this error.

        This is an alternative error message that, in general, is as short as
        the authors could make it.  However, brevity is often inversely
        proportional to clarity, so this short message may not be sufficiently
        informative to understand the nature of the error.  Calling
        applications may wish to check XMLError::getMessage() in addition or
        instead.

        @return the short error message text

        @see getErrorId()
        @see getMessage()
        @see getCategory()
        @see getSeverity()
          

        """
        return _libsbml.XMLError_getShortMessage(self)

    def getLine(self):
        """
        getLine(self) -> unsigned int

        Returns the line number in the XML input near where the error, warning
        or other diagnostic occurred.

        We say 'near where the problem occurred', because many factors affect
        how accurate the line/column information ultimately is.  For example,
        different XML parsers have different conventions for which line and
        column number they report for a particular problem (which in turn
        makes a difference when a problem involves an opening XML tag on one
        line and a closing tag on another line).  In some situations, some
        parsers report invalid line and/or column numbers altogether.  If this
        occurs, the line and/or column number in the XMLError object will be
        set to the the value of the maximum unsigned long integer
        representable on the platform where libSBML is running.  (This is
        equal to the constant named <code>ULONG_MAX</code> in C and C++.)  The
        probability that a true line or column number in an SBML model would
        equal this value is vanishingly small; thus, if an application
        encounters these values in an XMLError object, it can assume no valid
        line/column number could be provided by libSBML in that situation.

        @return the line number

        @see getColumn()
          

        """
        return _libsbml.XMLError_getLine(self)

    def getColumn(self):
        """
        getColumn(self) -> unsigned int

        Returns the column number in the XML input near where the error,
        warning or other diagnostic occurred.

        We say 'near where the problem occurred', because many factors affect
        how accurate the line/column information ultimately is.  For example,
        different XML parsers have different conventions for which line and
        column number they report for a particular problem (which in turn
        makes a difference when a problem involves an opening XML tag on one
        line and a closing tag on another line).  In some situations, some
        parsers report invalid line and/or column numbers altogether.  If this
        occurs, the line and/or column number in the XMLError object will be
        set to the the value of the maximum unsigned long integer
        representable on the platform where libSBML is running.  (This is
        equal to the constant named <code>ULONG_MAX</code> in C and C++.)  The
        probability that a true line or column number in an SBML model would
        equal this value is vanishingly small; thus, if an application
        encounters these values in an XMLError object, it can assume no valid
        line/column number could be provided by libSBML in that situation.

        @return the column number

        @see getLine()
          

        """
        return _libsbml.XMLError_getColumn(self)

    def getSeverity(self):
        """
        getSeverity(self) -> unsigned int

        Returns the severity of this error.

        XMLError defines an enumeration of severity codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own severity codes with numbers higher than those in the predefined
        set of severity codes.

        @return the severity of this XMLError.

        @see getSeverityAsString()
        @see getCategory()
          

        """
        return _libsbml.XMLError_getSeverity(self)

    def getSeverityAsString(self):
        """
        getSeverityAsString(self) -> string

        Returns a string describing the severity level of this error.

        XMLError defines an enumeration of severity codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own severity codes with numbers higher than those in the predefined
        set of severity codes.

        @return string representing the severity of this XMLError.

        @see getSeverity()
        @see getCategoryAsString()
          

        """
        return _libsbml.XMLError_getSeverityAsString(self)

    def getCategory(self):
        """
        getCategory(self) -> unsigned int

        Returns the category of this error.

        XMLError defines an enumeration of category codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own categories with numbers higher than those in the predefined
        set of category codes.

        Categories can be used to partition errors into distinct groups.
        Among other things, this can be used to prevent id conflicts by
        uniquely identifying an XMLError by both id and category.

        @return the category of this XMLError.

        @see getSeverity()
        @see getCategoryAsString()
          

        """
        return _libsbml.XMLError_getCategory(self)

    def getCategoryAsString(self):
        """
        getCategoryAsString(self) -> string

        Returns a string describing the category of this error.

        XMLError defines an enumeration of category codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own categories with numbers higher than those in the predefined
        set of category codes.

        Categories can be used to partition errors into distinct groups.
        Among other things, this can be used to prevent id conflicts by
        uniquely identifying an XMLError by both id and category.

        @return string representing the category of this XMLError.

        @see getCategory()
        @see getSeverityAsString()
          

        """
        return _libsbml.XMLError_getCategoryAsString(self)

    def isInfo(self):
        """
        isInfo(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        error object is for information purposes only.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError::getSeverity()) and then comparing it to the
        value <code>LIBSBML_SEV_INFO</code> from the
        @if clike enumeration
        #XMLErrorSeverity_t. @endif@if java set of predefined
        severity codes.@endif

        @return @c true if this XMLError is for informational purposes only,
        @c false otherwise.

        @see isWarning()
        @see isError()
        @see isFatal()
          

        """
        return _libsbml.XMLError_isInfo(self)

    def isWarning(self):
        """
        isWarning(self) -> bool

        Predicate returning @c true or @c false depending on whether 
        this error object is a warning.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError::getSeverity()) and then comparing it to the
        value <code>LIBSBML_SEV_WARNING</code> from the
        @if clike enumeration
        #XMLErrorSeverity_t. @endif@if java set of predefined
        severity codes.@endif

        @return @c true if this error is a warning, @c false otherwise.

        @see isInfo()
        @see isError()
        @see isFatal()
          

        """
        return _libsbml.XMLError_isWarning(self)

    def isError(self):
        """
        isError(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        error is a significant error.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError::getSeverity()) and then comparing it to the
        value <code>LIBSBML_SEV_ERROR</code> from the
        @if clike enumeration
        #XMLErrorSeverity_t. @endif@if java set of predefined
        severity codes.@endif

        @return @c true if this error is an error, @c false otherwise.

        @see isInfo()
        @see isWarning()
        @see isFatal()
          

        """
        return _libsbml.XMLError_isError(self)

    def isFatal(self):
        """
        isFatal(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        error is a fatal run-time error.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError::getSeverity()) and then comparing it to the
        value <code>LIBSBML_SEV_FATAL</code> from the
        @if clike enumeration
        #XMLErrorSeverity_t. @endif@if java set of predefined
        severity codes.@endif

        @return @c true if this error is a fatal error, @c false otherwise.

        @see isInfo()
        @see isWarning()
        @see isError()
          

        """
        return _libsbml.XMLError_isFatal(self)

    def isInternal(self):
        """
        isInternal(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        error resulted from an internal program error.

        This is equivalent to obtaining the category identifier from an
        XMLError object (via XMLError::getCategory()) and then comparing it to
        the value <code>LIBSBML_CAT_INTERNAL</code> from the
        @if clike
        enumeration #XMLErrorCategory_t. @endif@if java set of
        predefined category codes.@endif

        @return @c true or @c false

        @see isSystem()
        @see isXML()
          

        """
        return _libsbml.XMLError_isInternal(self)

    def isSystem(self):
        """
        isSystem(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        error was generated by the operating system.

        This is equivalent to obtaining the category identifier from an
        XMLError object (via XMLError::getCategory()) and then comparing it to
        the value <code>LIBSBML_CAT_SYSTEM</code> from the
        @if clike
        enumeration #XMLErrorCategory_t. @endif@if java set of
        predefined category codes.@endif

        @return @c true or @c false

        @see isInternal()
        @see isXML()
          

        """
        return _libsbml.XMLError_isSystem(self)

    def isXML(self):
        """
        isXML(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        error resulted from a problem in the XML input (e.g., an XML syntax
        error).

        This is equivalent to obtaining the category identifier from an
        XMLError object (via XMLError::getCategory()) and then comparing it to
        the value <code>LIBSBML_CAT_XML</code> from the
        @if clike
        enumeration #XMLErrorCategory_t. @endif@if java set of
        predefined category codes.@endif

        @return @c true or @c false

        @see isInternal()
        @see isSystem()
          

        """
        return _libsbml.XMLError_isXML(self)

    def setLine(self, *args):
        """
        setLine(self, unsigned int line) -> int

        Sets the line number where this error occurred.

        @param line an unsigned int, the line number to set.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see setColumn(unsigned int column)
          

        """
        return _libsbml.XMLError_setLine(self, *args)

    def setColumn(self, *args):
        """
        setColumn(self, unsigned int column) -> int

        Sets the column number where this error occurred.

        @param column an unsigned int, the column number to set.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see setLine(unsigned int line)
          

        """
        return _libsbml.XMLError_setColumn(self, *args)

    def getStandardMessage(*args):
        """
        getStandardMessage(int code) -> string

        Returns a copy of the message string associated with the given
        predefined XMLError code.

        @param code the error code whose message is sought; it must be a
        predefined value from @if clike <a class='el'
        href='#XMLErrorCode_t'>
        XMLErrorCode_t</a>. @endif@if java <a class='el'
        href='#XMLErrorCode_t'>the set of predefined error identifiers.@endif
          

        """
        return _libsbml.XMLError_getStandardMessage(*args)

    if _newclass:getStandardMessage = staticmethod(getStandardMessage)
    __swig_getmethods__["getStandardMessage"] = lambda x: getStandardMessage
    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLError_swigregister = _libsbml.XMLError_swigregister
XMLError_swigregister(XMLError)

def XMLError_getStandardMessage(*args):
  """
    XMLError_getStandardMessage(int code) -> string

    Returns a copy of the message string associated with the given
    predefined XMLError code.

    @param code the error code whose message is sought; it must be a
    predefined value from @if clike <a class='el'
    href='#XMLErrorCode_t'>
    XMLErrorCode_t</a>. @endif@if java <a class='el'
    href='#XMLErrorCode_t'>the set of predefined error identifiers.@endif
      

    """
  return _libsbml.XMLError_getStandardMessage(*args)

class XMLErrorLog(_object):
    """
    Log of errors and other events encountered while processing an XML
    file or data stream.

    @htmlinclude not-sbml-warning.html

    The error log is a list.  The XML layer of libSBML maintains an error
    log associated with a given XML document or data stream.  When an
    operation results in an error, or when there is something wrong with the
    XML content, the problem is reported as an XMLError object stored in the
    XMLErrorLog list.  Potential problems range from low-level issues (such
    as the inability to open a file) to XML syntax errors (such as
    mismatched tags or other problems).

    A typical approach for using this error log is to first use
    getNumErrors() to inquire how many XMLError object instances it
    contains, and then to iterate over the list of objects one at a time
    using getError(unsigned int n) const.  Indexing in the list begins at 0.

    In normal circumstances, programs using libSBML will actually obtain an
    SBMLErrorLog rather than an XMLErrorLog.  The former is subclassed from
    XMLErrorLog and simply wraps commands for working with SBMLError objects
    rather than the low-level XMLError objects.  Classes such as
    SBMLDocument use the higher-level SBMLErrorLog.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLErrorLog, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLErrorLog, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def getNumErrors(self):
        """
        getNumErrors(self) -> unsigned int

        Returns the number of errors that have been logged.

        To retrieve individual errors from the log, callers may use
        getError(unsigned int n) const.

        @return the number of errors that have been logged.
          

        """
        return _libsbml.XMLErrorLog_getNumErrors(self)

    def getError(self, *args):
        """
        getError(self, unsigned int n) -> XMLError

        Returns the <i>n</i>th XMLError object in this log.

        Index @p n is counted from 0.  Callers should first inquire about the
        number of items in the log by using the method getNumErrors().
        Attempts to use an error index number that exceeds the actual number
        of errors in the log will result in a @c NULL being returned.

        @param n the index number of the error to retrieve (with 0 being the
        first error).

        @return the <i>n</i>th XMLError in this log, or @c NULL if @p n is
        greater than or equal to getNumErrors().

        @see getNumErrors()
          

        """
        return _libsbml.XMLErrorLog_getError(self, *args)

    def clearLog(self):
        """
        clearLog(self)

        Deletes all errors from this log.
          

        """
        return _libsbml.XMLErrorLog_clearLog(self)

    __swig_destroy__ = _libsbml.delete_XMLErrorLog
    __del__ = lambda self : None;
    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLErrorLog_swigregister = _libsbml.XMLErrorLog_swigregister
XMLErrorLog_swigregister(XMLErrorLog)

class SBMLErrorLog(XMLErrorLog):
    """
    Log of errors and other events encountered during SBML processing.

    @htmlinclude not-sbml-warning.html

    The error log is a list.  Each SBMLDocument maintains its own
    SBMLErrorLog.  When a libSBML operation on SBML content results in an
    error, or when there is something worth noting about the SBML content,
    the issue is reported as an SBMLError object stored in the SBMLErrorLog
    list.

    SBMLErrorLog is derived from XMLErrorLog, an object class that serves
    exactly the same purpose but for the XML parsing layer.  XMLErrorLog
    provides crucial methods such as getNumErrors() for determining how many
    SBMLError or XMLError objects are in the log.  SBMLErrorLog inherits
    these methods.

    The general approach to working with SBMLErrorLog in user programs
    involves first obtaining a pointer to a log from a libSBML object such
    as SBMLDocument.  Callers should then use getNumErrors() to inquire how
    many objects there are in the list.  (The answer may be 0.)  If there is
    at least one SBMLError object in the SBMLErrorLog instance, callers can
    then iterate over the list using getError(unsigned int n) const, using
    methods provided by the SBMLError class to find out the error code and
    associated information such as the error severity, the message, and the
    line number in the input.

    If you wish to simply print the error strings for a human to read, an
    easier and more direct way might be to use SBMLDocument::printErrors().

    @see SBMLError
    @see XMLErrorLog
    @see XMLError

    """
    __swig_setmethods__ = {}
    for _s in [XMLErrorLog]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLErrorLog, name, value)
    __swig_getmethods__ = {}
    for _s in [XMLErrorLog]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLErrorLog, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def getError(self, *args):
        """
        getError(self, unsigned int n) -> SBMLError

        Returns the <i>n</i>th SBMLError object in this log.

        Index @p n is counted from 0.  Callers should first inquire about the
        number of items in the log by using the getNumErrors() method.  (This
        method is inherited from the parent class, XMLErrorLog).  Attempts to
        use an error index number that exceeds the actual number of errors in
        the log will result in a @c NULL being returned.

        @param n the index number of the error to retrieve (with 0 being the
        first error).

        @return the <i>n</i>th SBMLError in this log, or @c NULL if @p n is
        greater than or equal to getNumErrors().

        @see getNumErrors()
          

        """
        return _libsbml.SBMLErrorLog_getError(self, *args)

    def getNumFailsWithSeverity(self, *args):
        """
        getNumFailsWithSeverity(self, unsigned int severity) -> unsigned int

        Returns the number of errors that have been logged with the given
        severity code.

        LibSBML associates severity levels with every SBMLError object to
        provide an indication of how serious the problem is.  Severities range
        from informational diagnostics to fatal (irrecoverable) errors.  Given
        an SBMLError object instance, a caller can interrogate it for its
        severity level using methods such as SBMLError::getSeverity(),
        SBMLError::isFatal(), and so on.  The present method encapsulates
        iteration and interrogation of all objects in an SBMLErrorLog, making
        it easy to check for the presence of error objects with specific
        severity levels.

        @if clike @param severity a value from
        #SBMLErrorSeverity_t @endif@if java @param severity a
        value from the set of <code>LIBSBML_SEV_</code> constants defined by
        the interface class <code><a
        href='libsbmlConstants.html'>libsbmlConstants</a></code> @endif

        @return a count of the number of errors with the given severity code.

        @see getNumErrors()
          

        """
        return _libsbml.SBMLErrorLog_getNumFailsWithSeverity(self, *args)

    __swig_destroy__ = _libsbml.delete_SBMLErrorLog
    __del__ = lambda self : None;
SBMLErrorLog_swigregister = _libsbml.SBMLErrorLog_swigregister
SBMLErrorLog_swigregister(SBMLErrorLog)

UnknownError = _libsbml.UnknownError
NotUTF8 = _libsbml.NotUTF8
UnrecognizedElement = _libsbml.UnrecognizedElement
NotSchemaConformant = _libsbml.NotSchemaConformant
L3NotSchemaConformant = _libsbml.L3NotSchemaConformant
InvalidMathElement = _libsbml.InvalidMathElement
DisallowedMathMLSymbol = _libsbml.DisallowedMathMLSymbol
DisallowedMathMLEncodingUse = _libsbml.DisallowedMathMLEncodingUse
DisallowedDefinitionURLUse = _libsbml.DisallowedDefinitionURLUse
BadCsymbolDefinitionURLValue = _libsbml.BadCsymbolDefinitionURLValue
DisallowedMathTypeAttributeUse = _libsbml.DisallowedMathTypeAttributeUse
DisallowedMathTypeAttributeValue = _libsbml.DisallowedMathTypeAttributeValue
LambdaOnlyAllowedInFunctionDef = _libsbml.LambdaOnlyAllowedInFunctionDef
BooleanOpsNeedBooleanArgs = _libsbml.BooleanOpsNeedBooleanArgs
NumericOpsNeedNumericArgs = _libsbml.NumericOpsNeedNumericArgs
ArgsToEqNeedSameType = _libsbml.ArgsToEqNeedSameType
PiecewiseNeedsConsistentTypes = _libsbml.PiecewiseNeedsConsistentTypes
PieceNeedsBoolean = _libsbml.PieceNeedsBoolean
ApplyCiMustBeUserFunction = _libsbml.ApplyCiMustBeUserFunction
ApplyCiMustBeModelComponent = _libsbml.ApplyCiMustBeModelComponent
KineticLawParametersAreLocalOnly = _libsbml.KineticLawParametersAreLocalOnly
MathResultMustBeNumeric = _libsbml.MathResultMustBeNumeric
OpsNeedCorrectNumberOfArgs = _libsbml.OpsNeedCorrectNumberOfArgs
InvalidNoArgsPassedToFunctionDef = _libsbml.InvalidNoArgsPassedToFunctionDef
DisallowedMathUnitsUse = _libsbml.DisallowedMathUnitsUse
InvalidUnitsValue = _libsbml.InvalidUnitsValue
DuplicateComponentId = _libsbml.DuplicateComponentId
DuplicateUnitDefinitionId = _libsbml.DuplicateUnitDefinitionId
DuplicateLocalParameterId = _libsbml.DuplicateLocalParameterId
MultipleAssignmentOrRateRules = _libsbml.MultipleAssignmentOrRateRules
MultipleEventAssignmentsForId = _libsbml.MultipleEventAssignmentsForId
EventAndAssignmentRuleForId = _libsbml.EventAndAssignmentRuleForId
DuplicateMetaId = _libsbml.DuplicateMetaId
InvalidSBOTermSyntax = _libsbml.InvalidSBOTermSyntax
InvalidMetaidSyntax = _libsbml.InvalidMetaidSyntax
InvalidIdSyntax = _libsbml.InvalidIdSyntax
InvalidUnitIdSyntax = _libsbml.InvalidUnitIdSyntax
InvalidNameSyntax = _libsbml.InvalidNameSyntax
MissingAnnotationNamespace = _libsbml.MissingAnnotationNamespace
DuplicateAnnotationNamespaces = _libsbml.DuplicateAnnotationNamespaces
SBMLNamespaceInAnnotation = _libsbml.SBMLNamespaceInAnnotation
MultipleAnnotations = _libsbml.MultipleAnnotations
InconsistentArgUnits = _libsbml.InconsistentArgUnits
InconsistentKineticLawUnitsL3 = _libsbml.InconsistentKineticLawUnitsL3
AssignRuleCompartmentMismatch = _libsbml.AssignRuleCompartmentMismatch
AssignRuleSpeciesMismatch = _libsbml.AssignRuleSpeciesMismatch
AssignRuleParameterMismatch = _libsbml.AssignRuleParameterMismatch
AssignRuleStoichiometryMismatch = _libsbml.AssignRuleStoichiometryMismatch
InitAssignCompartmenMismatch = _libsbml.InitAssignCompartmenMismatch
InitAssignSpeciesMismatch = _libsbml.InitAssignSpeciesMismatch
InitAssignParameterMismatch = _libsbml.InitAssignParameterMismatch
InitAssignStoichiometryMismatch = _libsbml.InitAssignStoichiometryMismatch
RateRuleCompartmentMismatch = _libsbml.RateRuleCompartmentMismatch
RateRuleSpeciesMismatch = _libsbml.RateRuleSpeciesMismatch
RateRuleParameterMismatch = _libsbml.RateRuleParameterMismatch
RateRuleStoichiometryMismatch = _libsbml.RateRuleStoichiometryMismatch
KineticLawNotSubstancePerTime = _libsbml.KineticLawNotSubstancePerTime
SpeciesInvalidExtentUnits = _libsbml.SpeciesInvalidExtentUnits
DelayUnitsNotTime = _libsbml.DelayUnitsNotTime
EventAssignCompartmentMismatch = _libsbml.EventAssignCompartmentMismatch
EventAssignSpeciesMismatch = _libsbml.EventAssignSpeciesMismatch
EventAssignParameterMismatch = _libsbml.EventAssignParameterMismatch
EventAssignStoichiometryMismatch = _libsbml.EventAssignStoichiometryMismatch
OverdeterminedSystem = _libsbml.OverdeterminedSystem
InvalidModelSBOTerm = _libsbml.InvalidModelSBOTerm
InvalidFunctionDefSBOTerm = _libsbml.InvalidFunctionDefSBOTerm
InvalidParameterSBOTerm = _libsbml.InvalidParameterSBOTerm
InvalidInitAssignSBOTerm = _libsbml.InvalidInitAssignSBOTerm
InvalidRuleSBOTerm = _libsbml.InvalidRuleSBOTerm
InvalidConstraintSBOTerm = _libsbml.InvalidConstraintSBOTerm
InvalidReactionSBOTerm = _libsbml.InvalidReactionSBOTerm
InvalidSpeciesReferenceSBOTerm = _libsbml.InvalidSpeciesReferenceSBOTerm
InvalidKineticLawSBOTerm = _libsbml.InvalidKineticLawSBOTerm
InvalidEventSBOTerm = _libsbml.InvalidEventSBOTerm
InvalidEventAssignmentSBOTerm = _libsbml.InvalidEventAssignmentSBOTerm
InvalidCompartmentSBOTerm = _libsbml.InvalidCompartmentSBOTerm
InvalidSpeciesSBOTerm = _libsbml.InvalidSpeciesSBOTerm
InvalidCompartmentTypeSBOTerm = _libsbml.InvalidCompartmentTypeSBOTerm
InvalidSpeciesTypeSBOTerm = _libsbml.InvalidSpeciesTypeSBOTerm
InvalidTriggerSBOTerm = _libsbml.InvalidTriggerSBOTerm
InvalidDelaySBOTerm = _libsbml.InvalidDelaySBOTerm
NotesNotInXHTMLNamespace = _libsbml.NotesNotInXHTMLNamespace
NotesContainsXMLDecl = _libsbml.NotesContainsXMLDecl
NotesContainsDOCTYPE = _libsbml.NotesContainsDOCTYPE
InvalidNotesContent = _libsbml.InvalidNotesContent
OnlyOneNotesElementAllowed = _libsbml.OnlyOneNotesElementAllowed
InvalidNamespaceOnSBML = _libsbml.InvalidNamespaceOnSBML
MissingOrInconsistentLevel = _libsbml.MissingOrInconsistentLevel
MissingOrInconsistentVersion = _libsbml.MissingOrInconsistentVersion
PackageNSMustMatch = _libsbml.PackageNSMustMatch
LevelPositiveInteger = _libsbml.LevelPositiveInteger
VersionPositiveInteger = _libsbml.VersionPositiveInteger
AllowedAttributesOnSBML = _libsbml.AllowedAttributesOnSBML
MissingModel = _libsbml.MissingModel
IncorrectOrderInModel = _libsbml.IncorrectOrderInModel
EmptyListElement = _libsbml.EmptyListElement
NeedCompartmentIfHaveSpecies = _libsbml.NeedCompartmentIfHaveSpecies
OneOfEachListOf = _libsbml.OneOfEachListOf
OnlyFuncDefsInListOfFuncDefs = _libsbml.OnlyFuncDefsInListOfFuncDefs
OnlyUnitDefsInListOfUnitDefs = _libsbml.OnlyUnitDefsInListOfUnitDefs
OnlyCompartmentsInListOfCompartments = _libsbml.OnlyCompartmentsInListOfCompartments
OnlySpeciesInListOfSpecies = _libsbml.OnlySpeciesInListOfSpecies
OnlyParametersInListOfParameters = _libsbml.OnlyParametersInListOfParameters
OnlyInitAssignsInListOfInitAssigns = _libsbml.OnlyInitAssignsInListOfInitAssigns
OnlyRulesInListOfRules = _libsbml.OnlyRulesInListOfRules
OnlyConstraintsInListOfConstraints = _libsbml.OnlyConstraintsInListOfConstraints
OnlyReactionsInListOfReactions = _libsbml.OnlyReactionsInListOfReactions
OnlyEventsInListOfEvents = _libsbml.OnlyEventsInListOfEvents
L3ConversionFactorOnModel = _libsbml.L3ConversionFactorOnModel
L3TimeUnitsOnModel = _libsbml.L3TimeUnitsOnModel
L3VolumeUnitsOnModel = _libsbml.L3VolumeUnitsOnModel
L3AreaUnitsOnModel = _libsbml.L3AreaUnitsOnModel
L3LengthUnitsOnModel = _libsbml.L3LengthUnitsOnModel
L3ExtentUnitsOnModel = _libsbml.L3ExtentUnitsOnModel
AllowedAttributesOnModel = _libsbml.AllowedAttributesOnModel
AllowedAttributesOnListOfFuncs = _libsbml.AllowedAttributesOnListOfFuncs
AllowedAttributesOnListOfUnitDefs = _libsbml.AllowedAttributesOnListOfUnitDefs
AllowedAttributesOnListOfComps = _libsbml.AllowedAttributesOnListOfComps
AllowedAttributesOnListOfSpecies = _libsbml.AllowedAttributesOnListOfSpecies
AllowedAttributesOnListOfParams = _libsbml.AllowedAttributesOnListOfParams
AllowedAttributesOnListOfInitAssign = _libsbml.AllowedAttributesOnListOfInitAssign
AllowedAttributesOnListOfRules = _libsbml.AllowedAttributesOnListOfRules
AllowedAttributesOnListOfConstraints = _libsbml.AllowedAttributesOnListOfConstraints
AllowedAttributesOnListOfReactions = _libsbml.AllowedAttributesOnListOfReactions
AllowedAttributesOnListOfEvents = _libsbml.AllowedAttributesOnListOfEvents
FunctionDefMathNotLambda = _libsbml.FunctionDefMathNotLambda
InvalidApplyCiInLambda = _libsbml.InvalidApplyCiInLambda
RecursiveFunctionDefinition = _libsbml.RecursiveFunctionDefinition
InvalidCiInLambda = _libsbml.InvalidCiInLambda
InvalidFunctionDefReturnType = _libsbml.InvalidFunctionDefReturnType
OneMathElementPerFunc = _libsbml.OneMathElementPerFunc
AllowedAttributesOnFunc = _libsbml.AllowedAttributesOnFunc
InvalidUnitDefId = _libsbml.InvalidUnitDefId
InvalidSubstanceRedefinition = _libsbml.InvalidSubstanceRedefinition
InvalidLengthRedefinition = _libsbml.InvalidLengthRedefinition
InvalidAreaRedefinition = _libsbml.InvalidAreaRedefinition
InvalidTimeRedefinition = _libsbml.InvalidTimeRedefinition
InvalidVolumeRedefinition = _libsbml.InvalidVolumeRedefinition
VolumeLitreDefExponentNotOne = _libsbml.VolumeLitreDefExponentNotOne
VolumeMetreDefExponentNot3 = _libsbml.VolumeMetreDefExponentNot3
EmptyListOfUnits = _libsbml.EmptyListOfUnits
InvalidUnitKind = _libsbml.InvalidUnitKind
OffsetNoLongerValid = _libsbml.OffsetNoLongerValid
CelsiusNoLongerValid = _libsbml.CelsiusNoLongerValid
EmptyUnitListElement = _libsbml.EmptyUnitListElement
OneListOfUnitsPerUnitDef = _libsbml.OneListOfUnitsPerUnitDef
OnlyUnitsInListOfUnits = _libsbml.OnlyUnitsInListOfUnits
AllowedAttributesOnUnitDefinition = _libsbml.AllowedAttributesOnUnitDefinition
AllowedAttributesOnListOfUnits = _libsbml.AllowedAttributesOnListOfUnits
AllowedAttributesOnUnit = _libsbml.AllowedAttributesOnUnit
ZeroDimensionalCompartmentSize = _libsbml.ZeroDimensionalCompartmentSize
ZeroDimensionalCompartmentUnits = _libsbml.ZeroDimensionalCompartmentUnits
ZeroDimensionalCompartmentConst = _libsbml.ZeroDimensionalCompartmentConst
UndefinedOutsideCompartment = _libsbml.UndefinedOutsideCompartment
RecursiveCompartmentContainment = _libsbml.RecursiveCompartmentContainment
ZeroDCompartmentContainment = _libsbml.ZeroDCompartmentContainment
Invalid1DCompartmentUnits = _libsbml.Invalid1DCompartmentUnits
Invalid2DCompartmentUnits = _libsbml.Invalid2DCompartmentUnits
Invalid3DCompartmentUnits = _libsbml.Invalid3DCompartmentUnits
InvalidCompartmentTypeRef = _libsbml.InvalidCompartmentTypeRef
OneDimensionalCompartmentUnits = _libsbml.OneDimensionalCompartmentUnits
TwoDimensionalCompartmentUnits = _libsbml.TwoDimensionalCompartmentUnits
ThreeDimensionalCompartmentUnits = _libsbml.ThreeDimensionalCompartmentUnits
AllowedAttributesOnCompartment = _libsbml.AllowedAttributesOnCompartment
InvalidSpeciesCompartmentRef = _libsbml.InvalidSpeciesCompartmentRef
HasOnlySubsNoSpatialUnits = _libsbml.HasOnlySubsNoSpatialUnits
NoSpatialUnitsInZeroD = _libsbml.NoSpatialUnitsInZeroD
NoConcentrationInZeroD = _libsbml.NoConcentrationInZeroD
SpatialUnitsInOneD = _libsbml.SpatialUnitsInOneD
SpatialUnitsInTwoD = _libsbml.SpatialUnitsInTwoD
SpatialUnitsInThreeD = _libsbml.SpatialUnitsInThreeD
InvalidSpeciesSusbstanceUnits = _libsbml.InvalidSpeciesSusbstanceUnits
BothAmountAndConcentrationSet = _libsbml.BothAmountAndConcentrationSet
NonBoundarySpeciesAssignedAndUsed = _libsbml.NonBoundarySpeciesAssignedAndUsed
NonConstantSpeciesUsed = _libsbml.NonConstantSpeciesUsed
InvalidSpeciesTypeRef = _libsbml.InvalidSpeciesTypeRef
MultSpeciesSameTypeInCompartment = _libsbml.MultSpeciesSameTypeInCompartment
MissingSpeciesCompartment = _libsbml.MissingSpeciesCompartment
SpatialSizeUnitsRemoved = _libsbml.SpatialSizeUnitsRemoved
SubstanceUnitsOnSpecies = _libsbml.SubstanceUnitsOnSpecies
ConversionFactorOnSpecies = _libsbml.ConversionFactorOnSpecies
AllowedAttributesOnSpecies = _libsbml.AllowedAttributesOnSpecies
InvalidParameterUnits = _libsbml.InvalidParameterUnits
ParameterUnits = _libsbml.ParameterUnits
ConversionFactorMustConstant = _libsbml.ConversionFactorMustConstant
AllowedAttributesOnParameter = _libsbml.AllowedAttributesOnParameter
InvalidInitAssignSymbol = _libsbml.InvalidInitAssignSymbol
MultipleInitAssignments = _libsbml.MultipleInitAssignments
InitAssignmentAndRuleForSameId = _libsbml.InitAssignmentAndRuleForSameId
OneMathElementPerInitialAssign = _libsbml.OneMathElementPerInitialAssign
AllowedAttributesOnInitialAssign = _libsbml.AllowedAttributesOnInitialAssign
InvalidAssignRuleVariable = _libsbml.InvalidAssignRuleVariable
InvalidRateRuleVariable = _libsbml.InvalidRateRuleVariable
AssignmentToConstantEntity = _libsbml.AssignmentToConstantEntity
RateRuleForConstantEntity = _libsbml.RateRuleForConstantEntity
RepeatedRule10304 = _libsbml.RepeatedRule10304
CircularRuleDependency = _libsbml.CircularRuleDependency
OneMathElementPerRule = _libsbml.OneMathElementPerRule
AllowedAttributesOnAssignRule = _libsbml.AllowedAttributesOnAssignRule
AllowedAttributesOnRateRule = _libsbml.AllowedAttributesOnRateRule
AllowedAttributesOnAlgRule = _libsbml.AllowedAttributesOnAlgRule
ConstraintMathNotBoolean = _libsbml.ConstraintMathNotBoolean
IncorrectOrderInConstraint = _libsbml.IncorrectOrderInConstraint
ConstraintNotInXHTMLNamespace = _libsbml.ConstraintNotInXHTMLNamespace
ConstraintContainsXMLDecl = _libsbml.ConstraintContainsXMLDecl
ConstraintContainsDOCTYPE = _libsbml.ConstraintContainsDOCTYPE
InvalidConstraintContent = _libsbml.InvalidConstraintContent
OneMathElementPerConstraint = _libsbml.OneMathElementPerConstraint
OneMessageElementPerConstraint = _libsbml.OneMessageElementPerConstraint
AllowedAttributesOnConstraint = _libsbml.AllowedAttributesOnConstraint
NoReactantsOrProducts = _libsbml.NoReactantsOrProducts
IncorrectOrderInReaction = _libsbml.IncorrectOrderInReaction
EmptyListInReaction = _libsbml.EmptyListInReaction
InvalidReactantsProductsList = _libsbml.InvalidReactantsProductsList
InvalidModifiersList = _libsbml.InvalidModifiersList
OneSubElementPerReaction = _libsbml.OneSubElementPerReaction
CompartmentOnReaction = _libsbml.CompartmentOnReaction
AllowedAttributesOnReaction = _libsbml.AllowedAttributesOnReaction
InvalidSpeciesReference = _libsbml.InvalidSpeciesReference
RepeatedRule20611 = _libsbml.RepeatedRule20611
BothStoichiometryAndMath = _libsbml.BothStoichiometryAndMath
AllowedAttributesOnSpeciesReference = _libsbml.AllowedAttributesOnSpeciesReference
AllowedAttributesOnModifier = _libsbml.AllowedAttributesOnModifier
UndeclaredSpeciesRef = _libsbml.UndeclaredSpeciesRef
IncorrectOrderInKineticLaw = _libsbml.IncorrectOrderInKineticLaw
EmptyListInKineticLaw = _libsbml.EmptyListInKineticLaw
NonConstantLocalParameter = _libsbml.NonConstantLocalParameter
SubsUnitsNoLongerValid = _libsbml.SubsUnitsNoLongerValid
TimeUnitsNoLongerValid = _libsbml.TimeUnitsNoLongerValid
OneListOfPerKineticLaw = _libsbml.OneListOfPerKineticLaw
OnlyLocalParamsInListOfLocalParams = _libsbml.OnlyLocalParamsInListOfLocalParams
AllowedAttributesOnListOfLocalParam = _libsbml.AllowedAttributesOnListOfLocalParam
OneMathPerKineticLaw = _libsbml.OneMathPerKineticLaw
UndeclaredSpeciesInStoichMath = _libsbml.UndeclaredSpeciesInStoichMath
AllowedAttributesOnKineticLaw = _libsbml.AllowedAttributesOnKineticLaw
AllowedAttributesOnListOfSpeciesRef = _libsbml.AllowedAttributesOnListOfSpeciesRef
AllowedAttributesOnListOfMods = _libsbml.AllowedAttributesOnListOfMods
AllowedAttributesOnLocalParameter = _libsbml.AllowedAttributesOnLocalParameter
MissingTriggerInEvent = _libsbml.MissingTriggerInEvent
TriggerMathNotBoolean = _libsbml.TriggerMathNotBoolean
MissingEventAssignment = _libsbml.MissingEventAssignment
TimeUnitsEvent = _libsbml.TimeUnitsEvent
IncorrectOrderInEvent = _libsbml.IncorrectOrderInEvent
ValuesFromTriggerTimeNeedDelay = _libsbml.ValuesFromTriggerTimeNeedDelay
DelayNeedsValuesFromTriggerTime = _libsbml.DelayNeedsValuesFromTriggerTime
OneMathPerTrigger = _libsbml.OneMathPerTrigger
OneMathPerDelay = _libsbml.OneMathPerDelay
InvalidEventAssignmentVariable = _libsbml.InvalidEventAssignmentVariable
EventAssignmentForConstantEntity = _libsbml.EventAssignmentForConstantEntity
OneMathPerEventAssignment = _libsbml.OneMathPerEventAssignment
AllowedAttributesOnEventAssignment = _libsbml.AllowedAttributesOnEventAssignment
OnlyOneDelayPerEvent = _libsbml.OnlyOneDelayPerEvent
OneListOfEventAssignmentsPerEvent = _libsbml.OneListOfEventAssignmentsPerEvent
OnlyEventAssignInListOfEventAssign = _libsbml.OnlyEventAssignInListOfEventAssign
AllowedAttributesOnListOfEventAssign = _libsbml.AllowedAttributesOnListOfEventAssign
AllowedAttributesOnEvent = _libsbml.AllowedAttributesOnEvent
AllowedAttributesOnTrigger = _libsbml.AllowedAttributesOnTrigger
AllowedAttributesOnDelay = _libsbml.AllowedAttributesOnDelay
GeneralWarningNotSpecified = _libsbml.GeneralWarningNotSpecified
CompartmentShouldHaveSize = _libsbml.CompartmentShouldHaveSize
ParameterShouldHaveUnits = _libsbml.ParameterShouldHaveUnits
LocalParameterShadowsId = _libsbml.LocalParameterShadowsId
LibSBMLAdditionalCodesLowerBound = _libsbml.LibSBMLAdditionalCodesLowerBound
CannotConvertToL1V1 = _libsbml.CannotConvertToL1V1
NoEventsInL1 = _libsbml.NoEventsInL1
NoFunctionDefinitionsInL1 = _libsbml.NoFunctionDefinitionsInL1
NoConstraintsInL1 = _libsbml.NoConstraintsInL1
NoInitialAssignmentsInL1 = _libsbml.NoInitialAssignmentsInL1
NoSpeciesTypesInL1 = _libsbml.NoSpeciesTypesInL1
NoCompartmentTypeInL1 = _libsbml.NoCompartmentTypeInL1
NoNon3DComparmentsInL1 = _libsbml.NoNon3DComparmentsInL1
NoFancyStoichiometryMathInL1 = _libsbml.NoFancyStoichiometryMathInL1
NoNonIntegerStoichiometryInL1 = _libsbml.NoNonIntegerStoichiometryInL1
NoUnitMultipliersOrOffsetsInL1 = _libsbml.NoUnitMultipliersOrOffsetsInL1
SpeciesCompartmentRequiredInL1 = _libsbml.SpeciesCompartmentRequiredInL1
NoSpeciesSpatialSizeUnitsInL1 = _libsbml.NoSpeciesSpatialSizeUnitsInL1
NoSBOTermsInL1 = _libsbml.NoSBOTermsInL1
StrictUnitsRequiredInL1 = _libsbml.StrictUnitsRequiredInL1
NoConstraintsInL2v1 = _libsbml.NoConstraintsInL2v1
NoInitialAssignmentsInL2v1 = _libsbml.NoInitialAssignmentsInL2v1
NoSpeciesTypeInL2v1 = _libsbml.NoSpeciesTypeInL2v1
NoCompartmentTypeInL2v1 = _libsbml.NoCompartmentTypeInL2v1
NoSBOTermsInL2v1 = _libsbml.NoSBOTermsInL2v1
NoIdOnSpeciesReferenceInL2v1 = _libsbml.NoIdOnSpeciesReferenceInL2v1
NoDelayedEventAssignmentInL2v1 = _libsbml.NoDelayedEventAssignmentInL2v1
StrictUnitsRequiredInL2v1 = _libsbml.StrictUnitsRequiredInL2v1
SBOTermNotUniversalInL2v2 = _libsbml.SBOTermNotUniversalInL2v2
NoUnitOffsetInL2v2 = _libsbml.NoUnitOffsetInL2v2
NoKineticLawTimeUnitsInL2v2 = _libsbml.NoKineticLawTimeUnitsInL2v2
NoKineticLawSubstanceUnitsInL2v2 = _libsbml.NoKineticLawSubstanceUnitsInL2v2
NoDelayedEventAssignmentInL2v2 = _libsbml.NoDelayedEventAssignmentInL2v2
ModelSBOBranchChangedBeyondL2v2 = _libsbml.ModelSBOBranchChangedBeyondL2v2
StrictUnitsRequiredInL2v2 = _libsbml.StrictUnitsRequiredInL2v2
StrictSBORequiredInL2v2 = _libsbml.StrictSBORequiredInL2v2
DuplicateAnnotationInvalidInL2v2 = _libsbml.DuplicateAnnotationInvalidInL2v2
NoUnitOffsetInL2v3 = _libsbml.NoUnitOffsetInL2v3
NoKineticLawTimeUnitsInL2v3 = _libsbml.NoKineticLawTimeUnitsInL2v3
NoKineticLawSubstanceUnitsInL2v3 = _libsbml.NoKineticLawSubstanceUnitsInL2v3
NoSpeciesSpatialSizeUnitsInL2v3 = _libsbml.NoSpeciesSpatialSizeUnitsInL2v3
NoEventTimeUnitsInL2v3 = _libsbml.NoEventTimeUnitsInL2v3
NoDelayedEventAssignmentInL2v3 = _libsbml.NoDelayedEventAssignmentInL2v3
ModelSBOBranchChangedBeyondL2v3 = _libsbml.ModelSBOBranchChangedBeyondL2v3
StrictUnitsRequiredInL2v3 = _libsbml.StrictUnitsRequiredInL2v3
StrictSBORequiredInL2v3 = _libsbml.StrictSBORequiredInL2v3
DuplicateAnnotationInvalidInL2v3 = _libsbml.DuplicateAnnotationInvalidInL2v3
NoUnitOffsetInL2v4 = _libsbml.NoUnitOffsetInL2v4
NoKineticLawTimeUnitsInL2v4 = _libsbml.NoKineticLawTimeUnitsInL2v4
NoKineticLawSubstanceUnitsInL2v4 = _libsbml.NoKineticLawSubstanceUnitsInL2v4
NoSpeciesSpatialSizeUnitsInL2v4 = _libsbml.NoSpeciesSpatialSizeUnitsInL2v4
NoEventTimeUnitsInL2v4 = _libsbml.NoEventTimeUnitsInL2v4
ModelSBOBranchChangedInL2v4 = _libsbml.ModelSBOBranchChangedInL2v4
DuplicateAnnotationInvalidInL2v4 = _libsbml.DuplicateAnnotationInvalidInL2v4
NoSpeciesTypeInL3v1 = _libsbml.NoSpeciesTypeInL3v1
NoCompartmentTypeInL3v1 = _libsbml.NoCompartmentTypeInL3v1
NoUnitOffsetInL3v1 = _libsbml.NoUnitOffsetInL3v1
NoKineticLawTimeUnitsInL3v1 = _libsbml.NoKineticLawTimeUnitsInL3v1
NoKineticLawSubstanceUnitsInL3v1 = _libsbml.NoKineticLawSubstanceUnitsInL3v1
NoSpeciesSpatialSizeUnitsInL3v1 = _libsbml.NoSpeciesSpatialSizeUnitsInL3v1
NoEventTimeUnitsInL3v1 = _libsbml.NoEventTimeUnitsInL3v1
ModelSBOBranchChangedInL3v1 = _libsbml.ModelSBOBranchChangedInL3v1
DuplicateAnnotationInvalidInL3v1 = _libsbml.DuplicateAnnotationInvalidInL3v1
NoCompartmentOutsideInL3v1 = _libsbml.NoCompartmentOutsideInL3v1
NoStoichiometryMathInL3v1 = _libsbml.NoStoichiometryMathInL3v1
InvalidSBMLLevelVersion = _libsbml.InvalidSBMLLevelVersion
AnnotationNotesNotAllowedLevel1 = _libsbml.AnnotationNotesNotAllowedLevel1
InvalidRuleOrdering = _libsbml.InvalidRuleOrdering
SubsUnitsAllowedInKL = _libsbml.SubsUnitsAllowedInKL
TimeUnitsAllowedInKL = _libsbml.TimeUnitsAllowedInKL
FormulaInLevel1KL = _libsbml.FormulaInLevel1KL
TimeUnitsRemoved = _libsbml.TimeUnitsRemoved
BadMathML = _libsbml.BadMathML
FailedMathMLReadOfDouble = _libsbml.FailedMathMLReadOfDouble
FailedMathMLReadOfInteger = _libsbml.FailedMathMLReadOfInteger
FailedMathMLReadOfExponential = _libsbml.FailedMathMLReadOfExponential
FailedMathMLReadOfRational = _libsbml.FailedMathMLReadOfRational
BadMathMLNodeType = _libsbml.BadMathMLNodeType
NoTimeSymbolInFunctionDef = _libsbml.NoTimeSymbolInFunctionDef
InconsistentArgUnitsWarnings = _libsbml.InconsistentArgUnitsWarnings
InconsistentPowerUnitsWarnings = _libsbml.InconsistentPowerUnitsWarnings
InconsistentExponUnitsWarnings = _libsbml.InconsistentExponUnitsWarnings
UndeclaredUnits = _libsbml.UndeclaredUnits
UnrecognisedSBOTerm = _libsbml.UnrecognisedSBOTerm
ObseleteSBOTerm = _libsbml.ObseleteSBOTerm
IncorrectCompartmentSpatialDimensions = _libsbml.IncorrectCompartmentSpatialDimensions
CompartmentTypeNotValidAttribute = _libsbml.CompartmentTypeNotValidAttribute
ConstantNotValidAttribute = _libsbml.ConstantNotValidAttribute
MetaIdNotValidAttribute = _libsbml.MetaIdNotValidAttribute
SBOTermNotValidAttributeBeforeL2V3 = _libsbml.SBOTermNotValidAttributeBeforeL2V3
InvalidL1CompartmentUnits = _libsbml.InvalidL1CompartmentUnits
L1V1CompartmentVolumeReqd = _libsbml.L1V1CompartmentVolumeReqd
CompartmentTypeNotValidComponent = _libsbml.CompartmentTypeNotValidComponent
ConstraintNotValidComponent = _libsbml.ConstraintNotValidComponent
EventNotValidComponent = _libsbml.EventNotValidComponent
SBOTermNotValidAttributeBeforeL2V2 = _libsbml.SBOTermNotValidAttributeBeforeL2V2
FuncDefNotValidComponent = _libsbml.FuncDefNotValidComponent
InitialAssignNotValidComponent = _libsbml.InitialAssignNotValidComponent
VariableNotValidAttribute = _libsbml.VariableNotValidAttribute
UnitsNotValidAttribute = _libsbml.UnitsNotValidAttribute
ConstantSpeciesNotValidAttribute = _libsbml.ConstantSpeciesNotValidAttribute
SpatialSizeUnitsNotValidAttribute = _libsbml.SpatialSizeUnitsNotValidAttribute
SpeciesTypeNotValidAttribute = _libsbml.SpeciesTypeNotValidAttribute
HasOnlySubsUnitsNotValidAttribute = _libsbml.HasOnlySubsUnitsNotValidAttribute
IdNotValidAttribute = _libsbml.IdNotValidAttribute
NameNotValidAttribute = _libsbml.NameNotValidAttribute
SpeciesTypeNotValidComponent = _libsbml.SpeciesTypeNotValidComponent
StoichiometryMathNotValidComponent = _libsbml.StoichiometryMathNotValidComponent
MultiplierNotValidAttribute = _libsbml.MultiplierNotValidAttribute
OffsetNotValidAttribute = _libsbml.OffsetNotValidAttribute
InvalidTargetLevelVersion = _libsbml.InvalidTargetLevelVersion
L3NotSupported = _libsbml.L3NotSupported
SBMLCodesUpperBound = _libsbml.SBMLCodesUpperBound
LIBSBML_CAT_SBML = _libsbml.LIBSBML_CAT_SBML
LIBSBML_CAT_SBML_L1_COMPAT = _libsbml.LIBSBML_CAT_SBML_L1_COMPAT
LIBSBML_CAT_SBML_L2V1_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V1_COMPAT
LIBSBML_CAT_SBML_L2V2_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V2_COMPAT
LIBSBML_CAT_GENERAL_CONSISTENCY = _libsbml.LIBSBML_CAT_GENERAL_CONSISTENCY
LIBSBML_CAT_IDENTIFIER_CONSISTENCY = _libsbml.LIBSBML_CAT_IDENTIFIER_CONSISTENCY
LIBSBML_CAT_UNITS_CONSISTENCY = _libsbml.LIBSBML_CAT_UNITS_CONSISTENCY
LIBSBML_CAT_MATHML_CONSISTENCY = _libsbml.LIBSBML_CAT_MATHML_CONSISTENCY
LIBSBML_CAT_SBO_CONSISTENCY = _libsbml.LIBSBML_CAT_SBO_CONSISTENCY
LIBSBML_CAT_OVERDETERMINED_MODEL = _libsbml.LIBSBML_CAT_OVERDETERMINED_MODEL
LIBSBML_CAT_SBML_L2V3_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V3_COMPAT
LIBSBML_CAT_MODELING_PRACTICE = _libsbml.LIBSBML_CAT_MODELING_PRACTICE
LIBSBML_CAT_INTERNAL_CONSISTENCY = _libsbml.LIBSBML_CAT_INTERNAL_CONSISTENCY
LIBSBML_CAT_SBML_L2V4_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V4_COMPAT
LIBSBML_CAT_SBML_L3V1_COMPAT = _libsbml.LIBSBML_CAT_SBML_L3V1_COMPAT
LIBSBML_SEV_SCHEMA_ERROR = _libsbml.LIBSBML_SEV_SCHEMA_ERROR
LIBSBML_SEV_GENERAL_WARNING = _libsbml.LIBSBML_SEV_GENERAL_WARNING
LIBSBML_SEV_NOT_APPLICABLE = _libsbml.LIBSBML_SEV_NOT_APPLICABLE
class SBMLError(XMLError):
    """
    Representation of errors, warnings and other diagnostics

    @htmlinclude not-sbml-warning.html

    When a libSBML operation on SBML content results in an error, or when
    there is something wrong with the SBML content, the problems are
    reported as SBMLError objects.  These are generally stored in an
    SBMLErrorLog object; this log object, in turn, is kept in the
    SBMLDocument object containing the SBML content.  Applications can
    obtain the list of logged errors using SBMLDocument::getErrorLog() and
    then use the methods provided by SBMLErrorLog to access individual
    SBMLError objects.  (Note that despite the word 'error' in the name,
    SBMLError objects are used to represent not only 'true' errors, but also
    warnings and some informational diagnostics.  The name is a historical
    hold-over from early versions of libSBML, in which the object really was
    only used to report errors.)

    Each SBMLError object instance has an identification number that
    identifies the nature of the problem.  This 'error id' number will be up
    to five digits long, @if clike and it will be listed in one
    of two enumerations: <a class='el' href='#SBMLErrorCode_t'>
    SBMLErrorCode_t</a> (described <a class='el' href='#SBMLErrorCode_t'>
    below</a>) or @link XMLError::XMLErrorCode_t XMLErrorCode_t @endlink
    (described in the documentation for the class XMLError).  The former
    enumeration contains all the SBML validation rule numbers listed in the
    appendices of the SBML specification documents, as well as some
    additional libSBML-specific error codes.@endif@if java and
    it will come from one of two sets of static integer constants defined in
    the interface class <code><a href='libsbmlConstants.html'>
    libsbmlConstants</a></code>: either the SBML error identifiers <a
    class='el' href='#SBMLErrorCode_t'> (described below)</a> or the XML
    error identifiers (described in the documentation for the class <code><a
    href='XMLError.html'> XMLError</a></code>).  The former set of constants
    includes all the SBML validation rule numbers listed in the appendices
    of the SBML specification documents, as well as some additional
    libSBML-specific error codes.@endif

    Error codes are useful mainly for software.  For human readers,
    SBMLError also includes text messages that describe the nature of a
    given problem.  The messages can be accessed using
    SBMLError::getShortMessage() and SBMLError::getMessage().  The former
    provides a brief one-line description of the issue, while
    SBMLError::getMessage() provides a more detailed text, including (if
    appropriate) references to sections of the SBML specifications where
    relevant topics are discussed.  These text strings are suitable for
    displaying to human users.

    An SBMLError object also contains a category code; its value may be
    retrieved using the method SBMLError::getCategory().  Category values
    are @if clike drawn from the enumeration <a class='el'
    href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a> described below.
    Categories are used to partition errors into distinct conceptual groups.
    This is principally used by the libSBML validation system to group
    classes of validation checks.  For example, @c
    LIBSBML_CAT_IDENTIFIER_CONSISTENCY is the category for tests that check
    identifier consistency; @c LIBSBML_CAT_MATHML_CONSISTENCY is the
    category for MathML consistency checking; and so
    on.  @endif@if java drawn from a set of static integer
    constants defined in <code><a
    href='libsbmlConstants.html'>libsbmlConstants</a></code>, and having
    names beginning with the characters <code>LIBSBML_CAT_</code>.  The list
    of possible codes is described in a separate section below.  Categories
    are used to partition errors into distinct conceptual groups.  This is
    principally used by the libSBML validation system to group classes of
    validation checks.  For example, @c LIBSBML_CAT_IDENTIFIER_CONSISTENCY
    is the category for tests that check identifier consistency; @c
    LIBSBML_CAT_MATHML_CONSISTENCY is the category for MathML consistency
    checking; and so on. @endif

    In addition, SBMLError also has a severity code.  Its value may be
    retrieved using the method SBMLError::getSeverity().  The possible
    severity values are the same as those reported by @if clike
    XMLError.  Severity levels currently range from informational (@c
    LIBSBML_SEV_INFO) to fatal errors (@c LIBSBML_SEV_FATAL).  They can be
    used by an application to evaluate how serious a given problem
    is. @endif@if java <code><a
    href='XMLError.html'>XMLError</a></code>. Severity levels currently
    range from informational (@c LIBSBML_SEV_INFO) to fatal errors (@c
    LIBSBML_SEV_FATAL).  They can be used by an application to evaluate how
    serious a given problem is. @endif

    Finally, SBMLError records the line and column near where the problem
    occurred in the SBML content.  The values may be retrieved using the
    methods SBMLError::getLine() and SBMLError::getColumn().  We say 'near',
    because a lot of factors affect how accurate the line/column information
    ultimately is.  For example, different XML parsers have different
    conventions for which line and column number they report for a
    particular problem (which makes a difference when a problem involves an
    opening XML tag on one line and a closing tag on another line).  In some
    situations, some parsers report invalid line and/or column numbers
    altogether.  If this occurs, libSBML sets the line and/or column number
    in the SBMLError object to the the value of the maximum unsigned long
    integer representable on the platform where libSBML is running.  (This
    is equal to the constant named <code>ULONG_MAX</code> in C and C++.)
    The probability that a true line or column number in an SBML model would
    equal this value is vanishingly small; thus, if an application
    encounters these values in an XMLError object, it can assume no valid
    line/column number could be provided by libSBML in that situation.

    @if clike
    <h3><a class='anchor' name='SBMLErrorCode_t'>SBMLErrorCode_t</a></h3>

    SBMLErrorCode_t is an enumeration of all SBML-level error, warning and
    informational diagnostic codes.  Every SBMLError object has an error
    code value that can be either a value from this enumeration, or a value
    from the @link XMLError::XMLErrorCode_t XMLErrorCode_t @endlink
    enumeration (see the documentation for XMLError).  The latter values
    apply when the error or warning signifies a basic XML issue rather than
    an SBML issue per se.  The values of SBMLErrorCode_t are distinguished
    from those of @link XMLError::XMLErrorCode_t XMLErrorCode_t @endlink by
    being numbered 10000 and higher, while the XML layer's codes are 9999 and
    lower.  The method SBMLError::getErrorId() returns the error code of a
    given SBMLError object instance.

    The following is a table of the symbolic names of SBMLErrorCode_t values
    and the meaning of each code.  In this table, the right-hand columns
    titled 'L1V1', 'L1V2', etc. refer to Levels and Versions of the SBML
    specifications, and the entries in each column refer to whether the
    severity of the condition in that particular Level+Version of SBML.
    The codes stand for the following:

    @endif@if java <h3><a class='anchor' 
    name='SBMLErrorCode_t'>Error codes associated with SBMLError objects</a></h3>

    The error and warning codes returned by libSBML are listed in the table
    below.  The method SBMLError::getErrorId() returns the error code of a
    given SBMLError object instance.  In the libSBML Java language
    interface, these error identifiers are currently (in libSBML 3.3.x)
    implemented as static integer constants defined in the interface class
    <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>.  This
    is admittedly not an ideal approach from the standpoint of modern Java
    programming, but it was necessary to work around the lack of
    enumerations in Java prior to JDK 1.5.  Future versions of libSBML may
    use a proper Java enumeration type to define the error identifiers.

    In this table, the right-hand columns titled 'L1V1', 'L1V2', etc. refer
    to Levels and Versions of the SBML specifications, and the entries in
    each column refer to whether the severity of the condition in that
    particular Level+Version of SBML.  The codes stand for the following:

    @endif

    <table cellspacing='1' cellpadding='2' border='0' class='normal-font'>
    <tr><td class='s-na'>N</td><td>= Not applicable</td></tr>
    <tr><td class='s-info'>I</td><td>= Informational</td></tr>
    <tr><td class='s-warning'>W</td><td>= Warning</td></tr>
    <tr><td class='s-error'>E</td><td>= Error</td></tr>
    <tr><td class='s-fatal'>F</td><td>= Fatal</td></tr>
    </table>

    The text shown in the 'Meaning' is the text returned by the
    SBMLError::getShortMessage() method on a given SBMLError object.  A
    longer and (hopefully) clearer explanation of the issue is returned by
    SBMLError::getMessage().

    <center>
    <table width='95%' cellspacing='1' cellpadding='2' border='0' class='text-table small-font alt-row-colors'>
     <tr style='background: lightgray' class='normal-font'>
         <th valign='bottom'><strong>Enumerator</strong></th>
         <th valign='bottom'><strong>Meaning</strong></th>
         <th align='center' width='15'>L 1 V 1</th>
         <th align='center' width='15'>L 1 V 2</th>
         <th align='center' width='15'>L 2 V 1</th>
         <th align='center' width='15'>L 2 V 2</th>
         <th align='center' width='15'>L 2 V 3</th>
         <th align='center' width='15'>L 2 V 4</th>
         <th align='center' width='15'>L 3 V 1</th>
     </tr>
    <tr><td><code>UnknownError</code></td><td>Unknown internal libSBML error</td><td class='s-fatal'>F</td><td class='s-fatal'>F</td><td class='s-fatal'>F</td><td class='s-fatal'>F</td><td class='s-fatal'>F</td><td class='s-fatal'>F</td><td class='s-fatal'>F</td></tr>
    <tr><td><code>NotUTF8</code></td><td>Not UTF8</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>UnrecognizedElement</code></td><td>Unrecognized element</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NotSchemaConformant</code></td><td>Not conformant to SBML XML schema</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>L3NotSchemaConformant</code></td><td>Not conformant to SBML XML schema</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidMathElement</code></td><td>Invalid MathML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DisallowedMathMLSymbol</code></td><td>Disallowed MathML symbol</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DisallowedMathMLEncodingUse</code></td><td>Disallowed use of MathML 'encoding' attribute</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DisallowedDefinitionURLUse</code></td><td>Disallowed use of MathML 'definitionURL' attribute</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>BadCsymbolDefinitionURLValue</code></td><td>Invalid &lt;csymbol&gt; 'definitionURL' attribute value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DisallowedMathTypeAttributeUse</code></td><td>Disallowed use of MathML 'type' attribute</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DisallowedMathTypeAttributeValue</code></td><td>Disallowed MathML 'type' attribute value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>LambdaOnlyAllowedInFunctionDef</code></td><td>Use of &lt;lambda&gt; not permitted outside of a &lt;functionDefinition&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>BooleanOpsNeedBooleanArgs</code></td><td>Non-boolean argument given to boolean operator</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NumericOpsNeedNumericArgs</code></td><td>Non-numerical argument given to numerical operator</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ArgsToEqNeedSameType</code></td><td>Arguments to &lt;eq&gt; or &lt;neq&gt; have inconsistent data types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>PiecewiseNeedsConsistentTypes</code></td><td>&lt;piecewise&gt; terms have inconsistent data types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>PieceNeedsBoolean</code></td><td>Second argument of &lt;piece&gt; must yield a boolean value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ApplyCiMustBeUserFunction</code></td><td>&lt;ci&gt; does not refer to a function definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ApplyCiMustBeModelComponent</code></td><td>&lt;ci&gt;'s value is not a component in this model</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>KineticLawParametersAreLocalOnly</code></td><td>Cannot use &lt;kineticLaw&gt; parameter outside local scope</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>MathResultMustBeNumeric</code></td><td>Formula result is not a numerical value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OpsNeedCorrectNumberOfArgs</code></td><td>Incorrect number of arguments to operator</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidNoArgsPassedToFunctionDef</code></td><td>Incorrect number of arguments to function</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DisallowedMathUnitsUse</code></td><td>Attribute 'units' only permitted on cn element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidUnitsValue</code></td><td>Invalid value for 'units' attribute</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>DuplicateComponentId</code></td><td>Duplicate component identifier</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DuplicateUnitDefinitionId</code></td><td>Duplicate unit definition identifier</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DuplicateLocalParameterId</code></td><td>Duplicate local parameter identifier</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>MultipleAssignmentOrRateRules</code></td><td>Multiple rules for the same variable</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>MultipleEventAssignmentsForId</code></td><td>Multiple event assignments for the same variable</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>EventAndAssignmentRuleForId</code></td><td>'variable' value used in both event assignments and assignment rules</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DuplicateMetaId</code></td><td>Duplicate 'metaid' identifier</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidSBOTermSyntax</code></td><td>Invalid 'sboTerm' value syntax</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidMetaidSyntax</code></td><td>Invalid 'metaid' value syntax</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidIdSyntax</code></td><td>Invalid identifier syntax</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidUnitIdSyntax</code></td><td>Invalid unit identifier syntax</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidNameSyntax</code></td><td>Invalid name syntax</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>MissingAnnotationNamespace</code></td><td>Missing declaration of XML namespace for annotation</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DuplicateAnnotationNamespaces</code></td><td>Multiple annotations using same XML namespace</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>SBMLNamespaceInAnnotation</code></td><td>Invalid use of SBML XML namespace in annotation</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>MultipleAnnotations</code></td><td>Multiple annotation elements not allowed</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InconsistentArgUnits</code></td><td>Units of arguments to function call do not match function's definition</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InconsistentKineticLawUnitsL3</code></td><td>Inconsistent &lt;kineticLaw&gt; units</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>AssignRuleCompartmentMismatch</code></td><td>Mismatched units in assignment rule for compartment</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>AssignRuleSpeciesMismatch</code></td><td>Mismatched units in assignment rule for species</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>AssignRuleParameterMismatch</code></td><td>Mismatched units in assignment rule for parameter</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>AssignRuleStoichiometryMismatch</code></td><td>Mismatched units in assignment rule for stoichiometry</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InitAssignCompartmenMismatch</code></td><td>Mismatched units in initial assignment to compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InitAssignSpeciesMismatch</code></td><td>Mismatched units in initial assignment to species</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InitAssignParameterMismatch</code></td><td>Mismatched units in initial assignment to parameter</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InitAssignStoichiometryMismatch</code></td><td>Mismatched units in initial assignment to stoichiometry</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>RateRuleCompartmentMismatch</code></td><td>Mismatched units in rate rule for compartment</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>RateRuleSpeciesMismatch</code></td><td>Mismatched units in rate rule for species</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>RateRuleParameterMismatch</code></td><td>Mismatched units in rate rule for parameter</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>RateRuleStoichiometryMismatch</code></td><td>Mismatched units in rate rule for stoichiometry</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>KineticLawNotSubstancePerTime</code></td><td>Kinetic law units are not 'substance'/'time'</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>SpeciesInvalidExtentUnits</code></td><td>Species units not consistent with extent</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>DelayUnitsNotTime</code></td><td>Units of delay are not units of time</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>EventAssignCompartmentMismatch</code></td><td>Mismatched units in event assignment for compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>EventAssignSpeciesMismatch</code></td><td>Mismatched units in event assignment for species</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>EventAssignParameterMismatch</code></td><td>Mismatched units in event assignment for parameter</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>EventAssignStoichiometryMismatch</code></td><td>Mismatched units in event assignment for stoichiometry</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>OverdeterminedSystem</code></td><td>Model is overdetermined</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidModelSBOTerm</code></td><td>Invalid 'sboTerm' value for model</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidFunctionDefSBOTerm</code></td><td>Invalid 'sboTerm' value for function definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidParameterSBOTerm</code></td><td>Invalid 'sboTerm' value for parameter</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidInitAssignSBOTerm</code></td><td>Invalid 'sboTerm' value for initial assignment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidRuleSBOTerm</code></td><td>Invalid 'sboTerm' value for rule</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidConstraintSBOTerm</code></td><td>Invalid 'sboTerm' value for constraint</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidReactionSBOTerm</code></td><td>Invalid 'sboTerm' value for reaction</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidSpeciesReferenceSBOTerm</code></td><td>Invalid 'sboTerm' value for species reference</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidKineticLawSBOTerm</code></td><td>Invalid 'sboTerm' value for kinetic law</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidEventSBOTerm</code></td><td>Invalid 'sboTerm' value for event</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidEventAssignmentSBOTerm</code></td><td>Invalid 'sboTerm' value for event assignment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidCompartmentSBOTerm</code></td><td>Invalid 'sboTerm' value for compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidSpeciesSBOTerm</code></td><td>Invalid 'sboTerm' value for species</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidCompartmentTypeSBOTerm</code></td><td>Invalid 'sboTerm' value for compartment type</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidSpeciesTypeSBOTerm</code></td><td>Invalid 'sboTerm' value for species type</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidTriggerSBOTerm</code></td><td>Invalid 'sboTerm' value for event trigger</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidDelaySBOTerm</code></td><td>Invalid 'sboTerm' value for event delay</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>NotesNotInXHTMLNamespace</code></td><td>Notes not placed in XHTML namespace</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NotesContainsXMLDecl</code></td><td>XML declarations not permitted in notes</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NotesContainsDOCTYPE</code></td><td>XML DOCTYPE not permitted in notes</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidNotesContent</code></td><td>Invalid notes content</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>OnlyOneNotesElementAllowed</code></td><td>Only one notes element allowed.</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidNamespaceOnSBML</code></td><td>Invalid XML namespace for SBML container</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>MissingOrInconsistentLevel</code></td><td>Missing or inconsistent value for 'level' attribute</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>MissingOrInconsistentVersion</code></td><td>Missing or inconsistent value for 'version' attribute</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>PackageNSMustMatch</code></td><td>Invalid level/version on package namespace</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>LevelPositiveInteger</code></td><td>'level' must be positive integer</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>VersionPositiveInteger</code></td><td>'version' must be positive integer</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnSBML</code></td><td></td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>MissingModel</code></td><td>Missing model</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>IncorrectOrderInModel</code></td><td>Incorrect ordering of components in model definition</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>EmptyListElement</code></td><td>A given listOf___, if present, cannot be empty</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NeedCompartmentIfHaveSpecies</code></td><td>Missing compartment in species definition</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneOfEachListOf</code></td><td>Only one of each ListOf element allowed</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyFuncDefsInListOfFuncDefs</code></td><td>Only FunctionDefinitions allowed in ListOfFunctionDefinitions</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyUnitDefsInListOfUnitDefs</code></td><td>Only UnitDefinitions allowed in ListOfUnitDefinitions</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyCompartmentsInListOfCompartments</code></td><td>Only Compartments allowed in ListOfCompartments</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlySpeciesInListOfSpecies</code></td><td>Only Species allowed in ListOfSpecies</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyParametersInListOfParameters</code></td><td>Only parameters allowed in ListOfParameters</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyInitAssignsInListOfInitAssigns</code></td><td>Only InitialAssignments allowed in ListOfInitialAssignments</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyRulesInListOfRules</code></td><td>Only Rules allowed in ListOfRules</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyConstraintsInListOfConstraints</code></td><td>Only Constraints allowed in ListOfConstraints</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyReactionsInListOfReactions</code></td><td>Only Reactions allowed in ListOfReactions</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyEventsInListOfEvents</code></td><td>Only Events allowed in ListOfEvents</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>L3ConversionFactorOnModel</code></td><td>ConversionFactor must be parameter</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>L3TimeUnitsOnModel</code></td><td>Invalid value of 'timeUnits' on &lt;model&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>L3VolumeUnitsOnModel</code></td><td>Invalid value of 'volumeUnits' on &lt;model&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>L3AreaUnitsOnModel</code></td><td>Invalid value of 'areaUnits' on &lt;model&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>L3LengthUnitsOnModel</code></td><td>Invalid value of 'lengthUnits' on &lt;model&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>L3ExtentUnitsOnModel</code></td><td>Invalid value of 'extentUnits' on &lt;model&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>AllowedAttributesOnModel</code></td><td>Invalid attribute on &lt;model&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfFuncs</code></td><td>Invalid attribute on &lt;listOfFunctionDefinitions&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfUnitDefs</code></td><td>Invalid attribute on &lt;listOfUnitDefinitions&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfComps</code></td><td>Invalid attribute on &lt;listOfCompartments&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfSpecies</code></td><td>Invalid attribute on &lt;listOfSpecies&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfParams</code></td><td>Invalid attribute on &lt;listOfParameters&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfInitAssign</code></td><td>Invalid attribute on &lt;listOfInitialAssignments&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfRules</code></td><td>Invalid attribute on &lt;listOfRules&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfConstraints</code></td><td>Invalid attribute on &lt;listOfConstraints&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfReactions</code></td><td>Invalid attribute on &lt;listOfReactions&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfEvents</code></td><td>Invalid attribute on &lt;listOfEvents&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>FunctionDefMathNotLambda</code></td><td>Invalid expression in function definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidApplyCiInLambda</code></td><td>Invalid forward reference in &lt;apply&gt;&lt;ci&gt;...&lt;/ci&gt;&lt;/apply&gt; value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>RecursiveFunctionDefinition</code></td><td>Recursive function definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidCiInLambda</code></td><td>Unknown &lt;ci&gt; reference in &lt;lambda&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidFunctionDefReturnType</code></td><td>Function return type must be either numerical or boolean</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMathElementPerFunc</code></td><td>FunctionDefinition must contain one math element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnFunc</code></td><td>FunctionDefinition must have id and optionally metaid and sboTerm</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidUnitDefId</code></td><td>Invalid 'id' value for unit definition</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidSubstanceRedefinition</code></td><td>Invalid redefinition of 'substance'</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidLengthRedefinition</code></td><td>Invalid redefinition of 'length'</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidAreaRedefinition</code></td><td>Invalid redefinition of 'area'</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidTimeRedefinition</code></td><td>Invalid redefinition of 'time'</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidVolumeRedefinition</code></td><td>Invalid redefinition of 'volume'</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>VolumeLitreDefExponentNotOne</code></td><td>Must use 'exponent'=1 when defining 'volume' in terms of litres</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>VolumeMetreDefExponentNot3</code></td><td>Must use 'exponent'=3 when defining 'volume' in terms of metres</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>EmptyListOfUnits</code></td><td>Empty list of units not permitted</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidUnitKind</code></td><td>Invalid value of 'kind' in unit definition</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OffsetNoLongerValid</code></td><td>'offset' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>CelsiusNoLongerValid</code></td><td>'Celsius' not defined in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>EmptyUnitListElement</code></td><td>ListOfUnits must not be empty</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneListOfUnitsPerUnitDef</code></td><td>Only one ListOfUnits element on UnitDefinition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyUnitsInListOfUnits</code></td><td>Only Units allowed in ListOfUnits</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnUnitDefinition</code></td><td>Invalid attribute on &lt;unitDefinition&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfUnits</code></td><td>Invalid attribute on &lt;listOfUnits&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnUnit</code></td><td>Invalid attribute on &lt;unit&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>ZeroDimensionalCompartmentSize</code></td><td>Use of 'size' is invalid for a zero-dimensional compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>ZeroDimensionalCompartmentUnits</code></td><td>Use of 'units' is invalid for a zero-dimensional compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>ZeroDimensionalCompartmentConst</code></td><td>Zero-dimensional compartments cannot be non-constant</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>UndefinedOutsideCompartment</code></td><td>Undefined compartment used as 'outside' value</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>RecursiveCompartmentContainment</code></td><td>Recursive nesting of compartments via 'outside'</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>ZeroDCompartmentContainment</code></td><td>Invalid nesting of zero-dimensional compartments</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>Invalid1DCompartmentUnits</code></td><td>Invalid value of 'units' for a one-dimensional compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td></tr>
    <tr><td><code>Invalid2DCompartmentUnits</code></td><td>Invalid value of 'units' for a two-dimensional compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td></tr>
    <tr><td><code>Invalid3DCompartmentUnits</code></td><td>Invalid value of 'units' for a three-dimensional compartment</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td></tr>
    <tr><td><code>InvalidCompartmentTypeRef</code></td><td>Invalid 'compartmentType' reference</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>OneDimensionalCompartmentUnits</code></td><td>No units for 1D Compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>TwoDimensionalCompartmentUnits</code></td><td>No units for 2D Compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>ThreeDimensionalCompartmentUnits</code></td><td>No units for 3D Compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>AllowedAttributesOnCompartment</code></td><td>Invalid attribute on &lt;compartment&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidSpeciesCompartmentRef</code></td><td>Invalid 'compartment' reference</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>HasOnlySubsNoSpatialUnits</code></td><td>No 'spatialSizeUnits' permitted if 'hasOnlySubstanceUnits'='true'</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoSpatialUnitsInZeroD</code></td><td>No 'spatialSizeUnits' permitted if compartment is zero-dimensional</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoConcentrationInZeroD</code></td><td>No 'initialConcentration' permitted if compartment is zero-dimensional</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>SpatialUnitsInOneD</code></td><td>Invalid value of 'spatialSizeUnits' for a one-dimensional compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SpatialUnitsInTwoD</code></td><td>Invalid value of 'spatialSizeUnits' for a two-dimensional compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SpatialUnitsInThreeD</code></td><td>Invalid value of 'spatialSizeUnits' for a three-dimensional compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidSpeciesSusbstanceUnits</code></td><td>Invalid value of 'units'</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-warning'>W</td></tr>
    <tr><td><code>BothAmountAndConcentrationSet</code></td><td>Cannot set both 'initialConcentration' and 'initialAmount'</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NonBoundarySpeciesAssignedAndUsed</code></td><td>Cannot use non-boundary species in both reactions and rules simultaneously</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NonConstantSpeciesUsed</code></td><td>Cannot use non-boundary, constant species as reactant or product</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidSpeciesTypeRef</code></td><td>Invalid 'speciesType' reference</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>MultSpeciesSameTypeInCompartment</code></td><td>Cannot have multiple species of the same type in the same compartment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>MissingSpeciesCompartment</code></td><td>Missing 'compartment' value for species</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>SpatialSizeUnitsRemoved</code></td><td>Attribute 'spatialSizeUnits' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>SubstanceUnitsOnSpecies</code></td><td>No substance units for Species</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>ConversionFactorOnSpecies</code></td><td>Invalid conversionFactor attribute</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnSpecies</code></td><td>Invalid attribute on &lt;species&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidParameterUnits</code></td><td>Invalid value for 'units' in parameter definition</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ParameterUnits</code></td><td>No units for parameter</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td></tr>
    <tr><td><code>ConversionFactorMustConstant</code></td><td>ConversionFactor must be constant parameter</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnParameter</code></td><td>Invalid attribute on parameter</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidInitAssignSymbol</code></td><td>Invalid 'symbol' reference in initial assignment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>MultipleInitAssignments</code></td><td>Multiple initial assignments for the same 'symbol' value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InitAssignmentAndRuleForSameId</code></td><td>Cannot set a value with both initial assignments and assignment rules simultaneously</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMathElementPerInitialAssign</code></td><td>InitialAssignment must contain one math element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnInitialAssign</code></td><td>Invalid attribute on initialAssignment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidAssignRuleVariable</code></td><td>Invalid 'variable' reference in assignment rule</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidRateRuleVariable</code></td><td>Invalid 'variable' reference in rate rule</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>AssignmentToConstantEntity</code></td><td>Cannot reassign a constant in an assignment rule</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>RateRuleForConstantEntity</code></td><td>Cannot reassign a constant in a rate rule</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>RepeatedRule10304</code></td><td></td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>CircularRuleDependency</code></td><td>Circular dependency involving rules and reactions</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMathElementPerRule</code></td><td>Rule must contain one math element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnAssignRule</code></td><td>Invalid attribute on &lt;assignmentRule&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnRateRule</code></td><td>Invalid attribute on &lt;rateRule&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnAlgRule</code></td><td>Invalid attribute on &lt;algebraicRule&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>ConstraintMathNotBoolean</code></td><td>Non-boolean math expression in constraint definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>IncorrectOrderInConstraint</code></td><td>Incorrect order of elements in constraint definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>ConstraintNotInXHTMLNamespace</code></td><td>Constraint message is not in XHTML XML namespace</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>ConstraintContainsXMLDecl</code></td><td>XML declarations not permitted in constraint messages</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ConstraintContainsDOCTYPE</code></td><td>XML DOCTYPE not permitted in constraint messages</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidConstraintContent</code></td><td>Invalid content for constraint message</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>OneMathElementPerConstraint</code></td><td>Only one math element on &lt;constraint&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMessageElementPerConstraint</code></td><td>Only one message element on &lt;constraint&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnConstraint</code></td><td>Invalid attribute on &lt;constraint&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoReactantsOrProducts</code></td><td>Cannot have a reaction with neither reactants nor products</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>IncorrectOrderInReaction</code></td><td>Incorrect ordering of components in reaction definition</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>EmptyListInReaction</code></td><td>Reaction components, if present, cannot be empty</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidReactantsProductsList</code></td><td>Invalid element in list of reactants or products</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidModifiersList</code></td><td>Invalid element in list of modifiers</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneSubElementPerReaction</code></td><td>Only one of subelement on &lt;reaction&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>CompartmentOnReaction</code></td><td>Invalid compartment attribute on &lt;reaction&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnReaction</code></td><td>Invalid attribute on &lt;reaction&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidSpeciesReference</code></td><td>Invalid 'species' value in species reference</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>RepeatedRule20611</code></td><td></td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>BothStoichiometryAndMath</code></td><td>Cannot use both 'stoichiometry' and &lt;stoichiometryMath&gt; simultaneously</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>AllowedAttributesOnSpeciesReference</code></td><td>Invalid attribute on &lt;speciesReference&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnModifier</code></td><td>Invalid attribute on &lt;modifierSpeciesReference&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>UndeclaredSpeciesRef</code></td><td>Undeclared species referenced in kinetic law formula</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>IncorrectOrderInKineticLaw</code></td><td>Incorrect ordering of components in kinetic law definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>EmptyListInKineticLaw</code></td><td>The list of parameters component, if present, cannot be empty</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NonConstantLocalParameter</code></td><td>Parameters local to a kinetic law must have 'constant'='true'</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>SubsUnitsNoLongerValid</code></td><td>'substanceUnits' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>TimeUnitsNoLongerValid</code></td><td>'timeUnits' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>OneListOfPerKineticLaw</code></td><td>Only one listOfLocalParameters permitted on &lt;kineticLaw&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyLocalParamsInListOfLocalParams</code></td><td>Only LocalParameters allowed in ListOfLocalParameters</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfLocalParam</code></td><td>Invalid attribute on &lt;listOfLocalParameters&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMathPerKineticLaw</code></td><td>Only one math element on &lt;kineticLaw&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>UndeclaredSpeciesInStoichMath</code></td><td>Undeclared species referenced in &lt;stoichiometryMath&gt; formula</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>AllowedAttributesOnKineticLaw</code></td><td>Invalid attribute on &lt;kineticLaw&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfSpeciesRef</code></td><td>Invalid attribute on &lt;listOfSpeciesReferences&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfMods</code></td><td>Invalid attribute on &lt;listofModifiers&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnLocalParameter</code></td><td>Invalid attribute on &lt;localParameter&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>MissingTriggerInEvent</code></td><td>Missing trigger in event definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>TriggerMathNotBoolean</code></td><td>Non-boolean math expression in trigger definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>MissingEventAssignment</code></td><td>Missing event assignment in event definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>TimeUnitsEvent</code></td><td>Units of 'timeUnits' are not time units</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>IncorrectOrderInEvent</code></td><td>Incorrect ordering of components in event definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>ValuesFromTriggerTimeNeedDelay</code></td><td>'useValuesFromTriggerTime'='false', but no delay defined in event</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>DelayNeedsValuesFromTriggerTime</code></td><td>Delay requires useValuesFromTriggerTime</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMathPerTrigger</code></td><td>Trigger must have one math element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMathPerDelay</code></td><td>Delay must have one math element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>InvalidEventAssignmentVariable</code></td><td>Invalid value for 'variable' in event assignment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>EventAssignmentForConstantEntity</code></td><td>Cannot assign to a constant component in an event assignment</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneMathPerEventAssignment</code></td><td>EventAssignment must have one math element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnEventAssignment</code></td><td>Invalid attribute on &lt;eventAssignment&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyOneDelayPerEvent</code></td><td>Event can only have one &lt;delay&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OneListOfEventAssignmentsPerEvent</code></td><td>Event can only have one &lt;listOfEventAssignments&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>OnlyEventAssignInListOfEventAssign</code></td><td>&lt;listOfEventAssignments&gt; can only have &lt;eventAssignment&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnListOfEventAssign</code></td><td>Invalid attribute on &lt;listOfEventAssignments&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnEvent</code></td><td>Invalid attribute on &lt;event&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnTrigger</code></td><td>Invalid attribute on &lt;trigger&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>AllowedAttributesOnDelay</code></td><td>Invalid attribute on &lt;delay&gt;</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>CompartmentShouldHaveSize</code></td><td>It's best to define a size for every compartment in a model</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>ParameterShouldHaveUnits</code></td><td>It's best to declare units for every parameter in a model</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>LocalParameterShadowsId</code></td><td>Local parameters defined in a kinetic law shadow global parameters</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>CannotConvertToL1V1</code></td><td>Cannot convert to SBML Level 1 Version 1</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoEventsInL1</code></td><td>SBML Level 1 does not support events</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoFunctionDefinitionsInL1</code></td><td>SBML Level 1 does not support function definitions</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoConstraintsInL1</code></td><td>SBML Level 1 does not support constraints</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>NoInitialAssignmentsInL1</code></td><td>SBML Level 1 does not support initial assignments</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoSpeciesTypesInL1</code></td><td>SBML Level 1 does not support species types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoCompartmentTypeInL1</code></td><td>SBML Level 1 does not support compartment types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoNon3DComparmentsInL1</code></td><td>SBML Level 1 only supports three-dimensional compartments</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoFancyStoichiometryMathInL1</code></td><td>SBML Level 1 does not support non-integer nor non-rational stoichiometry formulas</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoNonIntegerStoichiometryInL1</code></td><td>SBML Level 1 does not support non-integer 'stoichiometry' attribute values</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoUnitMultipliersOrOffsetsInL1</code></td><td>SBML Level 1 does not support multipliers or offsets in unit definitions</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>SpeciesCompartmentRequiredInL1</code></td><td>In SBML Level 1, a value for 'compartment' is mandatory in species definitions</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoSpeciesSpatialSizeUnitsInL1</code></td><td>SBML Level 1 does not support species 'spatialSizeUnits' settings</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoSBOTermsInL1</code></td><td>SBML Level 1 does not support the 'sboTerm' attribute</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>StrictUnitsRequiredInL1</code></td><td>SBML Level 1 requires strict unit consistency</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>NoConstraintsInL2v1</code></td><td>SBML Level 2 Version 1 does not support constraints</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>NoInitialAssignmentsInL2v1</code></td><td>SBML Level 2 Version 1 does not support initial assignments</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoSpeciesTypeInL2v1</code></td><td>SBML Level 2 Version 1 does not support species types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoCompartmentTypeInL2v1</code></td><td>SBML Level 2 Version 1 does not support compartment types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoSBOTermsInL2v1</code></td><td>SBML Level 2 Version 1 does not support the 'sboTerm' attribute</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>NoIdOnSpeciesReferenceInL2v1</code></td><td>SBML Level 2 Version 1 does not support the 'id' attribute on species references</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>NoDelayedEventAssignmentInL2v1</code></td><td>Attribute 'useValuesFromTriggerTime' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>StrictUnitsRequiredInL2v1</code></td><td>SBML Level 2 Version 1 requires strict unit consistency</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>SBOTermNotUniversalInL2v2</code></td><td>The 'sboTerm' attribute is invalid for this component in Level 2 Version 2</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>NoUnitOffsetInL2v2</code></td><td>The unit 'offset' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawTimeUnitsInL2v2</code></td><td>The 'timeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawSubstanceUnitsInL2v2</code></td><td>The 'substanceUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoDelayedEventAssignmentInL2v2</code></td><td>Attribute 'useValuesFromTriggerTime' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ModelSBOBranchChangedBeyondL2v2</code></td><td>The allowable 'sboTerm' values for model differ for this SBML Level+Version</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>StrictUnitsRequiredInL2v2</code></td><td>SBML Level 2 Version 2 requires strict unit consistency</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>StrictSBORequiredInL2v2</code></td><td>SBML Level 2 Version 2 requires strict sbo consistency</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>DuplicateAnnotationInvalidInL2v2</code></td><td>Duplicate top level annotations invalid in L2V2</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoUnitOffsetInL2v3</code></td><td>Attribute 'offset' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawTimeUnitsInL2v3</code></td><td>Attribute 'timeUnits' not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawSubstanceUnitsInL2v3</code></td><td>Attribute 'substanceUnits' not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoSpeciesSpatialSizeUnitsInL2v3</code></td><td>Attribute 'spatialSizeUnits' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoEventTimeUnitsInL2v3</code></td><td>Attribute 'timeUnits' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoDelayedEventAssignmentInL2v3</code></td><td>Attribute 'useValuesFromTriggerTime' not supported in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ModelSBOBranchChangedBeyondL2v3</code></td><td>The allowable 'sboTerm' values for model differ for this SBML Level+Version</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>StrictUnitsRequiredInL2v3</code></td><td>SBML Level 2 Version 3 requires strict unit consistency</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>StrictSBORequiredInL2v3</code></td><td>SBML Level 2 Version 3 requires strict sbo consistency</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>DuplicateAnnotationInvalidInL2v3</code></td><td>Duplicate top level annotations invalid in L2V3</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoUnitOffsetInL2v4</code></td><td>The unit 'offset' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawTimeUnitsInL2v4</code></td><td>The 'timeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawSubstanceUnitsInL2v4</code></td><td>The 'substanceUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoSpeciesSpatialSizeUnitsInL2v4</code></td><td>The 'spatialSizeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoEventTimeUnitsInL2v4</code></td><td>The 'timeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>ModelSBOBranchChangedInL2v4</code></td><td>The allowable 'sboTerm' values for model differ for this SBML Level+Version</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>DuplicateAnnotationInvalidInL2v4</code></td><td>Duplicate top level annotations invalid in L2V4</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoSpeciesTypeInL3v1</code></td><td>SBML Level 3 Version 1 does not support species types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoCompartmentTypeInL3v1</code></td><td>SBML Level 3 Version 1 does not support compartment types</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoUnitOffsetInL3v1</code></td><td>The unit 'offset' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawTimeUnitsInL3v1</code></td><td>The 'timeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoKineticLawSubstanceUnitsInL3v1</code></td><td>The 'substanceUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoSpeciesSpatialSizeUnitsInL3v1</code></td><td>The 'spatialSizeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoEventTimeUnitsInL3v1</code></td><td>The 'timeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>ModelSBOBranchChangedInL3v1</code></td><td>The allowable 'sboTerm' values for model differ for this SBML Level+Version</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>DuplicateAnnotationInvalidInL3v1</code></td><td>Duplicate top level annotations invalid in L3V1</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoCompartmentOutsideInL3v1</code></td><td>The 'outside' attribute is invalid in this Level+Version of SBML</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-na'>N</td></tr>
    <tr><td><code>NoStoichiometryMathInL3v1</code></td><td>SBML Level 3 Version 1 does not support stoichiometryMath</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidSBMLLevelVersion</code></td><td>Invalid SBML Level and Version</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>AnnotationNotesNotAllowedLevel1</code></td><td>Annotation on &lt;sbml&gt; not permitted in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidRuleOrdering</code></td><td>Invalid ordering of rules</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SubsUnitsAllowedInKL</code></td><td>Disallowed value for attribute 'substanceUnits'</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>TimeUnitsAllowedInKL</code></td><td>Disallowed value for attribute 'timeUnits'</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>FormulaInLevel1KL</code></td><td>Only predefined functions are permitted in SBML Level 1 formulas</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>TimeUnitsRemoved</code></td><td>The 'timeUnits' attribute is invalid in this Level+Version of SBML</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>BadMathML</code></td><td>Invalid MathML expression</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>FailedMathMLReadOfDouble</code></td><td>Failed to read floating-point number</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>FailedMathMLReadOfInteger</code></td><td>Failed to read an integer</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>FailedMathMLReadOfExponential</code></td><td>Failed to read an exponential expression</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>FailedMathMLReadOfRational</code></td><td>Failed to read a rational expression</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>BadMathMLNodeType</code></td><td>Invalid MathML element</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>NoTimeSymbolInFunctionDef</code></td><td>&lt;csymbol&gt; for 'time' used within the &lt;math&gt; of a function definition</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>UndeclaredUnits</code></td><td>Undeclared units</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>UnrecognisedSBOTerm</code></td><td>Unrecognized 'sboTerm' value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>ObseleteSBOTerm</code></td><td>Obsolete 'sboTerm' value</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td><td class='s-warning'>W</td></tr>
    <tr><td><code>IncorrectCompartmentSpatialDimensions</code></td><td>in SBML Level 1, only three-dimensional compartments are permitted</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>CompartmentTypeNotValidAttribute</code></td><td>Compartment types not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>ConstantNotValidAttribute</code></td><td>Attribute 'constant' not supported on this component in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>MetaIdNotValidAttribute</code></td><td>Attribute 'metaid' not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SBOTermNotValidAttributeBeforeL2V3</code></td><td>'sboTerm' not available on this component before SBML Level 2 Version 3</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidL1CompartmentUnits</code></td><td>Invalid units for a compartment in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>L1V1CompartmentVolumeReqd</code></td><td>Compartment volume must be specified</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>CompartmentTypeNotValidComponent</code></td><td>Compartment types not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>ConstraintNotValidComponent</code></td><td>Constraints not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>EventNotValidComponent</code></td><td>Events not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SBOTermNotValidAttributeBeforeL2V2</code></td><td>The 'sboTerm' attribute is invalid for this component before Level 2 Version 2</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>FuncDefNotValidComponent</code></td><td>Function definitions are not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>InitialAssignNotValidComponent</code></td><td>Initial assignments are not supported in this Level+Version of SBML</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>VariableNotValidAttribute</code></td><td>Attribute 'variable' not valid</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>UnitsNotValidAttribute</code></td><td>Attribute 'units' not valid</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>ConstantSpeciesNotValidAttribute</code></td><td>Attribute 'constant' on species not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SpatialSizeUnitsNotValidAttribute</code></td><td>Attribute 'spatialSizeUnits' on species not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SpeciesTypeNotValidAttribute</code></td><td>Attribute 'speciesType' on species not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>HasOnlySubsUnitsNotValidAttribute</code></td><td>Attribute 'hasOnlySubstanceUnits' on species not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>IdNotValidAttribute</code></td><td>Attribute 'id' on species references not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>NameNotValidAttribute</code></td><td>Attribute 'name' on species references not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>SpeciesTypeNotValidComponent</code></td><td>Species types not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>StoichiometryMathNotValidComponent</code></td><td>&lt;stoichiometryMath&gt; not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-error'>E</td></tr>
    <tr><td><code>MultiplierNotValidAttribute</code></td><td>Attribute 'multiplier' on units not supported in SBML Level 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>OffsetNotValidAttribute</code></td><td>Attribute 'offset' on units only available in SBML Level 2 Version 1</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td><td class='s-na'>N</td></tr>
    <tr><td><code>InvalidTargetLevelVersion</code></td><td>The target Level/Version does not exist</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    <tr><td><code>L3NotSupported</code></td><td>SBML Level 3 is not yet supported</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td><td class='s-error'>E</td></tr>
    </table>
    </center>

    @if clike
    <h3><a class='anchor' name='SBMLErrorCategory_t'>SBMLErrorCategory_t</a></h3>

    SBMLErrorCategory_t is an enumeration of category codes for SBMLError
    diagnostics.  The category can be retrieved from an SBMLError object
    using the method SBMLError::getCategory().  These enumeration values are
    distinct from (and in addition to) the @link
    XMLError::XMLErrorCategory_t XMLErrorCategory_t @endlink codes used by
    the parent XMLError object.  User programs receiving an SBMLError object
    can use this distinction to check whether the error represents a
    low-level XML problem or an SBML problem.

    The following table lists each possible value and a brief description of
    its meaning.

    @endif@if java <h3><a class='anchor'
    name='SBMLErrorCategory_t'>Category codes associated with SBMLError objects</a></h3>

    As discussed above, each SBMLError object contains a value for a
    category identifier, describing the type of issue that the SBMLError
    object represents.  The category can be retrieved from an SBMLError
    object using the method SBMLError::getCategory().  The following table
    lists each possible value and a brief description of its meaning.

    As is the case with the error codes, in the libSBML Java language
    interface, the category identifiers are currently implemented as static
    integer constants defined in the interface class
    <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>. @endif

    <center>
    <table width='90%' cellspacing='1' cellpadding='4' border='0'  class='text-table normal-font alt-row-colors'>
     <tr style='background: lightgray' class='normal-font'>
         <th>Enumerator</td>
         <th>Meaning</td>
     </tr>
    <tr><td><code>LIBSBML_CAT_SBML</code></td><td>General error not falling into
    another category below.</td></tr> 
    <tr><td><code>LIBSBML_CAT_SBML_L1_COMPAT</code></td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model from SBML Level&nbsp;2 to SBML
    Level&nbsp;1.</td></tr> 
    <tr><td><code>LIBSBML_CAT_SBML_L2V1_COMPAT</code></td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;1.</td></tr> 
    <tr><td><code>LIBSBML_CAT_SBML_L2V2_COMPAT</code></td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;2.</td></tr> 
    <tr><td><code>LIBSBML_CAT_GENERAL_CONSISTENCY</code></td><td>Category of
    errors that can occur while validating general SBML constructs.  With
    respect to the SBML specification, these concern failures in applying
    the validation rules numbered 2xxxx in the Level&nbsp;2 Versions&nbsp;2
    and&nbsp;3 specifications.</td></tr>
    <tr><td><code>LIBSBML_CAT_IDENTIFIER_CONSISTENCY</code></td><td>Category of
    errors that can occur while validating symbol identifiers in a model.
    With respect to the SBML specification, these concern failures in
    applying the validation rules numbered 103xx in the Level&nbsp;2
    Versions&nbsp;2 and&nbsp;3 specifications.</td></tr>  
    <tr><td><code>LIBSBML_CAT_UNITS_CONSISTENCY</code></td><td>Category of
    errors that can occur while validating the units of measurement on
    quantities in a model.  With respect to the SBML specification, these
    concern failures in applying the validation rules numbered 105xx in the
    Level&nbsp;2 Versions&nbsp;2 and&nbsp;3 specifications.</td></tr> 
    <tr><td><code>LIBSBML_CAT_MATHML_CONSISTENCY</code></td><td>Category of
    errors that can occur while validating MathML formulas in a model.  With
    respect to the SBML specification, these concern failures in applying
    the validation rules numbered 102xx in the Level&nbsp;2 Versions&nbsp;2
    and&nbsp;3 specifications.</td></tr> 
    <tr><td><code>LIBSBML_CAT_SBO_CONSISTENCY</code></td><td>Category of errors
    that can occur while validating SBO identifiers in a model.  With
    respect to the SBML specification, these concern failures in applying
    the validation rules numbered 107xx in the Level&nbsp;2 Versions&nbsp;2
    and&nbsp;3 specifications.</td></tr> 
    <tr><td><code>LIBSBML_CAT_OVERDETERMINED_MODEL</code></td><td>Error in the
    system of equations in the model: the system is overdetermined,
    therefore violating a tenet of proper SBML.  With respect to the SBML
    specification, this is validation rule #10601 in the SBML Level&nbsp;2
    Versions&nbsp;2 and&nbsp;3 specifications.</td></tr> 
    <tr><td><code>LIBSBML_CAT_SBML_L2V3_COMPAT</code></td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;3.</td></tr> 
    <tr><td><code>LIBSBML_CAT_MODELING_PRACTICE</code></td><td>Category of
    warnings about recommended good practices involving SBML and
    computational modeling.  (These are tests performed by libSBML and do
    not have equivalent SBML validation rules.)</td></tr> 
    <tr><td><code>LIBSBML_CAT_INTERNAL_CONSISTENCY</code></td><td>Category of
    errors that can occur while validating libSBML's internal representation
    of SBML constructs. (These are tests performed by libSBML and do
    not have equivalent SBML validation rules.)</td></tr> 
    <tr><td><code>LIBSBML_CAT_SBML_L2V4_COMPAT</code></td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;4.</td></tr> 

    </table>
    </center>

    @if clike
    <h3><a class='anchor' name='SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a></h3>

    This is an enumeration of severity codes for SBMLError diagnostics.
    User programs receiving an SBMLError object can use this distinction to
    check whether the error represents a low-level XML problem or an SBML
    problem.

    In this verision of libSBML (3.3.x), there are no additional severity
    codes in SBMLErrorSeverity_t beyond those defined in @link
    XMLError::XMLErrorSeverity_t XMLErrorSeverity_t @endlink.

    <hr>
    @endif@if java <h3><a class='anchor'
    name='SBMLErrorSeverity_t'>Severity codes associated with SBMLError
    objects</h3>

    In this verision of libSBML (3.3.x), there are no additional severity
    codes beyond those defined by XMLError.  They are implemented as static
    integer constants defined in the interface class <code><a
    href='libsbmlConstants.html'>libsbmlConstants</a></code>, and have names
    beginning with <code>LIBSBML_SEV_</code>.
    @endif

    """
    __swig_setmethods__ = {}
    for _s in [XMLError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLError, name, value)
    __swig_getmethods__ = {}
    for _s in [XMLError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, 
            string details = "", 
            unsigned int line = 0, unsigned int column = 0, 
            unsigned int severity = LIBSBML_SEV_ERROR, 
            unsigned int category = LIBSBML_CAT_SBML) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, 
            string details = "", 
            unsigned int line = 0, unsigned int column = 0, 
            unsigned int severity = LIBSBML_SEV_ERROR) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, 
            string details = "", 
            unsigned int line = 0, unsigned int column = 0) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, 
            string details = "", 
            unsigned int line = 0) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, 
            string details = "") -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = 3) -> SBMLError
        __init__(self, unsigned int errorId = 0) -> SBMLError
        __init__(self) -> SBMLError
        __init__(self, SBMLError orig) -> SBMLError

        Copy constructor; creates a copy of this SBMLError.
          

        """
        this = _libsbml.new_SBMLError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLError
    __del__ = lambda self : None;
SBMLError_swigregister = _libsbml.SBMLError_swigregister
SBMLError_swigregister(SBMLError)

MODEL_QUALIFIER = _libsbml.MODEL_QUALIFIER
BIOLOGICAL_QUALIFIER = _libsbml.BIOLOGICAL_QUALIFIER
UNKNOWN_QUALIFIER = _libsbml.UNKNOWN_QUALIFIER
BQM_IS = _libsbml.BQM_IS
BQM_IS_DESCRIBED_BY = _libsbml.BQM_IS_DESCRIBED_BY
BQM_IS_DERIVED_FROM = _libsbml.BQM_IS_DERIVED_FROM
BQM_UNKNOWN = _libsbml.BQM_UNKNOWN
BQB_IS = _libsbml.BQB_IS
BQB_HAS_PART = _libsbml.BQB_HAS_PART
BQB_IS_PART_OF = _libsbml.BQB_IS_PART_OF
BQB_IS_VERSION_OF = _libsbml.BQB_IS_VERSION_OF
BQB_HAS_VERSION = _libsbml.BQB_HAS_VERSION
BQB_IS_HOMOLOG_TO = _libsbml.BQB_IS_HOMOLOG_TO
BQB_IS_DESCRIBED_BY = _libsbml.BQB_IS_DESCRIBED_BY
BQB_IS_ENCODED_BY = _libsbml.BQB_IS_ENCODED_BY
BQB_ENCODES = _libsbml.BQB_ENCODES
BQB_OCCURS_IN = _libsbml.BQB_OCCURS_IN
BQB_HAS_PROPERTY = _libsbml.BQB_HAS_PROPERTY
BQB_IS_PROPERTY_OF = _libsbml.BQB_IS_PROPERTY_OF
BQB_UNKNOWN = _libsbml.BQB_UNKNOWN
class CVTerm(_object):
    """
    Representation of MIRIAM-compliant controlled vocabulary annotation.

    @htmlinclude not-sbml-warning.html

    CVTerm is a libSBML construct used as part of the libSBML support for
    annotations conforming to the guidelines specified by MIRIAM ('Minimum
    Information Requested in the Annotation of biochemical Models').  The
    general scheme is as follows.  A set of RDF-based annotations attached
    to a given SBML <code>&lt;annotation&gt;</code> element are read by
    RDFAnnotationParser and converted into a list of CVTerm objects.  Each
    CVTerm object instance stores the following components of an annotation:

    <ul>
    <li>The qualifier, which can be a MIRIAM 'biological qualifier', a
    'model qualifier', or an unknown qualifier (as far as the CVTerm class
    is concerned).  Qualifiers are used in MIRIAM to indicate the nature of
    the relationship between the object being annotated and the resource.
    In CVTerm, the qualifiers can be manipulated using the methods
    getQualifierType(), setQualifierType(), and related methods.

    <li>The resource, represent by a URI (note: not a URL).  In CVTerm, the
    resource component can be manipulated using the methods addResource()
    and removeResource().
    </ul>

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CVTerm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CVTerm, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_CVTerm
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, QualifierType_t type = UNKNOWN_QUALIFIER) -> CVTerm
        __init__(self) -> CVTerm
        __init__(self, XMLNode node) -> CVTerm
        __init__(self, CVTerm orig) -> CVTerm

        Copy constructor; creates a copy of a CVTerm.

        @param orig the CVTerm instance to copy.
          

        """
        this = _libsbml.new_CVTerm(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> CVTerm

        Creates and returns a deep copy of this CVTerm.

        @return a (deep) copy of this CVTerm.
            

        """
        return _libsbml.CVTerm_clone(self)

    def getQualifierType(self):
        """
        getQualifierType(self) -> QualifierType_t

        Returns the Qualifier Type code for this %CVTerm.

        @return the #QualifierType_t value of this object or UNKNOWN_QUALIFIER
        (default).
          

        """
        return _libsbml.CVTerm_getQualifierType(self)

    def getModelQualifierType(self):
        """
        getModelQualifierType(self) -> ModelQualifierType_t

        Returns the Model QualifierType code for this %CVTerm.

        @return the #ModelQualifierType_t value of this object or BQM_UNKNOWN
        (default).
          

        """
        return _libsbml.CVTerm_getModelQualifierType(self)

    def getBiologicalQualifierType(self):
        """
        getBiologicalQualifierType(self) -> BiolQualifierType_t

        Returns the Biological QualifierType code for this %CVTerm.

        @return the #BiolQualifierType_t value of this object or BQB_UNKNOWN
        (default).
          

        """
        return _libsbml.CVTerm_getBiologicalQualifierType(self)

    def getResources(self, *args):
        """
        getResources(self) -> XMLAttributes
        getResources(self) -> XMLAttributes

        Returns the resources for this %CVTerm.

        @return the XMLAttributes that store the resources of this %CVTerm.
          

        """
        return _libsbml.CVTerm_getResources(self, *args)

    def getNumResources(self):
        """
        getNumResources(self) -> unsigned int

        Returns the number of resources for this %CVTerm.

        @return the number of resources in the set of XMLAttributes
        of this %CVTerm.
          

        """
        return _libsbml.CVTerm_getNumResources(self)

    def getResourceURI(self, *args):
        """
        getResourceURI(self, unsigned int n) -> string

        Returns the value of the nth resource for this %CVTerm.

        @param n the index of the resource to query

        @return string representing the value of the nth resource
        in the set of XMLAttributes of this %CVTerm.

        @note Since the values of the resource attributes in a CVTerm
        are URIs this is a convenience function to facilitate
        interaction with the CVTerm class.
          

        """
        return _libsbml.CVTerm_getResourceURI(self, *args)

    def setQualifierType(self, *args):
        """
        setQualifierType(self, QualifierType_t type) -> int

        Sets the #QualifierType_t value of this %CVTerm.

        @param type the #QualifierType_t type value 
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.CVTerm_setQualifierType(self, *args)

    def setModelQualifierType(self, *args):
        """
        setModelQualifierType(self, ModelQualifierType_t type) -> int

        Sets the #ModelQualifierType_t value of this %CVTerm.

        @param type the #ModelQualifierType_t value

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note If the Qualifier Type of this object is not MODEL_QUALIFIER,
        then the ModelQualifierType_t will default to BQM_UNKNOWN.
          

        """
        return _libsbml.CVTerm_setModelQualifierType(self, *args)

    def setBiologicalQualifierType(self, *args):
        """
        setBiologicalQualifierType(self, BiolQualifierType_t type) -> int

        Sets the #BiolQualifierType_t of this %CVTerm.

        @param type the #BiolQualifierType_t value

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note if the Qualifier Type of this object is not
        BIOLOGICAL_QUALIFIER, then the #BiolQualifierType_t value will default
        to BQB_UNKNOWN.
          

        """
        return _libsbml.CVTerm_setBiologicalQualifierType(self, *args)

    def addResource(self, *args):
        """
        addResource(self, string resource) -> int

        Adds a resource to the CVTerm.

        @param resource string representing the resource; e.g.,
        'http://www.geneontology.org/#GO:0005892'

        @note this method adds the name 'rdf:resource' to the attribute prior
        to adding it to the resources in this CVTerm.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.CVTerm_addResource(self, *args)

    def removeResource(self, *args):
        """
        removeResource(self, string resource) -> int

        Removes a resource from the CVTerm.

        @param resource string representing the resource; e.g.,
        'http://www.geneontology.org/#GO:0005892'

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.CVTerm_removeResource(self, *args)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Removes a resource from the CVTerm.

        @param resource string representing the resource; e.g.,
        'http://www.geneontology.org/#GO:0005892'

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
        @deprecated libSBML internal


        """
        return _libsbml.CVTerm_hasRequiredAttributes(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

CVTerm_swigregister = _libsbml.CVTerm_swigregister
CVTerm_swigregister(CVTerm)

class Date(_object):
    """
    Representation of MIRIAM-compliant dates used in ModelHistory.

    @htmlinclude not-sbml-warning.html

    A Date object stores a reasonably complete date representation,
    consisting of the following fields:
    <ul>
    <li> @em year: an unsigned int representing the year.
    <li> @em month: an unsigned int representing the month.
    <li> @em day: an unsigned int representing the day.
    <li> @em hour: an unsigned int representing the hour.
    <li> @em minute: an unsigned int representing the minute.
    <li> @em second: an unsigned int representing the second.
    <li> @em sign: an unsigned int representing the sign of the offset (0/1 equivalent to +/-). 
    <li> @em hours offset: an unsigned int representing the hoursOffset.
    <li> @em minute offset: an unsigned int representing the minutesOffset.
    </ul>

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Date, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Date, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Date
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0, 
            unsigned int sign = 0, unsigned int hoursOffset = 0, 
            unsigned int minutesOffset = 0) -> Date
        __init__(self, unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0, 
            unsigned int sign = 0, unsigned int hoursOffset = 0) -> Date
        __init__(self, unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0, 
            unsigned int sign = 0) -> Date
        __init__(self, unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0) -> Date
        __init__(self, unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0) -> Date
        __init__(self, unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0) -> Date
        __init__(self, unsigned int year = 2007, unsigned int month = 1, unsigned int day = 1) -> Date
        __init__(self, unsigned int year = 2007, unsigned int month = 1) -> Date
        __init__(self, unsigned int year = 2007) -> Date
        __init__(self) -> Date
        __init__(self, string date) -> Date
        __init__(self, Date orig) -> Date

        Copy constructor; creates a copy of this Date.
          

        """
        this = _libsbml.new_Date(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Date

        Returns a copy of this Date.

        @return a (deep) copy of this Date.
          

        """
        return _libsbml.Date_clone(self)

    def getYear(self):
        """
        getYear(self) -> unsigned int

        Returns the year from this Date.

        @return the year from this Date.
          

        """
        return _libsbml.Date_getYear(self)

    def getMonth(self):
        """
        getMonth(self) -> unsigned int

        Returns the month from this Date.

        @return the month from this Date.
          

        """
        return _libsbml.Date_getMonth(self)

    def getDay(self):
        """
        getDay(self) -> unsigned int

        Returns the day from this Date.

        @return the day from this Date.
          

        """
        return _libsbml.Date_getDay(self)

    def getHour(self):
        """
        getHour(self) -> unsigned int

        Returns the hour from this Date.

        @return the hour from this Date.
          

        """
        return _libsbml.Date_getHour(self)

    def getMinute(self):
        """
        getMinute(self) -> unsigned int

        Returns the minute from this Date.

        @return the minute from this Date.
          

        """
        return _libsbml.Date_getMinute(self)

    def getSecond(self):
        """
        getSecond(self) -> unsigned int

        Returns the seconds from this Date.

        @return the seconds from this Date.
          

        """
        return _libsbml.Date_getSecond(self)

    def getSignOffset(self):
        """
        getSignOffset(self) -> unsigned int

        Returns the sign of the offset from this Date.

        @return the sign of the offset from this Date.
          

        """
        return _libsbml.Date_getSignOffset(self)

    def getHoursOffset(self):
        """
        getHoursOffset(self) -> unsigned int

        Returns the hours of the offset from this Date.

        @return the hours of the offset from this Date.
          

        """
        return _libsbml.Date_getHoursOffset(self)

    def getMinutesOffset(self):
        """
        getMinutesOffset(self) -> unsigned int

        Returns the minutes of the offset from this Date.

        @return the minutes of the offset from this Date.
          

        """
        return _libsbml.Date_getMinutesOffset(self)

    def getDateAsString(self):
        """
        getDateAsString(self) -> string

        Returns the Date as a string.

        @return the date as a string.
          

        """
        return _libsbml.Date_getDateAsString(self)

    def setYear(self, *args):
        """
        setYear(self, unsigned int year) -> int

        Sets the value of the year checking appropriateness.
         
        @param year an unsigned int representing the year to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setYear(self, *args)

    def setMonth(self, *args):
        """
        setMonth(self, unsigned int month) -> int

        Sets the value of the month checking appropriateness.
         
        @param month an unsigned int representing the month to set  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setMonth(self, *args)

    def setDay(self, *args):
        """
        setDay(self, unsigned int day) -> int

        Sets the value of the day checking appropriateness.
         
        @param day an unsigned int representing the day to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setDay(self, *args)

    def setHour(self, *args):
        """
        setHour(self, unsigned int hour) -> int

        Sets the value of the hour checking appropriateness.
         
        @param hour an unsigned int representing the hour to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setHour(self, *args)

    def setMinute(self, *args):
        """
        setMinute(self, unsigned int minute) -> int

        Sets the value of the minute checking appropriateness.
         
        @param minute an unsigned int representing the minute to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setMinute(self, *args)

    def setSecond(self, *args):
        """
        setSecond(self, unsigned int second) -> int

        Sets the value of the second checking appropriateness.
         
        @param second an unsigned int representing the second to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setSecond(self, *args)

    def setSignOffset(self, *args):
        """
        setSignOffset(self, unsigned int sign) -> int

        Sets the value of the offset sign checking appropriateness.
         
        @param sign an unsigned int representing 
        the sign of the offset to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setSignOffset(self, *args)

    def setHoursOffset(self, *args):
        """
        setHoursOffset(self, unsigned int hoursOffset) -> int

        Sets the value of the offset hour checking appropriateness.
         
        @param hoursOffset an unsigned int representing the hours of the 
        offset to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setHoursOffset(self, *args)

    def setMinutesOffset(self, *args):
        """
        setMinutesOffset(self, unsigned int minutesOffset) -> int

        Sets the value of the offset minutes checking appropriateness.
         
        @param minutesOffset an unsigned int representing the minutes of the 
        offset to set.  

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink
          

        """
        return _libsbml.Date_setMinutesOffset(self, *args)

    def setDateAsString(self, *args):
        """
        setDateAsString(self, string date) -> int

        Sets the value of the date string checking appropriateness.

        @param date a string representing the date.


        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note the string should be in W3CDTF format 
        YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)
        where TZD is the time zone designator.
          

        """
        return _libsbml.Date_setDateAsString(self, *args)

    def representsValidDate(self):
        """
        representsValidDate(self) -> bool

        Sets the value of the date string checking appropriateness.

        @param date a string representing the date.


        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink

        @note the string should be in W3CDTF format 
        YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)
        where TZD is the time zone designator.
          

        """
        return _libsbml.Date_representsValidDate(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

Date_swigregister = _libsbml.Date_swigregister
Date_swigregister(Date)

class ModelCreator(_object):
    """
    Representation of MIRIAM-compliant model creator data used
    in ModelHistory. 

    @htmlinclude not-sbml-warning.html

    The SBML specification beginning with Level 2 Version 2 defines a
    standard approach to recording model history and model creator
    information in a form that complies with MIRIAM ('Minimum Information
    Requested in the Annotation of biochemical Models', <i>Nature
    Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  LibSBML provides the
    ModelCreator class as a convenience high-level interface for working
    with model creator data.

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelCreator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelCreator, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ModelCreator
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> ModelCreator
        __init__(self, XMLNode creator) -> ModelCreator
        __init__(self, ModelCreator orig) -> ModelCreator

        Copy constructor; creates a copy of the ModelCreator.
          

        """
        this = _libsbml.new_ModelCreator(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ModelCreator

        Creates and returns a copy of this ModelCreator.

        @return a (deep) copy of this ModelCreator.
          

        """
        return _libsbml.ModelCreator_clone(self)

    def getFamilyName(self):
        """
        getFamilyName(self) -> string

        Returns the familyName from the ModelCreator.

        @return familyName from the ModelCreator.
          

        """
        return _libsbml.ModelCreator_getFamilyName(self)

    def getGivenName(self):
        """
        getGivenName(self) -> string

        Returns the givenName from the ModelCreator.

        @return givenName from the ModelCreator.
          

        """
        return _libsbml.ModelCreator_getGivenName(self)

    def getEmail(self):
        """
        getEmail(self) -> string

        Returns the email from the ModelCreator.

        @return email from the ModelCreator.
          

        """
        return _libsbml.ModelCreator_getEmail(self)

    def getOrganization(self):
        """
        getOrganization(self) -> string

        Returns the organization from the ModelCreator.

        @return organization from the ModelCreator.
          

        """
        return _libsbml.ModelCreator_getOrganization(self)

    def getOrganisation(self):
        """
        getOrganisation(self) -> string

        Returns the organization from the ModelCreator.

        @note This function is an alias of getOrganization().

        @return organization from the ModelCreator.

        @see getOrganization()
          

        """
        return _libsbml.ModelCreator_getOrganisation(self)

    def isSetFamilyName(self):
        """
        isSetFamilyName(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ModelCreator's familyName has been set.

        @return @c true if the familyName of this ModelCreator has been set, @c false otherwise.
          

        """
        return _libsbml.ModelCreator_isSetFamilyName(self)

    def isSetGivenName(self):
        """
        isSetGivenName(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ModelCreator's givenName has been set.

        @return @c true if the givenName of this ModelCreator has been set, @c false otherwise.
          

        """
        return _libsbml.ModelCreator_isSetGivenName(self)

    def isSetEmail(self):
        """
        isSetEmail(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ModelCreator's email has been set.

        @return @c true if the email of this ModelCreator has been set, @c false otherwise.
          

        """
        return _libsbml.ModelCreator_isSetEmail(self)

    def isSetOrganization(self):
        """
        isSetOrganization(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ModelCreator's organization has been set.

        @return @c true if the organization of this ModelCreator has been set, @c false otherwise.
          

        """
        return _libsbml.ModelCreator_isSetOrganization(self)

    def isSetOrganisation(self):
        """
        isSetOrganisation(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ModelCreator's organization has been set.

        @note This function is an alias of isSetOrganization().

        @return @c true if the organization of this ModelCreator has been set, @c false otherwise.

        @see isSetOrganization()
          

        """
        return _libsbml.ModelCreator_isSetOrganisation(self)

    def setFamilyName(self, *args):
        """
        setFamilyName(self, string familyName) -> int

        Sets the family name
         
        @param familyName a string representing the familyName of the ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.ModelCreator_setFamilyName(self, *args)

    def setGivenName(self, *args):
        """
        setGivenName(self, string givenName) -> int

        Sets the given name
         
        @param givenName a string representing the givenName of the ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.ModelCreator_setGivenName(self, *args)

    def setEmail(self, *args):
        """
        setEmail(self, string email) -> int

        Sets the email
         
        @param email a string representing the email of the ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.ModelCreator_setEmail(self, *args)

    def setOrganization(self, *args):
        """
        setOrganization(self, string organization) -> int

        Sets the organization
         
        @param organization a string representing the organization of the 
        ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
          

        """
        return _libsbml.ModelCreator_setOrganization(self, *args)

    def setOrganisation(self, *args):
        """
        setOrganisation(self, string organization) -> int

        Sets the organization

        @param organization a string representing the organization of the
        ModelCreator.

        @note This function is an alias of setOrganization(std::string organization).

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink

        @see setOrganization(std::string organization)
          

        """
        return _libsbml.ModelCreator_setOrganisation(self, *args)

    def unsetFamilyName(self):
        """
        unsetFamilyName(self) -> int

        Unsets the familyName of this ModelCreator.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.ModelCreator_unsetFamilyName(self)

    def unsetGivenName(self):
        """
        unsetGivenName(self) -> int

        Unsets the givenName of this ModelCreator.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.ModelCreator_unsetGivenName(self)

    def unsetEmail(self):
        """
        unsetEmail(self) -> int

        Unsets the email of this ModelCreator.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.ModelCreator_unsetEmail(self)

    def unsetOrganization(self):
        """
        unsetOrganization(self) -> int

        Unsets the organization of this ModelCreator.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.ModelCreator_unsetOrganization(self)

    def unsetOrganisation(self):
        """
        unsetOrganisation(self) -> int

        Unsets the organization of this ModelCreator.

        @note This function is an alias of unsetOrganization().

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see unsetOrganization()
          

        """
        return _libsbml.ModelCreator_unsetOrganisation(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Unsets the organization of this ModelCreator.

        @note This function is an alias of unsetOrganization().

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink

        @see unsetOrganization()
        @deprecated libSBML internal


        """
        return _libsbml.ModelCreator_hasRequiredAttributes(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

ModelCreator_swigregister = _libsbml.ModelCreator_swigregister
ModelCreator_swigregister(ModelCreator)

class ModelHistory(_object):
    """
    Representation of MIRIAM-compliant model history data.

    @htmlinclude not-sbml-warning.html

    The SBML specification beginning with Level 2 Version 2 defines a
    standard approach to recording model history and model creator
    information in a form that complies with MIRIAM ('Minimum Information
    Requested in the Annotation of biochemical Models', <i>Nature
    Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  LibSBML provides the
    ModelHistory class as a convenience high-level interface for working
    with model history data.

    <!-- leave this next break as-is to work around some doxygen bug -->

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelHistory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelHistory, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ModelHistory
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> ModelHistory
        __init__(self, ModelHistory orig) -> ModelHistory

        Copy constructor; creates a copy of the ModelHistory.
         

        """
        this = _libsbml.new_ModelHistory(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ModelHistory

        Creates and returns a copy of this ModelHistory.

        @return a (deep) copy of this ModelHistory.
          

        """
        return _libsbml.ModelHistory_clone(self)

    def getCreatedDate(self):
        """
        getCreatedDate(self) -> Date

        Returns the createdDate from the ModelHistory.

        @return Date object representing the createdDate
        from the ModelHistory.
          

        """
        return _libsbml.ModelHistory_getCreatedDate(self)

    def isSetCreatedDate(self):
        """
        isSetCreatedDate(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ModelHistory's createdDate has been set.

        @return @c true if the createdDate of this ModelHistory has been set, 
        @c false otherwise.
          

        """
        return _libsbml.ModelHistory_isSetCreatedDate(self)

    def isSetModifiedDate(self):
        """
        isSetModifiedDate(self) -> bool

        Predicate returning @c true or @c false depending on whether this
        ModelHistory's modifiedDate has been set.

        @return @c true if the modifiedDate of this ModelHistory has been set, 
        @c false otherwise.
          

        """
        return _libsbml.ModelHistory_isSetModifiedDate(self)

    def setCreatedDate(self, *args):
        """
        setCreatedDate(self, Date date) -> int

        Sets the createdDate.
         
        @param date a Date object representing the date
        the ModelHistory was created. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.ModelHistory_setCreatedDate(self, *args)

    def setModifiedDate(self, *args):
        """
        setModifiedDate(self, Date date) -> int

        Sets the modifiedDate.
         
        @param date a Date object representing the date
        the ModelHistory was modified. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
          

        """
        return _libsbml.ModelHistory_setModifiedDate(self, *args)

    def addModifiedDate(self, *args):
        """
        addModifiedDate(self, Date date) -> int

        Adds a modifiedDate.
         
        @param date a Date object representing the date
        the ModelHistory was modified. 
          

        """
        return _libsbml.ModelHistory_addModifiedDate(self, *args)

    def getListModifiedDates(self):
      """
      getListModifiedDates(self) -> DateList

      Get the DateList of Date objects in this ModelHistory.

      @return the DateList for this ModelHistory.
            

      """
      return _libsbml.ModelHistory_getListModifiedDates(self)


    def getModifiedDate(self, *args):
        """
        getModifiedDate(self) -> Date
        getModifiedDate(self, unsigned int n) -> Date

        Get the nth Date object in the list of ModifiedDates
        in this ModelHistory.

        @return the nth Date in the list of ModifiedDates of 
        this ModelHistory.
          

        """
        return _libsbml.ModelHistory_getModifiedDate(self, *args)

    def getNumModifiedDates(self):
        """
        getNumModifiedDates(self) -> unsigned int

        Get the number of ModifiedDate objects in this 
        ModelHistory.

        @return the number of ModifiedDates in this 
        ModelHistory.
          

        """
        return _libsbml.ModelHistory_getNumModifiedDates(self)

    def addCreator(self, *args):
        """
        addCreator(self, ModelCreator mc) -> int

        Adds a copy of the given ModelCreator object to 
        this ModelHistory.

        @param mc the ModelCreator to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif The possible values
        returned by this function are:
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink
        @li @link OperationReturnValues_t#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink
        @li @link OperationReturnValues_t#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink
          

        """
        return _libsbml.ModelHistory_addCreator(self, *args)

    def getListCreators(self):
      """
      getListCreators(self) -> ModelCreatorList

      Get the ModelCreatorList of ModelCreator objects in this 
      ModelHistory.

      @return the ModelCreatorList for this ModelHistory.
            

      """
      return _libsbml.ModelHistory_getListCreators(self)


    def getCreator(self, *args):
        """
        getCreator(self, unsigned int n) -> ModelCreator

        Get the nth ModelCreator object in this ModelHistory.

        @return the nth ModelCreator of this ModelHistory.
          

        """
        return _libsbml.ModelHistory_getCreator(self, *args)

    def getNumCreators(self):
        """
        getNumCreators(self) -> unsigned int

        Get the number of ModelCreator objects in this 
        ModelHistory.

        @return the number of ModelCreators in this 
        ModelHistory.
          

        """
        return _libsbml.ModelHistory_getNumCreators(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Get the number of ModelCreator objects in this 
        ModelHistory.

        @return the number of ModelCreators in this 
        ModelHistory.
        @deprecated libSBML internal


        """
        return _libsbml.ModelHistory_hasRequiredAttributes(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

ModelHistory_swigregister = _libsbml.ModelHistory_swigregister
ModelHistory_swigregister(ModelHistory)

class RDFAnnotationParser(_object):
    """
    Read/write/manipulate RDF annotations stored in SBML
    annotation elements.

    @htmlinclude not-sbml-warning.html

    RDFAnnotationParser is a libSBML construct used as part of the libSBML
    support for annotations conforming to the guidelines specified by MIRIAM
    ('Minimum Information Requested in the Annotation of biochemical
    Models', <i>Nature Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  Section 6
    of the SBML Level&nbsp;2 Version&nbsp;4 specification defines a recommended way
    of encoding MIRIAM information as RDF annotations in SBML.  The general
    scheme is as follows.  A set of RDF-based annotations attached to a
    given SBML <code>&lt;annotation&gt;</code> element are read by
    RDFAnnotationParser and converted into a list of CVTerm objects.  There
    are different versions of the main method, @if clike RDFAnnotationParser::parseRDFAnnotation(const XMLNode *annotation, %List *CVTerms) @endif
    @if java RDFAnnotationParser::parseRDFAnnotation(const XMLNode *annotation, CVTermList *CVTerms) @endif
    and RDFAnnotationParser::parseRDFAnnotation(const XMLNode *annotation), 
    used depending on whether the annotation in question concerns the MIRIAM
    model history or other MIRIAM resource annotations.  A special object
    class, ModelHistory, is used to make it easier to manipulate model
    history annotations.

    All of the methods on RDFAnnotationParser are static; the class exists
    only to encapsulate the annotation and CVTerm parsing and manipulation
    functionality.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RDFAnnotationParser, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RDFAnnotationParser, name)
    __repr__ = _swig_repr
    def createAnnotation():
        """
        createAnnotation() -> XMLNode

        Creates a blank annotation and returns the XMLNode corresonding to it.

        The annotation created by this method is a completely empty SBML
        <code>&lt;annotation&gt;</code> element.  One use for this is to
        then call createRDFAnnotation() to construct RDF content for this
        empty annotation.

        @return a pointer to an XMLNode for the annotation

        @see createRDFAnnotation()
          

        """
        return _libsbml.RDFAnnotationParser_createAnnotation()

    if _newclass:createAnnotation = staticmethod(createAnnotation)
    __swig_getmethods__["createAnnotation"] = lambda x: createAnnotation
    def createRDFAnnotation():
        """
        createRDFAnnotation() -> XMLNode

        Creates blank RDF annotation content organized in the form defined in
        Section 6 of the SBML Level 2 Version 4 specification .

        The annotation created by this method has namespace declarations for
        all the relevant XML namespaces used in RDF annotations and also has
        an empty RDF element.  Note that this is not the containing
        <code>&lt;annotation&gt;</code> element; the method createAnnotation()
        is available for that purpose.

        @return a pointer to an XMLNode
          

        """
        return _libsbml.RDFAnnotationParser_createRDFAnnotation()

    if _newclass:createRDFAnnotation = staticmethod(createRDFAnnotation)
    __swig_getmethods__["createRDFAnnotation"] = lambda x: createRDFAnnotation
    def deleteRDFAnnotation(*args):
        """
        deleteRDFAnnotation(XMLNode annotation) -> XMLNode

        Deletes any RDF annotation found in the given XMLNode tree and returns
        any remaining annotation content.

        The name of the given XMLNode must be 'annotation', or else this
        method returns NULL.

        @param annotation the annotation tree within which the RDF annotation
        is to be found and deleted

        @return the XMLNode structure with any RDF annotations deleted
          

        """
        return _libsbml.RDFAnnotationParser_deleteRDFAnnotation(*args)

    if _newclass:deleteRDFAnnotation = staticmethod(deleteRDFAnnotation)
    __swig_getmethods__["deleteRDFAnnotation"] = lambda x: deleteRDFAnnotation
    def createRDFDescription(*args):
        """
        createRDFDescription(SBase object) -> XMLNode

        Takes an SBML object and creates an XMLNode corresponding to an
        RDF 'Description' element.

        This method is a handy way of creating RDF description objects linked
        by the appropriate 'metaid' field, for insertion into RDF annotations
        in a model.  (Note that this method does not create a complete
        annotation; it only creates a description element.  For creating empty
        RDF annotations that can serve as containers for RDF descriptions, see
        createRDFAnnotation().

        @param object the object to be annotated

        @return a new XMLNode containing the 'rdf:about' structure for an
        RDF 'Description' element.

        @see createRDFAnnotation()
          

        """
        return _libsbml.RDFAnnotationParser_createRDFDescription(*args)

    if _newclass:createRDFDescription = staticmethod(createRDFDescription)
    __swig_getmethods__["createRDFDescription"] = lambda x: createRDFDescription
    def createCVTerms(*args):
        """
        createCVTerms(SBase object) -> XMLNode

        Takes a list of CVTerms and creates a the RDF 'Description' element.

        This essentially takes the given SBML object, reads out the CVTerms
        attached to it, calls createRDFDescriptiom() to create an RDF
        'Description' element to hold the terms and adds each term with
        appropriate qualifiers.

        @param object the SBML object to start from

        @return the XMLNode tree corresponding to the Description element of
        an RDF annotation.
          

        """
        return _libsbml.RDFAnnotationParser_createCVTerms(*args)

    if _newclass:createCVTerms = staticmethod(createCVTerms)
    __swig_getmethods__["createCVTerms"] = lambda x: createCVTerms
    def parseCVTerms(*args):
        """
        parseCVTerms(SBase object) -> XMLNode

        Takes a list of CVTerms and creates a complete SBML annotation
        around it.

        This essentially takes the given SBML object, calls createCVTerms
        to read out the CVTerms
        attached to it, calls createRDFAnnotation() to create an RDF
        annotation to hold the terms, and finally calls createAnnotation() to
        wrap the result as an SBML <code>&lt;annotation&gt;</code> element.

        @param object the SBML object to start from

        @return the XMLNode tree corresponding to the annotation.
          

        """
        return _libsbml.RDFAnnotationParser_parseCVTerms(*args)

    if _newclass:parseCVTerms = staticmethod(parseCVTerms)
    __swig_getmethods__["parseCVTerms"] = lambda x: parseCVTerms
    def parseModelHistory(*args):
        """
        parseModelHistory(SBase object) -> XMLNode

        Takes an SBML object, reads off the model history information
        stored in it, and creates a complete SBML annotation to store that
        history.

        @param object any SBase object

        @return the XMLNode corresponding to an annotation containing 
        MIRIAM-compliant model history information in RDF format
          

        """
        return _libsbml.RDFAnnotationParser_parseModelHistory(*args)

    if _newclass:parseModelHistory = staticmethod(parseModelHistory)
    __swig_getmethods__["parseModelHistory"] = lambda x: parseModelHistory
    def parseRDFAnnotation(*args):
        """
        parseRDFAnnotation(XMLNode annotation) -> ModelHistory
        parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms)

        Parses an annotation into a ModelHistory class instance.

        This is used to take an annotation that has been read into an SBML
        model, identify the RDF elements representing model history
        information, and create a list of corresponding CVTerms.

        @param annotation XMLNode containing the annotation.

        @return a pointer to the ModelHistory created.
          

        """
        return _libsbml.RDFAnnotationParser_parseRDFAnnotation(*args)

    if _newclass:parseRDFAnnotation = staticmethod(parseRDFAnnotation)
    __swig_getmethods__["parseRDFAnnotation"] = lambda x: parseRDFAnnotation
    def __init__(self): 
        """__init__(self) -> RDFAnnotationParser"""
        this = _libsbml.new_RDFAnnotationParser()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_RDFAnnotationParser
    __del__ = lambda self : None;
RDFAnnotationParser_swigregister = _libsbml.RDFAnnotationParser_swigregister
RDFAnnotationParser_swigregister(RDFAnnotationParser)

def RDFAnnotationParser_createAnnotation():
  """
    RDFAnnotationParser_createAnnotation() -> XMLNode

    Creates a blank annotation and returns the XMLNode corresonding to it.

    The annotation created by this method is a completely empty SBML
    <code>&lt;annotation&gt;</code> element.  One use for this is to
    then call createRDFAnnotation() to construct RDF content for this
    empty annotation.

    @return a pointer to an XMLNode for the annotation

    @see createRDFAnnotation()
      

    """
  return _libsbml.RDFAnnotationParser_createAnnotation()

def RDFAnnotationParser_createRDFAnnotation():
  """
    RDFAnnotationParser_createRDFAnnotation() -> XMLNode

    Creates blank RDF annotation content organized in the form defined in
    Section 6 of the SBML Level 2 Version 4 specification .

    The annotation created by this method has namespace declarations for
    all the relevant XML namespaces used in RDF annotations and also has
    an empty RDF element.  Note that this is not the containing
    <code>&lt;annotation&gt;</code> element; the method createAnnotation()
    is available for that purpose.

    @return a pointer to an XMLNode
      

    """
  return _libsbml.RDFAnnotationParser_createRDFAnnotation()

def RDFAnnotationParser_deleteRDFAnnotation(*args):
  """
    RDFAnnotationParser_deleteRDFAnnotation(XMLNode annotation) -> XMLNode

    Deletes any RDF annotation found in the given XMLNode tree and returns
    any remaining annotation content.

    The name of the given XMLNode must be 'annotation', or else this
    method returns NULL.

    @param annotation the annotation tree within which the RDF annotation
    is to be found and deleted

    @return the XMLNode structure with any RDF annotations deleted
      

    """
  return _libsbml.RDFAnnotationParser_deleteRDFAnnotation(*args)

def RDFAnnotationParser_createRDFDescription(*args):
  """
    RDFAnnotationParser_createRDFDescription(SBase object) -> XMLNode

    Takes an SBML object and creates an XMLNode corresponding to an
    RDF 'Description' element.

    This method is a handy way of creating RDF description objects linked
    by the appropriate 'metaid' field, for insertion into RDF annotations
    in a model.  (Note that this method does not create a complete
    annotation; it only creates a description element.  For creating empty
    RDF annotations that can serve as containers for RDF descriptions, see
    createRDFAnnotation().

    @param object the object to be annotated

    @return a new XMLNode containing the 'rdf:about' structure for an
    RDF 'Description' element.

    @see createRDFAnnotation()
      

    """
  return _libsbml.RDFAnnotationParser_createRDFDescription(*args)

def RDFAnnotationParser_createCVTerms(*args):
  """
    RDFAnnotationParser_createCVTerms(SBase object) -> XMLNode

    Takes a list of CVTerms and creates a the RDF 'Description' element.

    This essentially takes the given SBML object, reads out the CVTerms
    attached to it, calls createRDFDescriptiom() to create an RDF
    'Description' element to hold the terms and adds each term with
    appropriate qualifiers.

    @param object the SBML object to start from

    @return the XMLNode tree corresponding to the Description element of
    an RDF annotation.
      

    """
  return _libsbml.RDFAnnotationParser_createCVTerms(*args)

def RDFAnnotationParser_parseCVTerms(*args):
  """
    RDFAnnotationParser_parseCVTerms(SBase object) -> XMLNode

    Takes a list of CVTerms and creates a complete SBML annotation
    around it.

    This essentially takes the given SBML object, calls createCVTerms
    to read out the CVTerms
    attached to it, calls createRDFAnnotation() to create an RDF
    annotation to hold the terms, and finally calls createAnnotation() to
    wrap the result as an SBML <code>&lt;annotation&gt;</code> element.

    @param object the SBML object to start from

    @return the XMLNode tree corresponding to the annotation.
      

    """
  return _libsbml.RDFAnnotationParser_parseCVTerms(*args)

def RDFAnnotationParser_parseModelHistory(*args):
  """
    RDFAnnotationParser_parseModelHistory(SBase object) -> XMLNode

    Takes an SBML object, reads off the model history information
    stored in it, and creates a complete SBML annotation to store that
    history.

    @param object any SBase object

    @return the XMLNode corresponding to an annotation containing 
    MIRIAM-compliant model history information in RDF format
      

    """
  return _libsbml.RDFAnnotationParser_parseModelHistory(*args)

def RDFAnnotationParser_parseRDFAnnotation(*args):
  """
    parseRDFAnnotation(XMLNode annotation) -> ModelHistory
    RDFAnnotationParser_parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms)

    Parses an annotation into a ModelHistory class instance.

    This is used to take an annotation that has been read into an SBML
    model, identify the RDF elements representing model history
    information, and create a list of corresponding CVTerms.

    @param annotation XMLNode containing the annotation.

    @return a pointer to the ModelHistory created.
      

    """
  return _libsbml.RDFAnnotationParser_parseRDFAnnotation(*args)




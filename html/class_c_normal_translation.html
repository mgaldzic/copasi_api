<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>copasi API: CNormalTranslation Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">copasi API
   &#160;<span id="projectnumber">0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">CNormalTranslation Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CNormalTranslation" -->
<p><code>#include &lt;<a class="el" href="_c_normal_translation_8h_source.html">CNormalTranslation.h</a>&gt;</code></p>

<p><a href="class_c_normal_translation-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ab3e7992027d31d9ae62c6ff0a564dada">simplifyTree</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a48054410ec2742cfc6895d739bbde260">simplifyTreeReptdly</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *root0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_normal_fraction.html">CNormalFraction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a58c90ebd836d3ea495177bf61f897b70">normAndSimplify</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *root0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_normal_fraction.html">CNormalFraction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aae9ba5c379c942409ab2982f196e7477">normAndSimplifyReptdly</a> (const <a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a> *tree0, unsigned int depth=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_normal_fraction.html">CNormalFraction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a229ce818a4877bc9aa08616c66e3d7d3">normAndSimplifyReptdly</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *tree0, unsigned int depth=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a2d7ba15dfa49582b97e00b46ca5fe8c1">createChain</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pLink, const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pNeutralElement, const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;elements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a5c95df0d28a4522d4e1ef3502880b857">createChain</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pLink, const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pNeutralElement, const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;elements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a6872ca2f6554f418bf874826b56358a7">createOperatorChain</a> (<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a> type, const char *data, const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;nodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a73c41a64638ae41f66d0587cbd6e954c">createOperatorChain</a> (<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a> type, const char *data, const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;nodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a15fd23961381a772ecef9264f89c481b">expandPowerBases</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRoot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#add171e1ab9b1ce9c4ed12dc7c178ceaa">expandPowerExponents</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRoot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a9ded47c6371819cdbbc595eefc1cda6a">findSummands</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRoot, std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;summands)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#af88daca38c1e571e802a39f3e0c43b0b">expandProducts</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a4fc2761b09b338563f1a9404e48d7a54">splitProduct</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRoot, std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;multiplications, std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;divisions, bool division)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aaca79f33227ee21837fa1a14302aa526">splitSum</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRoot, std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;additions, std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;substractions, bool minus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a674f97cc769b19c6060a5a86b0d8f24b">splitSum</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRoot, std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;additions, std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;substractions, bool minus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ad75eaf92bad1d34150b6ec3c83d20efd">evaluateNumbers</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aab7658060e61c06c17a09872608037d3">NEUTRAL_ELEMENT_ADD</a> = <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(CEvaluationNodeNumber::DOUBLE, &quot;0.0&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#af7bafe69abed5ddc58e9830424a74441">NEUTRAL_ELEMENT_MULTIPLY</a> = <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(CEvaluationNodeNumber::DOUBLE, &quot;1.0&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a0ae6878f8c10d2b2aa44f7c6a422b599">NEUTRAL_ELEMENT_OR</a> = <a class="el" href="class_c_evaluation_node_constant.html">CEvaluationNodeConstant</a>(CEvaluationNodeConstant::FALSE, &quot;FALSE&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a7d9055851a26e57066c4fe95b48613ea">NEUTRAL_ELEMENT_AND</a> = <a class="el" href="class_c_evaluation_node_constant.html">CEvaluationNodeConstant</a>(CEvaluationNodeConstant::TRUE, &quot;TRUE&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a97f8c0f5977bd4c5e3f01f3cf33eaa36">ZERO_NODE</a> = <a class="el" href="class_c_normal_translation.html#aab7658060e61c06c17a09872608037d3">CNormalTranslation::NEUTRAL_ELEMENT_ADD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a5a8c2fd4752f26b74a4b925b4c3446e5">ONE_NODE</a> = <a class="el" href="class_c_normal_translation.html#af7bafe69abed5ddc58e9830424a74441">CNormalTranslation::NEUTRAL_ELEMENT_MULTIPLY</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a1fbb73502f4ed305148030733151d9d1">PLUS_NODE</a> = <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(CEvaluationNodeOperator::PLUS, &quot;+&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ae91afc33a5a9362c6ce89804f4fe9885">TIMES_NODE</a> = <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(CEvaluationNodeOperator::MULTIPLY, &quot;*&quot;)</td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a9b371fe5234357684543499172c74446">swapNegativeNumbers</a> (std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;v1, std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;v2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a1d9d7059cebec7fbaed2cc5b78ba8f99">simplify</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aa2aa679d11bc88e5a6aae96d7481112a">elementaryElimination</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ae341fc559c457beb52544b018d4caa35">elementaryEliminationFunction</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pFunctionNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aaa2ece8364ec7c658ecf023f2104cd4e">elementaryEliminationPower</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pPowerNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aff90e7c6e4b0861dfc45a3438524fb22">elementaryEliminationModulus</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pModulusNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#accb572132030afb0063f04a144acc963">elementaryEliminationMultiply</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pMultiplyNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ac09388e136f9c272c7617e68d36cfe8f">elementaryEliminationDivide</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pDivideNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aad303ceac4b4c9f2754995e022c8f567">elementaryEliminationPlus</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pPlusNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#acce979ce6f7c4526c77d69088e08cfeb">elementaryEliminationMinus</a> (<a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pMinusNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#af8212a6cbaafde3a192f793f43ab4159">eliminateNestedPowers</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a9b69a7cdca2eb94d96ee7e7c917140fa">expandPowerNodes</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::pair<br class="typebreak"/>
&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <br class="typebreak"/>
*, <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a975f83aced0fc28393b0efeaa2b157f4">matchPowerBases</a> (const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;multiplications, const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;divisions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::pair<br class="typebreak"/>
&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <br class="typebreak"/>
*, <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a62514aa2b477f6e295b2dd1eea091046">matchSummands</a> (const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;additions, const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;subtractions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ac431a4255af2ff6cc182863c272a3fd7">multiply</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pNode1, const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pNode2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a662b5e7272572daccd90316791cb0ef3">cancel</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a72c99fe942309a3fb0679d2e4d758501">eliminate</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ad2b59b82fb9cae358fdaffbdb0173d41">eliminateDirectlyNestedFractions</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#ae2fa8dec5dc44dd2066d9372f74a3d01">eliminatePowersOfFractions</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#aba0cea7d560c27154dc8477bd7126032">product2fraction</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::pair<br class="typebreak"/>
&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <br class="typebreak"/>
*, <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a006cf9d416c29466f1723fb777e082bf">factorize</a> (const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;additions, const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;subtractions)</td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a3ace3221694c78841e354ae7ce285e8a">ZERO</a> = 1e-100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_normal_translation.html#a06798939caa076a26a03358abc9adfc6">RECURSION_LIMIT</a> = 20</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The class for simplification and translation of trees into CNormal </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a662b5e7272572daccd90316791cb0ef3"></a><!-- doxytag: member="CNormalTranslation::cancel" ref="a662b5e7272572daccd90316791cb0ef3" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method does all the canceling on a given node and its children. </p>

</div>
</div>
<a class="anchor" id="a2d7ba15dfa49582b97e00b46ca5fe8c1"></a><!-- doxytag: member="CNormalTranslation::createChain" ref="a2d7ba15dfa49582b97e00b46ca5fe8c1" args="(const CEvaluationNode *pLink, const CEvaluationNode *pNeutralElement, const std::vector&lt; const CEvaluationNode * &gt; &amp;elements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::createChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pNeutralElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>More general version of createOperatorChain. This method can also be used to combine logical item chains. Once I know this works, I will replace createOperatorChain with this method.</p>
<p>This version of create chain copies the given elements in the vector and then calls the createChain method which does not need copying. </p>

</div>
</div>
<a class="anchor" id="a5c95df0d28a4522d4e1ef3502880b857"></a><!-- doxytag: member="CNormalTranslation::createChain" ref="a5c95df0d28a4522d4e1ef3502880b857" args="(const CEvaluationNode *pLink, const CEvaluationNode *pNeutralElement, const std::vector&lt; CEvaluationNode * &gt; &amp;elements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::createChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pNeutralElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>More general version of createOperatorChain. This version does not copy the nodes in the given vector, but uses them directly. This method can also be used to combine logical item chains. method.</p>
<p>This method creates a chain of operations. The individual elements are linked with copies of pLink. NULL is returned if elements is empty. So if this method is used to create a chanin of OR linked elements which will be embedded in another and linked chain, the neutral element should be a TRUE node since AND combining something with true does not change the result. The neutral element is the element that does not change the result of the operation represented be pLink. So if pLink represents a multiplication, the neutral element is the number node 1.0. This method does not copy the elements in the given vector, but uses them in the chain directly. </p>

</div>
</div>
<a class="anchor" id="a6872ca2f6554f418bf874826b56358a7"></a><!-- doxytag: member="CNormalTranslation::createOperatorChain" ref="a6872ca2f6554f418bf874826b56358a7" args="(CEvaluationNodeOperator::SubType type, const char *data, const std::vector&lt; CEvaluationNode * &gt; &amp;nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::createOperatorChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector of nodes, this method creates a multiplication chain of all the nodes. The chain contains copies of the nodes passed in.</p>
<p>Given a vector of nodes, this method creates a multiplication chain of all the nodes. The chain contains the original nodes and not copies. </p>

</div>
</div>
<a class="anchor" id="a73c41a64638ae41f66d0587cbd6e954c"></a><!-- doxytag: member="CNormalTranslation::createOperatorChain" ref="a73c41a64638ae41f66d0587cbd6e954c" args="(CEvaluationNodeOperator::SubType type, const char *data, const std::vector&lt; const CEvaluationNode * &gt; &amp;nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::createOperatorChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector of nodes, this method creates a multiplication chain of all the nodes. The chain contains copies of the nodes passed in. </p>

</div>
</div>
<a class="anchor" id="aa2aa679d11bc88e5a6aae96d7481112a"></a><!-- doxytag: member="CNormalTranslation::elementaryElimination" ref="aa2aa679d11bc88e5a6aae96d7481112a" args="(CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryElimination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine is responsible for all elementary eliminations, e.g. addition of 0. These steps can not lead to new simplifications in the children of the node being simplified, so it is not necessary to run this on the children again. </p>

</div>
</div>
<a class="anchor" id="ac09388e136f9c272c7617e68d36cfe8f"></a><!-- doxytag: member="CNormalTranslation::elementaryEliminationDivide" ref="ac09388e136f9c272c7617e68d36cfe8f" args="(CEvaluationNode *pDivideNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryEliminationDivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pDivideNode</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method makes the elementary elimination on a divide node. </p>

</div>
</div>
<a class="anchor" id="ae341fc559c457beb52544b018d4caa35"></a><!-- doxytag: member="CNormalTranslation::elementaryEliminationFunction" ref="ae341fc559c457beb52544b018d4caa35" args="(CEvaluationNode *pFunctionNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryEliminationFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pFunctionNode</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method makes elementary eliminations on function nodes </p>

</div>
</div>
<a class="anchor" id="acce979ce6f7c4526c77d69088e08cfeb"></a><!-- doxytag: member="CNormalTranslation::elementaryEliminationMinus" ref="acce979ce6f7c4526c77d69088e08cfeb" args="(CEvaluationNode *pMinusNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryEliminationMinus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pMinusNode</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method makes the elementary elimination on a minus node. </p>

</div>
</div>
<a class="anchor" id="aff90e7c6e4b0861dfc45a3438524fb22"></a><!-- doxytag: member="CNormalTranslation::elementaryEliminationModulus" ref="aff90e7c6e4b0861dfc45a3438524fb22" args="(CEvaluationNode *pModulusNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryEliminationModulus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pModulusNode</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method makes the elementary elimination on a modulus node. </p>

</div>
</div>
<a class="anchor" id="accb572132030afb0063f04a144acc963"></a><!-- doxytag: member="CNormalTranslation::elementaryEliminationMultiply" ref="accb572132030afb0063f04a144acc963" args="(CEvaluationNode *pMultiplyNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryEliminationMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pMultiplyNode</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method makes the elementary elimination on a multiply node. </p>

</div>
</div>
<a class="anchor" id="aad303ceac4b4c9f2754995e022c8f567"></a><!-- doxytag: member="CNormalTranslation::elementaryEliminationPlus" ref="aad303ceac4b4c9f2754995e022c8f567" args="(CEvaluationNode *pPlusNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryEliminationPlus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pPlusNode</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method makes the elementary elimination on a plus node. </p>

</div>
</div>
<a class="anchor" id="aaa2ece8364ec7c658ecf023f2104cd4e"></a><!-- doxytag: member="CNormalTranslation::elementaryEliminationPower" ref="aaa2ece8364ec7c658ecf023f2104cd4e" args="(CEvaluationNode *pPowerNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::elementaryEliminationPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pPowerNode</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method makes the elementary elimination on a power node. </p>

</div>
</div>
<a class="anchor" id="a72c99fe942309a3fb0679d2e4d758501"></a><!-- doxytag: member="CNormalTranslation::eliminate" ref="a72c99fe942309a3fb0679d2e4d758501" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::eliminate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method elminates subexpressions from an expression </p>

</div>
</div>
<a class="anchor" id="ad2b59b82fb9cae358fdaffbdb0173d41"></a><!-- doxytag: member="CNormalTranslation::eliminateDirectlyNestedFractions" ref="ad2b59b82fb9cae358fdaffbdb0173d41" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::eliminateDirectlyNestedFractions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method eliminates directly nested fractions. ((a/b)/(c/d)) -&gt; (a*d)/(b*c)</p>
<p>This method eliminates directly nested fractions. </p>

</div>
</div>
<a class="anchor" id="af8212a6cbaafde3a192f793f43ab4159"></a><!-- doxytag: member="CNormalTranslation::eliminateNestedPowers" ref="af8212a6cbaafde3a192f793f43ab4159" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::eliminateNestedPowers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method removes nested power nodes, e.g. (a^b)^c -&gt; a^(b*c) </p>

</div>
</div>
<a class="anchor" id="ae2fa8dec5dc44dd2066d9372f74a3d01"></a><!-- doxytag: member="CNormalTranslation::eliminatePowersOfFractions" ref="ae2fa8dec5dc44dd2066d9372f74a3d01" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::eliminatePowersOfFractions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method gets rid of fractions within a power construct. (a/b)^3 -&gt; a^3 / b^3 </p>

</div>
</div>
<a class="anchor" id="ad75eaf92bad1d34150b6ec3c83d20efd"></a><!-- doxytag: member="CNormalTranslation::evaluateNumbers" ref="ad75eaf92bad1d34150b6ec3c83d20efd" args="(CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::evaluateNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method evaluates operators acting on two numbers </p>

</div>
</div>
<a class="anchor" id="a15fd23961381a772ecef9264f89c481b"></a><!-- doxytag: member="CNormalTranslation::expandPowerBases" ref="a15fd23961381a772ecef9264f89c481b" args="(const CEvaluationNode *pRoot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::expandPowerBases </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRoot</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a root node, this method traverses the tree and expands products in power bases to multiplications of power items. It is the responsibility of the caller to delete the returned node.</p>
<p>Given a root node, this method traverses the tree and expands produtcs in power bases to multiplications of power items. It is the responsibility of the caller to delete the returned node. </p>

</div>
</div>
<a class="anchor" id="add171e1ab9b1ce9c4ed12dc7c178ceaa"></a><!-- doxytag: member="CNormalTranslation::expandPowerExponents" ref="add171e1ab9b1ce9c4ed12dc7c178ceaa" args="(const CEvaluationNode *pRoot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::expandPowerExponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRoot</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a root node, this method traverses the tree and expands sums in power exponents to multiplications of power items. It is the responsibility of the caller to delete the returned node. </p>

</div>
</div>
<a class="anchor" id="a9b69a7cdca2eb94d96ee7e7c917140fa"></a><!-- doxytag: member="CNormalTranslation::expandPowerNodes" ref="a9b69a7cdca2eb94d96ee7e7c917140fa" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::expandPowerNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method expands the exponents of power nodes, e.g. A^(x+y) -&gt; A^x * A^y</p>
<p>This method splits a sum into the individual elements void <a class="el" href="class_c_normal_translation.html#aaca79f33227ee21837fa1a14302aa526">CNormalTranslation::splitSum(const CEvaluationNode* pRoot, std::vector&lt;CEvaluationNode*&gt;&amp; additions, std::vector&lt;CEvaluationNode*&gt;&amp; subtractions, bool minus)</a> { TODO this method might save some copy/delete cycles if the test for TODO negative number was done before making copies of children and TODO inserting them TODO this would also simplify the code since the test would be put TODO into a separate function if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(pRoot-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; ((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pRoot-&gt;getType()) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ab432ff27c1f9c3e654ce048b51452970">CEvaluationNodeOperator::PLUS</a> || (<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pRoot-&gt;getType()) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac08f19645f20aa1db61f3907975816e7">CEvaluationNodeOperator::MINUS</a>)) { const CEvaluationNode* pChild1 = dynamic_cast&lt;const CEvaluationNode*&gt;(pRoot-&gt;getChild()); assert(pChild1 != NULL); const CEvaluationNode* pChild2 = dynamic_cast&lt;const CEvaluationNode*&gt;(pChild1-&gt;getSibling()); assert(pChild2 != NULL); assert(pChild2-&gt;getSibling() == NULL); if (((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pRoot-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ab432ff27c1f9c3e654ce048b51452970">CEvaluationNodeOperator::PLUS</a>) { if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(pChild1-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; (((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild1-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ab432ff27c1f9c3e654ce048b51452970">CEvaluationNodeOperator::PLUS</a> || ((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild1-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac08f19645f20aa1db61f3907975816e7">CEvaluationNodeOperator::MINUS</a>)) { CNormalTranslation::splitSum(pChild1, additions, subtractions, minus); } else { if (minus == false) { additions.push_back(pChild1-&gt;copyBranch()); } else { subtractions.push_back(pChild1-&gt;copyBranch()); } } if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(pChild2-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; (((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild2-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ab432ff27c1f9c3e654ce048b51452970">CEvaluationNodeOperator::PLUS</a> || ((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild2-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac08f19645f20aa1db61f3907975816e7">CEvaluationNodeOperator::MINUS</a>)) { CNormalTranslation::splitSum(pChild2, additions, subtractions, minus); } else { if (minus == false) { additions.push_back(pChild2-&gt;copyBranch()); } else { subtractions.push_back(pChild2-&gt;copyBranch()); } } } else if (((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pRoot-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac08f19645f20aa1db61f3907975816e7">CEvaluationNodeOperator::MINUS</a>) { if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(pChild1-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; (((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild1-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ab432ff27c1f9c3e654ce048b51452970">CEvaluationNodeOperator::PLUS</a> || ((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild1-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac08f19645f20aa1db61f3907975816e7">CEvaluationNodeOperator::MINUS</a>)) { CNormalTranslation::splitSum(pChild1, additions, subtractions, minus); } else { if (minus == false) { additions.push_back(pChild1-&gt;copyBranch()); } else { subtractions.push_back(pChild1-&gt;copyBranch()); } } if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(pChild2-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; (((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild2-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ab432ff27c1f9c3e654ce048b51452970">CEvaluationNodeOperator::PLUS</a> || ((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pChild2-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac08f19645f20aa1db61f3907975816e7">CEvaluationNodeOperator::MINUS</a>)) { <a class="el" href="class_c_normal_translation.html#aaca79f33227ee21837fa1a14302aa526">CNormalTranslation::splitSum</a>(pChild2, additions, subtractions, !minus); } else { if (minus == false) { subtractions.push_back(pChild2-&gt;copyBranch()); } else { additions.push_back(pChild2-&gt;copyBranch()); } } } } else { additions.push_back(pRoot-&gt;copyBranch()); } check for negative numbers in additions and add them to subtractions likewise check for negative numbers in substractions and add them to additions do the same for multiplications with a negative number std::vector&lt;CEvaluationNode*&gt;::iterator it = additions.begin(); while (it != additions.end()) { if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>((*it)-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a5cd708e5bd1913c01508638dcf6fae3e">CEvaluationNode::NUMBER</a> &amp;&amp; dynamic_cast&lt;const CEvaluationNodeNumber*&gt;(*it)-&gt;value() &lt; 0.0) { std::ostringstream os; os.precision(18); os &lt;&lt; static_cast&lt;CEvaluationNodeNumber*&gt;(*it)-&gt;value() * -1.0; CEvaluationNode* pTmpNumber = new <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(<a class="el" href="class_c_evaluation_node_number.html#a82abcf0fd7082e54feab9739b3258948a93ffe20de6f762c274a3575679cfb7a4">CEvaluationNodeNumber::DOUBLE</a>, os.str().c_str()); subtractions.push_back(pTmpNumber); delete *it; it = additions.erase(it); } else if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>((*it)-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; (<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>((*it)-&gt;getType()) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a>) { actually there should be code that tests if both are negative numbers if ((<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild())-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a5cd708e5bd1913c01508638dcf6fae3e">CEvaluationNode::NUMBER</a> &amp;&amp; dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild())-&gt;value() &lt; 0.0)) { if(fabs(dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild())-&gt;value()) - 1.0 &lt; ZERO) { subtractions.push_back(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;copyBranch()); delete *it; it = additions.erase(it); } else { CEvaluationNode* pTmp = new <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a>, "*"); std::ostringstream os; os.precision(18); os &lt;&lt; static_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild())-&gt;value() * -1.0; pTmp-&gt;addChild(new <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(<a class="el" href="class_c_evaluation_node_number.html#a82abcf0fd7082e54feab9739b3258948a93ffe20de6f762c274a3575679cfb7a4">CEvaluationNodeNumber::DOUBLE</a>, os.str().c_str())); pTmp-&gt;addChild(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;copyBranch()); subtractions.push_back(pTmp); delete *it; it = additions.erase(it); } } else if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a5cd708e5bd1913c01508638dcf6fae3e">CEvaluationNode::NUMBER</a> &amp;&amp; dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;value() &lt; 0.0) { if(fabs(dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;value()) - 1.0 &lt; ZERO) { subtractions.push_back(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild())-&gt;copyBranch()); delete *it; it = additions.erase(it); } else { CEvaluationNode* pTmp = new <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a>, "*"); pTmp-&gt;addChild(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild())-&gt;copyBranch()); std::ostringstream os; os.precision(18); os &lt;&lt; static_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;value() * -1.0; pTmp-&gt;addChild(new <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(<a class="el" href="class_c_evaluation_node_number.html#a82abcf0fd7082e54feab9739b3258948a93ffe20de6f762c274a3575679cfb7a4">CEvaluationNodeNumber::DOUBLE</a>, os.str().c_str())); subtractions.push_back(pTmp); delete *it; it = additions.erase(it); } } else { ++it; } } else { ++it; } } it = subtractions.begin(); while (it != subtractions.end()) { if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>((*it)-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a5cd708e5bd1913c01508638dcf6fae3e">CEvaluationNode::NUMBER</a> &amp;&amp; dynamic_cast&lt;const CEvaluationNodeNumber*&gt;(*it)-&gt;value() &lt; 0.0) { std::ostringstream os; os.precision(18); os &lt;&lt; static_cast&lt;CEvaluationNodeNumber*&gt;(*it)-&gt;value() * -1.0; CEvaluationNode* pTmpNumber = new <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(<a class="el" href="class_c_evaluation_node_number.html#a82abcf0fd7082e54feab9739b3258948a93ffe20de6f762c274a3575679cfb7a4">CEvaluationNodeNumber::DOUBLE</a>, os.str().c_str()); additions.push_back(pTmpNumber); delete *it; it = subtractions.erase(it); } else if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>((*it)-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; (<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>((*it)-&gt;getType()) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a>) { actually there should be code that tests if both are negative numbers if ((<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild())-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a5cd708e5bd1913c01508638dcf6fae3e">CEvaluationNode::NUMBER</a> &amp;&amp; dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild())-&gt;value() &lt; 0.0)) { if(fabs(dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild())-&gt;value()) - 1.0 &lt; ZERO) { additions.push_back(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;copyBranch()); delete *it; it = subtractions.erase(it); } else { CEvaluationNode* pTmp = new <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a>, "*"); std::ostringstream os; os.precision(18); os &lt;&lt; static_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild())-&gt;value() * -1.0; pTmp-&gt;addChild(new <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(<a class="el" href="class_c_evaluation_node_number.html#a82abcf0fd7082e54feab9739b3258948a93ffe20de6f762c274a3575679cfb7a4">CEvaluationNodeNumber::DOUBLE</a>, os.str().c_str())); pTmp-&gt;addChild(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;copyBranch()); additions.push_back(pTmp); delete *it; it = subtractions.erase(it); } } else if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a5cd708e5bd1913c01508638dcf6fae3e">CEvaluationNode::NUMBER</a> &amp;&amp; dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;value() &lt; 0.0) { if(fabs(dynamic_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;value()) - 1.0 &lt; ZERO) { additions.push_back(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild())-&gt;copyBranch()); delete *it; it = subtractions.erase(it); } else { CEvaluationNode* pTmp = new <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a>, "*"); pTmp-&gt;addChild(dynamic_cast&lt;const CEvaluationNode*&gt;((*it)-&gt;getChild())-&gt;copyBranch()); std::ostringstream os; os.precision(18); os &lt;&lt; static_cast&lt;const CEvaluationNodeNumber*&gt;((*it)-&gt;getChild()-&gt;getSibling())-&gt;value() * -1.0; pTmp-&gt;addChild(new <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(<a class="el" href="class_c_evaluation_node_number.html#a82abcf0fd7082e54feab9739b3258948a93ffe20de6f762c274a3575679cfb7a4">CEvaluationNodeNumber::DOUBLE</a>, os.str().c_str())); additions.push_back(pTmp); delete *it; it = subtractions.erase(it); } } else { ++it; } } else { ++it; } } } This method expands the exponents of power nodes, e.g. A^(x+y) -&gt; A^x * A^y </p>

</div>
</div>
<a class="anchor" id="af88daca38c1e571e802a39f3e0c43b0b"></a><!-- doxytag: member="CNormalTranslation::expandProducts" ref="af88daca38c1e571e802a39f3e0c43b0b" args="(CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::expandProducts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method expands products. (A+B)*(C+D) -&gt; (A*C)+(A*D)+(B*C)+(B*D) This method should be replaced by the one below pretty soon.</p>
<p>This method expands products. (A+B)*(C+D) -&gt; (A*C)+(A*D)+(B*C)+(B*D) CEvaluationNode* CNormalTranslation::expandProducts(const CEvaluationNode* pOrig) { CEvaluationNode* pResult = NULL; we have to create operation chains and do the mutliplication on the numerator and the denominator chain if the node is a multiplication or a division if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(pOrig-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; ((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pOrig-&gt;getType()) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a> || (<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pOrig-&gt;getType()) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac57c4c4ad14989329031b3805fed9137">CEvaluationNodeOperator::DIVIDE</a>)) { std::vector&lt;const CEvaluationNode*&gt; multiplications, divisions; CNormalTranslation::splitProduct(pOrig, multiplications, divisions, false); unsigned int i, iMax = multiplications.size(); CEvaluationNode* pTmpResult; for (i = 0;i &lt; iMax;++i) { if (pResult == NULL) { pResult = CNormalTranslation::expandProducts(multiplications[i]); } else { CEvaluationNode* pTmpNode = CNormalTranslation::expandProducts(multiplications[i]); pTmpResult = CNormalTranslation::multiply(pResult, pTmpNode); delete pResult; delete pTmpNode; pResult = pTmpResult; } } if (!divisions.empty()) { CEvaluationNode* pDenominator = NULL; iMax = divisions.size(); for (i = 0;i &lt; iMax;++i) { if (pDenominator == NULL) { pDenominator = CNormalTranslation::expandProducts(divisions[i]); } else { CEvaluationNode* pTmpNode = CNormalTranslation::expandProducts(divisions[i]); pTmpResult = CNormalTranslation::multiply(pDenominator, pTmpNode); delete pDenominator; delete pTmpNode; pDenominator = pTmpResult; } delete divisions[i]; } pTmpResult = new <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98ac57c4c4ad14989329031b3805fed9137">CEvaluationNodeOperator::DIVIDE</a>, "/"); pTmpResult-&gt;addChild(pResult); pTmpResult-&gt;addChild(pDenominator); pResult = pTmpResult; } } else { const CEvaluationNode* pChild = dynamic_cast&lt;const CEvaluationNode*&gt;(pOrig-&gt;getChild()); std::vector&lt;CEvaluationNode*&gt; children; while (pChild != NULL) { children.push_back(CNormalTranslation::expandProducts(pChild)); pChild = dynamic_cast&lt;const CEvaluationNode*&gt;(pChild-&gt;getSibling()); } if (<a class="el" href="class_c_evaluation_node.html#a9e5fcf60f22d2701417f90756847d37b">CEvaluationNode::type</a>(pOrig-&gt;getType()) == <a class="el" href="class_c_evaluation_node.html#aeef59b7ae37d1323a4900e5d19140491a745531dbd3babe952bfaa4176744dbac">CEvaluationNode::OPERATOR</a> &amp;&amp; ((<a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98">CEvaluationNodeOperator::SubType</a>)<a class="el" href="class_c_evaluation_node.html#a2cb02df3d57dad7ad1f9654941135c31">CEvaluationNode::subType</a>(pOrig-&gt;getType())) == <a class="el" href="class_c_evaluation_node_operator.html#a39e738b7acfcf431f7c72e76b68ffa98af9d4b686c9ae4f20ca8f1cd707fbe6a0">CEvaluationNodeOperator::MULTIPLY</a>) { assert(children.size() == 2); pResult = CNormalTranslation::multiply(children[0], children[1]); delete the children delete children[0]; delete children[1]; } if (pResult == NULL) { pResult = pOrig-&gt;copyNode(children); } } return pResult; } This method expands products. (A+B)*(C+D) -&gt; (A*C)+(A*D)+(B*C)+(B*D) </p>

</div>
</div>
<a class="anchor" id="a006cf9d416c29466f1723fb777e082bf"></a><!-- doxytag: member="CNormalTranslation::factorize" ref="a006cf9d416c29466f1723fb777e082bf" args="(const std::vector&lt; CEvaluationNode * &gt; &amp;additions, const std::vector&lt; CEvaluationNode * &gt; &amp;subtractions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *, <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; CNormalTranslation::factorize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>additions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtractions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method takes two vectors. One with a list of nodes that are added and one with nodes that are subtracted. It tries to find common factors and divisors in those nodes and returns two result nodes. The first is the multiplication of all common factors and divisors, the other is the sum of the remaining additions and subtractions after removing the common factors and divisors. e.g. (A*B*D+A*C*D) -&gt; returns (A*D) and (B+C)</p>
<p>This method takes two vectors and checks if the elements in the two vectors can be split into multiplications and divisions and if there a common factors in all resulting subgroups. </p>

</div>
</div>
<a class="anchor" id="a9ded47c6371819cdbbc595eefc1cda6a"></a><!-- doxytag: member="CNormalTranslation::findSummands" ref="a9ded47c6371819cdbbc595eefc1cda6a" args="(const CEvaluationNode *pRoot, std::vector&lt; const CEvaluationNode * &gt; &amp;summands)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CNormalTranslation::findSummands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>summands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a node, the method check if the node is a PLUS node, if so, it calls itself recursively on the children. This way all summands of a summation chain are gathered. All items in the vector are children of pRoot. </p>

</div>
</div>
<a class="anchor" id="a975f83aced0fc28393b0efeaa2b157f4"></a><!-- doxytag: member="CNormalTranslation::matchPowerBases" ref="a975f83aced0fc28393b0efeaa2b157f4" args="(const std::vector&lt; const CEvaluationNode * &gt; &amp;multiplications, const std::vector&lt; const CEvaluationNode * &gt; &amp;divisions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *, <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &gt; CNormalTranslation::matchPowerBases </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplications</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>divisions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The methods get a vector of multiplication elements and a vector of division elements and tries to find elements with the same power base in those two vectors. </p>

</div>
</div>
<a class="anchor" id="a62514aa2b477f6e295b2dd1eea091046"></a><!-- doxytag: member="CNormalTranslation::matchSummands" ref="a62514aa2b477f6e295b2dd1eea091046" args="(const std::vector&lt; CEvaluationNode * &gt; &amp;additions, const std::vector&lt; CEvaluationNode * &gt; &amp;subtractions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *, <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &gt; CNormalTranslation::matchSummands </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>additions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtractions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The methods get a vector of addition elements and a vector of subtractions elements and tries to find equal elements in those two vectors. </p>

</div>
</div>
<a class="anchor" id="ac431a4255af2ff6cc182863c272a3fd7"></a><!-- doxytag: member="CNormalTranslation::multiply" ref="ac431a4255af2ff6cc182863c272a3fd7" args="(const CEvaluationNode *pNode1, const CEvaluationNode *pNode2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pNode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pNode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiplies the two given nodes and returns the result. </p>

</div>
</div>
<a class="anchor" id="a58c90ebd836d3ea495177bf61f897b70"></a><!-- doxytag: member="CNormalTranslation::normAndSimplify" ref="a58c90ebd836d3ea495177bf61f897b70" args="(const CEvaluationNode *root0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_normal_fraction.html">CNormalFraction</a> * CNormalTranslation::normAndSimplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>root0</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Translate and simplify a tree given by the root node into CNormal structure </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CNormalFraction* </dd></dl>

</div>
</div>
<a class="anchor" id="aae9ba5c379c942409ab2982f196e7477"></a><!-- doxytag: member="CNormalTranslation::normAndSimplifyReptdly" ref="aae9ba5c379c942409ab2982f196e7477" args="(const CEvaluationTree *tree0, unsigned int depth=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_normal_fraction.html">CNormalFraction</a> * CNormalTranslation::normAndSimplifyReptdly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a> *&#160;</td>
          <td class="paramname"><em>tree0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Translate and simplify a tree by calling normAndSimplify repeatedly until it cannot be simplified further The second parameter is a depth value that is used to track the recursion. If a given limit (currently 20) is reached, the algorithm throws an exception. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CNormalFraction*</dd></dl>
<p>Translate and simplify a tree by calling normAndSimplify repeatedly until it cannot be simplified further </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CNormalFraction* </dd></dl>

</div>
</div>
<a class="anchor" id="a229ce818a4877bc9aa08616c66e3d7d3"></a><!-- doxytag: member="CNormalTranslation::normAndSimplifyReptdly" ref="a229ce818a4877bc9aa08616c66e3d7d3" args="(const CEvaluationNode *tree0, unsigned int depth=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_normal_fraction.html">CNormalFraction</a> * CNormalTranslation::normAndSimplifyReptdly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>root0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Translate and simplify a tree by calling normAndSimplify repeatedly until it cannot be simplified further </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CNormalFraction* </dd></dl>

</div>
</div>
<a class="anchor" id="aba0cea7d560c27154dc8477bd7126032"></a><!-- doxytag: member="CNormalTranslation::product2fraction" ref="aba0cea7d560c27154dc8477bd7126032" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::product2fraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This methods converts a product of fractions into a fraction of products. </p>

</div>
</div>
<a class="anchor" id="a1d9d7059cebec7fbaed2cc5b78ba8f99"></a><!-- doxytag: member="CNormalTranslation::simplify" ref="a1d9d7059cebec7fbaed2cc5b78ba8f99" args="(const CEvaluationNode *pOrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrig</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine is responsible for recursively simplifying a given <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> based tree. </p>

</div>
</div>
<a class="anchor" id="ab3e7992027d31d9ae62c6ff0a564dada"></a><!-- doxytag: member="CNormalTranslation::simplifyTree" ref="ab3e7992027d31d9ae62c6ff0a564dada" args="(const CEvaluationNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::simplifyTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Simplify an evaluation tree given by the root node by creating a new simplified tree from the original one. The tree itself is actually not created! </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NodeClass*, pointer to root node of the newly created tree.</dd></dl>
<p>Simplify an evaluation tree given by the root node by creating a new simplified tree from the original one. The tree itself is actually not created! </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CEvaluationNode*, pointer to root node of the newly created tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a48054410ec2742cfc6895d739bbde260"></a><!-- doxytag: member="CNormalTranslation::simplifyTreeReptdly" ref="a48054410ec2742cfc6895d739bbde260" args="(const CEvaluationNode *root0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * CNormalTranslation::simplifyTreeReptdly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>root0</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creating a simplified tree by calling simplifyTree repeatedly until it cannot be simplified further. The tree itself is actually not created! </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NodeClass*, pointer to root node of the newly created tree.</dd></dl>
<p>Creating a simplified tree by calling simplifyTree repeatedly until it cannot be simplified further. The tree itself is actually not created! </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CEvaluationNode*, pointer to root node of the newly created tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fc2761b09b338563f1a9404e48d7a54"></a><!-- doxytag: member="CNormalTranslation::splitProduct" ref="a4fc2761b09b338563f1a9404e48d7a54" args="(const CEvaluationNode *pRoot, std::vector&lt; const CEvaluationNode * &gt; &amp;multiplications, std::vector&lt; const CEvaluationNode * &gt; &amp;divisions, bool division)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CNormalTranslation::splitProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplications</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>division</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method expands products. (A+B)*(C+D) -&gt; (A*C)+(A*D)+(B*C)+(B*D) This method splits a product into the individual elements</p>
<p>This method splits a product into the individual elements </p>

</div>
</div>
<a class="anchor" id="aaca79f33227ee21837fa1a14302aa526"></a><!-- doxytag: member="CNormalTranslation::splitSum" ref="aaca79f33227ee21837fa1a14302aa526" args="(const CEvaluationNode *pRoot, std::vector&lt; CEvaluationNode * &gt; &amp;additions, std::vector&lt; CEvaluationNode * &gt; &amp;substractions, bool minus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CNormalTranslation::splitSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>additions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtractions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method splits a sum into the individual elements. The returned nodes are copies of the original.</p>
<p>This method splits a sum into the individual elements The returned nodes are copies of the original. </p>

</div>
</div>
<a class="anchor" id="a674f97cc769b19c6060a5a86b0d8f24b"></a><!-- doxytag: member="CNormalTranslation::splitSum" ref="a674f97cc769b19c6060a5a86b0d8f24b" args="(const CEvaluationNode *pRoot, std::vector&lt; const CEvaluationNode * &gt; &amp;additions, std::vector&lt; const CEvaluationNode * &gt; &amp;substractions, bool minus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CNormalTranslation::splitSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>additions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtractions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method splits a sum into the individual elements. The returned nodes are part of the original node and not copies.</p>
<p>This method splits a sum into the individual elements The returned nodes are part of the original node and not copies. </p>

</div>
</div>
<a class="anchor" id="a9b371fe5234357684543499172c74446"></a><!-- doxytag: member="CNormalTranslation::swapNegativeNumbers" ref="a9b371fe5234357684543499172c74446" args="(std::vector&lt; CEvaluationNode * &gt; &amp;v1, std::vector&lt; CEvaluationNode * &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CNormalTranslation::swapNegativeNumbers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine moves all negative numbers from vector v1 to v2 and changes the number to a positive number. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aab7658060e61c06c17a09872608037d3"></a><!-- doxytag: member="CNormalTranslation::NEUTRAL_ELEMENT_ADD" ref="aab7658060e61c06c17a09872608037d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#aab7658060e61c06c17a09872608037d3">CNormalTranslation::NEUTRAL_ELEMENT_ADD</a> = <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(CEvaluationNodeNumber::DOUBLE, &quot;0.0&quot;)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neutral element for an addition chain. </p>

</div>
</div>
<a class="anchor" id="a7d9055851a26e57066c4fe95b48613ea"></a><!-- doxytag: member="CNormalTranslation::NEUTRAL_ELEMENT_AND" ref="a7d9055851a26e57066c4fe95b48613ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#a7d9055851a26e57066c4fe95b48613ea">CNormalTranslation::NEUTRAL_ELEMENT_AND</a> = <a class="el" href="class_c_evaluation_node_constant.html">CEvaluationNodeConstant</a>(CEvaluationNodeConstant::TRUE, &quot;TRUE&quot;)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neutral element for an and chain. </p>

</div>
</div>
<a class="anchor" id="af7bafe69abed5ddc58e9830424a74441"></a><!-- doxytag: member="CNormalTranslation::NEUTRAL_ELEMENT_MULTIPLY" ref="af7bafe69abed5ddc58e9830424a74441" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#af7bafe69abed5ddc58e9830424a74441">CNormalTranslation::NEUTRAL_ELEMENT_MULTIPLY</a> = <a class="el" href="class_c_evaluation_node_number.html">CEvaluationNodeNumber</a>(CEvaluationNodeNumber::DOUBLE, &quot;1.0&quot;)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neutral element for a multiplication chain. </p>

</div>
</div>
<a class="anchor" id="a0ae6878f8c10d2b2aa44f7c6a422b599"></a><!-- doxytag: member="CNormalTranslation::NEUTRAL_ELEMENT_OR" ref="a0ae6878f8c10d2b2aa44f7c6a422b599" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#a0ae6878f8c10d2b2aa44f7c6a422b599">CNormalTranslation::NEUTRAL_ELEMENT_OR</a> = <a class="el" href="class_c_evaluation_node_constant.html">CEvaluationNodeConstant</a>(CEvaluationNodeConstant::FALSE, &quot;FALSE&quot;)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neutral element for an or chain. </p>

</div>
</div>
<a class="anchor" id="a5a8c2fd4752f26b74a4b925b4c3446e5"></a><!-- doxytag: member="CNormalTranslation::ONE_NODE" ref="a5a8c2fd4752f26b74a4b925b4c3446e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#a5a8c2fd4752f26b74a4b925b4c3446e5">CNormalTranslation::ONE_NODE</a> = <a class="el" href="class_c_normal_translation.html#af7bafe69abed5ddc58e9830424a74441">CNormalTranslation::NEUTRAL_ELEMENT_MULTIPLY</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number node that represents 1.0 </p>

</div>
</div>
<a class="anchor" id="a1fbb73502f4ed305148030733151d9d1"></a><!-- doxytag: member="CNormalTranslation::PLUS_NODE" ref="a1fbb73502f4ed305148030733151d9d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#a1fbb73502f4ed305148030733151d9d1">CNormalTranslation::PLUS_NODE</a> = <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(CEvaluationNodeOperator::PLUS, &quot;+&quot;)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operator node that represents the PLUS operation. </p>

</div>
</div>
<a class="anchor" id="a06798939caa076a26a03358abc9adfc6"></a><!-- doxytag: member="CNormalTranslation::RECURSION_LIMIT" ref="a06798939caa076a26a03358abc9adfc6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="class_c_normal_translation.html#a06798939caa076a26a03358abc9adfc6">CNormalTranslation::RECURSION_LIMIT</a> = 20<code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae91afc33a5a9362c6ce89804f4fe9885"></a><!-- doxytag: member="CNormalTranslation::TIMES_NODE" ref="ae91afc33a5a9362c6ce89804f4fe9885" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#ae91afc33a5a9362c6ce89804f4fe9885">CNormalTranslation::TIMES_NODE</a> = <a class="el" href="class_c_evaluation_node_operator.html">CEvaluationNodeOperator</a>(CEvaluationNodeOperator::MULTIPLY, &quot;*&quot;)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operator node that represents the TIMES operation. </p>

</div>
</div>
<a class="anchor" id="a3ace3221694c78841e354ae7ce285e8a"></a><!-- doxytag: member="CNormalTranslation::ZERO" ref="a3ace3221694c78841e354ae7ce285e8a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_c_normal_translation.html#a3ace3221694c78841e354ae7ce285e8a">CNormalTranslation::ZERO</a> = 1e-100<code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a97f8c0f5977bd4c5e3f01f3cf33eaa36"></a><!-- doxytag: member="CNormalTranslation::ZERO_NODE" ref="a97f8c0f5977bd4c5e3f01f3cf33eaa36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> <a class="el" href="class_c_normal_translation.html#a97f8c0f5977bd4c5e3f01f3cf33eaa36">CNormalTranslation::ZERO_NODE</a> = <a class="el" href="class_c_normal_translation.html#aab7658060e61c06c17a09872608037d3">CNormalTranslation::NEUTRAL_ELEMENT_ADD</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number node that represents 0.0 </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>copasi/compareExpressions/<a class="el" href="_c_normal_translation_8h_source.html">CNormalTranslation.h</a></li>
<li>copasi/compareExpressions/<a class="el" href="_c_normal_translation_8cpp.html">CNormalTranslation.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 15 2011 20:32:34 for copasi API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>

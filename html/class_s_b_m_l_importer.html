<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>copasi API: SBMLImporter Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">copasi API
   &#160;<span id="projectnumber">0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">SBMLImporter Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="SBMLImporter" -->
<p><code>#include &lt;<a class="el" href="_s_b_m_l_importer_8h_source.html">SBMLImporter.h</a>&gt;</code></p>

<p><a href="class_s_b_m_l_importer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a0da5c22953d50d507f9f0ff00f7b9837">SBMLImporter</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#afd95a63976bb514a3444b845dd669d13">~SBMLImporter</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a24f760a128c40fe04cfc873c2cc262e7">readSBML</a> (std::string filename, <a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *funDB, SBMLDocument *&amp;pSBMLDocument, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, <a class="el" href="class_c_list_of_layouts.html">CListOfLayouts</a> *&amp;prLol, <a class="el" href="class_c_copasi_data_model.html">CCopasiDataModel</a> *pDataModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#adf9578513e1cce2a924a46a0e93c5dda">parseSBML</a> (const std::string &amp;sbmlDocumentText, <a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *funDB, SBMLDocument *&amp;pSBMLDocument, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, <a class="el" href="class_c_list_of_layouts.html">CListOfLayouts</a> *&amp;prLol, <a class="el" href="class_c_copasi_data_model.html">CCopasiDataModel</a> *pDataModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a808e13eae7937c4ed64ce989776bcd42">restoreFunctionDB</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ab7c3f20a666286ea61e4854c8f86f3f2">setImportHandler</a> (<a class="el" href="class_c_process_report.html">CProcessReport</a> *pHandler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_process_report.html">CProcessReport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8ec2db84bd14fc7d2842a0463b481e0f">getImportHandlerAddr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a86d7db236b41c28aaa476fb09f67678b">getImportCOPASIMIRIAM</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ad5f23358553e48562b7385abe9785bf7">setImportCOPASIMIRIAM</a> (bool import)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a2d5ef4903a7ed12d178107ef819b3b66">findIdInASTTree</a> (const ASTNode *pMath, const std::set&lt; std::string &gt; &amp;reactionIds)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a61d10c15681b398f297bee71eaa75dbe">areSBMLUnitDefinitionsIdentical</a> (const UnitDefinition *pUdef1, const UnitDefinition *pUdef2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static UnitDefinition *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a2511a51a2a17ac94c63dcf719f18f779">getSBMLUnitDefinitionForId</a> (const std::string &amp;unitId, const Model *pSBMLModel)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aedc9fc3ca40ac54787698cd2370a06dc">createCModelFromSBMLDocument</a> (SBMLDocument *doc, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_function.html">CFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a544798333f64b9a371d9add67076172d">createCFunctionFromFunctionDefinition</a> (const FunctionDefinition *sbmlFunction, <a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *pTmpFunctionDB, Model *pSBMLModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_function.html">CFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8635efa2b753c28b33f29f8f44b12161">createCFunctionFromFunctionTree</a> (const FunctionDefinition *pSBMLFunction, Model *pSBMLModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_compartment.html">CCompartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a879076815531affcbd0768f405f76475">createCCompartmentFromCompartment</a> (const Compartment *sbmlComp, <a class="el" href="class_c_model.html">CModel</a> *copasiModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, const Model *pSBMLModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_metab.html">CMetab</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a6e5e86bfa4b63886caa4daf1800a7abd">createCMetabFromSpecies</a> (const Species *sbmlSpecies, <a class="el" href="class_c_model.html">CModel</a> *copasiModel, <a class="el" href="class_c_compartment.html">CCompartment</a> *copasiCompartment, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, const Model *pSBMLModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a0e1dc15ef3ff133f828fb8f527ca7c68">areRulesUnique</a> (const Model *copasiMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ada0c2024af8f12fbef9c77ad4587fd68">importSBMLRule</a> (const Rule *sbmlRule, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a54e987b86e2c598008f5013b16eacc35">importRuleForModelEntity</a> (const Rule *rule, <a class="el" href="class_c_model_entity.html">CModelEntity</a> *pMV, <a class="el" href="class_c_model_entity.html#a86cb8e66e255d66db258324064efc78a">CModelEntity::Status</a> ruleType, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ac0d4d75e9f6785597142a2bce5131499">importEvents</a> (Model *pSBMLModel, <a class="el" href="class_c_model.html">CModel</a> *pCopasiModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aa251ce6bf2a3d52d2971c1ad7b0d90ec">importEvent</a> (const Event *pEvent, Model *pSBMLModel, <a class="el" href="class_c_model.html">CModel</a> *pCopasiModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a6a5f472d8d3c86bee75ca3ae677877c3">importRule</a> (const Rule *rule, <a class="el" href="class_c_model_entity.html#a86cb8e66e255d66db258324064efc78a">CModelEntity::Status</a> ruleType, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a5ac2addc8f38864b9b616830635b110a">getIdsFromNode</a> (const ASTNode *pNode, std::set&lt; std::string &gt; &amp;idSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a6d9048bf3ddc66ce0304345a54f6fa2f">checkRuleMathConsistency</a> (const Rule *pRule, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_model_value.html">CModelValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8595689dd63fec1e462ee49fd16ea333">createCModelValueFromParameter</a> (const Parameter *sbmlParameter, <a class="el" href="class_c_model.html">CModel</a> *copasiModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_reaction.html">CReaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a4c76a3dbe6ad1f874f6d24b6bb7fb8f9">createCReactionFromReaction</a> (Reaction *sbmlReaction, Model *sbmlModel, <a class="el" href="class_c_model.html">CModel</a> *cmodel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, <a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *pTmpFunctionDB)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, ASTNode * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a40d19d3a6cbe2fc34b1136644c3274cb">createBVarMap</a> (const ASTNode *uDefFunction, const ASTNode *function)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const FunctionDefinition *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a82afb75ea3c9cd40eead5e449007e23f">getFunctionDefinitionForName</a> (const std::string name, const Model *model)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a75709d25c4d1c5c05fc2a8caf38e4525">replaceBvars</a> (const ASTNode *node, std::map&lt; std::string, ASTNode * &gt; bvarMap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#acb25b2bd2e87cb5d0753b25991215681">replacePowerFunctionNodes</a> (ASTNode *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_c_model.html#a135194aaa96d335b89fbd59a81bff22c">CModel::LengthUnit</a>, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ac63af5c9fb48fdfac1fc3317954dca1f">handleLengthUnit</a> (const UnitDefinition *uDef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_c_model.html#addd8642dd9ff44bfc700e4d854206960">CModel::AreaUnit</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a47c92998532c601a66df4fae4e5a8b2d">handleAreaUnit</a> (const UnitDefinition *uDef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_c_model.html#aec54a4715a593a6c742193fabf74cb8d">CModel::VolumeUnit</a>, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aa1aca4da87cb2a912a7f27e0a21e6359">handleVolumeUnit</a> (const UnitDefinition *uDef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair<br class="typebreak"/>
&lt; <a class="el" href="class_c_model.html#ac6c52b224ba5973b9cae3cb3d503e25b">CModel::QuantityUnit</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aab3ad9f948cb55e9cb589d2b0bb3c934">handleSubstanceUnit</a> (const UnitDefinition *uDef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_c_model.html#a6301a7ea126c95b1bcabb917d17f0bda">CModel::TimeUnit</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aaf9850d5d4c3e287eb624ea7821682b2">handleTimeUnit</a> (const UnitDefinition *uDef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a6f2c4e20d24bb2a92ab1a2c2765fe2f7">replaceLog</a> (<a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *sourceNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a598cc8c19bb063cea35e5309c1c9fd26">replaceRoot</a> (<a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *sourceNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a3bf3c7539fc012eb3ca782f0ca44e5a8">sbmlId2CopasiCN</a> (ASTNode *pNode, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, <a class="el" href="class_c_copasi_parameter_group.html">CCopasiParameterGroup</a> &amp;pParamGroup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a556118a81345202b24dcac66c291532b">replaceCallNodeNames</a> (ASTNode *pNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a7ac29e15dc0e3a2795ec3b1a13e496fe">replace_delay_nodes</a> (<a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *pNode, Model *pModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, Reaction *pSBMLReaction, std::map&lt; std::string, std::string &gt; &amp;localReplacementMap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aca53cdde28ce5bb980ece4371c055fc8">find_local_parameters_in_delay</a> (ASTNode *pNode, Reaction *pSBMLReaction, Model *pModel, std::map&lt; std::string, std::string &gt; &amp;localReplacementMap, const std::set&lt; std::string &gt; &amp;localIds, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a6f596cc4208b32f8280111dcd7bc4727">replace_name_nodes</a> (ASTNode *pNode, const std::map&lt; std::string, std::string &gt; &amp;replacementMap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8dbe0a37260c5f96009615fe1ccfd069">replaceTimeNodeNames</a> (ASTNode *pNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8e416728d56ad3e80750885794bb60e9">isDelayFunctionUsed</a> (<a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *pNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a0bdaab30af2fb7e2bc5e637a2b40134a">preprocessNode</a> (<a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *pNode, Model *pSBMLModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, Reaction *pSBMLReaction=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_function.html">CFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#afd8e74cb5215a5f36caacc92cc12d3cf">findCorrespondingFunction</a> (const <a class="el" href="class_c_function.html">CFunction</a> *tree, const <a class="el" href="class_c_reaction.html">CReaction</a> *reaction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a41bd8f0562db3137b54c8f595a9b5f5c">areEqualFunctions</a> (const <a class="el" href="class_c_function.html">CFunction</a> *pFun, const <a class="el" href="class_c_function.html">CFunction</a> *pFun2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a4057a0fd56a54fe4f1f5c40c205dfaf2">areEqualSubtrees</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pNode1, const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pNode2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_c_evaluation_node_object.html">CEvaluationNodeObject</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a5eccfb6bf7001137ae5b14ecbfd0c971">isMassAction</a> (const <a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a> *pTree, const <a class="el" href="class_c_chem_eq.html">CChemEq</a> &amp;chemicalEquation, const <a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *pCallNode=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_c_evaluation_node_object.html">CEvaluationNodeObject</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#afa092dea2bdae901c5cbf41e7c4c7dd1">isMassActionExpression</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRootNode, const <a class="el" href="class_c_chem_eq.html">CChemEq</a> &amp;chemicalEquation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_c_evaluation_node_object.html">CEvaluationNodeObject</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8d114872c119310ca821f8f054b1b6e6">isMassActionFunction</a> (const <a class="el" href="class_c_function.html">CFunction</a> *pFun, const <a class="el" href="class_c_chem_eq.html">CChemEq</a> &amp;chemicalEquation, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;functionArgumentCNs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ab92634da43399704fc2ac9e201e4707a">separateProductArguments</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRootNode, std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;arguments)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a42cbb6f094224d7ec795eb172e40ab57">doMapping</a> (<a class="el" href="class_c_reaction.html">CReaction</a> *pCopasiReaction, const <a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *pCallNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#add8d8e41a0b4c3853049ee8f5d121d99">isSimpleFunctionCall</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRootNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ac31001c46406e6c9900dfee120afb0a5">setCorrectUsage</a> (<a class="el" href="class_c_reaction.html">CReaction</a> *pCopasiReaction, const <a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *pCallNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a632c364034d1112fdc3ed7e05dfd157c">isMultipliedByVolume</a> (const ASTNode *node, const std::string &amp;compartmentSBMLId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a9e1e81619841ec18ca458b1637e2601c">variables2objects</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pOrigNode, const std::map&lt; std::string, std::string &gt; &amp;replacementMap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a7d44bd16667ac649b9186979da296734">createExpressionFromFunction</a> (const <a class="el" href="class_c_function.html">CFunction</a> *pFun, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;functionArgumentCNs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#afa0fbf5c970cdfc26118c33a921caa5d">renameMassActionParameters</a> (<a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *pCallNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#acdc9c870d380d660ef11b4389eaf5bc8">containsVolume</a> (const ASTNode *pNode, const std::string &amp;compartmentCN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a3eab269f4577f39f76b021c4e3f75b37">removeUnusedFunctions</a> (<a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *pTmpFunctionDB, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a175d4d5e664bd89964dccf5ba89d25de">findFunctionCalls</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pNode, std::set&lt; std::string &gt; &amp;functionNameSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ac9b629c3ac0f557a6f94da2880781ed2">isStochasticModel</a> (const Model *pSBMLModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a9f528cf6d4ee5452d0b80565a90bb9dd">replace_time_with_initial_time</a> (ASTNode *pNode, const <a class="el" href="class_c_model.html">CModel</a> *pCOPASIModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ada6a4711ac017aa676ab4be88291a15b">replaceObjectNames</a> (ASTNode *pNode, const std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, bool initialExpression=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a15d24b615b23b00a505d720cd48917c7">replaceTimeNodesInFunctionDefinition</a> (ASTNode *root, std::string newNodeName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a30f60e2327471fd72cb0b6445e274b38">replaceTimeDependentFunctionCalls</a> (ASTNode *root)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a50b1ef1543256b1b2e0ae69c7f1ff7c6">setInitialValues</a> (<a class="el" href="class_c_model.html">CModel</a> *pModel, const std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a11c5ec0d43dba7741be5043bcd484e0d">checkElementUnits</a> (const Model *pSBMLModel, <a class="el" href="class_c_model.html">CModel</a> *pCopasiModel, int level, int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aee0459aaff9aa4dda4852bc5d61fad2c">importInitialAssignments</a> (Model *pSBMLModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlMap, const <a class="el" href="class_c_model.html">CModel</a> *pCOPASIModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a7d00c07d4d501255fa18951e949461b2">applyStoichiometricExpressions</a> (std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a359d319f85cd1bb24d2811b2b23fb7ab">createDelayFunctionDefinition</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a0e283899bb37b21959fa43ebe792588d">findAvogadroConstant</a> (Model *pSBMLModel, double factor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aaaae9a79b256a2015377b6fd36613deb">replaceAmountReferences</a> (<a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *pNode, Model *pSBMLModel, double factor, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a851212f9fbd299a9a2deaadf2d7a5eb1">createHasOnlySubstanceUnitFactor</a> (Model *pSBMLModel, double factor, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8a3910a5ef44cb9a35f36fc963002ed4">multiplySubstanceOnlySpeciesByVolume</a> (<a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *pNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aab2342964defac3d15b32eed20211e13">importMIRIAM</a> (const SBase *pSBMLObject, <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *pCOPASIObject)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ad01e17c0afbe5350a9c4474dadc0d168">importFunctionDefinitions</a> (Model *pSBMLModel, std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;copasi2sbmlmap)</td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static C_FLOAT64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a85c92e54900e9c0df1a1b890d52e9449">round</a> (const C_FLOAT64 &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a34f24c83698b4184ec7c8ab795efdee4">areApproximatelyEqual</a> (const double &amp;x, const double &amp;y, const double &amp;t=1e-9)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#adaced01dad763bc9aabccdd95f818ae8">isConstantFlux</a> (const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *pRoot, <a class="el" href="class_c_model.html">CModel</a> *pModel, <a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *pFunctionDB)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Unit *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a477bec05f03598fe9c52c95ccb441f88">convertSBMLCubicmetresToLitres</a> (const Unit *pU)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ae7bb5cbf2f09b5b7ec57510695ed1ec2">normalizeSBMLUnit</a> (Unit *pU)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a57920640816814412246e023fd98da7d">findDirectDependencies</a> (const FunctionDefinition *pFunDef, std::map&lt; const FunctionDefinition *, std::set&lt; std::string &gt; &gt; &amp;dependencies)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a3c3f358688531e3fba25e2476a02e248">findDirectDependencies</a> (const ASTNode *pNode, std::set&lt; std::string &gt; &amp;dependencies)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#acf0033487d629c27d4f133ac8ded9c02">mIgnoredSBMLMessages</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_c_metab.html">CMetab</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a2919a190a2cb8b7b5eb501af5c6f393e">speciesMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#af3884484e51df06669ba5bc4fc77c07c">functionDB</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#af39d5f3762cee43875daadd002af6f0e">mIncompleteModel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a0d1d70d874673527b508b3e8dcfed729">mUnsupportedRuleFound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a9dd94e991869614f42fc48347372e15c">mUnsupportedRateRuleFound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#ae215a7b25a8529b85a217e8bd0e006f0">mUnsupportedAssignmentRuleFound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8da36a9a8ae299a7ea5d4ac68382bb1e">mUnitOnNumberFound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a48bbb0ce9d9de02aa2d3d35147ca5b0f">mAssignmentToSpeciesReferenceFound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#aa2ceec377ae743892d56b522adbce41e">mLevel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a65cdc7be5200fff34240bcb2200fe558">mOriginalLevel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a7d741ae7e3799fdc819e689a3dafad86">mVersion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a> <br class="typebreak"/>
*, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a2bc4f5ddb47a8d776e4980be39af3d35">sbmlIdMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a64e5323f84c8730e7c120e8e9a965d13">mUsedFunctions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_copasi_data_model.html">CCopasiDataModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a2aa8c57db3550fc84175ad38f1f3661e">mpDataModel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#abc1b2ec95e8d7fa93910e094e948cb2f">mpCopasiModel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8dbcde81bbd9c319d5e2500756c15ce4">mFunctionNameMapping</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a09fb60445d24cc1bd582e23869cfaee1">mDivisionByCompartmentReactions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_process_report.html">CProcessReport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a32b10e0dc03fc5bbf7b4842b0d314ff6">mpImportHandler</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned C_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a9e83963c608041887b5d5e292be033c9">mImportStep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned C_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a9ec30028cc55992d6a25bb5ec4479361">mhImportStep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned C_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a76924558eafc00f4f3e01d19bd73577b">mTotalSteps</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; Species <br class="typebreak"/>
*, Compartment * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a5d0a2880f878659d6a0fc2fe0cc15610">mSubstanceOnlySpecies</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a3d029d1a08dc8f22dba1eedc57b036e3">mFastReactions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8728f6d9cdf831a37754c20bb9353a04">mReactionsWithReplacedLocalParameters</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8eb1281de56a2232df925ba8de420412">mExplicitelyTimeDependentFunctionDefinitions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a43ba9124187b089d5fb4122e8d9d7be2">mIgnoredParameterUnits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; const ASTNode <br class="typebreak"/>
*, <a class="el" href="class_c_chem_eq_element.html">CChemEqElement</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8ff64c7fedb1863cac4572f246ca65f7">mStoichiometricExpressionMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a7f40d8fba618f0e960f83849b93f357d">mDelayFound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; const Parameter * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a273943602d6059106e5d0ef3dd3e6e45">mPotentialAvogadroNumbers</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a057bc71f45b8f39fa15355f653163842">mAvogadroCreated</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a4588fba30554cfe8dbe394a6ad6685eb">mImportCOPASIMIRIAM</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a39b4cb542ae7593d545434fdcc03573e">mDelayNodeMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a8f78f336ef119556c847afdb8e86674d">mUsedSBMLIds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_b_m_l_importer.html#a19097f961c78f8d0383999d957b1b32f">mUsedSBMLIdsPopulated</a></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0da5c22953d50d507f9f0ff00f7b9837"></a><!-- doxytag: member="SBMLImporter::SBMLImporter" ref="a0da5c22953d50d507f9f0ff00f7b9837" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SBMLImporter::SBMLImporter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor that initializes speciesMap and the FunctionDB object </p>

</div>
</div>
<a class="anchor" id="afd95a63976bb514a3444b845dd669d13"></a><!-- doxytag: member="SBMLImporter::~SBMLImporter" ref="afd95a63976bb514a3444b845dd669d13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SBMLImporter::~SBMLImporter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor that does nothing. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7d00c07d4d501255fa18951e949461b2"></a><!-- doxytag: member="SBMLImporter::applyStoichiometricExpressions" ref="a7d00c07d4d501255fa18951e949461b2" args="(std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::applyStoichiometricExpressions </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method evaluates all stoichiometric expressions and sets them as constants on the <a class="el" href="class_c_chem_eq_element.html">CChemEqElement</a>. </p>

</div>
</div>
<a class="anchor" id="a34f24c83698b4184ec7c8ab795efdee4"></a><!-- doxytag: member="SBMLImporter::areApproximatelyEqual" ref="a34f24c83698b4184ec7c8ab795efdee4" args="(const double &amp;x, const double &amp;y, const double &amp;t=1e&#45;9)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::areApproximatelyEqual </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41bd8f0562db3137b54c8f595a9b5f5c"></a><!-- doxytag: member="SBMLImporter::areEqualFunctions" ref="a41bd8f0562db3137b54c8f595a9b5f5c" args="(const CFunction *pFun, const CFunction *pFun2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::areEqualFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_function.html">CFunction</a> *&#160;</td>
          <td class="paramname"><em>pFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_function.html">CFunction</a> *&#160;</td>
          <td class="paramname"><em>pFun2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4057a0fd56a54fe4f1f5c40c205dfaf2"></a><!-- doxytag: member="SBMLImporter::areEqualSubtrees" ref="a4057a0fd56a54fe4f1f5c40c205dfaf2" args="(const CEvaluationNode *pNode1, const CEvaluationNode *pNode2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::areEqualSubtrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pNode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pNode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares to <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> based subtrees recursively. </p>

</div>
</div>
<a class="anchor" id="a0e1dc15ef3ff133f828fb8f527ca7c68"></a><!-- doxytag: member="SBMLImporter::areRulesUnique" ref="a0e1dc15ef3ff133f828fb8f527ca7c68" args="(const Model *copasiMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::areRulesUnique </td>
          <td>(</td>
          <td class="paramtype">const Model *&#160;</td>
          <td class="paramname"><em>copasiMode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if no id is used in more than one Assignment and RateRule. </p>

</div>
</div>
<a class="anchor" id="a61d10c15681b398f297bee71eaa75dbe"></a><!-- doxytag: member="SBMLImporter::areSBMLUnitDefinitionsIdentical" ref="a61d10c15681b398f297bee71eaa75dbe" args="(const UnitDefinition *pUdef1, const UnitDefinition *pUdef2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::areSBMLUnitDefinitionsIdentical </td>
          <td>(</td>
          <td class="paramtype">const UnitDefinition *&#160;</td>
          <td class="paramname"><em>pUdef1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitDefinition *&#160;</td>
          <td class="paramname"><em>pUdef2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enhanced method to identify identical SBML unit definitions. This method uses the areIdentical method from libSBML, but if the method return false, it does some extra checks. Right now it check for example if two volumes, one given in litre and one given in cubic meters are identical.</p>
<p>Enhanced method to identify identical sbml unit definitions. The method first converts the unit definitions to SI units and simplifies them, only then they are compared. </p>

</div>
</div>
<a class="anchor" id="a11c5ec0d43dba7741be5043bcd484e0d"></a><!-- doxytag: member="SBMLImporter::checkElementUnits" ref="a11c5ec0d43dba7741be5043bcd484e0d" args="(const Model *pSBMLModel, CModel *pCopasiModel, int level, int version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::checkElementUnits </td>
          <td>(</td>
          <td class="paramtype">const Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>pCopasiModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d9048bf3ddc66ce0304345a54f6fa2f"></a><!-- doxytag: member="SBMLImporter::checkRuleMathConsistency" ref="a6d9048bf3ddc66ce0304345a54f6fa2f" args="(const Rule *pRule, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::checkRuleMathConsistency </td>
          <td>(</td>
          <td class="paramtype">const Rule *&#160;</td>
          <td class="paramname"><em>pRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks the expression for a give rate or assignment rule for consistency. This basically means it checks that no id present in the expression is the target for one of the following rate or assignment rules. </p>

</div>
</div>
<a class="anchor" id="acdc9c870d380d660ef11b4389eaf5bc8"></a><!-- doxytag: member="SBMLImporter::containsVolume" ref="acdc9c870d380d660ef11b4389eaf5bc8" args="(const ASTNode *pNode, const std::string &amp;compartmentCN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::containsVolume </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compartmentCN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the volume with the given CN is one of the parameters to the given call node. </p>

</div>
</div>
<a class="anchor" id="a477bec05f03598fe9c52c95ccb441f88"></a><!-- doxytag: member="SBMLImporter::convertSBMLCubicmetresToLitres" ref="a477bec05f03598fe9c52c95ccb441f88" args="(const Unit *pU)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Unit * SBMLImporter::convertSBMLCubicmetresToLitres </td>
          <td>(</td>
          <td class="paramtype">const Unit *&#160;</td>
          <td class="paramname"><em>pU</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the given UnitDefinition can be converted to a form of litre, the function return the UnitDefinition in litre, otherwise NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a40d19d3a6cbe2fc34b1136644c3274cb"></a><!-- doxytag: member="SBMLImporter::createBVarMap" ref="a40d19d3a6cbe2fc34b1136644c3274cb" args="(const ASTNode *uDefFunction, const ASTNode *function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, ASTNode * &gt; SBMLImporter::createBVarMap </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>uDefFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a map of each parameter of the function definition and its corresponding parameter in the function call. </p>

</div>
</div>
<a class="anchor" id="a879076815531affcbd0768f405f76475"></a><!-- doxytag: member="SBMLImporter::createCCompartmentFromCompartment" ref="a879076815531affcbd0768f405f76475" args="(const Compartment *sbmlComp, CModel *copasiModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, const Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_compartment.html">CCompartment</a> * SBMLImporter::createCCompartmentFromCompartment </td>
          <td>(</td>
          <td class="paramtype">const Compartment *&#160;</td>
          <td class="paramname"><em>sbmlCompartment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>copasiModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and returns a COPASI <a class="el" href="class_c_compartment.html">CCompartment</a> from the SBML Compartment given as argument.</p>
<p>Creates and returns a Copasi <a class="el" href="class_c_compartment.html">CCompartment</a> from the SBML Compartment given as argument. </p>

</div>
</div>
<a class="anchor" id="a544798333f64b9a371d9add67076172d"></a><!-- doxytag: member="SBMLImporter::createCFunctionFromFunctionDefinition" ref="a544798333f64b9a371d9add67076172d" args="(const FunctionDefinition *sbmlFunction, CFunctionDB *pTmpFunctionDB, Model *pSBMLModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_function.html">CFunction</a> * SBMLImporter::createCFunctionFromFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">const FunctionDefinition *&#160;</td>
          <td class="paramname"><em>sbmlFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td>
          <td class="paramname"><em>pTmpFunctionDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and returns a COPASI <a class="el" href="class_c_function.html" title="The class for handling a chemical kinetic function.">CFunction</a> from the SBML FunctionDefinition given as argument. </p>

</div>
</div>
<a class="anchor" id="a8635efa2b753c28b33f29f8f44b12161"></a><!-- doxytag: member="SBMLImporter::createCFunctionFromFunctionTree" ref="a8635efa2b753c28b33f29f8f44b12161" args="(const FunctionDefinition *pSBMLFunction, Model *pSBMLModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_function.html">CFunction</a> * SBMLImporter::createCFunctionFromFunctionTree </td>
          <td>(</td>
          <td class="paramtype">const FunctionDefinition *&#160;</td>
          <td class="paramname"><em>pSBMLFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e5e86bfa4b63886caa4daf1800a7abd"></a><!-- doxytag: member="SBMLImporter::createCMetabFromSpecies" ref="a6e5e86bfa4b63886caa4daf1800a7abd" args="(const Species *sbmlSpecies, CModel *copasiModel, CCompartment *copasiCompartment, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, const Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_metab.html">CMetab</a> * SBMLImporter::createCMetabFromSpecies </td>
          <td>(</td>
          <td class="paramtype">const Species *&#160;</td>
          <td class="paramname"><em>sbmlSpecies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>copasiModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_compartment.html">CCompartment</a> *&#160;</td>
          <td class="paramname"><em>copasiCompartment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and returns a COPASI <a class="el" href="class_c_metab.html">CMetab</a> from the given SBML Species object.</p>
<p>Creates and returns a Copasi <a class="el" href="class_c_metab.html">CMetab</a> from the given SBML Species object. </p>

</div>
</div>
<a class="anchor" id="aedc9fc3ca40ac54787698cd2370a06dc"></a><!-- doxytag: member="SBMLImporter::createCModelFromSBMLDocument" ref="aedc9fc3ca40ac54787698cd2370a06dc" args="(SBMLDocument *doc, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_model.html">CModel</a> * SBMLImporter::createCModelFromSBMLDocument </td>
          <td>(</td>
          <td class="paramtype">SBMLDocument *&#160;</td>
          <td class="paramname"><em>sbmlDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and returns a COPASI <a class="el" href="class_c_model.html">CModel</a> from the SBMLDocument given as argument.</p>
<p>Creates and returns a Copasi <a class="el" href="class_c_model.html">CModel</a> from the SBMLDocument given as argument. </p>

</div>
</div>
<a class="anchor" id="a8595689dd63fec1e462ee49fd16ea333"></a><!-- doxytag: member="SBMLImporter::createCModelValueFromParameter" ref="a8595689dd63fec1e462ee49fd16ea333" args="(const Parameter *sbmlParameter, CModel *copasiModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_model_value.html">CModelValue</a> * SBMLImporter::createCModelValueFromParameter </td>
          <td>(</td>
          <td class="paramtype">const Parameter *&#160;</td>
          <td class="paramname"><em>sbmlParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>copasiModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and returns a COPASI <a class="el" href="class_c_model_value.html">CModelValue</a> from the given SBML Parameter object. </p>

</div>
</div>
<a class="anchor" id="a4c76a3dbe6ad1f874f6d24b6bb7fb8f9"></a><!-- doxytag: member="SBMLImporter::createCReactionFromReaction" ref="a4c76a3dbe6ad1f874f6d24b6bb7fb8f9" args="(Reaction *sbmlReaction, Model *sbmlModel, CModel *cmodel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, CFunctionDB *pTmpFunctionDB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_reaction.html">CReaction</a> * SBMLImporter::createCReactionFromReaction </td>
          <td>(</td>
          <td class="paramtype">Reaction *&#160;</td>
          <td class="paramname"><em>sbmlReaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>copasiModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td>
          <td class="paramname"><em>pTmpFunctionDB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and returns a COPASI <a class="el" href="class_c_reaction.html">CReaction</a> object from the given SBML Reaction object.</p>
<p>Creates and returns a Copasi <a class="el" href="class_c_reaction.html">CReaction</a> object from the given SBML Reaction object. </p>

</div>
</div>
<a class="anchor" id="a359d319f85cd1bb24d2811b2b23fb7ab"></a><!-- doxytag: member="SBMLImporter::createDelayFunctionDefinition" ref="a359d319f85cd1bb24d2811b2b23fb7ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::createDelayFunctionDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a function definition for the delay function. </p>

</div>
</div>
<a class="anchor" id="a7d44bd16667ac649b9186979da296734"></a><!-- doxytag: member="SBMLImporter::createExpressionFromFunction" ref="a7d44bd16667ac649b9186979da296734" args="(const CFunction *pFun, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;functionArgumentCNs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a> * SBMLImporter::createExpressionFromFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_function.html">CFunction</a> *&#160;</td>
          <td class="paramname"><em>pFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functionArgumentCNs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a851212f9fbd299a9a2deaadf2d7a5eb1"></a><!-- doxytag: member="SBMLImporter::createHasOnlySubstanceUnitFactor" ref="a851212f9fbd299a9a2deaadf2d7a5eb1" args="(Model *pSBMLModel, double factor, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::createHasOnlySubstanceUnitFactor </td>
          <td>(</td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method creates a global parameter the represents the factor that is used to convert a particle number into the amount units set on the model. The parameter is only created if it is needed and after exporting the model, the parameter is deleted from the COPASI model again. </p>

</div>
</div>
<a class="anchor" id="a42cbb6f094224d7ec795eb172e40ab57"></a><!-- doxytag: member="SBMLImporter::doMapping" ref="a42cbb6f094224d7ec795eb172e40ab57" args="(CReaction *pCopasiReaction, const CEvaluationNodeCall *pCallNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::doMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_reaction.html">CReaction</a> *&#160;</td>
          <td class="paramname"><em>pCopasiReaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *&#160;</td>
          <td class="paramname"><em>pCallNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aca53cdde28ce5bb980ece4371c055fc8"></a><!-- doxytag: member="SBMLImporter::find_local_parameters_in_delay" ref="aca53cdde28ce5bb980ece4371c055fc8" args="(ASTNode *pNode, Reaction *pSBMLReaction, Model *pModel, std::map&lt; std::string, std::string &gt; &amp;localReplacementMap, const std::set&lt; std::string &gt; &amp;localIds, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::find_local_parameters_in_delay </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reaction *&#160;</td>
          <td class="paramname"><em>pSBMLReaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>localReplacementMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>localIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If we replace delay nodes within kineitc laws, we have to make sure that there is no reference to a local parameter within the replaced delay node because that would mean that we end up with a reference to a local parameter in the rule for the delay replacement which is not allowed in SBML. Therefore we have to convert all local parameters which occur within a delay call into global parameters. This method finds all local parameters that have to be converted to global parameters and it already creates the necessary global parameters. The localReplacementMap returns a mapping between the is of the original parameter and the id of the new parameter it will be replaced with. This map is used in a second step to actually replace the nodes in the expression.</p>
<p>If we replace delay nodes within kineitc laws, we have to make sure that there is no reference to a local parameter within the replaced delay node because that would mean that we end up with a reference to a local parameter in the rule for the delay replacement which is not allowed in SBML. Therefore we have to convert all local parameters which occur within a delay call into global parameters. </p>

</div>
</div>
<a class="anchor" id="a0e283899bb37b21959fa43ebe792588d"></a><!-- doxytag: member="SBMLImporter::findAvogadroConstant" ref="a0e283899bb37b21959fa43ebe792588d" args="(Model *pSBMLModel, double factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::findAvogadroConstant </td>
          <td>(</td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method goes through the list of global parameters and tries to find a parameter that could correspond to avogadros number. </p>

</div>
</div>
<a class="anchor" id="afd8e74cb5215a5f36caacc92cc12d3cf"></a><!-- doxytag: member="SBMLImporter::findCorrespondingFunction" ref="afd8e74cb5215a5f36caacc92cc12d3cf" args="(const CFunction *tree, const CReaction *reaction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_function.html">CFunction</a> * SBMLImporter::findCorrespondingFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_function.html">CFunction</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_reaction.html">CReaction</a> *&#160;</td>
          <td class="paramname"><em>pCopasiReaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The methods gets a function where all the parameters have a usage of "PARAMETER". In addition it get the root node of a call to that function which is an expression and contains the acutal objects with which the function is called in a certain reaction. From this expression we can determine if there already is a function in the database that does the same. Or we can find out if this function is a Mass Action kinetic. </p>

</div>
</div>
<a class="anchor" id="a57920640816814412246e023fd98da7d"></a><!-- doxytag: member="SBMLImporter::findDirectDependencies" ref="a57920640816814412246e023fd98da7d" args="(const FunctionDefinition *pFunDef, std::map&lt; const FunctionDefinition *, std::set&lt; std::string &gt; &gt; &amp;dependencies)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::findDirectDependencies </td>
          <td>(</td>
          <td class="paramtype">const FunctionDefinition *&#160;</td>
          <td class="paramname"><em>pFunDef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const FunctionDefinition *, std::set&lt; std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dependencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>static method that finds all direct function dependencies of a given function definition. </p>

</div>
</div>
<a class="anchor" id="a3c3f358688531e3fba25e2476a02e248"></a><!-- doxytag: member="SBMLImporter::findDirectDependencies" ref="a3c3f358688531e3fba25e2476a02e248" args="(const ASTNode *pNode, std::set&lt; std::string &gt; &amp;dependencies)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::findDirectDependencies </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dependencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>static method that recursively finds all direct function dependencies of the expression rooted at the given node. </p>

</div>
</div>
<a class="anchor" id="a175d4d5e664bd89964dccf5ba89d25de"></a><!-- doxytag: member="SBMLImporter::findFunctionCalls" ref="a175d4d5e664bd89964dccf5ba89d25de" args="(const CEvaluationNode *pNode, std::set&lt; std::string &gt; &amp;functionNameSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::findFunctionCalls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>functionNameSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds all functions calls directly or indirectly used in a function tree. </p>

</div>
</div>
<a class="anchor" id="a2d5ef4903a7ed12d178107ef819b3b66"></a><!-- doxytag: member="SBMLImporter::findIdInASTTree" ref="a2d5ef4903a7ed12d178107ef819b3b66" args="(const ASTNode *pMath, const std::set&lt; std::string &gt; &amp;reactionIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBMLImporter::findIdInASTTree </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>pMath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>reactionIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method takes an AST node and a set of ids and returns the first id from the set it finds in the AST tree. This is e.g. used to check if expression in L2V1 contain references to reaction ids. </p>

</div>
</div>
<a class="anchor" id="a82afb75ea3c9cd40eead5e449007e23f"></a><!-- doxytag: member="SBMLImporter::getFunctionDefinitionForName" ref="a82afb75ea3c9cd40eead5e449007e23f" args="(const std::string name, const Model *model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const FunctionDefinition * SBMLImporter::getFunctionDefinitionForName </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Model *&#160;</td>
          <td class="paramname"><em>sbmlModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the user defined SBML function definition that belongs to the given name, or NULL if none can be found. </p>

</div>
</div>
<a class="anchor" id="a5ac2addc8f38864b9b616830635b110a"></a><!-- doxytag: member="SBMLImporter::getIdsFromNode" ref="a5ac2addc8f38864b9b616830635b110a" args="(const ASTNode *pNode, std::set&lt; std::string &gt; &amp;idSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::getIdsFromNode </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>idSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Recurses an ASTNode tree and gets all SBML Ids in the tree. The ids are stored in the given set. </p>

</div>
</div>
<a class="anchor" id="a86d7db236b41c28aaa476fb09f67678b"></a><!-- doxytag: member="SBMLImporter::getImportCOPASIMIRIAM" ref="a86d7db236b41c28aaa476fb09f67678b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::getImportCOPASIMIRIAM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the flag that determines whether COPASI MIRIAM annotation is imported if it is present. </p>

</div>
</div>
<a class="anchor" id="a8ec2db84bd14fc7d2842a0463b481e0f"></a><!-- doxytag: member="SBMLImporter::getImportHandlerAddr" ref="a8ec2db84bd14fc7d2842a0463b481e0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_process_report.html">CProcessReport</a> * SBMLImporter::getImportHandlerAddr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2511a51a2a17ac94c63dcf719f18f779"></a><!-- doxytag: member="SBMLImporter::getSBMLUnitDefinitionForId" ref="a2511a51a2a17ac94c63dcf719f18f779" args="(const std::string &amp;unitId, const Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnitDefinition * SBMLImporter::getSBMLUnitDefinitionForId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unitId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method takes the id of a unit as it can appear in an SBML file, and returns a new UnitDefinition object for that id. </p>

</div>
</div>
<a class="anchor" id="a47c92998532c601a66df4fae4e5a8b2d"></a><!-- doxytag: member="SBMLImporter::handleAreaUnit" ref="a47c92998532c601a66df4fae4e5a8b2d" args="(const UnitDefinition *uDef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_model.html#addd8642dd9ff44bfc700e4d854206960">CModel::AreaUnit</a>, bool &gt; SBMLImporter::handleAreaUnit </td>
          <td>(</td>
          <td class="paramtype">const UnitDefinition *&#160;</td>
          <td class="paramname"><em>uDef</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the copasi AreaUnit corresponding to the given SBML area UnitDefinition. </p>

</div>
</div>
<a class="anchor" id="ac63af5c9fb48fdfac1fc3317954dca1f"></a><!-- doxytag: member="SBMLImporter::handleLengthUnit" ref="ac63af5c9fb48fdfac1fc3317954dca1f" args="(const UnitDefinition *uDef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_model.html#a135194aaa96d335b89fbd59a81bff22c">CModel::LengthUnit</a>, bool &gt; SBMLImporter::handleLengthUnit </td>
          <td>(</td>
          <td class="paramtype">const UnitDefinition *&#160;</td>
          <td class="paramname"><em>uDef</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions replaces all species nodes for species that are in the substanceOnlySpeciesVector. With the node multiplied by the volume of the species compartment. void replaceSubstanceOnlySpeciesNodes(ConverterASTNode* node, const std::map&lt;Species*, Compartment*&gt;&amp; substanceOnlySpecies); Returns the copasi LengthUnit corresponding to the given SBML length UnitDefinition.</p>
<p>Returns the copasi LengthUnit corresponding to the given SBML length UnitDefinition. </p>

</div>
</div>
<a class="anchor" id="aab3ad9f948cb55e9cb589d2b0bb3c934"></a><!-- doxytag: member="SBMLImporter::handleSubstanceUnit" ref="aab3ad9f948cb55e9cb589d2b0bb3c934" args="(const UnitDefinition *uDef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_model.html#ac6c52b224ba5973b9cae3cb3d503e25b">CModel::QuantityUnit</a>, bool &gt; SBMLImporter::handleSubstanceUnit </td>
          <td>(</td>
          <td class="paramtype">const UnitDefinition *&#160;</td>
          <td class="paramname"><em>uDef</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the COPASI QuantityUnit corresponding to the given SBML Substance UnitDefinition.</p>
<p>Returns the copasi QuantityUnit corresponding to the given SBML Substance UnitDefinition. </p>

</div>
</div>
<a class="anchor" id="aaf9850d5d4c3e287eb624ea7821682b2"></a><!-- doxytag: member="SBMLImporter::handleTimeUnit" ref="aaf9850d5d4c3e287eb624ea7821682b2" args="(const UnitDefinition *uDef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_model.html#a6301a7ea126c95b1bcabb917d17f0bda">CModel::TimeUnit</a>, bool &gt; SBMLImporter::handleTimeUnit </td>
          <td>(</td>
          <td class="paramtype">const UnitDefinition *&#160;</td>
          <td class="paramname"><em>uDef</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the COPASI TimeUnit corresponding to the given SBML Time UnitDefinition.</p>
<p>Returns the copasi TimeUnit corresponding to the given SBML Time UnitDefinition. </p>

</div>
</div>
<a class="anchor" id="aa1aca4da87cb2a912a7f27e0a21e6359"></a><!-- doxytag: member="SBMLImporter::handleVolumeUnit" ref="aa1aca4da87cb2a912a7f27e0a21e6359" args="(const UnitDefinition *uDef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_model.html#aec54a4715a593a6c742193fabf74cb8d">CModel::VolumeUnit</a>, bool &gt; SBMLImporter::handleVolumeUnit </td>
          <td>(</td>
          <td class="paramtype">const UnitDefinition *&#160;</td>
          <td class="paramname"><em>uDef</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the copasi VolumeUnit corresponding to the given SBML Volume UnitDefinition. </p>

</div>
</div>
<a class="anchor" id="aa251ce6bf2a3d52d2971c1ad7b0d90ec"></a><!-- doxytag: member="SBMLImporter::importEvent" ref="aa251ce6bf2a3d52d2971c1ad7b0d90ec" args="(const Event *pEvent, Model *pSBMLModel, CModel *pCopasiModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::importEvent </td>
          <td>(</td>
          <td class="paramtype">const Event *&#160;</td>
          <td class="paramname"><em>pEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>pCopasiModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Imports the given event. </p>

</div>
</div>
<a class="anchor" id="ac0d4d75e9f6785597142a2bce5131499"></a><!-- doxytag: member="SBMLImporter::importEvents" ref="ac0d4d75e9f6785597142a2bce5131499" args="(Model *pSBMLModel, CModel *pCopasiModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::importEvents </td>
          <td>(</td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>pCopasiModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Imports all events </p>

</div>
</div>
<a class="anchor" id="ad01e17c0afbe5350a9c4474dadc0d168"></a><!-- doxytag: member="SBMLImporter::importFunctionDefinitions" ref="ad01e17c0afbe5350a9c4474dadc0d168" args="(Model *pSBMLModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> * SBMLImporter::importFunctionDefinitions </td>
          <td>(</td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starting with SBML Level 2 Version 4, function definitions no longer need to be ordered, i.e. a function definition may refer to another function definition that is defined somewhere further down in the file. So we have to import the function definitions in the correct order. </p>

</div>
</div>
<a class="anchor" id="aee0459aaff9aa4dda4852bc5d61fad2c"></a><!-- doxytag: member="SBMLImporter::importInitialAssignments" ref="aee0459aaff9aa4dda4852bc5d61fad2c" args="(Model *pSBMLModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlMap, const CModel *pCOPASIModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::importInitialAssignments </td>
          <td>(</td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>pCOPASIModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Imports all initial assignments if there are any. </p>

</div>
</div>
<a class="anchor" id="aab2342964defac3d15b32eed20211e13"></a><!-- doxytag: member="SBMLImporter::importMIRIAM" ref="aab2342964defac3d15b32eed20211e13" args="(const SBase *pSBMLObject, CCopasiObject *pCOPASIObject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::importMIRIAM </td>
          <td>(</td>
          <td class="paramtype">const SBase *&#160;</td>
          <td class="paramname"><em>pSBMLObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *&#160;</td>
          <td class="paramname"><em>pCOPASIObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Imports the MIRIAM annotation from the given SBML object and sets it on the given COPASI object. </p>

</div>
</div>
<a class="anchor" id="a6a5f472d8d3c86bee75ca3ae677877c3"></a><!-- doxytag: member="SBMLImporter::importRule" ref="a6a5f472d8d3c86bee75ca3ae677877c3" args="(const Rule *rule, CModelEntity::Status ruleType, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::importRule </td>
          <td>(</td>
          <td class="paramtype">const Rule *&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model_entity.html#a86cb8e66e255d66db258324064efc78a">CModelEntity::Status</a>&#160;</td>
          <td class="paramname"><em>ruleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Imports the given RateRule if COPASI supports this kind of RateRule, otherwise a warning is created. </p>

</div>
</div>
<a class="anchor" id="a54e987b86e2c598008f5013b16eacc35"></a><!-- doxytag: member="SBMLImporter::importRuleForModelEntity" ref="a54e987b86e2c598008f5013b16eacc35" args="(const Rule *rule, CModelEntity *pMV, CModelEntity::Status ruleType, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::importRuleForModelEntity </td>
          <td>(</td>
          <td class="paramtype">const Rule *&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model_entity.html">CModelEntity</a> *&#160;</td>
          <td class="paramname"><em>pMV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model_entity.html#a86cb8e66e255d66db258324064efc78a">CModelEntity::Status</a>&#160;</td>
          <td class="paramname"><em>ruleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Imports the given AssignmentRule which is for a global parameter. </p>

</div>
</div>
<a class="anchor" id="ada0c2024af8f12fbef9c77ad4587fd68"></a><!-- doxytag: member="SBMLImporter::importSBMLRule" ref="ada0c2024af8f12fbef9c77ad4587fd68" args="(const Rule *sbmlRule, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::importSBMLRule </td>
          <td>(</td>
          <td class="paramtype">const Rule *&#160;</td>
          <td class="paramname"><em>sbmlRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Imports the given Rule if COPASI supports this kind of Rule, otherwise a warning is created. </p>

</div>
</div>
<a class="anchor" id="adaced01dad763bc9aabccdd95f818ae8"></a><!-- doxytag: member="SBMLImporter::isConstantFlux" ref="adaced01dad763bc9aabccdd95f818ae8" args="(const CEvaluationNode *pRoot, CModel *pModel, CFunctionDB *pFunctionDB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_copasi_object.html">CCopasiObject</a> * SBMLImporter::isConstantFlux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>pModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td>
          <td class="paramname"><em>pFunctionDB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the given node is an object node that represents a parameter or a model value or a function which has a single parameter and a single node which also represents a parameter. </p>

</div>
</div>
<a class="anchor" id="a8e416728d56ad3e80750885794bb60e9"></a><!-- doxytag: member="SBMLImporter::isDelayFunctionUsed" ref="a8e416728d56ad3e80750885794bb60e9" args="(ConverterASTNode *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::isDelayFunctionUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>COPASI can not handle the delay function yet, so if it is used in some expression, we have to abort reading the file. </p>

</div>
</div>
<a class="anchor" id="a5eccfb6bf7001137ae5b14ecbfd0c971"></a><!-- doxytag: member="SBMLImporter::isMassAction" ref="a5eccfb6bf7001137ae5b14ecbfd0c971" args="(const CEvaluationTree *pTree, const CChemEq &amp;chemicalEquation, const CEvaluationNodeCall *pCallNode=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_c_evaluation_node_object.html">CEvaluationNodeObject</a> * &gt; * SBMLImporter::isMassAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a> *&#160;</td>
          <td class="paramname"><em>pTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_chem_eq.html">CChemEq</a> &amp;&#160;</td>
          <td class="paramname"><em>chemicalEquation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *&#160;</td>
          <td class="paramname"><em>pCallNode</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afa092dea2bdae901c5cbf41e7c4c7dd1"></a><!-- doxytag: member="SBMLImporter::isMassActionExpression" ref="afa092dea2bdae901c5cbf41e7c4c7dd1" args="(const CEvaluationNode *pRootNode, const CChemEq &amp;chemicalEquation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_c_evaluation_node_object.html">CEvaluationNodeObject</a> * &gt; * SBMLImporter::isMassActionExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRootNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_chem_eq.html">CChemEq</a> &amp;&#160;</td>
          <td class="paramname"><em>chemicalEquation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8d114872c119310ca821f8f054b1b6e6"></a><!-- doxytag: member="SBMLImporter::isMassActionFunction" ref="a8d114872c119310ca821f8f054b1b6e6" args="(const CFunction *pFun, const CChemEq &amp;chemicalEquation, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;functionArgumentCNs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_c_evaluation_node_object.html">CEvaluationNodeObject</a> * &gt; * SBMLImporter::isMassActionFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_function.html">CFunction</a> *&#160;</td>
          <td class="paramname"><em>pFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_chem_eq.html">CChemEq</a> &amp;&#160;</td>
          <td class="paramname"><em>chemicalEquation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functionArgumentCNs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a632c364034d1112fdc3ed7e05dfd157c"></a><!-- doxytag: member="SBMLImporter::isMultipliedByVolume" ref="a632c364034d1112fdc3ed7e05dfd157c" args="(const ASTNode *node, const std::string &amp;compartmentSBMLId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> * SBMLImporter::isMultipliedByVolume </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compartmentSBMLId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if a given tree is multiplied by a compartment identifier. If so, a copy of the tree is returned in which the multiplication has been removed. </p>

</div>
</div>
<a class="anchor" id="add8d8e41a0b4c3853049ee8f5d121d99"></a><!-- doxytag: member="SBMLImporter::isSimpleFunctionCall" ref="add8d8e41a0b4c3853049ee8f5d121d99" args="(const CEvaluationNode *pRootNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::isSimpleFunctionCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRootNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9b629c3ac0f557a6f94da2880781ed2"></a><!-- doxytag: member="SBMLImporter::isStochasticModel" ref="ac9b629c3ac0f557a6f94da2880781ed2" args="(const Model *pSBMLModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::isStochasticModel </td>
          <td>(</td>
          <td class="paramtype">const Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Heuristically checks whether a model was meant to be simulated stochastically. If the substance units are set to items and all reaction are irreversible this function will return true; </p>

</div>
</div>
<a class="anchor" id="a8a3910a5ef44cb9a35f36fc963002ed4"></a><!-- doxytag: member="SBMLImporter::multiplySubstanceOnlySpeciesByVolume" ref="a8a3910a5ef44cb9a35f36fc963002ed4" args="(ConverterASTNode *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::multiplySubstanceOnlySpeciesByVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiplies all species nodes that belong to species with the hasSubstanceOnlyUnits flag set with the volume of the compartment that the species belongs to. This is only done for kineticLaw, all other mathematical expressions import those references as particle number nodes divided by the quantity2unit factor. </p>

</div>
</div>
<a class="anchor" id="ae7bb5cbf2f09b5b7ec57510695ed1ec2"></a><!-- doxytag: member="SBMLImporter::normalizeSBMLUnit" ref="ae7bb5cbf2f09b5b7ec57510695ed1ec2" args="(Unit *pU)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::normalizeSBMLUnit </td>
          <td>(</td>
          <td class="paramtype">Unit *&#160;</td>
          <td class="paramname"><em>pU</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function normalizes the multiplier to be within the range 1.0 &lt;= multiplier &lt; 10.0. </p>

</div>
</div>
<a class="anchor" id="adf9578513e1cce2a924a46a0e93c5dda"></a><!-- doxytag: member="SBMLImporter::parseSBML" ref="adf9578513e1cce2a924a46a0e93c5dda" args="(const std::string &amp;sbmlDocumentText, CFunctionDB *funDB, SBMLDocument *&amp;pSBMLDocument, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, CListOfLayouts *&amp;prLol, CCopasiDataModel *pDataModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_model.html">CModel</a> * SBMLImporter::parseSBML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sbmlDocumentText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td>
          <td class="paramname"><em>funDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SBMLDocument *&amp;&#160;</td>
          <td class="paramname"><em>pSBMLDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_list_of_layouts.html">CListOfLayouts</a> *&amp;&#160;</td>
          <td class="paramname"><em>prLol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_copasi_data_model.html">CCopasiDataModel</a> *&#160;</td>
          <td class="paramname"><em>pDataModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function parses an SBML document with libsbml and converts it to a COPASI <a class="el" href="class_c_model.html">CModel</a> object which is returned. Deletion of the returned pointer is up to the caller. </p>

</div>
</div>
<a class="anchor" id="a0bdaab30af2fb7e2bc5e637a2b40134a"></a><!-- doxytag: member="SBMLImporter::preprocessNode" ref="a0bdaab30af2fb7e2bc5e637a2b40134a" args="(ConverterASTNode *pNode, Model *pSBMLModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, Reaction *pSBMLReaction=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::preprocessNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reaction *&#160;</td>
          <td class="paramname"><em>pSBMLReaction</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In a preprocessing step each expression tree that is imported, e.g. for function definitions, rules, event or kinetic laws is preprocessed to replace some of the nodes data. See also replaceCallNodeNames and replaceTimeNodeNames. </p>

</div>
</div>
<a class="anchor" id="a24f760a128c40fe04cfc873c2cc262e7"></a><!-- doxytag: member="SBMLImporter::readSBML" ref="a24f760a128c40fe04cfc873c2cc262e7" args="(std::string filename, CFunctionDB *funDB, SBMLDocument *&amp;pSBMLDocument, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, CListOfLayouts *&amp;prLol, CCopasiDataModel *pDataModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_model.html">CModel</a> * SBMLImporter::readSBML </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td>
          <td class="paramname"><em>funDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SBMLDocument *&amp;&#160;</td>
          <td class="paramname"><em>pSBMLDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_list_of_layouts.html">CListOfLayouts</a> *&amp;&#160;</td>
          <td class="paramname"><em>prLol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_copasi_data_model.html">CCopasiDataModel</a> *&#160;</td>
          <td class="paramname"><em>pDataModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions replaces all species nodes for species that are in the substanceOnlySpeciesVector. With the node multiplied by the volume of the species compartment. void SBMLImporter::replaceSubstanceOnlySpeciesNodes(ConverterASTNode* node, const std::map&lt;Species*, Compartment*&gt;&amp; substanceOnlySpecies) { if (node != NULL) { if (node-&gt;getType() == AST_NAME) { std::map&lt;Species*, Compartment*&gt;::const_iterator it = substanceOnlySpecies.begin(); std::map&lt;Species*, Compartment*&gt;::const_iterator endIt = substanceOnlySpecies.end(); while (it != endIt) { if (it-&gt;first-&gt;getId() == node-&gt;getName()) { replace node List* l = new List(); ConverterASTNode* child1 = new ConverterASTNode(AST_NAME); child1-&gt;setName(node-&gt;getName()); ConverterASTNode* child2 = new ConverterASTNode(AST_NAME); child2-&gt;setName(it-&gt;second-&gt;getId().c_str()); l-&gt;add(child1); l-&gt;add(child2); node-&gt;setChildren(l); node-&gt;setType(AST_TIMES); break; } ++it; } } else { unsigned int counter; for (counter = 0;counter &lt; node-&gt;getNumChildren();counter++) { this-&gt;replaceSubstanceOnlySpeciesNodes((ConverterASTNode*)node-&gt;getChild(counter), substanceOnlySpecies); } } } } Function reads an SBML file with libsbml and converts it to a Copasi <a class="el" href="class_c_model.html">CModel</a> </p>

</div>
</div>
<a class="anchor" id="a3eab269f4577f39f76b021c4e3f75b37"></a><!-- doxytag: member="SBMLImporter::removeUnusedFunctions" ref="a3eab269f4577f39f76b021c4e3f75b37" args="(CFunctionDB *pTmpFunctionDB, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::removeUnusedFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a> *&#160;</td>
          <td class="paramname"><em>pTmpFunctionDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds all functions that are used and removes those that are not. </p>

</div>
</div>
<a class="anchor" id="afa0fbf5c970cdfc26118c33a921caa5d"></a><!-- doxytag: member="SBMLImporter::renameMassActionParameters" ref="afa0fbf5c970cdfc26118c33a921caa5d" args="(CEvaluationNodeCall *pCallNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::renameMassActionParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *&#160;</td>
          <td class="paramname"><em>pCallNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ac29e15dc0e3a2795ec3b1a13e496fe"></a><!-- doxytag: member="SBMLImporter::replace_delay_nodes" ref="a7ac29e15dc0e3a2795ec3b1a13e496fe" args="(ConverterASTNode *pNode, Model *pModel, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, Reaction *pSBMLReaction, std::map&lt; std::string, std::string &gt; &amp;localReplacementMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replace_delay_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reaction *&#160;</td>
          <td class="paramname"><em>pSBMLReaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>localReplacementMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function replaces calls to the delay function in an ASTNode tree by a node that references a new global parameter which the function creates. The global parameter gets an expression which corresponds to the delay call. This is necessary because all knetic laws in COPASI are function calls and function definitions should not contain a call to delay. </p>

</div>
</div>
<a class="anchor" id="a6f596cc4208b32f8280111dcd7bc4727"></a><!-- doxytag: member="SBMLImporter::replace_name_nodes" ref="a6f596cc4208b32f8280111dcd7bc4727" args="(ASTNode *pNode, const std::map&lt; std::string, std::string &gt; &amp;replacementMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replace_name_nodes </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacementMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method gets an ASTNode and a map between old node names and new node names. All AST_NAME nodes with an "old" name are replaced by a node with the "new" name. </p>

</div>
</div>
<a class="anchor" id="a9f528cf6d4ee5452d0b80565a90bb9dd"></a><!-- doxytag: member="SBMLImporter::replace_time_with_initial_time" ref="a9f528cf6d4ee5452d0b80565a90bb9dd" args="(ASTNode *pNode, const CModel *pCOPASIModel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replace_time_with_initial_time </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>pCopasiModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If an initial expression uses time, we have to import it as initial time instead. This method takes an AST node and converts all time nodes to object nodes that have the common name of the time as the name. </p>

</div>
</div>
<a class="anchor" id="aaaae9a79b256a2015377b6fd36613deb"></a><!-- doxytag: member="SBMLImporter::replaceAmountReferences" ref="aaaae9a79b256a2015377b6fd36613deb" args="(ConverterASTNode *pNode, Model *pSBMLModel, double factor, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replaceAmountReferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model *&#160;</td>
          <td class="paramname"><em>pSBMLModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method replaces references to the id of species which have the hasOnlySubstanceUnits flag set with the reference divided by avogadros number. The method tries to determine if there already is a multiplication with avogadros number and removes this multiplication rather than adding a new division. </p>

</div>
</div>
<a class="anchor" id="a75709d25c4d1c5c05fc2a8caf38e4525"></a><!-- doxytag: member="SBMLImporter::replaceBvars" ref="a75709d25c4d1c5c05fc2a8caf38e4525" args="(const ASTNode *node, std::map&lt; std::string, ASTNode * &gt; bvarMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> * SBMLImporter::replaceBvars </td>
          <td>(</td>
          <td class="paramtype">const ASTNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, ASTNode * &gt;&#160;</td>
          <td class="paramname"><em>bvarMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the variables in a function definition with the actual function parameters that were used when the function was called. The function returns a pointer to the ConverterAST node with the replaced variables. </p>

</div>
</div>
<a class="anchor" id="a556118a81345202b24dcac66c291532b"></a><!-- doxytag: member="SBMLImporter::replaceCallNodeNames" ref="a556118a81345202b24dcac66c291532b" args="(ASTNode *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replaceCallNodeNames </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Upon import a function object might change its name due to naming conflicts in the function database. So each ASTNode tree has its call node names replaced before it will be processed further. </p>

</div>
</div>
<a class="anchor" id="a6f2c4e20d24bb2a92ab1a2c2765fe2f7"></a><!-- doxytag: member="SBMLImporter::replaceLog" ref="a6f2c4e20d24bb2a92ab1a2c2765fe2f7" args="(ConverterASTNode *sourceNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replaceLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces all occurrences of the log function with two arguments by a division of two separate calls to log. </p>

</div>
</div>
<a class="anchor" id="ada6a4711ac017aa676ab4be88291a15b"></a><!-- doxytag: member="SBMLImporter::replaceObjectNames" ref="ada6a4711ac017aa676ab4be88291a15b" args="(ASTNode *pNode, const std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, bool initialExpression=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replaceObjectNames </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialExpression</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb25b2bd2e87cb5d0753b25991215681"></a><!-- doxytag: member="SBMLImporter::replacePowerFunctionNodes" ref="acb25b2bd2e87cb5d0753b25991215681" args="(ASTNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replacePowerFunctionNodes </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function replaces the AST_FUNCTION_POWER ASTNodes in a ASTNode tree with the AST_POWER node. </p>

</div>
</div>
<a class="anchor" id="a598cc8c19bb063cea35e5309c1c9fd26"></a><!-- doxytag: member="SBMLImporter::replaceRoot" ref="a598cc8c19bb063cea35e5309c1c9fd26" args="(ConverterASTNode *sourceNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replaceRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_converter_a_s_t_node.html">ConverterASTNode</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces all occurrences of the root function with two arguments by a call to the power function with the inverse of the first argument. </p>

</div>
</div>
<a class="anchor" id="a30f60e2327471fd72cb0b6445e274b38"></a><!-- doxytag: member="SBMLImporter::replaceTimeDependentFunctionCalls" ref="a30f60e2327471fd72cb0b6445e274b38" args="(ASTNode *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replaceTimeDependentFunctionCalls </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function replaces function calls to all functions listed in mExplicitelyTimeDependentFunctionDefinitions with the same call but an additional parameter which is the time. This replacement includes all model entities that have a mathematical expression, so depending on the version of SBML, this would include: initial assignments, rules, constraints, kinetic laws and events. The corresponding replacement for the function definitions is done in replaceTimeNodesInFunctionDefinition. </p>

</div>
</div>
<a class="anchor" id="a8dbe0a37260c5f96009615fe1ccfd069"></a><!-- doxytag: member="SBMLImporter::replaceTimeNodeNames" ref="a8dbe0a37260c5f96009615fe1ccfd069" args="(ASTNode *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::replaceTimeNodeNames </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The data for a <a class="el" href="class_c_evaluation_node_object.html">CEvaluationNodeObject</a> needs to have the common name of the model it refers to as its data. Since this model is only known via a pointer in the <a class="el" href="class_s_b_m_l_importer.html">SBMLImporter</a> at the time of import, all AST_NAME_TIME nodes that are imported need to have their name replaced by the common name of this model. </p>

</div>
</div>
<a class="anchor" id="a15d24b615b23b00a505d720cd48917c7"></a><!-- doxytag: member="SBMLImporter::replaceTimeNodesInFunctionDefinition" ref="a15d24b615b23b00a505d720cd48917c7" args="(ASTNode *root, std::string newNodeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::replaceTimeNodesInFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newNodeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For function definitions that use the time symbol we have to make this a variable that is passed to the function instead. The function recursively goes through the AST tree rooted in root and changes all time nodes to variable nodes with name newNodeName. If a time node has been found, the function return true, otherwise false is returned.</p>
<p>For function definitions that use the time symbol we have to make this a variable that is passed to the function instead. The function recursively goes through the AST tree rooted in root and changs all time nodes to variable nodes with name newNodeName. Additionally all function calls to functions in mExplicitelyTimeDependentFunctionDefinitions have to be changed to contain the added parameter. If a time node has been found, the function return true, otherwise false is returned. </p>

</div>
</div>
<a class="anchor" id="a808e13eae7937c4ed64ce989776bcd42"></a><!-- doxytag: member="SBMLImporter::restoreFunctionDB" ref="a808e13eae7937c4ed64ce989776bcd42" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::restoreFunctionDB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a85c92e54900e9c0df1a1b890d52e9449"></a><!-- doxytag: member="SBMLImporter::round" ref="a85c92e54900e9c0df1a1b890d52e9449" args="(const C_FLOAT64 &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C_FLOAT64 SBMLImporter::round </td>
          <td>(</td>
          <td class="paramtype">const C_FLOAT64 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3bf3c7539fc012eb3ca782f0ca44e5a8"></a><!-- doxytag: member="SBMLImporter::sbmlId2CopasiCN" ref="a3bf3c7539fc012eb3ca782f0ca44e5a8" args="(ASTNode *pNode, std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap, CCopasiParameterGroup &amp;pParamGroup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::sbmlId2CopasiCN </td>
          <td>(</td>
          <td class="paramtype">ASTNode *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_copasi_parameter_group.html">CCopasiParameterGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>pParamGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the ids of named nodes in an ASTNode tree with the correspondingCopasi Common Names. </p>

</div>
</div>
<a class="anchor" id="ab92634da43399704fc2ac9e201e4707a"></a><!-- doxytag: member="SBMLImporter::separateProductArguments" ref="ab92634da43399704fc2ac9e201e4707a" args="(const CEvaluationNode *pRootNode, std::vector&lt; const CEvaluationNode * &gt; &amp;arguments)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::separateProductArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pRootNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function takes a node and tries to find out whether the tree under this node consists only of multiply operators and object nodes. The arguments to the multiply operators are returned. </p>

</div>
</div>
<a class="anchor" id="ac31001c46406e6c9900dfee120afb0a5"></a><!-- doxytag: member="SBMLImporter::setCorrectUsage" ref="ac31001c46406e6c9900dfee120afb0a5" args="(CReaction *pCopasiReaction, const CEvaluationNodeCall *pCallNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::setCorrectUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_reaction.html">CReaction</a> *&#160;</td>
          <td class="paramname"><em>pCopasiReaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node_call.html">CEvaluationNodeCall</a> *&#160;</td>
          <td class="paramname"><em>pCallNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5f23358553e48562b7385abe9785bf7"></a><!-- doxytag: member="SBMLImporter::setImportCOPASIMIRIAM" ref="ad5f23358553e48562b7385abe9785bf7" args="(bool import)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::setImportCOPASIMIRIAM </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>import</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the flag that determines whether COPASI MIRIAM annotation is imported if it is present. </p>

</div>
</div>
<a class="anchor" id="ab7c3f20a666286ea61e4854c8f86f3f2"></a><!-- doxytag: member="SBMLImporter::setImportHandler" ref="ab7c3f20a666286ea61e4854c8f86f3f2" args="(CProcessReport *pHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBMLImporter::setImportHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_process_report.html">CProcessReport</a> *&#160;</td>
          <td class="paramname"><em>pHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a50b1ef1543256b1b2e0ae69c7f1ff7c6"></a><!-- doxytag: member="SBMLImporter::setInitialValues" ref="a50b1ef1543256b1b2e0ae69c7f1ff7c6" args="(CModel *pModel, const std::map&lt; CCopasiObject *, SBase * &gt; &amp;copasi2sbmlmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SBMLImporter::setInitialValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_model.html">CModel</a> *&#160;</td>
          <td class="paramname"><em>pModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="class_c_copasi_object.html">CCopasiObject</a> *, SBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copasi2sbmlmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the initial values on compartments, metabolites and model values if those initial values have been set in the SBML model. Otherwise the routine checks if a rule or an initial assignment has been set for the entity. If the entity has not been set in any way, an error message is created. </p>

</div>
</div>
<a class="anchor" id="a9e1e81619841ec18ca458b1637e2601c"></a><!-- doxytag: member="SBMLImporter::variables2objects" ref="a9e1e81619841ec18ca458b1637e2601c" args="(const CEvaluationNode *pOrigNode, const std::map&lt; std::string, std::string &gt; &amp;replacementMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> * SBMLImporter::variables2objects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_evaluation_node.html">CEvaluationNode</a> *&#160;</td>
          <td class="paramname"><em>pOrigNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacementMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af3884484e51df06669ba5bc4fc77c07c"></a><!-- doxytag: member="SBMLImporter::functionDB" ref="af3884484e51df06669ba5bc4fc77c07c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_function_d_b.html">CFunctionDB</a>* <a class="el" href="class_s_b_m_l_importer.html#af3884484e51df06669ba5bc4fc77c07c">SBMLImporter::functionDB</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a48bbb0ce9d9de02aa2d3d35147ca5b0f"></a><!-- doxytag: member="SBMLImporter::mAssignmentToSpeciesReferenceFound" ref="a48bbb0ce9d9de02aa2d3d35147ca5b0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a48bbb0ce9d9de02aa2d3d35147ca5b0f">SBMLImporter::mAssignmentToSpeciesReferenceFound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a057bc71f45b8f39fa15355f653163842"></a><!-- doxytag: member="SBMLImporter::mAvogadroCreated" ref="a057bc71f45b8f39fa15355f653163842" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a057bc71f45b8f39fa15355f653163842">SBMLImporter::mAvogadroCreated</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f40d8fba618f0e960f83849b93f357d"></a><!-- doxytag: member="SBMLImporter::mDelayFound" ref="a7f40d8fba618f0e960f83849b93f357d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a7f40d8fba618f0e960f83849b93f357d">SBMLImporter::mDelayFound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a39b4cb542ae7593d545434fdcc03573e"></a><!-- doxytag: member="SBMLImporter::mDelayNodeMap" ref="a39b4cb542ae7593d545434fdcc03573e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a39b4cb542ae7593d545434fdcc03573e">SBMLImporter::mDelayNodeMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a09fb60445d24cc1bd582e23869cfaee1"></a><!-- doxytag: member="SBMLImporter::mDivisionByCompartmentReactions" ref="a09fb60445d24cc1bd582e23869cfaee1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a09fb60445d24cc1bd582e23869cfaee1">SBMLImporter::mDivisionByCompartmentReactions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8eb1281de56a2232df925ba8de420412"></a><!-- doxytag: member="SBMLImporter::mExplicitelyTimeDependentFunctionDefinitions" ref="a8eb1281de56a2232df925ba8de420412" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a8eb1281de56a2232df925ba8de420412">SBMLImporter::mExplicitelyTimeDependentFunctionDefinitions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3d029d1a08dc8f22dba1eedc57b036e3"></a><!-- doxytag: member="SBMLImporter::mFastReactions" ref="a3d029d1a08dc8f22dba1eedc57b036e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a3d029d1a08dc8f22dba1eedc57b036e3">SBMLImporter::mFastReactions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8dbcde81bbd9c319d5e2500756c15ce4"></a><!-- doxytag: member="SBMLImporter::mFunctionNameMapping" ref="a8dbcde81bbd9c319d5e2500756c15ce4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a8dbcde81bbd9c319d5e2500756c15ce4">SBMLImporter::mFunctionNameMapping</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ec30028cc55992d6a25bb5ec4479361"></a><!-- doxytag: member="SBMLImporter::mhImportStep" ref="a9ec30028cc55992d6a25bb5ec4479361" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned C_INT32 <a class="el" href="class_s_b_m_l_importer.html#a9ec30028cc55992d6a25bb5ec4479361">SBMLImporter::mhImportStep</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a43ba9124187b089d5fb4122e8d9d7be2"></a><!-- doxytag: member="SBMLImporter::mIgnoredParameterUnits" ref="a43ba9124187b089d5fb4122e8d9d7be2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a43ba9124187b089d5fb4122e8d9d7be2">SBMLImporter::mIgnoredParameterUnits</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf0033487d629c27d4f133ac8ded9c02"></a><!-- doxytag: member="SBMLImporter::mIgnoredSBMLMessages" ref="acf0033487d629c27d4f133ac8ded9c02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;unsigned int&gt; <a class="el" href="class_s_b_m_l_importer.html#acf0033487d629c27d4f133ac8ded9c02">SBMLImporter::mIgnoredSBMLMessages</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4588fba30554cfe8dbe394a6ad6685eb"></a><!-- doxytag: member="SBMLImporter::mImportCOPASIMIRIAM" ref="a4588fba30554cfe8dbe394a6ad6685eb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a4588fba30554cfe8dbe394a6ad6685eb">SBMLImporter::mImportCOPASIMIRIAM</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e83963c608041887b5d5e292be033c9"></a><!-- doxytag: member="SBMLImporter::mImportStep" ref="a9e83963c608041887b5d5e292be033c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned C_INT32 <a class="el" href="class_s_b_m_l_importer.html#a9e83963c608041887b5d5e292be033c9">SBMLImporter::mImportStep</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af39d5f3762cee43875daadd002af6f0e"></a><!-- doxytag: member="SBMLImporter::mIncompleteModel" ref="af39d5f3762cee43875daadd002af6f0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#af39d5f3762cee43875daadd002af6f0e">SBMLImporter::mIncompleteModel</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa2ceec377ae743892d56b522adbce41e"></a><!-- doxytag: member="SBMLImporter::mLevel" ref="aa2ceec377ae743892d56b522adbce41e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_s_b_m_l_importer.html#aa2ceec377ae743892d56b522adbce41e">SBMLImporter::mLevel</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65cdc7be5200fff34240bcb2200fe558"></a><!-- doxytag: member="SBMLImporter::mOriginalLevel" ref="a65cdc7be5200fff34240bcb2200fe558" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_s_b_m_l_importer.html#a65cdc7be5200fff34240bcb2200fe558">SBMLImporter::mOriginalLevel</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc1b2ec95e8d7fa93910e094e948cb2f"></a><!-- doxytag: member="SBMLImporter::mpCopasiModel" ref="abc1b2ec95e8d7fa93910e094e948cb2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_model.html">CModel</a>* <a class="el" href="class_s_b_m_l_importer.html#abc1b2ec95e8d7fa93910e094e948cb2f">SBMLImporter::mpCopasiModel</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2aa8c57db3550fc84175ad38f1f3661e"></a><!-- doxytag: member="SBMLImporter::mpDataModel" ref="a2aa8c57db3550fc84175ad38f1f3661e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_copasi_data_model.html">CCopasiDataModel</a>* <a class="el" href="class_s_b_m_l_importer.html#a2aa8c57db3550fc84175ad38f1f3661e">SBMLImporter::mpDataModel</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a32b10e0dc03fc5bbf7b4842b0d314ff6"></a><!-- doxytag: member="SBMLImporter::mpImportHandler" ref="a32b10e0dc03fc5bbf7b4842b0d314ff6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_process_report.html">CProcessReport</a>* <a class="el" href="class_s_b_m_l_importer.html#a32b10e0dc03fc5bbf7b4842b0d314ff6">SBMLImporter::mpImportHandler</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a273943602d6059106e5d0ef3dd3e6e45"></a><!-- doxytag: member="SBMLImporter::mPotentialAvogadroNumbers" ref="a273943602d6059106e5d0ef3dd3e6e45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;const Parameter*&gt; <a class="el" href="class_s_b_m_l_importer.html#a273943602d6059106e5d0ef3dd3e6e45">SBMLImporter::mPotentialAvogadroNumbers</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8728f6d9cdf831a37754c20bb9353a04"></a><!-- doxytag: member="SBMLImporter::mReactionsWithReplacedLocalParameters" ref="a8728f6d9cdf831a37754c20bb9353a04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a8728f6d9cdf831a37754c20bb9353a04">SBMLImporter::mReactionsWithReplacedLocalParameters</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ff64c7fedb1863cac4572f246ca65f7"></a><!-- doxytag: member="SBMLImporter::mStoichiometricExpressionMap" ref="a8ff64c7fedb1863cac4572f246ca65f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;const ASTNode*, <a class="el" href="class_c_chem_eq_element.html">CChemEqElement</a>* &gt; <a class="el" href="class_s_b_m_l_importer.html#a8ff64c7fedb1863cac4572f246ca65f7">SBMLImporter::mStoichiometricExpressionMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d0a2880f878659d6a0fc2fe0cc15610"></a><!-- doxytag: member="SBMLImporter::mSubstanceOnlySpecies" ref="a5d0a2880f878659d6a0fc2fe0cc15610" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Species*, Compartment*&gt; <a class="el" href="class_s_b_m_l_importer.html#a5d0a2880f878659d6a0fc2fe0cc15610">SBMLImporter::mSubstanceOnlySpecies</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a76924558eafc00f4f3e01d19bd73577b"></a><!-- doxytag: member="SBMLImporter::mTotalSteps" ref="a76924558eafc00f4f3e01d19bd73577b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned C_INT32 <a class="el" href="class_s_b_m_l_importer.html#a76924558eafc00f4f3e01d19bd73577b">SBMLImporter::mTotalSteps</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8da36a9a8ae299a7ea5d4ac68382bb1e"></a><!-- doxytag: member="SBMLImporter::mUnitOnNumberFound" ref="a8da36a9a8ae299a7ea5d4ac68382bb1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a8da36a9a8ae299a7ea5d4ac68382bb1e">SBMLImporter::mUnitOnNumberFound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae215a7b25a8529b85a217e8bd0e006f0"></a><!-- doxytag: member="SBMLImporter::mUnsupportedAssignmentRuleFound" ref="ae215a7b25a8529b85a217e8bd0e006f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#ae215a7b25a8529b85a217e8bd0e006f0">SBMLImporter::mUnsupportedAssignmentRuleFound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9dd94e991869614f42fc48347372e15c"></a><!-- doxytag: member="SBMLImporter::mUnsupportedRateRuleFound" ref="a9dd94e991869614f42fc48347372e15c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a9dd94e991869614f42fc48347372e15c">SBMLImporter::mUnsupportedRateRuleFound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d1d70d874673527b508b3e8dcfed729"></a><!-- doxytag: member="SBMLImporter::mUnsupportedRuleFound" ref="a0d1d70d874673527b508b3e8dcfed729" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a0d1d70d874673527b508b3e8dcfed729">SBMLImporter::mUnsupportedRuleFound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a64e5323f84c8730e7c120e8e9a965d13"></a><!-- doxytag: member="SBMLImporter::mUsedFunctions" ref="a64e5323f84c8730e7c120e8e9a965d13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a64e5323f84c8730e7c120e8e9a965d13">SBMLImporter::mUsedFunctions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f78f336ef119556c847afdb8e86674d"></a><!-- doxytag: member="SBMLImporter::mUsedSBMLIds" ref="a8f78f336ef119556c847afdb8e86674d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a8f78f336ef119556c847afdb8e86674d">SBMLImporter::mUsedSBMLIds</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a19097f961c78f8d0383999d957b1b32f"></a><!-- doxytag: member="SBMLImporter::mUsedSBMLIdsPopulated" ref="a19097f961c78f8d0383999d957b1b32f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_b_m_l_importer.html#a19097f961c78f8d0383999d957b1b32f">SBMLImporter::mUsedSBMLIdsPopulated</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d741ae7e3799fdc819e689a3dafad86"></a><!-- doxytag: member="SBMLImporter::mVersion" ref="a7d741ae7e3799fdc819e689a3dafad86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_s_b_m_l_importer.html#a7d741ae7e3799fdc819e689a3dafad86">SBMLImporter::mVersion</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2bc4f5ddb47a8d776e4980be39af3d35"></a><!-- doxytag: member="SBMLImporter::sbmlIdMap" ref="a2bc4f5ddb47a8d776e4980be39af3d35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="class_c_evaluation_tree.html">CEvaluationTree</a>*, std::string&gt; <a class="el" href="class_s_b_m_l_importer.html#a2bc4f5ddb47a8d776e4980be39af3d35">SBMLImporter::sbmlIdMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2919a190a2cb8b7b5eb501af5c6f393e"></a><!-- doxytag: member="SBMLImporter::speciesMap" ref="a2919a190a2cb8b7b5eb501af5c6f393e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_c_metab.html">CMetab</a>*&gt; <a class="el" href="class_s_b_m_l_importer.html#a2919a190a2cb8b7b5eb501af5c6f393e">SBMLImporter::speciesMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>copasi/sbml/<a class="el" href="_s_b_m_l_importer_8h_source.html">SBMLImporter.h</a></li>
<li>copasi/sbml/<a class="el" href="_s_b_m_l_importer_8cpp.html">SBMLImporter.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 15 2011 20:03:39 for copasi API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>

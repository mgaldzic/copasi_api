<!-- Creator     : groff version 1.20.1 -->
<!-- CreationDate: Fri Jan 29 17:23:22 2010 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style type="text/css">
/*<![CDATA[*/
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
/*]]>*/
</style>
<title>Raptor RDF Parser Toolkit - Raptor API</title>
</head>
<body bgcolor="#ffffff" text="#000085">
<h1>Raptor RDF Parser Toolkit - Raptor API</h1>
<hr />
<h2>NAME <a name="NAME" id="NAME"></a></h2>
<p style="margin-left:11%; margin-top: 1em">libraptor &minus; Raptor RDF parser and serializer library</p>
<h2>SYNOPSIS <a name="SYNOPSIS" id="SYNOPSIS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>#include &lt;raptor.h&gt;</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_init();<br />
raptor_parser *</b><i>p</i><b>=raptor_new_parser("rdfxml");<br />
raptor_set_statement_handler(</b><i>p</i><b>,</b><i>NULL</i><b>,</b><i>print_triples</i><b>);<br />
raptor_uri *</b><i>file_uri</i><b>=raptor_new_uri("http://example.org/");<br />
raptor_parse_file(</b><i>p</i><b>,</b><i>file_uri</i><b>,</b><i>base_uri</i><b>);<br />
raptor_parse_uri(</b><i>p</i><b>,</b><i>uri</i><b>,</b><i>NULL</i><b>);<br />
raptor_free_parser(</b><i>p</i><b>);<br />
raptor_free_uri(</b><i>file_uri</i><b>);<br />
raptor_finish();</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>cc file.c -lraptor</b></p>
<h2>DESCRIPTION <a name="DESCRIPTION" id="DESCRIPTION"></a></h2>
<p style="margin-left:11%; margin-top: 1em">The <i>Raptor</i> library provides a high-level interface to a set of parsers and serializers that generate Resource Description Framework (RDF) triples by parsing syntaxes or serialize the triples into syntaxes.</p>
<p style="margin-left:11%; margin-top: 1em">The supported parsing syntaxes include RDF/XML, N-Triples, Turtle, TRiG, RSS tag soup (including all RSS and Atoms), GRDDL, RDFa and the serializing syntaxes include RDF/XML (3 varieties), N-Triples, Turtle, RSS 1.0, Atom 1.0, GraphViz DOT and RDF/JSON. The RDF/XML parser can use either <i>expat</i> or <i>libxml</i> XML parsers for providing the SAX event stream. The library functions are arranged in an object-oriented style with constructors, destructors and method calls. The statements and error messages are delivered via callback functions.</p>
<p style="margin-left:11%; margin-top: 1em">Raptor contains a URI-reference parsing and resolving (not retrieval) class (raptor_uri) sufficient for dealing with URI-references inside RDF. This functionality is modular and can be transparently replaced with another existing and compatible URI implementation.</p>
<p style="margin-left:11%; margin-top: 1em">It also provides a URI-retrieval class (raptor_www) for wrapping existing library such as libcurl, libxml2 or BSD libfetch that provides full or partial retrieval of data from URIs and an I/O stream abstraction (raptor_iostream) for supportin serializing to a variety of outputs.</p>
<p style="margin-left:11%; margin-top: 1em">Raptor uses Unicode strings for RDF literals and URIs and preserves them throughout the library. It uses the UTF-8 encoding of Unicode at the API for passing in or returning Unicode strings. It is intended that the preservation of Unicode for URIs will support Internationalized Resource Identifiers (IRIs) which are still under development and standardisation.</p>
<h2>LIBRARY INITIALISATION AND CLEANUP <a name="LIBRARY_INITIALISATION_AND_CLEANUP"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_init()<br />
raptor_finish()</b></p>
<p style="margin-left:22%;">Initialise and cleanup the library. These must be called before any raptor class such as raptor_parser, raptor_uri is created or used. Note: as of 1.4.19 these are wrappers around a static instance of the new <b>raptor_world</b> class. In Raptor 2.0 this initialisation and cleanup method will be removed.</p>
<p style="margin-left:11%;"><b>void raptor_set_libxslt_security_preferences(void<br />
*</b><i>security_preferences</i><b>)</b></p>
<p style="margin-left:22%;">Set libxslt security preferences object.</p>
<p style="margin-left:11%;"><b>void raptor_set_libxml_flags(int</b> <i>flags</i><b>)</b></p>
<p style="margin-left:22%;">Set libxml flags from the choices: <b>RAPTOR_LIBXML_FLAGS_GENERIC_ERROR_SAVE</b>: save/restore the libxml generic error handler when parsing and <b>RAPTOR_LIBXML_FLAGS_STRUCTURED_ERROR_SAVE: save/restore the libxml structured error handler when parsing.</b></p>
<h2>PARSER CLASS <a name="PARSER_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This class provides the functionality of turning syntaxes into RDF triples - RDF parsing.</p>
<h2>PARSER CONSTRUCTORS <a name="PARSER_CONSTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_parser* raptor_new_parser(name)</b></p>
<p style="margin-left:22%;">Create a new raptor parser object for the parser with name <i>name</i> currently either "rdfxml", "turtle" or "rss-tag-soup" for the RSS Tag Soup parser.</p>
<p style="margin-left:11%;"><b>raptor_parser* raptor_new_parser_for_content(raptor_uri *</b><i>uri</i><b>, const<br />
char *</b><i>mime_type</i><b>, const unsigned char *</b><i>buffer</i><b>, size_t</b> <i>len</i><b>, const<br />
unsigned char *</b><i>identifier</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor parser object for a syntax identified by URI <i>uri</i>, MIME type <i>mime_type</i>, some initial content <i>buffer</i> of size <i>len</i> or content with identifier <i>identifier</i>. See the raptor_guess_parser_name description for further details.</p>
<h2>PARSER DESTRUCTOR <a name="PARSER_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_parser(raptor_parser *</b><i>parser</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a Raptor parser object.</p>
<h2>PARSER MESSAGE CALLBACK METHODS <a name="PARSER_MESSAGE_CALLBACK_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">Several methods can be registered for the parser that return a variable-argument message in the style of printf(3). These also return a <i>raptor_locator</i> that can contain URI, file, line, column and byte counts of where the message is about. This structure can be used with the raptor_format_locator, raptor_print_locator functions below or the structures fields directly, which are defined in raptor.h <b><br />
void raptor_set_fatal_error_handler(raptor_parser*</b> <i>parser, void<br />
*user_data, raptor_message_handler handler)</i></p>
<p style="margin-left:22%;">Set the parser fatal error handler callback.</p>
<p style="margin-left:11%;"><b>void raptor_set_error_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>,<br />
raptor_message_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the parser non-fatal error handler callback.</p>
<p style="margin-left:11%;"><b>void raptor_set_warning_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>,<br />
raptor_message_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the parser warning message handler callback.</p>
<p style="margin-left:11%;"><b>raptor_set_namespace_handler(raptor_parser*</b> <i>parser</i><b>, void*</b> <i>user_data</i><b>,<br />
raptor_namespace_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the namespace declaration handler callback.</p>
<h2>PARSER STATEMENT CALLBACK METHOD <a name="PARSER_STATEMENT_CALLBACK_METHOD"></a></h2>
<p style="margin-left:11%; margin-top: 1em">The parser allows the registration of a callback function to return the statements to the application. <b><br />
void raptor_set_statement_handler(raptor_parser*</b> <i>parser</i><b>, void<br />
*</b><i>user_data</i><b>, raptor_statement_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the statement callback function for the parser. The <i>raptor_statement</i> structure is defined in raptor.h and includes fields for the subject, predicate, object of the statements along with their types and for literals, language and datatype.</p>
<h2>PARSER PARSING METHODS <a name="PARSER_PARSING_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">These methods perform the entire parsing in one method. Statements warnings, errors and fatal errors are delivered via the registered statement, error etc. handler functions.</p>
<p style="margin-left:11%; margin-top: 1em">In both of these methods, the base URI is required for the RDF/XML parser (name "rdfxml") and Turtle parser (name "turtle"). The N-Triples parser (name "ntriples") or RSS Tag Soup parser (name "rss-tag-soup") do not use this. <b><br />
int raptor_parse_file(raptor_parser*</b> <i>parser</i><b>, raptor_uri *</b><i>uri</i><b>,<br />
raptor_uri *</b><i>base_uri</i><b>)</b></p>
<p style="margin-left:22%;">Parse the given filename (a URI like file:filename) according to the optional base URI <i>base_uri</i>. If <i>uri</i> is NULL, read from standard input and <i>base_uri</i> is then required.</p>
<p style="margin-left:11%;"><b>int raptor_parse_file_stream(raptor_parser*</b> <i>parser</i><b>, FILE*</b> <i>stream</i><b>, const<br />
char*</b> <i>filename</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
<p style="margin-left:22%;">Parse the given C FILE* stream according to the base URI <i>base_uri</i> (required). <i>filename</i> is optional and if given, is used for error messages via the raptor_locator structure.</p>
<p style="margin-left:11%;"><b>int raptor_parse_uri(raptor_parser*</b> <i>parser</i><b>, raptor_uri*</b> <i>uri</i><b>,<br />
raptor_uri *</b><i>base_uri</i><b>)</b></p>
<p style="margin-left:22%;">Parse the URI according to the base URI <i>base_uri</i>, or NULL if not needed. If no base URI is given, the <i>uri</i> is used. This method depends on the raptor_www subsystem (see <b>WWW Class</b> section below) and an existing underlying URI retrieval implementation such as libcurl, libxml or BSD libfetch to retrieve the content.</p>
<h2>PARSER CHUNKED PARSING METHODS <a name="PARSER_CHUNKED_PARSING_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">These methods perform the parsing in parts by working on multiple chunks of memory passed by the application. Statements warnings, errors and fatal errors are delivered via the registered statement, error etc. handler functions. <b><br />
int raptor_start_parse(raptor_parser*</b> <i>parser</i><b>, const char *</b><i>uri</i><b>)</b></p>
<p style="margin-left:22%;">Start a parse of chunked content with the base URI <i>uri</i> or NULL if not needed. The base URI is required for the RDF/XML parser (name "rdfxml") and Turtle parser (name "turtle"). The N-Triples parser (name "ntriples") or RSS Tag Soup parser (name "rss-tag-soup") do not use this.</p>
<p style="margin-left:11%;"><b>int raptor_parse_chunk(raptor_parser*</b> <i>parser</i><b>, const unsigned char<br />
*buffer, size_t</b> <i>len</i><b>, int</b> <i>is_end</i><b>)</b></p>
<p style="margin-left:22%;">Parse the memory at <i>buffer</i> of size <i>len</i> returning statements via the statement handler callback. If <i>is_end</i> is non-zero, it indicates the end of the parsing stream. This method can only be called after <b>raptor_start_parse()</b>.</p>
<h2>PARSER UTILITY METHODS <a name="PARSER_UTILITY_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>const char* raptor_get_mime_type(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
<p style="margin-left:22%;">Return the MIME type for the parser.</p>
<p style="margin-left:11%;"><b>void raptor_set_parser_strict(raptor_parser *</b><i>parser</i><b>, int</b> <i>is_strict</i><b>)</b></p>
<p style="margin-left:22%;">Set the parser to strict (<i>is_strict</i> not zero) or lax (default) mode. The detail of the strictness can be controlled by raptor_set_feature.</p>
<p style="margin-left:11%;"><b>int raptor_set_feature(raptor_parser *</b><i>parser</i><b>, raptor_feature</b> <i>feature</i><b>,<br />
int</b> <i>value</i><b>)</b></p>
<p style="margin-left:22%;">Set a parser feature <i>feature</i> to a particular <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined parser features are: <i><br />
Feature Values</i> <b><br />
RAPTOR_FEATURE_ALLOW_BAGID</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_ASSUME_IS_RDF</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_CHECK_RDF_ID</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_HTML_LINK</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_HTML_TAG_SOUP</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_MICROFORMATS</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_NON_NFC_FATAL</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_NORMALIZE_LANGUAGE</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_NO_NET</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_RELATIVE_URIS</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_SCANNING</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_WARN_OTHER_PARSETYPES</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_WWW_TIMEOUT</b> Integer <b><br />
RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL</b> String <b><br />
RAPTOR_FEATURE_WWW_HTTP_USER_AGENT</b> String</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>allow_bagid</i> feature is true (default true) then the RDF/XML parser will support the rdf:bagID attribute that was removed from the RDF/XML language when it was revised. This support may be removed in future.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>allow_non_ns_attributes</i> feature is true (default true), then the RDF/XML parser will allow non-XML namespaced attributes to be accepted as well as rdf: namespaced ones. For example, &rsquo;about&rsquo; and &rsquo;ID&rsquo; will be interpreted as if they were rdf:about and rdf:ID respectively.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>allow_other_parsetypes</i> feature is true (default true) then the RDF/XML parser will allow unknown parsetypes to be present and will pass them on to the user. Unimplemented at present.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>allow_rdf_type_rdf_list</i> feature is true (default false) then the RDF/XML parser will generate the idList rdf:type rdf:List triple in the handling of rdf:parseType="Collection". This triple was removed during the revising of RDF/XML after collections were initially added.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>assume_is_rdf</i> feature is true (default false), then the RDF/XML parser will assume the content is RDF/XML, not require that rdf:RDF root element, and immediately interpret the content as RDF/XML.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>check_rdf_id</i> feature is true (default true) then rdf:ID values will be checked for duplicates and cause an error if found.</p>
<p style="margin-left:11%; margin-top: 1em">if the <i>html_link</i> feature is true (default true), look for head &amp;lt;link&amp;gt; to type rdf/xml for GRDDL parser</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>html_tag_soup</i> feature is true (default true), use a lax HTML parser if an XML parser fails when read HTML for GRDDL parser.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>microformats</i> feature is true (default true), look for microformats for GRDDL parser.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>non_nfc_fatal</i> feature is true (default false) then illegal Unicode Normal Form C in literals will give a fatal error, otherwise it gives a warning.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>normalize_language</i> feature is true (default true) then XML language values such as from xml:lang will be normalized to lowercase.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>no_net</i> feature is true (default false) then network requests are denied.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>scanning</i> feature is true (default false), then the RDF/XML parser will look for embedded rdf:RDF elements inside the XML content, and not require that the XML start with an rdf:RDF root element.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>www_timeout</i> feature is set to an integer larger than 0, it sets the timeout in seconds for internal WWW URI requests for the GRDDL parser.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>www_http_cache_control</i> feature is set to a string value (default none), it is sent as the value of the HTTP Cache-Control: header in requests.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>www_http_user_agent</i> feature is set to a string value, it is sent as the value of the HTTP User-Agent: header in requests. <b><br />
raptor_parser_set_feature_string(raptor_parser *</b><i>parser</i><b>, raptor_feature</b> <i><br />
feature</i><b>, const unsigned char *</b><i>value</i><b>)</b></p>
<p style="margin-left:22%;">Set a parser feature <i>feature</i> to a particular string <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined parser features are given in <b>raptor_set_feature</b> and at present only take integer values. If an integer value feature is set with this function, <i>value</i> is interpreted as an integer and then that value is used.</p>
<p style="margin-left:11%;"><b>int raptor_get_feature(raptor_parser*</b> <i>parser</i><b>, raptor_feature</b> <i>feature</i><b>)</b></p>
<p style="margin-left:22%;">Get parser feature integer values. The allowed <i>feature</i> values and types are given under <b>raptor_features_enumerate</b>.</p>
<p style="margin-left:11%;"><b>const unsigned char* raptor_parser_get_feature_string(raptor_parser<br />
*</b><i>parser</i><b>, raptor_feature</b> <i>feature</i><b>)</b></p>
<p style="margin-left:22%;">Get parser feature string values. The allowed <i>feature</i> values and types are given under <b>raptor_features_enumerate</b>.</p>
<p style="margin-left:11%;"><b>unsigned int raptor_get_feature_count(void)</b></p>
<p style="margin-left:22%;">Get the count of features defined. Prefered to the compile time-only symbol <b>RAPTOR_FEATURE_LAST</b> which returns the maximum value, not the count. Added raptor_get_need_base_uri</p>
<p style="margin-left:11%;"><b>int raptor_feature_value_type(const raptor_feature feature)</b></p>
<p style="margin-left:22%;">Get a raptor feature value tyype - integer or string.</p>
<p style="margin-left:11%;"><b>raptor_locator* raptor_get_locator(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
<p style="margin-left:22%;">Return the current raptor_locator object for the parser. This is a public structure defined in raptor.h that can be used directly, or formatted via raptor_print_locator.</p>
<p style="margin-left:11%;"><b>void raptor_get_name(raptor_parser *</b><i>parser</i><b>)</b></p>
<p style="margin-left:22%;">Return the string short name for the parser.</p>
<p style="margin-left:11%;"><b>void raptor_get_label(raptor_parser *</b><i>parser</i><b>)</b></p>
<p style="margin-left:22%;">Return a string label for the parser.</p>
<p style="margin-left:11%;"><b>void raptor_set_default_generate_id_parameters(raptor_parser*</b> <i><br />
rdf_parser</i><b>, char *</b><i>prefix</i><b>, int</b> <i>base</i><b>)</b></p>
<p style="margin-left:22%;">Control the default method for generation of IDs for blank nodes and bags. The method uses a short string <i>prefix</i> and an integer <i>base</i> to generate the identifier which is not guaranteed to be a strict concatenation. If <i>prefix</i> is NULL, the default is used. If base is less than 1, it is initialised to 1.</p>
<p style="margin-left:11%;"><b>void raptor_set_generate_id_handler(raptor_parser*</b> <i>parser</i><b>, void<br />
*</b><i>user_data</i><b>, raptor_generate_id_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Allow full customisation of the generated IDs by setting a callback <i>handler</i> and associated <i>user_data</i> that is called whenever a blank node or bag identifier is required. The memory returned is deallocated inside raptor. Some systems require this to be allocated inside the same library, in which case the <b>raptor_alloc_memory</b> function may be useful.</p>
<p style="margin-left:11%;"><b>void raptor_parser_set_uri_filter(raptor_parser*</b> <i>parser</i><b>,<br />
raptor_uri_filter_func</b> <i>filter</i><b>, void*</b> <i>user_data</i><b>)</b></p>
<p style="margin-left:22%;">Set the URI filter function <i>filter</i> for URIs retrieved during parsing by the the raptor_parser.</p>
<p style="margin-left:11%;"><b>int raptor_get_need_base_uri(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
<p style="margin-left:22%;">Get a boolean whether this parser needs a base URI to start parsing.</p>
<p style="margin-left:11%;"><b>unsigned char* raptor_parser_generate_id(raptor_parser*</b> <i>rdf_parser</i><b>,<br />
raptor_genid_type</b> <i>type</i><b>)</b></p>
<p style="margin-left:22%;">Generate an ID for a parser of type <i>type</i>, either <b>RAPTOR_GENID_TYPE_BNODEID</b> or <b>RAPTOR_GENID_TYPE_BAGID</b>. This uses any configuration set by <b>raptor_set_generate_id_handler</b>.</p>
<p style="margin-left:11%;"><b>void raptor_set_graph_handler(raptor_parser*</b> <i>parser</i><b>, void*</b> <i>user_data</i><b>,<br />
raptor_graph_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the graph handler callback.</p>
<p style="margin-left:11%;"><b>raptor_world* raptor_parser_get_world(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
<p style="margin-left:22%;">Get the world object for the given <i>rdf_parser</i>.</p>
<h2>PARSER UTILITY FUNCTIONS <a name="PARSER_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_parsers_enumerate(const unsigned int</b> <i>counter</i><b>, const char<br />
**</b><i>name</i><b>, const char **</b><i>label</i><b>)</b></p>
<p style="margin-left:22%;">Return the parser name/label for a parser with a given integer counter, returning non-zero if no such parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
<p style="margin-left:11%;"><b>int raptor_syntaxes_enumerate(const unsigned int</b> <i>counter</i><b>, const char<br />
**name, const char **</b><i>label</i><b>, const char **</b><i>mime_type</i><b>, const unsigned char<br />
**</b><i>uri-string</i><b>)</b></p>
<p style="margin-left:22%;">Return the name, label, mime type or URI string (all optional) for a parser syntax with a given integer counter, returning non-zero if no such syntax parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
<p style="margin-left:11%;"><b>int raptor_features_enumerate(const raptor_feature</b> <i>feature</i><b>, const char<br />
**</b><i>name</i><b>, raptor_uri **</b><i>uri</i><b>, const char **</b><i>label</i><b>)</b></p>
<p style="margin-left:22%;">Return the name, URI, string label (all optional) for a parser <i>feature</i>, returning non-zero if no such feature exists.</p>
<p style="margin-left:11%; margin-top: 1em">Raptor features have URIs that are constructed from the URI <i>http://feature.librdf.org/raptor-</i> and the <i>name</i> so for example feature <i>scanForRDF</i> has URI <i>http://feature.librdf.org/raptor-scanForRDF</i> <b><br />
int raptor_syntax_name_check(const char *</b><i>name</i><b>)</b></p>
<p style="margin-left:22%;">Check <i>name</i> is a known syntax name.</p>
<p style="margin-left:11%;"><b>const char* raptor_guess_parser_name(raptor_uri *</b><i>uri</i><b>, const char<br />
*</b><i>mime_type</i><b>, const unsigned char *</b><i>buffer</i><b>, size_t</b> <i>len</i><b>, const unsigned<br />
char *</b><i>identifier</i><b>)</b></p>
<p style="margin-left:22%;">Guess a parser name for a syntax identified by URI <i>uri</i>, MIME type <i>mime_type</i>, some initial content <i>buffer</i> of size <i>len</i> or with content identifier <i>identifier</i>. All of these parameters are optional and only used if not NULL. The parser is chosen by scoring the hints that are given.</p>
<p style="margin-left:11%;"><b>raptor_feature raptor_feature_from_uri(raptor_uri *</b><i>uri</i><b>)</b></p>
<p style="margin-left:22%;">Turn a URI <i>uri</i> into a raptor feature identifier, or &lt;0 if the feature is unknown. The URIs are described below raptor_set_feature.</p>
<h2>STATEMENT UTILITY FUNCTIONS <a name="STATEMENT_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_statement_compare(const raptor_statement *</b><i>s1</i><b>, const<br />
raptor_statement *</b><i>s2</i><b>)</b></p>
<p style="margin-left:22%;">Compare two statements and return an ordering between them.</p>
<p style="margin-left:11%;"><b>void raptor_print_statement(const raptor_statement* const</b> <i>statement</i><b>,<br />
FILE *</b><i>stream</i><b>)</b></p>
<p style="margin-left:22%;">Print a raptor statement object in a simple format for debugging only. The format of this output is not guaranteed to remain the same between releases.</p>
<p style="margin-left:11%;"><b>void raptor_print_statement_as_ntriples(const raptor_statement*</b> <i><br />
statement</i><b>, FILE *</b><i>stream</i><b>)</b></p>
<p style="margin-left:22%;">Print a raptor statement object in N-Triples format, using all the escapes as defined in <a href="http://www.w3.org/TR/rdf-testcases/#ntriples">http://www.w3.org/TR/rdf-testcases/#ntriples</a></p>
<p style="margin-left:11%;"><b>raptor_statement_part_as_counted_string(const void *</b><i>term</i><b>,<br />
raptor_identifier_type</b> <i>type</i><b>, raptor_uri*</b> <i>literal_datatype</i><b>, const<br />
unsigned char *</b><i>literal_language</i><b>, size_t*</b> <i>len_p</i><b>)<br />
char* raptor_statement_part_as_string(const void *</b><i>term</i><b>,<br />
raptor_identifier_type</b> <i>type</i><b>, raptor_uri*</b> <i>literal_datatype</i><b>, const<br />
unsigned char *</b><i>literal_language</i><b>)</b></p>
<p style="margin-left:22%;">Turns part of raptor statement into N-Triples format, using all the escapes as defined in <a href="http://www.w3.org/TR/rdf-testcases/#ntriples">http://www.w3.org/TR/rdf-testcases/#ntriples</a> The part (subject, predicate, object) of the raptor_statement is passed in as <i>term</i>, the part type (subject_type, predicate_type, object_type) is passed in as <i>type</i>. When the part is a literal, the <i>literal_datatype</i> and <i>literal_language</i> fields are set, otherwise NULL (usually object_datatype, object_literal_language).</p>
<p style="margin-left:22%; margin-top: 1em">If <b>raptor_statement_part_as_counted_string</b> is used, the length of the returned string is stored in *<i>len_p</i> if not NULL.</p>
<h2>LOCATOR UTILITY FUNCTIONS <a name="LOCATOR_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_format_locator(char *</b><i>buffer</i><b>, size_t</b> <i>length</i><b>, raptor_locator*</b> <i><br />
locator</i><b>)</b></p>
<p style="margin-left:22%;">This method takes a <i>raptor_locator</i> object as passed to an error, warning or other handler callback and formats it into the <i>buffer</i> of size <i>length</i> bytes. If <i>buffer</i> is NULL or <i>length</i> is insufficient for the size of the formatted locator, returns the number of additional bytes required in the buffer to write the locator.</p>
<p style="margin-left:22%; margin-top: 1em">In particular, if this form is used:<br />
length=raptor_format_locator(NULL, 0, locator) it will return in <i>length</i> the size of a buffer that can be allocated for <i>locator</i> and a second call will perform the formatting:<br />
raptor_format_locator(buffer, length, locator)</p>
<p style="margin-left:11%;"><b>void raptor_print_locator(FILE *</b><i>stream</i><b>, raptor_locator*</b> <i>locator</i><b>)</b></p>
<p style="margin-left:22%;">This method takes a <i>raptor_locator</i> object as passed to an error, warning or other handler callback, formats and prints it to the given stdio <i>stream</i>.</p>
<p style="margin-left:11%;"><b>int raptor_locator_line(raptor_locator *locator)</b></p>
<p style="margin-left:22%;">Returns the line number in a locator structure or &lt;0 if not available.</p>
<p style="margin-left:11%;"><b>int raptor_locator_column(raptor_locator *locator)</b></p>
<p style="margin-left:22%;">Returns the column number in a locator structure or &lt;0 if not available.</p>
<p style="margin-left:11%;"><b>int raptor_locator_byte(raptor_locator *locator)</b></p>
<p style="margin-left:22%;">Returns the byte offset in a locator structure or &lt;0 if not available.</p>
<p style="margin-left:11%;"><b>const char * raptor_locator_file(raptor_locator *locator)</b></p>
<p style="margin-left:22%;">Returns the filename in a locator structure or NULL if not available. Note the returned pointer is to a shared string that must be copied if needed.</p>
<p style="margin-left:11%;"><b>const char * raptor_locator_uri(raptor_locator *locator)</b></p>
<p style="margin-left:22%;">Returns the URI string in a locator structure or NULL if not available. Note this does not return a raptor_uri* pointer and the returned pointer is to a shared string that must be copied if needed.</p>
<h2>N-TRIPLES UTILITY FUNCTIONS <a name="N-TRIPLES_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_print_ntriples_string(FILE*</b> <i>stream</i><b>, const char*</b> <i>string</i><b>,<br />
const char</b> <i>delim</i><b>)</b></p>
<p style="margin-left:22%;">This is a standalone function that prints the given string according to N-Triples escaping rules, expecting to be terminated by delimiter <i>delim</i> which is usually either &rsquo;, " or &lt;. If a null delimiter \0 is given, no extra escaping is performed.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_string_ntriples(raptor_iostream *</b><i>iostr</i><b>, const<br />
unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>, const char</b> <i>delim</i><b>)</b></p>
<p style="margin-left:22%;">Write an N-Triples encoded version of the given string to iostream <i>iostr</i>. If <i>delim</i> is given, that is the ending delimeter of the encoded string and it will be escaped in the output as appropriate. Useful delim values are &rsquo;, " and &gt;. If a null delimiter \0 is given, no extra escaping is performed.</p>
<p style="margin-left:11%;">int raptor_iostream_write_string_python(raptor_iostream *<i>iostr</i>, const<br />
unsigned char *<i>string</i>, size_t <i>len</i>, const char <i>delim</i>, int <i>flags</i>)</p>
<p style="margin-left:22%;">Write <i>string</i> encoded to an iostream according to the delimeter <i>delim</i> and encoding flags. The <i>flag</i> value selects formatting according to the appropriate Python-related languages such as N-Triples (0), Turtle (1), Turtle long quoted string (2), JSON (3).</p>
<p style="margin-left:11%;"><b>void raptor_iostream_write_statement_ntriples(raptor_iostream* iostr,<br />
const raptor_statement *statement)</b></p>
<p style="margin-left:22%;">Write an N-Triples encoded version of the raptor_statement <i>statement</i> to iostream <i>iostr</i>.</p>
<p style="margin-left:11%;"><b>void raptor_iostream_write_string_turtle(raptor_iostream*</b> <i>iostr</i><b>, const<br />
unsigned char*</b> <i>string</i><b>, size_t</b> <i>len</i><b>)</b></p>
<p style="margin-left:22%;">DEPRECATED in 1.4.17 - use raptor_iostream_write_string_python instead. Write an UTF-8 <i>string</i> of length <i>len</i> using the Turtle "longString" triple quoting format to the iostream <i>iostr</i>.</p>
<p style="margin-left:11%;"><b>const char* raptor_ntriples_term_as_string (raptor_ntriples_term_type</b> <i><br />
term</i><b>)</b></p>
<p style="margin-left:22%;">Deprecated, for internal use.</p>
<h2>XML UTILITY FUNCTIONS <a name="XML_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_xml_any_escape_string(const unsigned char*</b> <i>string</i><b>, size_t</b> <i><br />
len</i><b>, unsigned char*</b> <i>buffer</i><b>, size_t</b> <i>length</i><b>, char</b> <i>quote</i><b>, int</b> <i>xml_version</i><b>,<br />
raptor_simple_message_handler</b> <i>error_handler</i><b>, void*</b> <i>error_data</i><b>)<br />
int raptor_xml_escape_string(const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>,<br />
unsigned char *</b><i>buffer</i><b>, size_t</b> <i>length</i><b>, char</b> <i>quote</i><b>,<br />
raptor_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
<p style="margin-left:22%;">Apply the XML escaping rules to the string given in (string, len) into the <i>buffer</i> of size <i>length</i>. If <i>quote</i> is given, the escaped content is for an XML attribute and the appropriate quote character XML element content (CDATA). The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given. If buffer is NULL, returns the size of the buffer required to escape. Otherwise the return value is the number of bytes used or &lt;0 on failure.</p>
<p style="margin-left:22%; margin-top: 1em">When an <i>xml_version</i> argument is present and has a value 10 (XML 1.0) or 11 (XML 1.1) then that version is used. The default with no argument is to generate XML 1.0.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_xml_any_escaped_string(raptor_iostream*</b> <i><br />
iostr</i><b>, const unsigned char*</b> <i>string</i><b>, size_t</b> <i>len</i><b>, char</b> <i>quote</i><b>, int</b> <i><br />
xml_version</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void*</b> <i><br />
error_data</i><b>)<br />
int raptor_iostream_write_xml_escaped_string(raptor_iostream*</b> <i>iostr</i><b>,<br />
const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>, char</b> <i>quote</i><b>,<br />
raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
<p style="margin-left:22%;">Write an XML-escaped version of the string given in (string, len) to iostream <i>iostr</i>. If <i>quote</i> is given, the escaped content is for an XML attribute and the appropriate quote character is used, otherwise it is XML element content (CDATA). The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given.</p>
<p style="margin-left:22%; margin-top: 1em">When an <i>xml_version</i> argument is present and has a value 10 (XML 1.0) or 11 (XML 1.1) then that version is used. The default with no argument is to generate XML 1.0.</p>
<p style="margin-left:11%;"><b>int raptor_xml_name_check(const unsigned char *</b><i>string</i><b>, size_t</b> <i>length</i><b>,<br />
int xml_version)</b></p>
<p style="margin-left:22%;">Check that the given <i>string</i> of <i>length</i> bytes is a legal XML name according to XML 1.0 or XML 1.1. <i>xml_version</i> is set to 10 or 11 respectively. Returns non-zero if the name is legal.</p>
<h2>MEMORY UTILITY FUNCTIONS <a name="MEMORY_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_memory(void *</b><i>ptr</i><b>)</b></p>
<p style="margin-left:22%;">Free memory allocated inside raptor. Some systems require memory allocated in a library to be deallocated inside that library. This function can be used in that situation to free memory allocated by raptor, such as the result of the <i>_to_</i> methods that return allocated memory such as <b>raptor_uri_to_filename</b>, <b>raptor_uri_to_string</b>, <b>raptor_uri_to_relative_counted_uri_string</b>, <b>raptor_uri_to_relative_uri_string</b> or <b>raptor_new_namespace_parts_from_string</b>.</p>
<p style="margin-left:11%;"><b>void* raptor_alloc_memory(size_t</b> <i>size</i><b>)</b></p>
<p style="margin-left:22%;">Allocate memory inside the raptor library. Some systems require memory allocated in a library to be deallocated inside that library. This function can be used in that situation to allocate memory for raptor to free later, such as inside the handler function declared with <b>raptor_set_generate_id_handler</b> which returns new memory.</p>
<p style="margin-left:11%;"><b>void* raptor_calloc_memory(size_t</b> <i>nmemb</i><b>, size_t</b> <i>size</i><b>)</b></p>
<p style="margin-left:22%;">Allocate zeroed array of items inside raptor. Some systems require memory allocated in a library to be deallocated inside that library. This function can be used in that situation to clear an array of allocated memory for raptor to use, for freeing later, such as inside the handler function declared with <b>raptor_set_generate_id_handler</b> which returns new memory.</p>
<h2>UNICODE UTILITY FUNCTIONS <a name="UNICODE_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_unicode_char_to_utf8(raptor_unichar</b> <i>c</i><b>, unsigned char<br />
*</b><i>output</i><b>)</b></p>
<p style="margin-left:22%;">Turn a Unicode character into UTF8 bytes in <i>output</i> of size <i>c</i> bytes which must be of sufficient size. Returns the number of bytes encoded or &lt;0 on failure.</p>
<p style="margin-left:11%;"><b>int raptor_utf8_to_unicode_char(raptor_unichar *</b><i>output</i><b>, const unsigned<br />
char *</b><i>input</i><b>, int</b> <i>length</i><b>)</b></p>
<p style="margin-left:22%;">Decode a sequence UTF8 bytes in <i>input</i> of size <i>length</i> into a Unicode character in <i>output</i> returning the number of bytes used or &lt;0 on failure.</p>
<p style="margin-left:11%;"><b>int raptor_utf8_check(const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>gth)</b></p>
<p style="margin-left:22%;">Check that a given <i>string</i> is legal UTF-8 encoding and includes only legal Unicode characters U+0 to U+0x10ffff inclusive. Returns non-0 if the string is good.</p>
<p style="margin-left:11%;"><b>int raptor_unicode_is_xml11_namestartchar(raptor_unichar</b> <i>c</i><b>)<br />
int raptor_unicode_is_xml10_namestartchar(raptor_unichar</b> <i>c</i><b>)<br />
int raptor_unicode_is_xml11_namechar(raptor_unichar</b> <i>c</i><b>)<br />
int raptor_unicode_is_xml10_namechar(raptor-unichar</b> <i>c</i><b>)</b></p>
<p style="margin-left:22%;">Check that given Unicode characters are allowed as XML 1.0 or XML 1.0 names - either as the starting character (<b>*_namestartchar</b>) or continuing character (<b>*_namechar</b>). Returns non-0 if the character is allowed.</p>
<h2>ERROR UTILITY FUNCTIONS <a name="ERROR_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_error_handlers_init(raptor_error_handlers*</b> <i>error_handlers</i><b>)</b></p>
<p style="margin-left:22%;">Initialise an error_handlers structure after the log level handlers and user data pointers have been set.</p>
<h2>MISCELLANEOUS UTILITY FUNCTIONS <a name="MISCELLANEOUS_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>char* raptor_vsnprintf(const char *message, va_list arguments)</b></p>
<p style="margin-left:22%;">Compatibility wrapper around vsnprintf.</p>
<h2>STATIC VARIABLES <a name="STATIC_VARIABLES"></a></h2>
<p style="margin-left:11%; margin-top: 1em">There are several read-only static variables in the raptor library: <b><br />
const char * const raptor_short_copyright_string</b></p>
<p style="margin-left:22%;">Short copyright string, suitable for one line.</p>
<p style="margin-left:11%;"><b>const char * const raptor_copyright_string</b></p>
<p style="margin-left:22%;">Full copyright over several lines including URLs.</p>
<p style="margin-left:11%;"><b>const char * const raptor_version_string</b></p>
<p style="margin-left:22%;">The version as a string</p>
<p style="margin-left:11%;"><b>const unsigned int raptor_version_major</b></p>
<p style="margin-left:22%;">The major version number as an integer.</p>
<p style="margin-left:11%;"><b>const unsigned int raptor_version_minor</b></p>
<p style="margin-left:22%;">The minor version number as an integer.</p>
<p style="margin-left:11%;"><b>const unsigned int raptor_version_release</b></p>
<p style="margin-left:22%;">The release version number as an integer.</p>
<p style="margin-left:11%;"><b>const unsigned int raptor_version_decimal</b></p>
<p style="margin-left:22%;">The version number as a single decimal.</p>
<p style="margin-left:11%;"><b>const char * const raptor_license_string</b></p>
<p style="margin-left:22%;">The license string over several lines including URLs.</p>
<p style="margin-left:11%;"><b>const char * const raptor_home_url_string</b></p>
<p style="margin-left:22%;">The home page URL as a string.</p>
<h2>SERIALIZER CLASS <a name="SERIALIZER_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This class provides the functionality of turning RDF triples into syntaxes - RDF serializing.</p>
<h2>SERIALIZER CONSTRUCTOR <a name="SERIALIZER_CONSTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_serializer* raptor_new_serializer(const char *</b><i>name</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor serializer object for the serializer with name <i>name</i> currently either "rdfxml" or "ntriples". or "rss-1.0" for the RSS 1.0 serializer.</p>
<h2>SERIALIZER DESTRUCTOR <a name="SERIALIZER_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_serializer(raptor_serializer*</b> <i>rdf_serializer</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a Raptor serializer object.</p>
<h2>SERIALIZER SERIALIZING METHODS <a name="SERIALIZER_SERIALIZING_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_serialize_start(raptor_serializer*</b> <i>rdf_serializer</i><b>,<br />
raptor_uri *</b><i>uri</i><b>, raptor_iostream *</b><i>iostream</i><b>)</b></p>
<p style="margin-left:22%;">Start to serialize content using the given <i>iostream</i> to write to with optional base URI <i>uri</i>. The <i>iostream</i> becomes owned by the serializer object and is destroyed at the end of serializing when raptor_serialize_end() is called. Note that some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
<p style="margin-left:11%;"><b>int raptor_serialize_start_to_iostream(raptor_serializer*</b> <i><br />
rdf_serializer</i><b>, raptor_uri*</b> <i>uri</i><b>, raptor_iostream*</b> <i>iostream</i><b>)</b></p>
<p style="margin-left:22%;">Start to serialize content using the given <i>iostream</i> to write to with optional base URI <i>uri</i>. The <i>iostream</i> does NOT become owned by the serializer object and the caller may continue to write to it after serializing is finished. Note that some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
<p style="margin-left:11%;"><b>int raptor_serialize_start_to_filename(raptor_serializer*</b> <i><br />
rdf_serializer</i><b>, const char *</b><i>filename</i><b>)</b></p>
<p style="margin-left:22%;">Start to serialize content to the file <i>filename</i> which is opened for writing. The base URI is calculated from the file name.</p>
<p style="margin-left:11%;"><b>int raptor_serialize_start_to_string(raptor_serializer*</b> <i>rdf_serializer</i><b>,<br />
raptor_uri *</b><i>uri</i><b>, void **</b><i>string_p</i><b>, size_t *</b><i>length_p</i><b>)</b></p>
<p style="margin-left:22%;">Start to serialize content to a string. <i>string_p</i> must point to a void* pointer that will be used at the end of serializing to store the newly allocated string. <i>length_p</i> if not NULL, it will be used to store the length of the new string. The serializing is done with optional base URI <i>uri</i> however some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
<p style="margin-left:11%;"><b>int raptor_serialize_start_to_file_handle(raptor_serializer*</b> <i><br />
rdf_serializer</i><b>, raptor_uri *</b><i>uri</i><b>, FILE *</b><i>handle</i><b>)</b></p>
<p style="margin-left:22%;">Start to serialize content to the already open C Standard I/O FILE* <i>handle</i> with the base URI <i>uri</i>, which is optional and may be NULL. Note that some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
<p style="margin-left:11%;"><b>int raptor_serialize_statement(raptor_serializer*</b> <i>rdf_serializer</i><b>, const<br />
raptor_statement *</b><i>statement</i><b>)</b></p>
<p style="margin-left:22%;">Serialize a single <i>statement</i> using the serializer.</p>
<p style="margin-left:11%;"><b>int raptor_serialize_end(raptor_serializer*</b> <i>rdf_serializer</i><b>)</b></p>
<p style="margin-left:22%;">End the serializing. This may close and delete resources used in serializing. No more calls to raptor_serialize_statement or raptor_serialize_end may be done at this point.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_serializer_get_iostream(raptor_serializer<br />
*</b><i>serializer</i><b>)</b></p>
<p style="margin-left:22%;">Return a pointer to the raptor_iostream* used by the serializer.</p>
<p style="margin-left:11%;"><b>int raptor_serializer_set_namespace(raptor_serializer*</b> <i>serializer</i><b>,<br />
raptor_uri *</b><i>uri</i><b>, const char *</b><i>prefix</i><b>)</b></p>
<p style="margin-left:22%;">Set a suggested namespace URI/prefix mapping for use in serializing.</p>
<h2>SERIALIZER UTILITY METHODS <a name="SERIALIZER_UTILITY_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_serializer_set_error_handler(raptor_serializer*</b> <i>serializer</i><b>,<br />
void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the serializer non-fatal error handler callback.</p>
<p style="margin-left:11%;"><b>void raptor_serializer_set_warning_handler(raptor_serializer*</b> <i><br />
serializer</i><b>, void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the serializer warning message handler callback.</p>
<p style="margin-left:11%;"><b>raptor_locator* raptor_serializer_get_locator(raptor_serializer*</b> <i><br />
rdf_serializer</i><b>)</b></p>
<p style="margin-left:22%;">Return the current raptor_locator object for the serializer. This is a public structure defined in raptor.h that can be used directly, or formatted via raptor_print_locator.</p>
<p style="margin-left:11%;"><b>int raptor_serializer_set_feature(raptor_serializer *</b><i>serializer</i><b>,<br />
raptor_feature</b> <i>feature</i><b>, int</b> <i>value</i><b>)</b></p>
<p style="margin-left:22%;">Set a serializer feature <i>feature</i> to a particular <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined serializer features are: <i><br />
Feature Values</i> <b><br />
RAPTOR_FEATURE_RELATIVE_URIS</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_WRITE_BASE_URI</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_START_URI</b> URI String <b><br />
RAPTOR_FEATURE_BNODE_BORDER</b> String <b><br />
RAPTOR_FEATURE_BNODE_FILL</b> String <b><br />
RAPTOR_FEATURE_JSON_CALLBACK</b> String <b><br />
RAPTOR_FEATURE_JSON_EXTRA_DATA</b> String <b><br />
RAPTOR_FEATURE_LITERAL_BORDER</b> String <b><br />
RAPTOR_FEATURE_LITERAL_FILL</b> String <b><br />
RAPTOR_FEATURE_RESOURCE_BORDER</b> String <b><br />
RAPTOR_FEATURE_RESOURCE_FILL</b> String <b><br />
RAPTOR_FEATURE_RSS_TRIPLES</b> String <b><br />
RAPTOR_FEATURE_ATOM_ENTRY_URI</b> String</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>relative_uris</i> feature is true (default false) then when serialising, preference is given to generating relative URIs where possible.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>write_base_uri</i> feature is true (default true) then the atom, rdfxml, rdfxml-abbrev and turtle serializers will write an @base or xml:base directive in the output.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>start_uri</i> feature is set to a URI it is used by the serializer to start serializing from.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>bnode_border</i> feature is set, the DOT serializer uses it as the bnode border colour.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>bnode_fill</i> feature is set, the DOT serializer uses it as the bnode fill colour.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>json_callback</i> feature is set, the JSON serializers use it as the name of the callback to wrap the outer JSON object.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>json_extra_data</i> feature is set, the JSON serializers use it as extra data inside the outer JSON object.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>literal_border</i> feature is set, the DOT serializer uses it as the literal border colour.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>literal_fill</i> feature is set, the DOT serializer uses it as the literal fill colour.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>resource_border</i> feature is set, the DOT serializer uses it as the resource border colour.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>resource_fill</i> feature is set, the DOT serializer uses it as the resource fill colour.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>rss_triples</i> feature is set to the string "rdf-xml" for the rss-1.0 serializer or "atom-triples" for the atom serializer, it writes extra rdf triples into the serialized output.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>atom_entry_uri</i> feature is set to a URI string, it is used to trigger generation of an atom entry document for the atom serializer. <b><br />
int raptor_serializer_get_feature(raptor_serializer*</b> <i>serializer</i><b>,<br />
raptor_feature</b> <i>feature</i><b>)</b></p>
<p style="margin-left:22%;">Get serializer features, the allowed <i>feature</i> values are available</p>
<p style="margin-left:11%;"><b>raptor_world* raptor_serializer_get_world(raptor_serializer*</b> <i><br />
rdf_serializer</i><b>)</b></p>
<p style="margin-left:22%;">Get the world object for the given <i>rdf_serializer</i>.</p>
<h2>SERIALIZER UTILITY FUNCTIONS <a name="SERIALIZER_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_serializers_enumerate(const unsigned</b> <i>int counter</i><b>, const char<br />
**</b><i>name</i><b>, const char **</b><i>label</i><b>, const char **</b><i>mime_type</i><b>, const unsigned char<br />
**</b><i>uri_string</i><b>)</b></p>
<p style="margin-left:22%;">Return the serializer name/label for a serializer with a given integer counter, returning non-zero if no such parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
<p style="margin-left:11%;"><b>int raptor_serializer_syntax_name_check(const char *</b><i>name</i><b>)</b></p>
<p style="margin-left:22%;">Check <i>name</i> is a known serializer syntax name.</p>
<h2>URI CLASS <a name="URI_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">Raptor has a raptor_uri class must be used for manipulating and passing URI references. The default internal implementation uses char* strings for URIs, manipulating them and constructing them. This URI implementation can be replaced by any other that provides the equivalent functionality, using the <b>raptor_uri_set_handler</b> function.</p>
<h2>URI CONSTRUCTORS <a name="URI_CONSTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">There a several constructors for raptor_uri to build them from char* strings and existing raptor_uri objects. <b><br />
raptor_uri* raptor_new_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor URI from a string URI-reference <i>uri_string</i>.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_new_uri_from_uri_local_name(raptor_uri*</b> <i>uri</i><b>, const<br />
unsigned char*</b> <i>local_name</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor URI from a string URI-reference <i>local_name</i> relative to an existing URI-reference. This performs concatenation of the <i>local_name</i> to the <i>uri</i> and not relative URI resolution, which is done by the raptor_new_uri_relative_to_base constructor.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_new_uri_relative_to_base(raptor_uri*</b> <i>base_uri, const<br />
unsigned char* uri_string</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor URI from a string URI-reference <i>uri_string</i> using relative URI resolution to the <i>base_uri</i>.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_new_uri_from_id(raptor_uri*</b> <i>base_uri</i><b>, const unsigned<br />
char*</b> <i>id</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor URI from a string RDF ID <i>id</i> concatenated to the <i>base_uri</i> base URI.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_new_uri_for_rdf_concept(const char*</b> <i>name</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor URI for the RDF namespace concept <i>name</i>.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_new_uri_for_xmlbase(raptor_uri*</b> <i>old_uri</i><b>))</b></p>
<p style="margin-left:22%;">Create a raptor URI suitable for use with xml:base (throw away fragment)</p>
<h2>URI DESTRUCTOR <a name="URI_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_uri(raptor_uri*</b> <i>uri</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a raptor URI object.</p>
<h2>URI METHODS <a name="URI_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_uri_equals(raptor_uri*</b> <i>uri1</i><b>, raptor_uri*</b> <i>uri2</i><b>)</b></p>
<p style="margin-left:22%;">Return non-zero if the given URIs are equal.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_uri_copy(raptor_uri*</b> <i>uri</i><b>)</b></p>
<p style="margin-left:22%;">Return a copy of the given raptor URI <i>uri</i>.</p>
<p style="margin-left:11%;"><b>unsigned char* raptor_uri_as_counted_string(raptor_uri *uri, size_t*<br />
len_p)<br />
unsigned char* raptor_uri_as_string(raptor_uri*</b> <i>uri</i><b>)</b></p>
<p style="margin-left:22%;">Return a shared pointer to a string representation of the given raptor URI <i>uri</i>. This string is shared and must not be freed (otherwise see the <b>raptor_uri_to_*</b> methods below). If <b>raptor_uri_as_counted_string</b> is used, the length of the returned string is stored in *<i>len_p</i> if not NULL.</p>
<p style="margin-left:11%;"><b>unsigned char* raptor_uri_to_counted_string(raptor_uri *</b><i>uri</i><b>, size_t<br />
*</b><i>len_p</i><b>)<br />
unsigned char* raptor_uri_to_string(raptor_uri *</b><i>uri</i><b>)</b></p>
<p style="margin-left:22%;">Return a to a newly alloced string representation of the given raptor URI <i>uri</i>. This string must be freed by the caller using <b>raptor_free_memory</b>. If <b>raptor_uri_to_counted_string</b> is used, the length of the returned string is stored in *<i>len_p</i> if not NULL.</p>
<p style="margin-left:11%;"><b>unsigned char* raptor_uri_to_relative_counted_uri_string(raptor_uri<br />
*</b><i>base_uri</i><b>, raptor_uri *</b><i>reference_uri</i><b>, size_t *</b><i>length_p</i><b>)<br />
unsigned char* raptor_uri_to_relative_uri_string(raptor_uri *</b><i>base_uri</i><b>,<br />
raptor_uri *</b><i>reference_uri</i><b>)</b></p>
<p style="margin-left:22%;">Return a new relative URI string of a URI <i>reference_uri against a base URI base_uri. The returned string must be freed with</i> <b>raptor_free_memory</b><i>. If</i> <b>raptor_uri_to_relative_counted_string</b> <i>is used, the length of the returned string is stored in *len_p if not NULL.</i></p>
<p style="margin-left:11%;"><b>void raptor_uri_print(const raptor_uri*</b> <i>uri</i><b>, FILE *</b><i>stream</i><b>)</b></p>
<p style="margin-left:22%;">Print URI <i>uri</i> to the file handle <i>stream</i>.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_uri(raptor_iostream*</b> <i>iostr</i><b>, raptor_uri*</b> <i>uri</i><b>)</b></p>
<p style="margin-left:22%;">Write the raptor_uri <i>uri</i> to the iostream <i>ostr</i>.</p>
<h2>URI UTILITY FUNCTIONS <a name="URI_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_uri_resolve_uri_reference (const unsigned char*</b> <i>base_uri</i><b>,<br />
const unsigned char*</b> <i>reference_uri</i><b>, char unsigned*</b> <i>buffer</i><b>, size_t</b> <i><br />
length</i><b>)</b></p>
<p style="margin-left:22%;">This is a standalone function that resolves the relative URI <i>reference_uri</i> against the base URI <i>base_uri</i> according to the URI resolution rules in RFC2396. The resulting URI is stored in <i>buffer</i> which is of <i>length</i> bytes. If this is too small, no work will be done.</p>
<p style="margin-left:11%;"><b>char *raptor_uri_filename_to_uri_string(const unsigned char*</b> <i>filename</i><b>)</b></p>
<p style="margin-left:22%;">This is a standalone function that turns a local filename (Windows or Unix style as appropriate for platform) into a URI string (file).<br />
The returned string must be freed by the caller. Some systems require memory allocated in a library to be deallocated inside that library in which case <b>raptor_free_memory</b> may be used.</p>
<p style="margin-left:11%;"><b>char *raptor_uri_uri_string_to_filename(const unsigned char*</b> <i><br />
uri_string</i><b>)<br />
char *raptor_uri_uri_string_to_filename(const unsigned char*</b> <i><br />
uri_string</i><b>, unsigned char **</b><i>fragment_p</i><b>)</b></p>
<p style="margin-left:22%;">These are standalone functions that turn a URI string that represents a local filename (file:) into a filename, with optional URI fragment. If <i>fragment_p</i> is not NULL it points to the location to store a newly allocated string containing the fragment. The returned strings must be freed by the caller. Some systems require memory allocated in a library to be deallocated inside that library in which case <b>raptor_free_memory</b> may be used.</p>
<p style="margin-left:11%;"><b>int raptor_uri_is_file_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
<p style="margin-left:22%;">DEPRECATED in 1.4.9. Returns non-zero if the given URI string represents a filename. Use <b>raptor_uri_uri_string_is_file_uri</b> in preference.</p>
<p style="margin-left:11%;"><b>int raptor_uri_uri_string_is_file_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
<p style="margin-left:22%;">Returns non-zero if the given URI string represents a filename.</p>
<h2>URI CLASS IMPLEMENTATION <a name="URI_CLASS_IMPLEMENTATION"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_uri_set_handler(const raptor_uri_handler *</b><i>handler</i><b>, void<br />
*</b><i>context</i><b>)</b></p>
<p style="margin-left:22%;">Change the URI class implementation to the functions provided by the <i>handler</i> URI implementation. The <i>context</i> user data is passed in to the handler URI implementation calls.</p>
<p style="margin-left:11%;"><b>void raptor_uri_get_handler(raptor_uri_handler **</b><i>handler</i><b>, void<br />
**</b><i>context</i><b>)</b></p>
<p style="margin-left:22%;">Return the current raptor URI class implementation <i>handler</i> and <i>context</i></p>
<h2>WWW CLASS <a name="WWW_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This is a small wrapper class around existing WWW libraries in order to provide HTTP GET or better URI retrieval for Raptor. It is not intended to be a general purpose WWW retrieval interface.</p>
<h2>WWW CLASS INITIALISATION AND CLEANUP <a name="WWW_CLASS_INITIALISATION_AND_CLEANUP"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_www_init(void)<br />
void raptor_www_finish(void)</b></p>
<p style="margin-left:22%;">Initialise or terminate the raptor_www infrastructure. raptor_www_init and raptor_finish are called by raptor_init and raptor_finish respecitively, otherwise must be called once each.</p>
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">
<p>NOTE</p>
</td>
<td width="5%"></td>
<td width="78%">
<p>Several of the WWW library implementations require once-only initialisation and termination functions to be called, however raptor cannot determine whether this is already done before the library is initialised in <b>raptor_www_init</b> or terminated in <b>raptor_www_finish</b>, so always performs it. This can be changed by <b>raptor_www_no_www_library_init_finish</b>.</p>
</td>
</tr>
</table>
<p style="margin-left:11%;"><b>void raptor_www_no_www_library_init_finish(void)</b></p>
<p style="margin-left:22%;">If this is called before <b>raptor_www_init</b>, it will not call the underlying WWW library global initialise or terminate functions. The application code must perform both operations.</p>
<p style="margin-left:22%; margin-top: 1em">For example with curl, after this function is called, neither <b>curl_global_init</b> nor <b>curl_global_cleanup</b> will be called during <b>raptor_www_init</b> or <b>raptor_www_finish</b> respectively.</p>
<h2>WWW CONSTRUCTORS <a name="WWW_CONSTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_www *raptor_www_new(void)<br />
raptor_www *raptor_www_new_with_connection(void*</b> <i>connection</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor WWW object capable of URI retrieval. If <i>connection</i> is given, it must match the connection object of the underlying WWW implementation. At present, this is only for libcurl, and allows you to re-use an existing curl handle, or use one which has been set up with some desired qualities.</p>
<h2>WWW DESTRUCTOR <a name="WWW_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_www_free(raptor_www *</b><i>www</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a raptor WWW object.</p>
<h2>WWW METHODS <a name="WWW_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_www_set_user_agent(raptor_www *</b><i>www</i><b>, const char *</b><i>user_agent</i><b>)</b></p>
<p style="margin-left:22%;">Set the HTTP User-Agent header value.</p>
<p style="margin-left:11%;"><b>int raptor_www_set_http_cache_control(raptor_www*</b> <i>www</i><b>, const char*</b> <i><br />
cache_control</i><b>)</b></p>
<p style="margin-left:22%;">Set the HTTP Cache-Control header value.</p>
<p style="margin-left:11%;"><b>void raptor_www_set_proxy(raptor_www *</b><i>www</i><b>, const char *</b><i>proxy</i><b>)</b></p>
<p style="margin-left:22%;">Set the HTTP proxy - usually a string of the form http://server:port</p>
<p style="margin-left:11%;"><b>raptor_www_set_write_bytes_handler(raptor_www *</b><i>www</i><b>,<br />
raptor_www_write_bytes_handler</b> <i>handler</i><b>, void *</b><i>user_data</i><b>)</b></p>
<p style="margin-left:22%;">Set the handler to receive bytes written by the raptor_www implementation.</p>
<p style="margin-left:11%;"><b>void raptor_www_set_content_type_handler(raptor_www *</b><i>www</i><b>,<br />
raptor_www_content_type_handler</b> <i>handler</i><b>, void *</b><i>user_data</i><b>)</b></p>
<p style="margin-left:22%;">Set the handler to receive the HTTP Content-Type value, when/if discovered during retrieval by the raptor_www implementation.</p>
<p style="margin-left:11%;"><b>void raptor_www_set_http_accept(raptor_www *</b><i>www</i><b>, const char *</b><i>value</i><b>)</b></p>
<p style="margin-left:22%;">Set the WWW HTTP Accept: header to <i>value</i>. If <i>value</i> is NULL, an empty header is sent.</p>
<p style="margin-left:11%;"><b>void raptor_www_set_error_handler(raptor_www *www,<br />
raptor_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
<p style="margin-left:22%;">Set the error handler routine for the raptor_www class. This takes the same arguments as the raptor_parser error, warning handler methods.</p>
<p style="margin-left:11%;"><b>void raptor_www_set_uri_filter(raptor_www*</b> <i>www</i><b>, raptor_uri_filter_func</b> <i><br />
filter</i><b>, void*</b> <i>user_data</i><b>)</b></p>
<p style="margin-left:22%;">Set the URI filter function <i>filter</i> for URIs retrieved by the raptor_www object.</p>
<p style="margin-left:11%;"><b>void* raptor_www_get_connection(raptor_www *</b><i>www</i><b>)</b></p>
<p style="margin-left:22%;">Return the underlying WWW library connection object. For example, for libcurl this is the curl_handle.</p>
<p style="margin-left:11%;"><b>void raptor_www_set_connection_timeout(raptor_www*</b> <i>www</i><b>, int</b> <i>timeout</i><b>)</b></p>
<p style="margin-left:22%;">Set the WWW connection <i>timeout</i> in seconds.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_www_get_final_uri(raptor_www*</b> <i>www</i><b>)</b></p>
<p style="margin-left:22%;">Get the final URI from a WWW retrieval, which may include redirections.</p>
<h2>WWW ACTION METHODS <a name="WWW_ACTION_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_www_fetch(raptor_www *www, raptor_uri *uri)</b></p>
<p style="margin-left:22%;">Retrieve the given URL, returning non zero on failure.</p>
<p style="margin-left:11%;"><b>int raptor_www_fetch_to_string(raptor_www *www, raptor_uri *uri, void<br />
**string_p, size_t *length_p, void *(*malloc_handler)(size_t size))</b></p>
<p style="margin-left:22%;">Retrieve the given URL to a string. <i>string_p</i> must point to a void* pointer that will be used to store the newly allocated string. <i>length_p</i> if not NULL, it will be used to store the length of the new string.</p>
<p style="margin-left:11%;"><b>void raptor_www_abort(raptor_www *www, const char *reason)</b></p>
<p style="margin-left:22%;">Abort an ongoing raptor WWW operation. Typically used within one of the raptor WWW handlers.</p>
<h2>QNAME CLASS <a name="QNAME_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This is a class for handling XML QNames consisting of the pair of (a URI from a namespace, a local name) along with an optional value -- useful for XML attributes. This is used with the raptor_namespace_stack and raptor_namespace classes to handle a stack of raptor_namespace that build on raptor_qname.</p>
<h2>QNAME CONSTRUCTORS <a name="QNAME_CONSTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">There are two constructors for raptor_qname to build qnames with optional values on a stack of names. <b><br />
raptor_qname* raptor_new_qname(raptor_namespace_stack *</b><i>nstack</i><b>, const<br />
unsigned char *</b><i>name</i><b>, const unsigned char *</b><i>value</i><b>,<br />
raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor QName <i>name</i> (a possibly :-separated name) with name to be resolved against the given <i>nstack</i> namespace stack. An optional <i>value</i> can be given, and if there is an error, the <i>error_handler</i> <b>and</b> <i>error_data</i> <b>will be used to invoke the callback.</b></p>
<p style="margin-left:11%;"><b>raptor_qname* raptor_new_qname_from_namespace_local_name<br />
(raptor_namespace *</b><i>ns</i><b>, const unsigned char *</b><i>local_name</i><b>, const unsigned<br />
char *</b><i>value</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor QName using the namespace name of the raptor_namespace <i>ns</i> and the local name <i>local_name</i>, along with optional value <i>value</i>. Errors are reported using the error handling and data of the namespace.</p>
<p style="margin-left:11%;"><b>raptor_qname* raptor_qname_copy(raptor_qname *</b><i>qname</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor QName from an existing one, returning NULL on failure.</p>
<h2>QNAME DESTRUCTOR <a name="QNAME_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_qname(raptor_qname*</b> <i>name</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a raptor qname object.</p>
<h2>QNAME METHODS <a name="QNAME_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_qname_equal(raptor_qname*</b> <i>name1</i><b>, raptor_qname *</b><i>name2</i><b>)</b></p>
<p style="margin-left:22%;">Return non-zero if the given QNames are equal.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_qname(raptor_iostream*</b> <i>iostr</i><b>, raptor_qname<br />
*</b><i>qname</i><b>)</b></p>
<p style="margin-left:22%;">Write the raptor_qname <i>qname</i> to the iostream <i>ostr</i>.</p>
<p style="margin-left:11%;"><b>const unsigned char* raptor_qname_get_local_name(raptor_qname*</b> <i>name</i><b>)</b></p>
<p style="margin-left:22%;">Get the local name of the QName.</p>
<p style="margin-left:11%;"><b>const unsigned char* raptor_qname_get_value(raptor_qname*</b> <i>name</i><b>)</b></p>
<p style="margin-left:22%;">Get the value of the QName for an XML attribute QName.</p>
<p style="margin-left:11%;"><b>const unsigned char* raptor_qname_get_counted_value(raptor_qname*</b> <i>name</i><b>,<br />
size_t*</b> <i>length_p</i><b>)</b></p>
<p style="margin-left:22%;">Get the value fo the QName along with the length (if <i>length_p</i> is not NULL) for an XML attribute QName.</p>
<p style="margin-left:11%;"><b>unsigned char* raptor_qname_to_counted_name(raptor_qname*</b> <i>qname</i><b>,<br />
size_t*</b> <i>length_p</i><b>)</b></p>
<p style="margin-left:22%;">Get the formatted QName as a newly allocated counted string (if <i>length_p</i> is not NULL).</p>
<h2>QNAME UTILITY FUNCTIONS <a name="QNAME_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_uri* raptor_qname_string_to_uri(raptor_namespace_stack *</b><i>nstack</i><b>,<br />
const unsigned char *</b><i>name</i><b>, size_t</b> <i>name_len</i><b>,<br />
raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
<p style="margin-left:22%;">Return the URI corresponding to the QName according to the RDF method; concatenating the namespace&rsquo;s name (URI) with the local name. Takes the same arguments as <b>raptor_new_qname</b> but does not create a raptor_qname object.</p>
<p style="margin-left:11%;"><b>raptor_namespace* raptor_qname_get_namespace(raptor_qname*</b> <i>name</i><b>)</b></p>
<p style="margin-left:22%;">Return the raptor_namespace used by the QName. Will never be NULL even for the default namespace in which case the URI of the returned namespace object will be NULL.</p>
<h2>NAMESPACE CLASS <a name="NAMESPACE_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">An XML namespace class - each entry is on a stack and consists of a name (URI) and prefix. The prefix or the name but not both may be empty. If the prefix is empty, it defines the default prefix. If the name is empty, it undefines the given prefix.</p>
<h2>NAMESPACE CONSTRUCTORS <a name="NAMESPACE_CONSTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_namespace* raptor_new_namespace(raptor_namespace_stack *</b><i>nstack</i><b>,<br />
const unsigned char *</b><i>prefix</i><b>, const unsigned char *</b><i>ns_uri_string</i><b>, int</b> <i><br />
depth</i><b>)<br />
raptor_namespace* raptor_new_namespace_from_uri(raptor_namespace_stack<br />
*</b><i>nstack</i><b>, const unsigned char *</b><i>prefix</i><b>, raptor_uri*</b> <i>ns_uri</i><b>, int</b> <i>depth</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor_namespace object on the given namespace stack <i>nstack</i> with prefix <i>prefix</i> and namespace name either from URI string <i>ns_uri_string</i> or from copying URI <i>ns_uri</i>.</p>
<p style="margin-left:11%; margin-top: 1em">If <i>prefix</i> is NULL, it defines the URI for the default namespace prefix. If the namespace name (<i>ns_uri_string</i> or <i>ns_uri</i>) is NULL, it undefines the given <i>prefix</i> in the current scope. Both prefix and URI may be NULL to undefine the default namespace. <i>depth</i> signifies the position of the namespace on the stack; 0 is the bottom of the stack and generally the first depth for user namespace declarations.</p>
<p style="margin-left:11%; margin-top: 1em">Namespaces declared on the same depth (such as on the same XML element, typically) can be handily freed with <i>raptor_namespaces_end_for_depth</i> method on the namespace stack class.</p>
<h2>NAMESPACE DESTRUCTOR <a name="NAMESPACE_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_namespace(raptor_namespace *ns)</b></p>
<p style="margin-left:22%;">Destroy a raptor namespace object.</p>
<h2>NAMESPACE METHODS <a name="NAMESPACE_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_uri* raptor_namespace_get_uri(const raptor_namespace *ns)</b></p>
<p style="margin-left:22%;">Return the namespace name (URI) of the namespace.</p>
<p style="margin-left:11%;"><b>const unsigned char* raptor_namespace_get_prefix(const raptor_namespace<br />
*ns)</b></p>
<p style="margin-left:22%;">Return the prefix of the namespace.</p>
<p style="margin-left:11%;"><b>const unsigned char* raptor_namespace_get_counted_prefix(const<br />
raptor_namespace*</b> <i>ns</i><b>, size_t*</b> <i>length_p</i><b>)</b></p>
<p style="margin-left:22%;">Return the prefix of the namespace as a string with optional count stored in the variable address <i>length_p</i> if it is not NULL.</p>
<p style="margin-left:11%;"><b>unsigned char *raptor_namespaces_format(const raptor_namespace *ns,<br />
size_t *length_p)</b></p>
<p style="margin-left:22%;">Format the namespace as a string and return it as a new string, returning the length of the resulting string in <i>length_p</i> if it is not NULL. The string format is suitable for emitting in XML to declare the namespace.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_namespace(raptor_iostream*</b> <i>iostr</i><b>,<br />
raptor_namespace *</b><i>ns</i><b>)</b></p>
<p style="margin-left:22%;">Write a formatted namespace declaration like xmlns... to an iostream <i>iostr</i>.</p>
<h2>NAMESPACE UTILITY FUNCTIONS <a name="NAMESPACE_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_namespace_copy(raptor_namespace_stack *nstack,<br />
raptor_namespace *ns, int new_depth)</b></p>
<p style="margin-left:22%;">Copy the namespace from the current stack to the new one, <i>nstack</i> at depth <i>new_depth</i>.</p>
<p style="margin-left:11%;"><b>int raptor_new_namespace_parts_from_string(unsigned char *</b><i>string</i><b>,<br />
unsigned char **</b><i>prefix</i><b>, unsigned char **</b><i>uri_string</i><b>)</b></p>
<p style="margin-left:22%;">Parse <i>string</i> with an XML-style namespace declaration like xmlns="", xmlns="uri", xmlns:prefix="" or xmlns:prefix="uri" into the strings pointed to by <i>prefix</i> string and a <i>uri_string</i>. Empty prefixes or namespace names return NULL pointers. Returned strings must be freed by the caller using <b>raptor_free_memory</b>.</p>
<h2>NAMESPACE STACK CLASS <a name="NAMESPACE_STACK_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">A stack of raptor_namespace objects where the namespaces on top of the stack have wider scope and override earlier (lower) namespace declarations. Intended to match the XML namespace declaring semantics using xmlns attributes.</p>
<h2>NAMESPACE STACK CONSTRUCTORS <a name="NAMESPACE_STACK_CONSTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_namespace_stack* raptor_new_namespaces(raptor_uri_handler<br />
*uri_handler, void *uri_context, raptor_simple_message_handler<br />
error_handler, void *error_data, int defaults)<br />
int raptor_namespaces_init(raptor_namespace_stack *nstack,<br />
raptor_uri_handler *handler, void *context,<br />
raptor_simple_message_handler error_handler, void *error_data, int<br />
defaults)</b></p>
<p style="margin-left:22%;">Create or initialise a new raptor_namespace_stack object with the given URI and error handlers. <b>raptor_namespaces_new</b> allocates new memory for the namespace stack and <b>raptor_namespaces_init</b> initialises an existing declared <i>nstack</i>, which could be statically allocated. Note that <b>raptor_uri_get_handler</b> can be useful to return the current raptor URI handler/context. The <i>defaults</i> argument describes which default namespaces are declared in the empty stack. At present, 0 is none, 1 for just the XML namespace and 2 is for a typical set of namespaces used for RDF, RDFS, Dublin Core, OWL, ... that may vary over time.</p>
<p style="margin-left:22%; margin-top: 1em">In versions 1.4.16 or newer this returns an integer result, non-0 on failure.</p>
<h2>NAMESPACE STACK DESTRUCTORS <a name="NAMESPACE_STACK_DESTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_namespaces(raptor_namespace_stack *nstack)</b></p>
<p style="margin-left:22%;">Destroy a namespace stack object, freeing the <i>nstack</i> (goes with <b>raptor_new_namespaces</b>).</p>
<p style="margin-left:11%;"><b>void raptor_namespaces_clear(raptor_namespace_stack *nstack)</b></p>
<p style="margin-left:22%;">Clear a statically allocated namespace stack; does not free the <i>nstack</i>. (goes with <b>raptor_namespaces_init</b>).</p>
<h2>NAMESPACE STACK METHODS <a name="NAMESPACE_STACK_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_namespaces_start_namespace(raptor_namespace_stack *nstack,<br />
raptor_namespace *nspace)</b></p>
<p style="margin-left:22%;">Start the given <i>nspace</i> on the stack, at the depth already defined.</p>
<p style="margin-left:11%;"><b>int raptor_namespaces_start_namespace_full(raptor_namespace_stack<br />
*nstack, const unsigned char *prefix, const unsigned char *nspace, int<br />
depth)</b></p>
<p style="margin-left:22%;">Create a new raptor_namespace and start it on the stack. See <b>raptor_new_namespace</b> for the meaning of the argumens.</p>
<p style="margin-left:11%;"><b>void raptor_namespaces_end_for_depth(raptor_namespace_stack *nstack,<br />
int depth)</b></p>
<p style="margin-left:22%;">End (and free) all namespaces on the stack at the given <i>depth</i>.</p>
<p style="margin-left:11%;"><b>raptor_namespace* raptor_namespaces_get_default_namespace<br />
(raptor_namespace_stack *nstack)</b></p>
<p style="margin-left:22%;">Return the current default raptor_namespace of the namespace stack or NULL if there is none.</p>
<p style="margin-left:11%;"><b>raptor_namespace*<br />
raptor_namespaces_find_namespace_by_uri(raptor_namespace_stack *</b><i>nstack</i><b>,<br />
raptor_uri *</b><i>ns_uri</i><b>)</b></p>
<p style="margin-left:22%;">Find the first namespace on the stack with the given uri <i>ns_uri</i> or NULL if there is none.</p>
<p style="margin-left:11%;"><b>raptor_namespace<br />
*raptor_namespaces_find_namespace_by_uri(raptor_namespace_stack<br />
*nstack, const unsigned char *prefix, int prefix_length)</b></p>
<p style="margin-left:22%;">Find the first namespace on the stack with the given namespace <i>prefix</i> or NULL if there is none.</p>
<p style="margin-left:11%;"><b>int raptor_namespaces_namespace_in_scope(raptor_namespace_stack<br />
*nstack, const raptor_namespace *nspace)</b></p>
<p style="margin-left:22%;">Return non-zero if the raptor_namespace <i>nspace</i> is declared on the stack; i.e. in scope if this is a stack of XML namespaces.</p>
<h2>NAMESPACE STACK UTILITY FUNCTIONS <a name="NAMESPACE_STACK_UTILITY_FUNCTIONS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_qname* raptor_namespaces_qname_from_uri(raptor_namespace_stack*</b> <i><br />
nstack</i><b>, raptor_uri*</b> <i>uri</i><b>, int</b> <i>xml_version</i><b>)</b></p>
<p style="margin-left:22%;">Create a raptor QName from the URI <i>uri</i> if the URI is squal one of the namespace URIs on the namespace stack <i>nstack</i> URIs concatenated to a legal XML name for the given XML version. URIs are created and errors are reported using the namespace stack fields. Fails if it cannot be legally described with any of the namespaces.</p>
<h2>SEQUENCE CLASS <a name="SEQUENCE_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">A class for ordered sequences of items, adding at either end of the sequence. The method names should be familiar to Perl users.</p>
<h2>SEQUENCE CONSTRUCTOR <a name="SEQUENCE_CONSTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_sequence* raptor_new_sequence(raptor_sequence_free_handler*</b> <i><br />
free_handler</i><b>, raptor_sequence_print_handler*</b> <i>print_handler</i><b>)</b></p>
<p style="margin-left:22%;">Create a new empty sequence, with optional handler for freeing elements (as used by <b>raptor_free_sequence</b> and printing out elements (used by <b>raptor_sequence_print</b>).</p>
<h2>SEQUENCE DESTRUCTOR <a name="SEQUENCE_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_sequence(raptor_sequence*</b> <i>seq</i><b>)</b></p>
<p style="margin-left:22%;">Destoy a sequence object, freeing any items if the free handler was defined in the constructor.</p>
<h2>SEQUENCE METHODS <a name="SEQUENCE_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_sequence_size(raptor_sequence*</b> <i>seq</i><b>)</b></p>
<p style="margin-left:22%;">Return the number of items in the sequence.</p>
<p style="margin-left:11%;"><b>int raptor_sequence_set_at(raptor_sequence*</b> <i>seq</i><b>, int</b> <i>idx</i><b>, void *data)</b></p>
<p style="margin-left:22%;">Set the sequence item at index <i>idx</i> to the value <i>data</i>, extending it if necessary.</p>
<p style="margin-left:11%;"><b>int raptor_sequence_push(raptor_sequence*</b> <i>seq</i><b>, void *</b><i>data</i><b>)</b></p>
<p style="margin-left:22%;">Add item <i>data</i> to the end of the sequence.</p>
<p style="margin-left:11%;"><b>int raptor_sequence_shift(raptor_sequence*</b> <i>seq</i><b>, void *</b><i>data</i><b>)</b></p>
<p style="margin-left:22%;">Add item <i>data</i> to the start of the sequence.</p>
<p style="margin-left:11%;"><b>void* raptor_sequence_get_at(raptor_sequence*</b> <i>seq</i><b>, int</b> <i>idx</i><b>)</b></p>
<p style="margin-left:22%;">Get the sequence item at index <i>idx</i> or NULL if no such index exists.</p>
<p style="margin-left:11%;"><b>void* raptor_sequence_pop(raptor_sequence*</b> <i>seq</i><b>)</b></p>
<p style="margin-left:22%;">Remove and return an item from the end of the sequence, or NULL if is empty.</p>
<p style="margin-left:11%;"><b>void* raptor_sequence_unshift(raptor_sequence*</b> <i>seq</i><b>)</b></p>
<p style="margin-left:22%;">Remove and return an item from the start of the sequence, or NULL if is empty.</p>
<p style="margin-left:11%;"><b>void raptor_sequence_sort(raptor_sequence*</b> <i>seq</i><b>, int(*</b><i>compare</i><b>)(const<br />
void *, const void *))</b></p>
<p style="margin-left:22%;">Sort the sequence using the given comparison function <i>compare</i> which is passed to qsort(3) internally.</p>
<p style="margin-left:11%;"><b>int raptor_compare_strings(const void *</b><i>a</i><b>, const void *</b><i>b</i><b>)</b></p>
<p style="margin-left:22%;">Helper function useful with <b>raptor_sequence_sort</b>.</p>
<p style="margin-left:11%;"><b>void raptor_sequence_set_print_handler(raptor_sequence *</b><i>seq</i><b>,<br />
raptor_sequence_print_handler *</b><i>print_handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the print handler for the sequence, an alternative to setting it in the constructor.</p>
<p style="margin-left:11%;"><b>void raptor_sequence_print_string(char *</b><i>data</i><b>, FILE *</b><i>fh</i><b>)</b></p>
<p style="margin-left:22%;">Helper print handler function useful for printing out sequences of strings.</p>
<p style="margin-left:11%;"><b>void raptor_sequence_print_uri(char *</b><i>data</i><b>, FILE *</b><i>fh</i><b>)</b></p>
<p style="margin-left:22%;">Helper print handler function useful for printing out sequences of raptor_uri* objects.</p>
<p style="margin-left:11%;"><b>void raptor_sequence_print(raptor_sequence*</b> <i>seq</i><b>, FILE*</b> <i>fh</i><b>)</b></p>
<p style="margin-left:22%;">Print out the sequence in a debug format to the given file handler <i>fh</i>. NOTE: The exact format is not guaranteed to remain the same between releases.</p>
<p style="margin-left:11%;"><b>int raptor_sequence_join(raptor_sequence*</b> <i>dest</i><b>, raptor_sequence *</b><i>src</i><b>)</b></p>
<p style="margin-left:22%;">Join two sequences moving all items from sequence <i>src</i> to the end of sequence <i>dest</i>. After this operation, sequence <i>src</i> will be empty (zero size) but will have the same item capacity as before.</p>
<p style="margin-left:11%;"><b>void* raptor_sequence_delete_at(raptor_sequence*</b> <i>seq</i><b>, int</b> <i>idx</i><b>)</b></p>
<p style="margin-left:22%;">Remove an item from position <i>idx</i> in the sequence, returning it.</p>
<h2>STRINGBUFFER CLASS <a name="STRINGBUFFER_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">A class for growing strings, small chunks at a time.</p>
<h2>STRINGBUFFER CONSTRUCTOR <a name="STRINGBUFFER_CONSTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_stringbuffer* raptor_new_stringbuffer(void)</b></p>
<p style="margin-left:22%;">Create a new stringbuffer.</p>
<h2>STRINGBUFFER DESTRUCTOR <a name="STRINGBUFFER_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_stringbuffer(raptor_stringbuffer*</b> <i>stringbuffer</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a stringbuffer.</p>
<h2>STRINGBUFFER METHODS <a name="STRINGBUFFER_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_stringbuffer_append_counted_string(raptor_stringbuffer*</b> <i><br />
stringbuffer</i><b>, const unsigned char *</b><i>string</i><b>, size_t</b> <i>length</i><b>, int</b> <i>do_copy</i><b>)</b></p>
<p style="margin-left:22%;">Append a <i>string</i> of <i>length</i> bytes to a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
<p style="margin-left:11%;"><b>int raptor_stringbuffer_append_string(raptor_stringbuffer*</b> <i><br />
stringbuffer</i><b>, const unsigned char*</b> <i>string</i><b>, int</b> <i>do_copy</i><b>)</b></p>
<p style="margin-left:22%;">Append a <i>string</i> to a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
<p style="margin-left:11%;"><b>int raptor_stringbuffer_append_decimal(raptor_stringbuffer*</b> <i><br />
stringbuffer</i><b>, int</b> <i>integer</i><b>)</b></p>
<p style="margin-left:22%;">Append a formatted decimal <i>integer</i> to a stringbuffer.</p>
<p style="margin-left:11%;"><b>int raptor_stringbuffer_append_stringbuffer(raptor_stringbuffer*</b> <i><br />
stringbuffer</i><b>, raptor_stringbuffer*</b> <i>append</i><b>)</b></p>
<p style="margin-left:22%;">Append a stringbuffer <i>append</i> to a stringbuffer. The append stringbuffer is emptied but not destroyed.</p>
<p style="margin-left:11%;"><b>int raptor_stringbuffer_prepend_counted_string(raptor_stringbuffer*</b> <i><br />
stringbuffer</i><b>, const unsigned char*</b> <i>string</i><b>, size_t</b> <i>length</i><b>, int</b> <i>do_copy</i><b>)</b></p>
<p style="margin-left:22%;">Prepend a <i>string</i> of <i>length</i> bytes to the start of a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
<p style="margin-left:11%;"><b>int raptor_stringbuffer_prepend_string(raptor_stringbuffer*</b> <i><br />
stringbuffer</i><b>, const unsigned char*</b> <i>string</i><b>, int</b> <i>do_copy</i><b>)</b></p>
<p style="margin-left:22%;">Prepend a <i>string</i> to the start of a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
<p style="margin-left:11%;"><b>unsigned char * raptor_stringbuffer_as_string(raptor_stringbuffer*</b> <i><br />
stringbuffer</i><b>)</b></p>
<p style="margin-left:22%;">Return the stringbuffer as a single string. The string is shared and should be copied if needed.</p>
<p style="margin-left:11%;"><b>size_t raptor_stringbuffer_length(raptor_stringbuffer*</b> <i>stringbuffer</i><b>)</b></p>
<p style="margin-left:22%;">Return the length of the stringbuffer.</p>
<p style="margin-left:11%;"><b>int raptor_stringbuffer_copy_to_string(raptor_stringbuffer*<br />
stringbuffer, unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>gth)</b></p>
<p style="margin-left:22%;">Copy the stringbuffer into a single string buffer <i>string</i> of size <i>length</i>. Returns non-0 on failure.</p>
<h2>IOSTREAM CLASS <a name="IOSTREAM_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This class provides an I/O stream that can write to filenames, FILE*, strings and user-defined output via callbacks.</p>
<h2>IOSTREAM CONSTRUCTOR <a name="IOSTREAM_CONSTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_iostream* raptor_new_iostream_from_handler2(void*</b> <i>context</i><b>, const<br />
raptor_iostream_handler2 *</b><i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor read or write iostream from a user-defined raptor_iostream_handler2 <i>handler</i> that is called with the passed-in <i>context</i> for the write operations.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_from_handler(void*</b> <i>context</i><b>, const<br />
raptor_iostream_handler *</b><i>handler</i><b>)</b></p>
<p style="margin-left:22%;">DEPRECATED in 1.4.17 - use <b>raptor_new_iostream_from_handler2()</b> with the new handler format. Create a new raptor read iostream from a user-defined raptor_iostream_handler <i>handler</i> that is called with the passed-in <i>context</i> for the write operations.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_to_sink(void)</b></p>
<p style="margin-left:22%;">Create a new raptor write iostream that discards all written output.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_to_filename(const char *</b><i>filename</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor write iostream that creates and writes to a new file <i>filename</i>.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_to_file_handle(FILE *</b><i>handle</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor write iostream that creates and writes to an existing, already opened, C Standard I/O handle FILE* <i>handle</i>.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_to_string(void **</b><i>string_p</i><b>, size_t<br />
*</b><i>length_p</i><b>, void *(*</b><i>malloc_handler</i><b>)(size_t size))</b></p>
<p style="margin-left:22%;">Create a new raptor write iostream which creates a new string once raptor_free_iostream is called. The new string pointer is written in <i>string</i>, the length in <i>length_p</i> (if not NULL) and the memory allocation is made using the <i>malloc_handler</i>, or if NULL, raptor&rsquo;s default memory allocator.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_from_sink(void)</b></p>
<p style="margin-left:22%;">Create a new raptor read iostream that is immediately finished and returns end of file.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_from_filename(const char<br />
*</b><i>filename</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor read iostream from an existing file <i>filename</i>.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_from_file_handle(FILE *</b><i>handle</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor read iostream from an already opened, C Standard I/O handle FILE* <i>handler</i>.</p>
<p style="margin-left:11%;"><b>raptor_iostream* raptor_new_iostream_from_string(void *</b><i>string</i><b>, size_t</b> <i><br />
length</i><b>)</b></p>
<p style="margin-left:22%;">Create a new raptor read iostream reading from an existing <i>string</i> of <i>length</i> bytes.</p>
<h2>IOSTREAM DESTRUCTOR <a name="IOSTREAM_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_iostream(raptor_iostream *</b><i>iostr</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a Raptor iostream object.</p>
<h2>IOSTREAM METHODS <a name="IOSTREAM_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_iostream_write_bytes(raptor_iostream *</b><i>iostr</i><b>, const void<br />
*</b><i>ptr</i><b>, size_t</b> <i>size</i><b>, size_t</b> <i>nmemb</i><b>)</b></p>
<p style="margin-left:22%;">Write a counted set of elements to an iostream. Inmemb is the count of elements of size <i>size</i>, starting at memory <i>ptr</i>. Similar to fwrite(3) and write(2).</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_byte(raptor_iostream *</b><i>iostr</i><b>, const int</b> <i>byte</i><b>)</b></p>
<p style="margin-left:22%;">Write a single <i>byte</i> an iostream. Similar to fputc(3).</p>
<p style="margin-left:11%;"><b>void raptor_iostream_write_end(raptor_iostream *</b><i>iostr</i><b>)</b></p>
<p style="margin-left:22%;">Finish writing to an iostream.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_string(raptor_iostream *</b><i>iostr</i><b>, const void<br />
*</b><i>string</i><b>)</b></p>
<p style="margin-left:22%;">Write a NUL-terminated <i>string</i> to an iostream. Similar to fputs(3).</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_counted_string(raptor_iostream *</b><i>iostr</i><b>, const<br />
void *</b><i>string</i><b>, size_t</b> <i>len</i><b>)</b></p>
<p style="margin-left:22%;">Write a <i>string</i> of length <i>len</i> to an iostream.</p>
<p style="margin-left:11%;"><b>unsigned long raptor_iostream_tell(raptor_iostream *</b><i>iostr</i><b>)</b></p>
<p style="margin-left:22%;">Return the byte offset into the iostream.</p>
<p style="margin-left:11%;"><b>size_t raptor_iostream_get_bytes_written_count(raptor_iostream *</b><i>iostr</i><b>)</b></p>
<p style="margin-left:22%;">DEPRECATED in 1.4.17 for <b>raptor_iostream_tell()</b>. Return the number of bytes written so far to the iostream.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_decimal(raptor_iostream *</b><i>iostr</i><b>, int</b> <i>integer</i><b>)</b></p>
<p style="margin-left:22%;">Write a decimal formatted integer <i>integer</i> to the iostream.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_format_hexadecimal(raptor_iostream *</b><i>iostr</i><b>, unsigned<br />
int</b> <i>integer</i><b>, int</b> <i>width</i><b>)</b></p>
<p style="margin-left:22%;">Write a hexadecimal formatted unsigned <i>integer</i> to the iostream, left-padded with &rsquo;0&rsquo;s to <i>width</i> columns.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_stringbuffer(raptor_iostream*</b> <i>iostr</i><b>,<br />
raptor_stringbuffer *</b><i>sb</i><b>)</b></p>
<p style="margin-left:22%;">Write the stringbuffer to an iostream <i>iostr</i>.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_read_bytes(raptor_iostream*</b> <i>iostr</i><b>, void *</b><i>ptr</i><b>,<br />
size_t</b> <i>size</i><b>, size_t</b> <i>nmemb</i><b>)</b></p>
<p style="margin-left:22%;">Read bytes from the iostream into buffer <i>ptr</i> up to <i>nmemb</i> elements of size <i>size</i>.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_read_eof(raptor_iostream *</b><i>iostr</i><b>)</b></p>
<p style="margin-left:22%;">Return non-0 if the iostream is finished.</p>
<h2>XML SAX2 READER CLASS <a name="XML_SAX2_READER_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This class provides the functionality to generate SAX2 events from parsing XML content, including XML namespace support.</p>
<h2>XML SAX2 CONSTRUCTOR <a name="XML_SAX2_CONSTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_sax2* raptor_new_sax2(void *</b><i>user_data</i><b>, raptor_error_handlers*</b> <i><br />
error_handlers</i><b>)</b></p>
<p style="margin-left:22%;">Create a new SAX2 XML reader with the given error handler object.</p>
<h2>XML WRITER DESTRUCTOR <a name="XML_WRITER_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_sax2(raptor_sax2 *</b><i>sax2</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a SAX2 XML reader object.</p>
<h2>SAX2 SET HANDLER METHODS <a name="SAX2_SET_HANDLER_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_sax2_set_start_element_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_sax2_start_element_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 start element <i>handler</i>.</p>
<p style="margin-left:11%;"><b>void raptor_sax2_set_end_element_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_sax2_end_element_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 end element <i>handler</i>.</p>
<p style="margin-left:11%;"><b>void raptor_sax2_set_characters_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_sax2_characters_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 character data element <i>handler</i>.</p>
<p style="margin-left:11%;"><b>void raptor_sax2_set_cdata_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_sax2_cdata_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 CDATA section element <i>handler</i>.</p>
<p style="margin-left:11%;"><b>void raptor_sax2_set_comment_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_sax2_comment_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 XML comment <i>handler</i>.</p>
<p style="margin-left:11%;"><b>void raptor_sax2_set_unparsed_entity_decl_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_sax2_unparsed_entity_decl_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 XML unparsed entity declaration <i>handler</i>.</p>
<p style="margin-left:11%;"><b>void raptor_sax2_set_external_entity_ref_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_sax2_external_entity_ref_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 XML external entity reference <i>handler</i>.</p>
<p style="margin-left:11%;"><b>void raptor_sax2_set_namespace_handler(raptor_sax2 *</b><i>sax2</i><b>,<br />
raptor_namespace_handler</b> <i>handler</i><b>)</b></p>
<p style="margin-left:22%;">Set the SAX2 XML namespace declaration <i>handler</i> when an XML namespace is declared.</p>
<h2>SAX2 PARSING METHODS <a name="SAX2_PARSING_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_sax2_parse_start(raptor_sax2 *</b><i>sax2</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
<p style="margin-left:22%;">Start a SAX2 parse of XML content with the base URI <i>uri</i>.</p>
<p style="margin-left:11%;"><b>int raptor_sax2_parse_chunk(raptor_sax2 *</b><i>sax2</i><b>, const unsigned char<br />
*</b><i>buffer</i><b>, size_t</b> <i>len</i><b>, int</b> <i>is_end</i><b>)</b></p>
<p style="margin-left:22%;">Parse the XML content in <i>buffer</i> of size <i>len</i> returning SAX2 events via handlers. If <i>is_end</i> is non-zero, it indicates the end of the parsing. This method can only be called after <b>raptor_sax2_parse_start()</b>.</p>
<h2>SAX2 SCOPE METHODS <a name="SAX2_SCOPE_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>const unsigned char* raptor_sax2_inscope_xml_language(raptor_sax2<br />
*</b><i>sax2</i><b>)</b></p>
<p style="margin-left:22%;">Get the current in-scope XML language (xml:lang) value.</p>
<p style="margin-left:11%;"><b>raptor_uri* raptor_sax2_inscope_base_uri(raptor_sax2 *</b><i>sax2</i><b>)</b></p>
<p style="margin-left:22%;">Get the current in-scope Base URI (xml:base or document or protocol) value.</p>
<h2>XML ELEMENT CLASS <a name="XML_ELEMENT_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This class provides an XML element that can be used with the XML Writer Class to generate XML documents.</p>
<h2>XML ELEMENT CONSTRUCTORS <a name="XML_ELEMENT_CONSTRUCTORS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_xml_element* raptor_new_xml_element(raptor_qname*</b> <i>name</i><b>, const<br />
unsigned char*</b> <i>xml_language</i><b>, raptor_uri*</b> <i>xml_base</i><b>)</b></p>
<p style="margin-left:22%;">Create a new XML element with the element name <i>name</i> in the context of xml:lang <i>xml_language</i> and base URI <i>xml_base</i>.</p>
<p style="margin-left:11%;"><b>raptor_xml_element*<br />
raptor_new_xml_element_from_namespace_local_name(raptor_namespace *</b><i>ns</i><b>,<br />
const unsigned char *</b><i>name</i><b>, const unsigned char*</b> <i>xml_language</i><b>,<br />
raptor_uri*</b> <i>xml_base</i></p>
<p style="margin-left:22%;">Create a new XML element based on the given XML <i>namespace</i> and <i>localname</i> in the context of xml:lang <i>xml_language and base URI xml_base.</i></p>
<h2>XML ELEMENT DESTRUCTOR <a name="XML_ELEMENT_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><i><b>void raptor_free_xml_element(raptor_xml_element *</b>element</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a XML element object.</p>
<h2>XML ELEMENT METHODS <a name="XML_ELEMENT_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_qname* raptor_xml_element_get_name(raptor_xml_element*</b> <i><br />
xml_element</i><b>)</b></p>
<p style="margin-left:22%;">Get the XML element QName of XML element <i>xml_element</i>.</p>
<p style="margin-left:11%;"><b>void raptor_xml_element_set_attributes(raptor_xml_element*</b> <i>xml_element</i><b>,<br />
raptor_qname **</b><i>attributes</i><b>, int</b> <i>count</i><b>)</b></p>
<p style="margin-left:22%;">Set the attributes on XML element <i>xml_element</i> to the array of QNames in array <i>attributes</i> of size <i>count</i>.</p>
<p style="margin-left:11%;"><b>raptor_qname** raptor_xml_element_get_attributes(raptor_xml_element*</b> <i><br />
xml_element</i><b>)</b></p>
<p style="margin-left:22%;">Get the attributes of an XML element <i>xml_element</i> as an array of QNames. As set by <b>void raptor_xml_element_set_attributes</b>.</p>
<p style="margin-left:11%;"><b>int raptor_xml_element_get_attributes_count(raptor_xml_element*</b> <i><br />
xml_element</i><b>)</b></p>
<p style="margin-left:22%;">Get the number of attributes of an XML element <i>xml_element</i> as set by <b>void raptor_xml_element_set_attributes</b>.</p>
<p style="margin-left:11%;"><b>int raptor_xml_element_declare_namespace(raptor_xml_element*</b> <i><br />
xml_element</i><b>, raptor_namespace*</b> <i>nspace</i><b>)</b></p>
<p style="margin-left:22%;">Declare an XML namespace <i>nspace</i> expliclitly on XML element <i>xml_element</i>. Namespaces used in the element or attribute names are automatically declared, this method allows additional ones to be done.</p>
<p style="margin-left:11%;"><b>int raptor_xml_element_is_empty(raptor_xml_element*</b> <i>xml_element</i><b>)</b></p>
<p style="margin-left:22%;">Return non-0 if the XML element is empty.</p>
<p style="margin-left:11%;"><b>int raptor_iostream_write_xml_element(raptor_iostream*</b> <i>iostr</i><b>,<br />
raptor_xml_element *</b><i>element</i><b>, raptor_namespace_stack*</b> <i>nstack</i><b>, int</b> <i><br />
is_empty</i><b>, int</b> <i>is_end</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>,<br />
void*</b> <i>error_data</i><b>, int</b> <i>depth</i><b>)</b></p>
<p style="margin-left:22%;">Write a XML element <i>xml_element</i> to iostream <i>ostr</i>. This is done in context of an XML namespace stack <i>nstack</i> and at depth <i>depth</i> in the stack (see Namespace class constructors).</p>
<p style="margin-left:22%; margin-top: 1em">The element may be an empty element if <i>is_empty</i> is non-zero or may be a close element if <i>is_end</i> is non-zero (else is a start element). The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given.</p>
<p style="margin-left:11%;"><b>const unsigned char*<br />
raptor_xml_element_get_language(raptor_xml_element*</b> <i>xml_element</i><b>)</b></p>
<p style="margin-left:22%;">Get the xml:lang language of the XML element.</p>
<h2>XML WRITER CLASS <a name="XML_WRITER_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This class provides the functionality to generate simple XML documents consisting of elements with attributes, character data and comments. The documents can be written to an iostream.</p>
<h2>XML WRITER CONSTRUCTOR <a name="XML_WRITER_CONSTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_xml_writer* raptor_new_xml_writer(raptor_namespace_stack*</b> <i><br />
nstack</i><b>, raptor_uri_handler*</b> <i>uri_handler</i><b>, void*</b> <i>uri_context</i><b>,<br />
raptor_iostream*</b> <i>iostr</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>,<br />
void *</b><i>error_data</i><b>, int</b> <i>canonicalize</i><b>)</b></p>
<p style="margin-left:22%;">Create a new XML Writer writing to iostream <i>iostr</i>. The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given. <i>nstack</i> is either an existing namespace stack to be used or if NULL, a new one with only the XML namespace defined is created. Note that <b>raptor_uri_get_handler</b> can be useful to return the current raptor URI handler/context. <i>canonicalize</i> is currently unused and should be set to 1 but may allow non-canonical XML writing to be allowed in future.</p>
<h2>XML WRITER DESTRUCTOR <a name="XML_WRITER_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_xml_writer(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a XML Writer object.</p>
<h2>XML WRITER METHODS <a name="XML_WRITER_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_xml_writer_empty_element(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
raptor_xml_element *</b><i>element</i><b>)</b></p>
<p style="margin-left:22%;">Write XML element <i>element</i> as an empty element (no element content) to the XML Writer <i>xml_writer</i>.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_start_element(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
raptor_xml_element *</b><i>element</i><b>)</b></p>
<p style="margin-left:22%;">Write a start element along with an attributes and namespace declarations for XML element <i>element</i> to the XML Writer <i>xml_writer</i>.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_end_element(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
raptor_xml_element *</b><i>element</i><b>)</b></p>
<p style="margin-left:22%;">Write an end element form for XML element <i>element</i> to the XML Writer <i>xml_writer</i>.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_cdata(raptor_xml_writer*</b> <i>xml_writer</i><b>, const<br />
unsigned char *str)</b></p>
<p style="margin-left:22%;">Write XML character data in <i>str</i> to the XML Writer <i>xml_writer</i>. The characters in <i>str</i> will be XML escaped.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_cdata_counted(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
const unsigned char*</b> <i>str</i><b>, unsigned int</b> <i>length</i><b>)</b></p>
<p style="margin-left:22%;">Write XML character data in <i>str</i> of length <i>length</i> to the XML Writer <i>xml_writer</i>. The characters in <i>str</i> will be XML escaped.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_raw(raptor_xml_writer*</b> <i>xml_writer</i><b>, const<br />
unsigned char*</b> <i>str</i><b>)</b></p>
<p style="margin-left:22%;">Write character data in <i>str length</i> to the XML Writer <i>xml_writer</i> without XML escaping.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_raw_counted(raptor_xml_writer*</b> <i>xml_writer</i><b>, const<br />
unsigned char*</b> <i>str</i><b>, unsigned int</b> <i>length</i><b>)</b></p>
<p style="margin-left:22%;">Write character data in <i>str</i> of length <i>length</i> to the XML Writer <i>xml_writer</i> without XML escaping.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_comment(raptor_xml_writer*</b> <i>xml_writer</i><b>, const<br />
unsigned char*</b> <i>str</i><b>)</b></p>
<p style="margin-left:22%;">Write an XML comment in <i>str</i> to the XML Writer <i>xml_writer</i>.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_comment_counted(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
const unsigned char*</b> <i>str</i><b>, unsigned int</b> <i>length</i><b>)</b></p>
<p style="margin-left:22%;">Write an XML comment in <i>str</i> of length <i>length</i> to the XML Writer <i>xml_writer</i>.</p>
<p style="margin-left:11%;"><b>int raptor_xml_writer_features_enumerate(const raptor_feature</b> <i>feature</i><b>,<br />
const char **</b><i>name</i><b>, raptor_uri **</b><i>uri</i><b>, const char **</b><i>label</i><b>)</b></p>
<p style="margin-left:22%;">Return the name, URI, string label (all optional) for an XML write <i>feature</i>, returning non-zero if no such feature exists.</p>
<p style="margin-left:11%; margin-top: 1em">Raptor features have URIs that are constructed from the URI <i>http://feature.librdf.org/raptor-</i> and the <i>name</i> so for example feature <i>scanForRDF</i> has URI <i>http://feature.librdf.org/raptor-scanForRDF</i> <b><br />
int raptor_xml_writer_set_feature(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
raptor_feature</b> <i>feature</i><b>, int</b> <i>value</i><b>)</b></p>
<p style="margin-left:22%;">Set an XML writer feature <i>feature</i> to a particular <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined writer features are: <i><br />
Feature Values</i> <b><br />
RAPTOR_FEATURE_WRITER_AUTO_INDENT</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_WRITER_AUTO_EMPTY</b> Boolean (non 0 true) <b><br />
RAPTOR_FEATURE_WRITER_INDENT_WIDTH</b> Integer <b><br />
RAPTOR_FEATURE_WRITER_XML_DECLARATION</b> Boolean (non 0 true)</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>writer_auto_indent</i> feature is set (default true), the XML writer will automatically indent the output.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>writer_auto_empty</i> feature is set (default true), the XML writer will automatically generate empty elements if a start/end element sequence has no content.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>writer_indent_width</i> feature is set (default 2) if the XML writer is outputing indented XML, it will use that many spaces.</p>
<p style="margin-left:11%; margin-top: 1em">If the <i>writer_xml_declaration</i> feature is set (default true) the XML declaration is written at the start of serialized XML. <b><br />
int raptor_xml_writer_set_feature_string(raptor_xml_writer *xml_writer,<br />
raptor_feature feature, const unsigned char *value)</b></p>
<p style="margin-left:22%;">Set an XML writer feature <i>feature</i> to a particular string <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined XML writer features are given in <b>raptor_xml_writer_set_feature</b> and at present only take integer values. If an integer value feature is set with this function, <i>value</i> is interpreted as an integer and then that value is used.</p>
<p style="margin-left:11%;"><b>int raptor_xml_writer_get_feature(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
raptor_feature</b> <i>feature</i><b>)</b></p>
<p style="margin-left:22%;">Get XML writer feature integer values. The allowed <i>feature</i> values and types are given under <b>raptor_xml_writer_features_enumerate</b>.</p>
<p style="margin-left:11%;"><b>const unsigned char<br />
*raptor_xml_writer_get_feature_string(raptor_xml_writer*</b> <i>xml_writer</i><b>,<br />
raptor_feature</b> <i>feature</i><b>)</b></p>
<p style="margin-left:22%;">Get XML writer feature string values. The allowed <i>feature</i> values and types are given under <b>raptor_xml_writer_features_enumerate</b>.</p>
<p style="margin-left:11%;"><b>int raptor_xml_writer_get_depth(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
<p style="margin-left:22%;">Get the current XML writer element stack depth.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_flush(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
<p style="margin-left:22%;">Flush the XML writer output for any pending writes.</p>
<p style="margin-left:11%;"><b>void raptor_xml_writer_newline(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
<p style="margin-left:22%;">Write a newline to the XML writer (which may trigger indenting before the next item).</p>
<h2>WORLD CLASS <a name="WORLD_CLASS"></a></h2>
<p style="margin-left:11%; margin-top: 1em">This class stores the library state and configuration. It will be the main class for initialsiing and configuring the library in Raptor 2.0.</p>
<h2>WORLD CLASS CONSTRUCTOR <a name="WORLD_CLASS_CONSTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_world* raptor_new_world(void)</b></p>
<p style="margin-left:22%;">Create a new raptor library object.</p>
<h2>WORLD CLASS DESTRUCTOR <a name="WORLD_CLASS_DESTRUCTOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>void raptor_free_world(raptor_world*</b> <i>world</i><b>)</b></p>
<p style="margin-left:22%;">Destroy a raptor library object and free all resources.</p>
<h2>WORLD CLASS METHODS <a name="WORLD_CLASS_METHODS"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>int raptor_world_open(raptor_world*</b> <i>world</i><b>)</b></p>
<p style="margin-left:22%;">Start using a raptor library - allocate any dependent resources. This is optional.</p>
<p style="margin-left:11%;"><b>void raptor_world_set_libxslt_security_preferences(raptor_world *</b><i>world</i><b>,<br />
void *security_preferences)</b></p>
<p style="margin-left:22%;">See <b>raptor_set_libxslt_security_preferences()</b> description.</p>
<p style="margin-left:11%;"><b>void raptor_world_set_libxml_flags(raptor_world *</b><i>world</i><b>, int flags)</b></p>
<p style="margin-left:22%;">See <b>raptor_set_libxml_flags()</b> description.</p>
<h2>API CHANGES <a name="API_CHANGES"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.21</b><br />
No changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.20</b><br />
No changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.19</b><br />
Added <b>raptor_world</b> class to prepare for V2 API with constructor <b>raptor_new_world()</b>, destructor <b>raptor_free_world()</b> and methods <b>raptor_world_open()</b>, <b>raptor_world_set_libxslt_security_preferences()</b> and <b>raptor_world_set_libxml_flags()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">The <b>raptor_identifier</b>, <b>raptor_error_handlers</b> structs both gained a raptor_world* pointer field.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_set_libxslt_security_preferences()</b> and <b>raptor_set_libxml_flags()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_libxml_flags</b> enum for flags for <b>raptor_world_set_libxml_flags()</b> and <b>raptor_set_libxml_flags()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>RAPTOR_FEATURE_PREFIX_ELEMENTS</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.18</b><br />
Added atom serializer</p>
<p style="margin-left:11%; margin-top: 1em">Added rdfa parser</p>
<p style="margin-left:11%; margin-top: 1em">Added serializer features <b>RAPTOR_FEATURE_RSS_TRIPLES</b> and <b>RAPTOR_FEATURE_ATOM_ENTRY_URI</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_qname_to_counted_name()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_serialize_start_to_iostream()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_sequence_delete_at()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_xml_writer_newline()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_xml_writer_flush()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_xml_writer_get_depth()</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.17</b><br />
Added SAX2 class <b>raptor_sax2</b>. Added new SAX2 API typedefs: <b>raptor_sax2_start_element_handler</b>, <b>raptor_sax2_end_element_handler</b>, <b>raptor_sax2_characters_handler</b>, <b>raptor_sax2_cdata_handler</b>, <b>raptor_sax2_comment_handler</b>, <b>raptor_sax2_unparsed_entity_decl_handler</b> and <b>raptor_sax2_external_entity_ref_handler</b>. Added new SAX2 API functions: <b>raptor_new_sax2()</b>, <b>raptor_free_sax2()</b>, <b>raptor_sax2_set_start_element_handler()</b>, <b>raptor_sax2_set_end_element_handler()</b>, <b>raptor_sax2_set_characters_handler()</b>, <b>raptor_sax2_set_cdata_handler()</b>, <b>raptor_sax2_set_comment_handler()</b>, <b>raptor_sax2_set_unparsed_entity_decl_handler()</b>, <b>raptor_sax2_set_external_entity_ref_handler()</b>, <b>raptor_sax2_set_namespace_handler()</b>, <b>raptor_sax2_parse_start()</b>, <b>raptor_sax2_parse_chunk()</b>, <b>raptor_sax2_inscope_xml_language()</b> and <b>raptor_sax2_inscope_base_uri()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added features <b>RAPTOR_FEATURE_WRITE_BASE_URI</b>, <b>RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL</b>, <b>RAPTOR_FEATURE_WWW_HTTP_USER_AGENT</b>, <b>RAPTOR_FEATURE_JSON_CALLBACK</b> and <b>RAPTOR_FEATURE_JSON_EXTRA_DATA</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_handler_closure</b> structure for error handlers.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_statement_compare()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_iostream_write_string_python()</b> and deprecated <b>raptor_iostream_write_string_turtle()</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_uri_set_handler()</b>, <b>raptor_uri_get_handler()</b>, <b>raptor_new_namespaces()</b>, <b>raptor_namespaces_init()</b> and <b>raptor_new_xml_writer()</b> now take const handler pointers.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_www_set_http_cache_control()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added QName class methods: <b>raptor_qname_get_local_name()</b>, <b>raptor_qname_get_value()</b> and <b>raptor_qname_get_counted_value()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_iostream</b> read handler typedefs <b>raptor_iostream_read_bytes_func</b>, <b>raptor_iostream_read_eof_func</b> and added new structure <b>raptor_iostream_handler2</b> replacing deprecated <b>raptor_iostream_handler</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_new_iostream_from_handler2()</b> replacing deprecated <b>raptor_new_iostream_from_handler()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_new_iostream_from_sink()</b>, <b>raptor_new_iostream_from_filename()</b>, <b>raptor_new_iostream_from_file_handle()</b> and <b>raptor_new_iostream_from_string()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_iostream_tell</b> deprecating <b>raptor_iostream_get_bytes_written_count()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_iostream_read_bytes()</b> and <b>raptor_iostream_read_eof()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_xml_element_get_language()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added new enum <b>raptor_log_level</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added new typedef <b>raptor_error_handlers</b>. and new function <b>raptor_error_handlers_init()</b>.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.16<br />
raptor_namespaces_init()</b> now returns an integer status</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_new_xml_element_from_namespace_local_name()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_uri_compare()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added new features for the &rsquo;grddl&rsquo; parser: <b>RAPTOR_FEATURE_HTML_TAG_SOUP</b>, <b>RAPTOR_FEATURE_MICROFORMATS</b> and <b>RAPTOR_FEATURE_HTML_LINK</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added parser feature <b>RAPTOR_FEATURE_WWW_TIMEOUT</b></p>
<p style="margin-left:11%; margin-top: 1em">Added raptor_graph_handler typedef and <b>raptor_set_graph_handler()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added raptor_www_final_uri_handler typedef and <b>raptor_www_set_final_uri_handler()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_www_set_connection_timeout()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_www_get_final_uri()</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.15</b><br />
No changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.14</b><br />
Add two new exported strings raptor_license_string and raptor_home_url_string.</p>
<p style="margin-left:11%; margin-top: 1em">Added new features for the &rsquo;dot&rsquo; serializer: <b>RAPTOR_FEATURE_RESOURCE_BORDER</b>, <b>RAPTOR_FEATURE_LITERAL_BORDER</b>, <b>RAPTOR_FEATURE_BNODE_BORDER</b>, <b>RAPTOR_FEATURE_RESOURCE_FILL</b>, <b>RAPTOR_FEATURE_LITERAL_FILL</b> and <b>RAPTOR_FEATURE_BNODE_FILL</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_parser_generate_id()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_iostream_write_string_turtle()</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.13</b><br />
No API changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.12</b><br />
No API changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.11</b><br />
Added <b>raptor_get_feature_count()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_get_need_base_uri()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added parser feature <b>RAPTOR_FEATURE_NO_NET</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_www_set_uri_filter()</b>, <b>raptor_parser_set_uri_filter()</b> with filter type <b>raptor_uri_filter_func</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.10</b><br />
No API changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.9</b><br />
Added <b>raptor_parser_get_accept_header()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_xml_element_is_empty()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_qname_get_namespace()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_iostream_write_uri()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_namespaces_qname_from_uri()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_namespace_get_counted_prefix()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_serialize_set_namespace_from_namespace()</b></p>
<p style="margin-left:11%; margin-top: 1em">Deprecated <b>raptor_uri_is_file_uri()</b> for new <b>raptor_uri_string_is_file_uri()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_xml_element_get_attributes()</b> and <b>raptor_xml_element_get_attributes_count()</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.8</b><br />
Added <b>raptor_set_namespace_handler()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added XML 1.1 serializing support, feature <b>RAPTOR_FEATURE_WRITER_XML_VERSION</b> with shortname <i>xmlVersion</i> for serializer and xml writer classes to support it. Added XML writer feature <b>RAPTOR_FEATURE_WRITER_XML_DECLARATION</b> to control generation of the XML declaration. Added new functions <b>raptor_xml_any_escape_string()</b> and <b>raptor_iostream_write_xml_any_escaped_string()</b> to allow generating XML 1.1 or XML 1.0.</p>
<p style="margin-left:11%; margin-top: 1em"><b>RAPTOR_IDENTIFIER_TYPE_PREDICATE</b> will no longer be generated from version 1.4.9 onwards as the type of returned statement predicates. <b>RAPTOR_IDENTIFIER_TYPE_RESOURCE</b> will be returned.</p>
<p style="margin-left:11%; margin-top: 1em"><b>RAPTOR_IDENTIFIER_TYPE_ORDINAL</b> may no longer be generated from version 1.4.9 onwards, <b>RAPTOR_IDENTIFIER_TYPE_RESOURCE</b> may replace it.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.7</b><br />
No changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.6</b><br />
No changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.5</b><br />
Deprecated <b>raptor_ntriples_string_as_utf8_string()</b> (never documented above) since it can only work with a raptor_parser object which makes it rather unusable alone.</p>
<p style="margin-left:11%; margin-top: 1em">Added XML writer features and support functions <b>raptor_xml_writer_features_enumerate()</b>, <b>raptor_xml_writer_set_feature()</b>, <b>raptor_xml_writer_set_feature_string()</b>, <b>raptor_xml_writer_get_feature()</b> and <b>raptor_xml_writer_get_feature_string()</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.3</b><br />
Added XML Writer class (<b>raptor_xml_writer</b>) and XML Element class (<b>raptor_xml_element</b>)</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_parser_get_feature_string()</b>, <b>raptor_parser_set_feature_string()</b>, <b>raptor_serializer_set_feature_string()</b>, <b>raptor_serializer_get_feature_string()</b> and <b>raptor_feature_value_type()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_serializer_set_namespace</b>, <b>raptor_serializer_set_feature()</b> and <b>raptor_serializer_get_feature()</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_new_namespace_from_uri()</b>, <b>raptor_new_namespace_parts_from_string()</b>, Added <b>raptor_namespaces_find_namespace_by_uri()</b>. and <b>raptor_iostream_write_namespace()</b> to write a namespace declaration to an iostream.</p>
<p style="margin-left:11%; margin-top: 1em">Added copy constructor <b>raptor_qname_copy()</b> and <b>raptor_iostream_write_qname()</b> to write a qname to an iostream.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_sequence_join()</b> to join two sequences, leaving one empty.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_iostream_write_stringbuffer()</b> to write a stringbuffer to an iostream.</p>
<p style="margin-left:11%; margin-top: 1em">Added N-Triples <b>raptor_iostream_write_string_ntriples()</b> and <b>raptor_iostream_write_statement_ntriples()</b> utility functions for writing to raptor_iostreams.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_uri_to_relative_counted_uri_string()</b>, <b>raptor_uri_to_relative_uri_string()</b>. <b>raptor_uri_print()</b>, <b>raptor_uri_to_counted_string()</b> and <b>raptor_uri_to_string()</b></p>
<p style="margin-left:11%; margin-top: 1em">Added unicode name checking utility functions for XML 1.0 and XML 1.1 name starting character and continued name character. <b>raptor_unicode_is_xml10_namestartchar raptor_unicode_is_xml10_namechar</b>, <b>raptor_unicode_is_xml11_namechar</b> and <b>raptor_unicode_is_xml11_namestartchar</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_xml_name_check</b> to check if a name is a legal XML 1.0 or 1.0 name. and <b>raptor_iostream_write_xml_escaped_string</b> to write an XML-escaped string to an iostream.</p>
<p style="margin-left:11%; margin-top: 1em">Added UTF8-checking utility function <b>raptor_utf8_check</b>.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.2</b><br />
No changes.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.1</b><br />
The <b>raptor_xml_escape_string</b> now returns &lt;0 on failure rather than 0, so that if an empty string is escaped, 0 bytes required is returned.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.4.0</b><br />
Added new <b>raptor_serializer</b> class supporting RDF/XML (name <b>rdfxml</b>) and N-Triples (name <b>ntriples</b>).<br />
Added new <b>raptor_iostream</b> class<br />
Added <b>raptor_stringbuffer_copy_to_string</b> to allow efficient copy-out of a constructed string.<br />
Added <b>raptor_www_fetch_to_string</b> to allow retrieving of web content as a single string.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.3.3</b><br />
Added <b>raptor_calloc_memory</b> to provide a calloc inside raptor.<br />
Added feature check_rdf_id (see raptor_set_feature documentation).</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.3.2</b><br />
Added <b>raptor_alloc_memory</b> to allocate memory inside raptor.</p>
<p style="margin-left:11%; margin-top: 1em">Added accessor functions for the public raptor_locator structure:</p>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_locator_line<br />
raptor_locator_column<br />
raptor_locator_byte<br />
raptor_locator_file<br />
raptor_locator_uri</b></p>
<p style="margin-left:11%; margin-top: 1em"><b>1.3.1</b><br />
Correct raptor_print_statement declaration argument statement to have one less &rsquo;const&rsquo;, to match the code.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.3.0</b><br />
Added the following parser methods, utility methods and helper functions:</p>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_new_parser_for_content (Parser class constructor)<br />
raptor_get_mime_type<br />
raptor_get_feature<br />
raptor_syntax_name_check<br />
raptor_guess_parser_name<br />
raptor_features_enumerate<br />
raptor_feature_from_uri<br />
raptor_www_set_http_accept (WWW class)</b></p>
<p style="margin-left:11%; margin-top: 1em">Changed <b>raptor_set_feature</b> to now return an int success or failure.</p>
<p style="margin-left:11%; margin-top: 1em">Added the following functions: <b><br />
raptor_free_memory<br />
raptor_unicode_char_to_utf8<br />
raptor_utf8_to_unicode_char<br />
raptor_vsnprintf</b></p>
<p style="margin-left:11%; margin-top: 1em">Added the raptor_sequence class, its constructor, destructor, methods and helper functions.</p>
<p style="margin-left:11%; margin-top: 1em">Added the raptor_stringbuffer class and constructor, destructor and methods.</p>
<p style="margin-left:11%; margin-top: 1em">Deprecated <b>raptor_print_statement_detailed</b> always intended to be internal.</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.2.0</b><br />
Added <b>raptor_syntaxes_enumerate</b> to get full information on syntax mime type and URIs as well as name and label.</p>
<p style="margin-left:11%; margin-top: 1em">N-Triples Plus parser renamed to Turtle (name turtle)</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.1.0</b><br />
Added N-Triples Plus parser (name ntriples-plus)</p>
<p style="margin-left:11%; margin-top: 1em">Made URI class constructors, methods and factory methods as well as some other utility functions using or returning URIs or literals take unsigned char* rather than char*. The affected calls are:</p>
<p style="margin-left:11%; margin-top: 1em">URI factory methods changed to all take/return unsigned char* for URI strings: <b><br />
raptor_new_uri_func<br />
raptor_new_uri_from_local_name_func<br />
raptor_new_uri_relative_to_base_func<br />
raptor_uri_as_string_func<br />
raptor_uri_as_counted_string_func</b></p>
<p style="margin-left:11%; margin-top: 1em">Constructors and methods changed to take/return unsigned char* for URI strings: <b><br />
raptor_statement_part_as_counted_string<br />
raptor_statement_part_as_string<br />
raptor_new_uri<br />
raptor_new_uri_from_uri_local_name<br />
raptor_new_uri_relative_to_base<br />
raptor_uri_as_string<br />
raptor_uri_as_counted_string<br />
raptor_print_ntriples_string</b></p>
<p style="margin-left:11%; margin-top: 1em">Changed to use unsigned char* for URI strings, char* for filenames: <b><br />
raptor_uri_resolve_uri_reference<br />
raptor_uri_filename_to_uri_string<br />
raptor_uri_uri_string_to_filename<br />
raptor_uri_uri_string_to_filename_fragment<br />
raptor_uri_is_file_uri</b></p>
<p style="margin-left:11%; margin-top: 1em">Changed to return unsigned char* for UTF8 string: <b><br />
raptor_ntriples_string_as_utf8_string</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_parsers_enumerate</b> to discover supported parsers.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_uri_uri_string_to_filename_fragment</b> with fragment arg to return the URI fragment.</p>
<p style="margin-left:11%; margin-top: 1em">Made the raptor_namespace, raptor_namespace_stack and raptor_qname class and APIs public.</p>
<p style="margin-left:11%; margin-top: 1em">Added feature non_nfc_fatal (see raptor_set_feature documentation).</p>
<p style="margin-left:11%; margin-top: 1em"><b>1.0.0</b><br />
Removed the following deprecated methods and functions (see 0.9.6 changes for the new names): <b><br />
raptor_free</b>, <b>raptor_new</b>, <b>raptor_ntriples_free</b>, <b>raptor_ntriples_new</b>, <b>raptor_ntriples_parse_file</b>, <b>raptor_ntriples_set_error_handler</b>, <b>raptor_ntriples_set_fatal_error_handler</b>, <b>raptor_ntriples_set_statement_handler</b> and <b>raptor_parser_abort</b>.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_parse_file_stream</b> for reading FILE* streams without necessarily having a file.</p>
<p style="margin-left:11%; margin-top: 1em"><b>0.9.12</b><br />
Added <b>raptor_new_uri_for_retrieval</b> to turn URI references into URIs suitable for retrieval (no fragments).</p>
<p style="margin-left:11%; margin-top: 1em"><b>0.9.11</b><br />
Added <b>raptor_get_name</b> and <b>raptor_get_label</b>.</p>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_xml_escape_string</b> now takes error message handler, data pointer, loses parser argument.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_set_default_generate_id_parameters</b> and <b>raptor_set_generate_id_handler</b> to control the default generation of IDs, allow full customisation.</p>
<p style="margin-left:11%; margin-top: 1em"><b>0.9.10</b><br />
Added <b>raptor_set_parser_strict</b> and <b>raptor_www_no_www_library_init_finish</b>.</p>
<p style="margin-left:11%; margin-top: 1em"><b>raptor_xml_escape_string</b> now takes an output string length pointer.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_statement_part_as_counted_string</b>, <b>raptor_statement_part_as_string and raptor_parse_abort.</b></p>
<p style="margin-left:11%; margin-top: 1em">Deprecated <b>raptor_parser_abort</b>.</p>
<p style="margin-left:11%; margin-top: 1em"><b>0.9.9</b><br />
Added raptor_www class and all its constructors, destructor, methods, calls.</p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_parse_uri</b>, <b>raptor_parser_abort</b>, <b>raptor_ntriples_term_as_string</b> and <b>raptor_xml_escape_string</b>.</p>
<p style="margin-left:11%; margin-top: 1em"><b>0.9.7<br />
raptor_parse_chunk, raptor_new_uri_from_id, arguments are now unsigned char.</b></p>
<p style="margin-left:11%; margin-top: 1em">Added <b>raptor_new_uri_for_xmlbase</b>.</p>
<p style="margin-left:11%; margin-top: 1em"><b>0.9.6</b><br />
In this version, the raptor/ntriples parser calling APIs were modified. The following table lists the changes:</p>
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><i>OLD API</i></p>
</td>
<td width="37%">
<p><i>NEW API (0.9.6+)</i></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>raptor_new()</b></p>
</td>
<td width="37%">
<p><b>raptor_new_parser("rdfxml")</b></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>ntriples_new()</b></p>
</td>
<td width="37%">
<p><b>raptor_new_parser("ntriples")</b></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>raptor_free</b></p>
</td>
<td width="37%">
<p><b>raptor_free_parser</b></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>ntriples_free</b></p>
</td>
<td width="37%">
<p><b>raptor_ntriples_parser</b></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>raptor_ntriples_parse_file</b></p>
</td>
<td width="37%">
<p><b>raptor_parse_file</b></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>raptor_ntriples_set_error_handler</b></p>
</td>
<td width="37%">
<p><b>raptor_set_error_handler</b></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>raptor_ntriples_set_fatal_error_handler</b></p>
</td>
<td width="37%">
<p><b>raptor_set_fatal_error_handler</b></p>
</td>
</tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="52%">
<p><b>raptor_ntriples_set_statement_handler</b></p>
</td>
<td width="37%">
<p><b>raptor_set_statement_handler</b></p>
</td>
</tr>
</table>
<h2>CONFORMING TO <a name="CONFORMING_TO"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b><i>RDF/XML Syntax (Revised)</i></b>, Dave Beckett (ed.) W3C Recommendation, <a href="http://www.w3.org/TR/rdf-syntax-grammar/">http://www.w3.org/TR/rdf-syntax-grammar/</a></p>
<p style="margin-left:11%; margin-top: 1em"><i>N-Triples</i>, in <i>RDF Test Cases</i>, Jan Grant and Dave Beckett (eds.) W3C Recommendation, <a href="http://www.w3.org/TR/rdf-testcases/#ntriples">http://www.w3.org/TR/rdf-testcases/#ntriples</a></p>
<p style="margin-left:11%; margin-top: 1em"><i>Turtle - Terse RDF Triple Language</i>, Dave Beckett, <a href="http://www.dajobe.org/2004/01/turtle/">http://www.dajobe.org/2004/01/turtle/</a></p>
<p style="margin-left:11%; margin-top: 1em"><i>RSS 0.91 spec revision 3</i>, Dan Libby, Netscape, <a href="http://my.netscape.com/publish/formats/rss-spec-0.91.html">http://my.netscape.com/publish/formats/rss-spec-0.91.html</a></p>
<p style="margin-left:11%; margin-top: 1em"><i>RDF Site Summary (RSS) 1.0</i>, <a href="http://purl.org/rss/1.0/spec">http://purl.org/rss/1.0/spec</a></p>
<p style="margin-left:11%; margin-top: 1em"><i>Atom 1.0 syndication format</i>, RFC 4287, <a href="http://www.ietf.org/rfc/rfc4287.txt">http://www.ietf.org/rfc/rfc4287.txt</a></p>
<p style="margin-left:11%; margin-top: 1em"><i>Gleaning Resource Descriptions from Dialects of Languages (GRDDL)</i>, Dan Connolly (ed.), W3C Recommendation, 2007-09-11, <a href="http://www.w3.org/TR/2007/REC-grddl-20070911/">http://www.w3.org/TR/2007/REC-grddl-20070911/</a></p>
<p style="margin-left:11%; margin-top: 1em"><i>RDFa in XHTML: Syntax and Processing</i>, Ben Adida, Mark Birbeck, Shane McCarron, Steven Pemberton (eds.)<br />
W3C Recommendation, 2008-10-14, <a href="http://www.w3.org/TR/2008/REC-rdfa-syntax-20081014/">http://www.w3.org/TR/2008/REC-rdfa-syntax-20081014/</a></p>
<h2>SEE ALSO <a name="SEE_ALSO"></a></h2>
<p style="margin-left:11%; margin-top: 1em"><b>rapper(1),</b>raptor-config(1)</p>
<h2>AUTHOR <a name="AUTHOR" id="AUTHOR"></a></h2>
<p style="margin-left:11%; margin-top: 1em">Dave Beckett - <a href="http://www.dajobe.org/">http://www.dajobe.org/</a></p>
<hr />

<p>Copyright 2002-2010 <a href="http://www.dajobe.org/">Dave Beckett</a><br />2002-2010 <a href="http://www.bristol.ac.uk/">University of Bristol</a></p>

</body>
</html>
